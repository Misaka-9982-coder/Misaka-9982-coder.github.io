{"meta":{"title":"Misaka's blog","subtitle":"","description":"","author":"Misaka","url":"http://www.misaka-9982.com","root":"/"},"pages":[{"title":"link","date":"2022-01-14T10:37:12.000Z","updated":"2023-03-07T12:21:54.294Z","comments":true,"path":"link/index.html","permalink":"http://www.misaka-9982.com/link/index.html","excerpt":"","text":""},{"title":"about","date":"2023-02-24T07:25:44.000Z","updated":"2023-02-24T10:27:29.051Z","comments":true,"path":"about/index.html","permalink":"http://www.misaka-9982.com/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-01-14T07:25:44.000Z","updated":"2022-03-01T13:18:20.006Z","comments":true,"path":"tags/index.html","permalink":"http://www.misaka-9982.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-01-14T07:27:27.000Z","updated":"2022-03-01T13:18:23.363Z","comments":true,"path":"categories/index.html","permalink":"http://www.misaka-9982.com/categories/index.html","excerpt":"","text":""},{"title":"留言板","date":"2022-01-14T07:27:27.000Z","updated":"2022-03-02T10:19:33.424Z","comments":true,"path":"messageboard/index.html","permalink":"http://www.misaka-9982.com/messageboard/index.html","excerpt":"","text":""}],"posts":[{"title":"Codewar 体验","slug":"Codewar-体验","date":"2023-06-27T16:00:42.000Z","updated":"2023-06-27T16:16:13.387Z","comments":true,"path":"2023/06/28/Codewar-体验/","link":"","permalink":"http://www.misaka-9982.com/2023/06/28/Codewar-%E4%BD%93%E9%AA%8C/","excerpt":"","text":"先膜拜个大佬： 在Codewars上做JavaScript算法题是一种怎样的体验？ - 千里冰封二瓣之的回答 - 知乎 https://www.zhihu.com/question/53766913/answer/212285498 之前阅读&quot;The Little Schemer&quot;和&quot;The Seasoned Schemer&quot;这两本书，感觉需要找一个地方来练习和提升我对Scheme语言的理解和技巧，而且刚好莎莎推荐了《Essentials of Compilation_ An Incremental Approach in Racket》这本书作为编译原理的入门书，就决定来练习Scheme的方言Racket。虽然目前LeetCode也能支持Racket，但是用Racket做Leetcode的题目总觉得有点别扭，而且LeetCode对于练习一个新语言来说并不是那么的友好，于是转到Codewar来做些练习，Codewar支持的语言就非常的多，在这里做语法题目练习就很方便，它提供了不少语言的测试框架和测试样例，在本地搭建好环境后，就可以实现在本地运行并进行测试，自己随意的打印字符串打印变量，添加测试样例这些东西来调试代码，这点就比Leetcode强很多，体验很棒。 个人体会，LeetCode更偏向于去应付面试和练习算法，而Codewar的题目更适合锻炼自己的工程编程能力，考察的东西除了算法之外还有很多，例如语言特性，框架原型，代码Debug等。难度较高的题目中有很多关于解析器（parser）和编译器子模块的题目，这些题目很有挑战性，但当题目通过的时候，又会觉得嘎嘎爽。 对于Codewar的题目难度，我觉得它分为8个等级还是比较合理的，尽管有些3kyu的题目让我感觉并不比2kyu的题目简单（比如这道Prime counting)。从4kyu开始的题目就需要结合很多其他的知识来解题(比如编译原理)。我觉得5-8kyu的题目比较简单，适合熟悉一些比较基本的语法，3-4kyu的题目难度适中，非常适合锻炼编程能力。1 - 2 kyu 本人目前也没写过几道，而且好像不少编译器相关的题目，就暂时还没能力去解题","categories":[],"tags":[]},{"title":"6.S081 Lab 3 page tables","slug":"6-S081-Lab-3-page-tables","date":"2023-03-15T12:44:26.000Z","updated":"2023-03-16T02:40:43.301Z","comments":true,"path":"2023/03/15/6-S081-Lab-3-page-tables/","link":"","permalink":"http://www.misaka-9982.com/2023/03/15/6-S081-Lab-3-page-tables/","excerpt":"","text":"kernel/memlayout.h 这段代码是一个RISC-V处理器上的内存布局和地址映射相关的配置。RISC-V是一种开放的指令集架构（ISA），在很多领域得到了广泛应用。以下是这段代码的解释： 这段代码首先定义了一些硬件寄存器的物理地址： UART0（0x10000000L）：串行通信接口UART的基地址。 VIRTIO0（0x10001000）：虚拟I/O设备的基地址。 CLINT（0x2000000L）：核心局部中断器（Core Local Interruptor）的基地址。 PLIC（0x0c000000L）：平台级中断控制器（Platform-Level Interrupt Controller）的基地址。 之后，定义了与中断相关的寄存器地址和宏函数。 定义了内核使用的物理内存区域： KERNBASE（0x80000000L）：内核程序的起始地址。 PHYSTOP：内核使用的物理内存的结束地址。 定义了内核栈和用户栈的内存布局。 用户内存布局定义如下： 首先是文本段、原始数据段、BSS段。 固定大小的栈。 可扩展的堆。 用户系统调用（USYSCALL）区域。 中断帧（TRAPFRAME）区域，用于存储进程的中断帧。 跳板区域（TRAMPOLINE），与内核空间共享。 这些配置用于设置处理器上的内存布局和地址映射。在实际系统中，硬件组件的地址、中断号等可能根据具体实现而有所不同。这段代码为一个基于RISC-V的操作系统内核提供了一个内存布局的模板。 kernel/vm.c 给定的代码实现了在 RISC-V 架构上运行的 xv6 操作系统的页表管理。 kvminit 函数通过创建内核直接映射页表并进行各种映射来初始化内核页表。它为 UART0 设备、virtio 磁盘接口、内核文本和数据段、陷阱入口/出口跳板、进程内核栈以及物理本地中断控制器 (PLIC) 分配和映射内存区域。 kvminithart 函数将硬件页表寄存器切换到内核的页表，并启用分页机制。 walk 函数返回与虚拟地址 va 对应的页面 pagetable 中 PTE 的地址。如果 alloc!=0，则会创建所需的页面表页面。 walkaddr 函数查找虚拟地址，返回物理地址或 0（如果未映射）。此函数仅可用于查找用户页面。 mappages函数为从va开始引用起始物理地址pa的虚拟地址创建PTE。va和size可能不是对齐的。成功时返回0，如果 walk() 无法分配所需的页面表页面，则返回-1。 uvmunmap函数从va开始移除npages个映射。 va必须对齐页。 映射必须存在。 可选地，它释放物理内存。 uvmcreate函数创建一个空的用户页表。 如果内存不足，则返回0。 uvmfirst函数将用户initcode加载到第一个进程的pagetable地址0中。 sz必须小于一页。 uvmalloc函数分配PTE和物理内存以使进程从oldsz增长到newsz，这不需要对齐页面大小。 它返回新大小或错误时返回0。 uvmdealloc函数取消分配用户页面以将进程大小从oldsz调整为newsz. oldsz和newsz无需对齐页面大小，而且newsz无需小于oldsz. oldsz可以大于实际进程大小。 它返回新的进程大小。 freewalk函数递归释放页表页面。所有叶映射必须已经被删除。 uvmfree函数先释放用户内存页面，然后再释放页表页面。 uvmcopy函数将父进程的页表中的内存复制到子进程的页表中。它同时复制了页表和物理内存。成功返回0，失败返回-1。在失败时会释放任何分配的页面。 uvmclear函数标记一个PTE对于用户访问无效。它由exec用于用户堆栈保护页面。 copyout函数从内核向用户空间复制内存。它将长度为len字节的数据从src复制到给定页表中虚拟地址dstva处。成功返回0，错误返回-1. copyin函数从用户空间向内核复制内存。它将长度为len字节的数据从给定页表中虚拟地址srcva处复制到dst中。成功返回0，错误返回-1. copyinstr函数从用户空间向内核复制以null结尾字符串（即C风格字符串）。它将最多max个字节或直到遇到’\\0’停止，并将其从给定页表中虚拟地址srcva处开始进行操作并写入dst缓冲区中 。成功则返回0，否则返回-1. kernel/kalloc.c 这段代码实现了一个物理内存分配器，用于分配给用户进程、内核栈、页表页面和管道缓冲区。分配器使用 4096 字节（4KB）的整数倍页面。 代码中包含的主要结构和函数如下： 结构 run：表示一个可用的内存块，包含一个指向下一个可用内存块的指针。 结构 kmem：管理可用内存块链表的结构，包含一个自旋锁和一个指向可用内存块链表的指针。 函数 kinit()：初始化内存分配器。设置 kmem 结构的自旋锁，然后调用 freerange() 函数，将内核结束地址（end）到物理内存结束地址（PHYSTOP）之间的内存空间初始化为可用内存块。 函数 freerange(void *pa_start, void *pa_end)：将给定范围内的物理内存地址空间初始化为可用内存块，并将它们添加到 kmem 的可用内存块链表中。 函数 kfree(void *pa)：释放由 kalloc() 分配的物理内存页面。将要释放的内存页面填充为特定值（这里是 1），以捕获悬空引用。然后将页面添加回 kmem 的可用内存块链表中。 函数 kalloc(void)：分配一个 4096 字节（4KB）的物理内存页面。从 kmem 的可用内存块链表中取一个内存块，并将其从链表中移除。如果成功分配到内存块，则将其填充为特定值（这里是 5），并将指针返回给内核。 这段代码提供了一个简单的物理内存管理功能，以满足内核和用户进程的内存分配需求。 Speed up system calls (easy) 一些操作系统（例如Linux）通过在用户空间和内核之间共享只读区域中的数据来加速某些系统调用。这消除了执行这些系统调用时需要进行内核交叉的需求。为了帮助您学习如何将映射插入到页表中，您的第一个任务是为xv6实现getpid()系统调用的此优化。 当创建每个进程时，在 USYSCALL 处映射一个只读页面（在memlayout.h中定义的虚拟地址）。在该页面开头存储一个 struct usyscall(也在 memlayout.h 中定义)，并将其初始化以存储当前进程的PID。对于本实验室，已经提供了用户空间上的 ugetpid() 并且会自动使用 USYSCALL 映射。如果运行 pgtbltest 时 ugetpid 测试案例通过，则您将获得此实验室部分积分。 一些建议： 您可以在 kernel/proc.c 的 proc_pagetable() 中执行映射。 选择允许用户空间仅读取页面的权限位。 您可能会发现 mappages() 是有用工具。 不要忘记在 allocproc() 中分配和初始化页面。 确保在 freeproc() 中释放该页。","categories":[],"tags":[{"name":"OS","slug":"OS","permalink":"http://www.misaka-9982.com/tags/OS/"},{"name":"6.S081","slug":"6-S081","permalink":"http://www.misaka-9982.com/tags/6-S081/"}]},{"title":"6.S081-Lab 2: System Calls","slug":"6-S081-Lab-2-System-Calls","date":"2023-03-14T09:46:30.000Z","updated":"2023-03-15T07:21:34.489Z","comments":true,"path":"2023/03/14/6-S081-Lab-2-System-Calls/","link":"","permalink":"http://www.misaka-9982.com/2023/03/14/6-S081-Lab-2-System-Calls/","excerpt":"","text":"官方材料：https://pdos.csail.mit.edu/6.S081/2021/labs/syscall.html 参考材料： https://th0ar.gitbooks.io/xv6-chinese/content/ https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/ 在开始编码之前，请阅读xv6书籍的第2章、第4章的4.3和4.4节以及相关的源文件: 将系统调用路由到内核的用户空间“stubs”位于 user/usys.S，在运行make时由 user/usys.pl生成。声明在 user/user.h 中 将系统调用路由到实现它的内核函数的内核空间代码位于 kernel/syscall.c 和 kernel/syscall.h 中。 与进程相关的代码是 kernel/proc.h 和 kernel/proc.c 。 要向xv6添加新的系统调用，您需要修改几个文件： 在 kernel/syscall.h中定义系统调用号。在xv6中的惯例是给每个系统调用一个以SYS_ 开头并以小写字母表示该系统调用名称结尾的数字。例如，获取进程ID的系统调用被定义为 SYS_getpid。 在 kernel/syscall.c 中添加一个新的内核函数来实现该系统调用。此函数使用copyin() 函数从用户空间获取参数，并使用 copyout() 函数将结果返回到用户空间。请注意验证用户指针并在无效时返回错误。 在 user/usys.S 中添加一个用户空间存根（stub）。存根应将系统调用号推送到堆栈上，然后使用ecall指令转换到内核模式。参数数量和类型取决于所需的系统调用。 在user/user.h中声明该系统调用。此声明应与内核函数原型匹配，并包括该系统调用号。 最后，在 user/user.c 中添加一个用户空间包装器(wrapper)函数，它使用在user/usys.S 中定义的包装器(wrapper) 函数来 调 用 系 统 调 试 。 此 包 装 器 (wrapper) 函 数 应 按 相 同 的 订 单 接 受 内 核 函 数 的 参数 并 返回 结 果。 进行这些更改后，您需要运行 make 重新构建内核和用户空间二进制文件。完成之后，您可以编写一个测试程序来调用您新创建的 系统 调 试 ， 并 在 xv6 中 运 行 它 。 System call tracing (moderate) In this assignment you will add a system call tracing feature that may help you when debugging later labs. You’ll create a new trace system call that will control tracing. It should take one argument, an integer “mask”, whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls trace(1 &lt;&lt; SYS_fork), where SYS_fork is a syscall number from kernel/syscall.h. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call’s number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don’t need to print the system call arguments. The trace system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes. 由于 xv6 内核是一个操作系统，因此它包含内核代码和用户级代码。用户级代码通常编写为用户级进程，使用系统调用来与内核进行通信。 在本次任务中，您需要修改 xv6 内核来实现一个新的系统调用，以及一个用户级程序来调用该系统调用。下面是一些提示，以帮助您完成此任务： 在 Makefile 中添加 $U/_trace 到 UPROGS，以便编译 trace 程序。 1234567891011121314151617UPROGS=\\ $U/_cat\\ $U/_echo\\ $U/_forktest\\ $U/_grep\\ $U/_init\\ $U/_kill\\ $U/_ln\\ $U/_ls\\ $U/_mkdir\\ $U/_rm\\ $U/_sh\\ $U/_stressfs\\ $U/_usertests\\ $U/_wc\\ $U/_zombie\\ $U/_trace 修改 user/user.h，添加 trace 系统调用的函数原型。 1234567891011121314151617181920212223// system callsint fork(void);int exit(int) __attribute__((noreturn));int wait(int*);int pipe(int*);int write(int, const void*, int);int read(int, void*, int);int close(int);int kill(int);int exec(const char*, char**);int open(const char*, int);int mknod(const char*, short, short);int unlink(const char*);int fstat(int fd, struct stat*);int link(const char*, const char*);int mkdir(const char*);int chdir(const char*);int dup(int);int getpid(void);char* sbrk(int);int sleep(int);int uptime(void);int trace(int); // &lt;--- Here! 在 user/usys.pl 中添加对 trace 系统调用的支持。 12345678910111213141516171819202122entry(&quot;fork&quot;);entry(&quot;exit&quot;);entry(&quot;wait&quot;);entry(&quot;pipe&quot;);entry(&quot;read&quot;);entry(&quot;write&quot;);entry(&quot;close&quot;);entry(&quot;kill&quot;);entry(&quot;exec&quot;);entry(&quot;open&quot;);entry(&quot;mknod&quot;);entry(&quot;unlink&quot;);entry(&quot;fstat&quot;);entry(&quot;link&quot;);entry(&quot;mkdir&quot;);entry(&quot;chdir&quot;);entry(&quot;dup&quot;);entry(&quot;getpid&quot;);entry(&quot;sbrk&quot;);entry(&quot;sleep&quot;);entry(&quot;uptime&quot;);entry(&quot;trace&quot;); // &lt;--- Here! 运行后会生成汇编文件 123456.global tracetrace: li a7, SYS_trace ecall ret 在 kernel/syscall.h 中添加 trace 系统调用的号码。 1234567891011121314151617181920212223// System call numbers#define SYS_fork 1#define SYS_exit 2#define SYS_wait 3#define SYS_pipe 4#define SYS_read 5#define SYS_kill 6#define SYS_exec 7#define SYS_fstat 8#define SYS_chdir 9#define SYS_dup 10#define SYS_getpid 11#define SYS_sbrk 12#define SYS_sleep 13#define SYS_uptime 14#define SYS_open 15#define SYS_write 16#define SYS_mknod 17#define SYS_unlink 18#define SYS_link 19#define SYS_mkdir 20#define SYS_close 21#define SYS_trace 22 // &lt;--- Here 在 kernel/syscall.c 中添加一个数组，用于将系统调用号码映射到名称。例如： 123456789101112131415161718192021222324static char* syscalls_name[] = &#123;[SYS_fork] &quot;syscall fork&quot;,[SYS_exit] &quot;syscall exit&quot;,[SYS_wait] &quot;syscall wait&quot;,[SYS_pipe] &quot;syscall pipe&quot;,[SYS_read] &quot;syscall read&quot;,[SYS_kill] &quot;syscall kill&quot;,[SYS_exec] &quot;syscall exec&quot;,[SYS_fstat] &quot;syscall fstat&quot;,[SYS_chdir] &quot;syscall chdir&quot;,[SYS_dup] &quot;syscall dup&quot;,[SYS_getpid] &quot;syscall getpid&quot;,[SYS_sbrk] &quot;syscall sbrk&quot;,[SYS_sleep] &quot;syscall sleep&quot;,[SYS_uptime] &quot;syscall uptime&quot;,[SYS_open] &quot;syscall open&quot;,[SYS_write] &quot;syscall write&quot;,[SYS_mknod] &quot;syscall mknod&quot;,[SYS_unlink] &quot;syscall unlink&quot;,[SYS_link] &quot;syscall link&quot;,[SYS_mkdir] &quot;syscall mkdir&quot;,[SYS_close] &quot;syscall close&quot;,[SYS_trace] &quot;syscall trace&quot;,&#125;; 用 extern 全局声明新的内核调用函数，并且在 syscalls 映射表中，加入从前面定义的编号到系统调用函数指针的映射 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// Prototypes for the functions that handle system calls.extern uint64 sys_fork(void);extern uint64 sys_exit(void);extern uint64 sys_wait(void);extern uint64 sys_pipe(void);extern uint64 sys_read(void);extern uint64 sys_kill(void);extern uint64 sys_exec(void);extern uint64 sys_fstat(void);extern uint64 sys_chdir(void);extern uint64 sys_dup(void);extern uint64 sys_getpid(void);extern uint64 sys_sbrk(void);extern uint64 sys_sleep(void);extern uint64 sys_uptime(void);extern uint64 sys_open(void);extern uint64 sys_write(void);extern uint64 sys_mknod(void);extern uint64 sys_unlink(void);extern uint64 sys_link(void);extern uint64 sys_mkdir(void);extern uint64 sys_close(void);extern uint64 sys_trace(void); // &lt;--- Here// An array mapping syscall numbers from syscall.h// to the function that handles the system call.static uint64 (*syscalls[])(void) = &#123;[SYS_fork] sys_fork,[SYS_exit] sys_exit,[SYS_wait] sys_wait,[SYS_pipe] sys_pipe,[SYS_read] sys_read,[SYS_kill] sys_kill,[SYS_exec] sys_exec,[SYS_fstat] sys_fstat,[SYS_chdir] sys_chdir,[SYS_dup] sys_dup,[SYS_getpid] sys_getpid,[SYS_sbrk] sys_sbrk,[SYS_sleep] sys_sleep,[SYS_uptime] sys_uptime,[SYS_open] sys_open,[SYS_write] sys_write,[SYS_mknod] sys_mknod,[SYS_unlink] sys_unlink,[SYS_link] sys_link,[SYS_mkdir] sys_mkdir,[SYS_close] sys_close,[SYS_trace] sys_trace, // &lt;--- Here&#125;; 在 kernel/proc.h 中給proc 结构体添加 mask 字段 1uint64 mask; 在 kernel/sysproc.c 中添加 sys_trace() 函数，该函数用于实现新的 trace 系统调用。在该函数中，将传递给 trace 系统调用的参数保存到进程的 proc 结构中。 123456789uint64sys_trace(void)&#123; int mask; argint(0, &amp;mask); struct proc *p = myproc(); p-&gt;mask = mask; return 0;&#125; 修改 kernel/proc.c 中的 fork() 函数，以便将父进程的跟踪掩码复制到子进程中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// Create a new process, copying the parent.// Sets up child kernel stack to return as if from fork() system call.intfork(void)&#123; int i, pid; struct proc *np; struct proc *p = myproc(); // Allocate process. if((np = allocproc()) == 0)&#123; return -1; &#125; // Copy user memory from parent to child. if(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; 0)&#123; freeproc(np); release(&amp;np-&gt;lock); return -1; &#125; np-&gt;sz = p-&gt;sz; np-&gt;mask = p-&gt;mask; // copy saved user registers. *(np-&gt;trapframe) = *(p-&gt;trapframe); // Cause fork to return 0 in the child. np-&gt;trapframe-&gt;a0 = 0; // increment reference counts on open file descriptors. for(i = 0; i &lt; NOFILE; i++) if(p-&gt;ofile[i]) np-&gt;ofile[i] = filedup(p-&gt;ofile[i]); np-&gt;cwd = idup(p-&gt;cwd); safestrcpy(np-&gt;name, p-&gt;name, sizeof(p-&gt;name)); pid = np-&gt;pid; release(&amp;np-&gt;lock); acquire(&amp;wait_lock); np-&gt;parent = p; release(&amp;wait_lock); acquire(&amp;np-&gt;lock); np-&gt;state = RUNNABLE; release(&amp;np-&gt;lock); return pid;&#125; 修改 kernel/syscall.c 中的 syscall() 函数，以在需要时输出跟踪信息。 12345678910111213141516171819202122voidsyscall(void)&#123; int num; struct proc *p = myproc(); num = p-&gt;trapframe-&gt;a7; if(num &gt; 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123; // Use num to lookup the system call function for num, call it, // and store its return value in p-&gt;trapframe-&gt;a0 p-&gt;trapframe-&gt;a0 = syscalls[num](); if ((p-&gt;mask &gt;&gt; num) &amp;0b1) &#123; printf(&quot;%d: %s -&gt; %d\\n&quot;, p-&gt;pid, syscalls_name[num], p-&gt;trapframe-&gt;a0); &#125; &#125; else &#123; printf(&quot;%d %s: unknown sys call %d\\n&quot;, p-&gt;pid, p-&gt;name, num); p-&gt;trapframe-&gt;a0 = -1; &#125;&#125; 实现 user/trace.c 程序。该程序应该在新的进程中调用 trace 系统调用，然后运行另一个程序，以便跟踪指定的系统调用。在实现 user/trace.c 时，您需要使用 fork() 和 exec() 系统调用来运行其他程序。 Answer 代码改动见 commit Sysinfo (moderate) In this assignment you will add a system call, sysinfo, that collects information about the running system. The system call takes one argument: a pointer to a struct sysinfo (see kernel/sysinfo.h). The kernel should fill out the fields of this struct: the freemem field should be set to the number of bytes of free memory, and the nproc field should be set to the number of processes whose state is not UNUSED. We provide a test program sysinfotest; you pass this assignment if it prints “sysinfotest: OK”. 在 kernel/sysinfo.h 中声明 struct sysinfo 结构体，并包含两个字段： uint64_t freemem 和 uint64_t nproc. 1234struct sysinfo &#123; uint64 freemem; // amount of free memory (bytes) uint64 nproc; // number of process&#125;; usys.pl 1234567891011121314151617181920212223entry(&quot;fork&quot;);entry(&quot;exit&quot;);entry(&quot;wait&quot;);entry(&quot;pipe&quot;);entry(&quot;read&quot;);entry(&quot;write&quot;);entry(&quot;close&quot;);entry(&quot;kill&quot;);entry(&quot;exec&quot;);entry(&quot;open&quot;);entry(&quot;mknod&quot;);entry(&quot;unlink&quot;);entry(&quot;fstat&quot;);entry(&quot;link&quot;);entry(&quot;mkdir&quot;);entry(&quot;chdir&quot;);entry(&quot;dup&quot;);entry(&quot;getpid&quot;);entry(&quot;sbrk&quot;);entry(&quot;sleep&quot;);entry(&quot;uptime&quot;);entry(&quot;trace&quot;);entry(&quot;sysinfo&quot;); user.h 12345678910111213141516171819202122232425// system callsint fork(void);int exit(int) __attribute__((noreturn));int wait(int*);int pipe(int*);int write(int, const void*, int);int read(int, void*, int);int close(int);int kill(int);int exec(const char*, char**);int open(const char*, int);int mknod(const char*, short, short);int unlink(const char*);int fstat(int fd, struct stat*);int link(const char*, const char*);int mkdir(const char*);int chdir(const char*);int dup(int);int getpid(void);char* sbrk(int);int sleep(int);int uptime(void);int trace(int);struct sysinfo;int sysinfo(struct sysinfo *); 在 kernel/syscall.h 中添加一个名为 sysinfo() 的原型和一个新的系统调用号。 123456789101112131415161718192021222324// System call numbers#define SYS_fork 1#define SYS_exit 2#define SYS_wait 3#define SYS_pipe 4#define SYS_read 5#define SYS_kill 6#define SYS_exec 7#define SYS_fstat 8#define SYS_chdir 9#define SYS_dup 10#define SYS_getpid 11#define SYS_sbrk 12#define SYS_sleep 13#define SYS_uptime 14#define SYS_open 15#define SYS_write 16#define SYS_mknod 17#define SYS_unlink 18#define SYS_link 19#define SYS_mkdir 20#define SYS_close 21#define SYS_trace 22#define SYS_sysinfo 23 在 kernel/sysproc.c 中实现 sys_sysinfo() 函数。 123456789101112131415161718uint64sys_sysinfo(void)&#123; // user pointer to struct sysinfo uint64 si_addr; argaddr(0, &amp;si_addr); struct sysinfo sysinfo; sysinfo.freemem = free_mem_num(); sysinfo.nproc = num_of_processes(); if (copyout(myproc()-&gt;pagetable, si_addr, (char *)&amp;sysinfo, sizeof(sysinfo)) &lt; 0) return -1; return 0;&#125; 添加一个名为 free_mem_num() 的函数到 kernel/kalloc.c, 返回系统中空闲内存的字节数。 1234567891011121314151617// 统计未使用内存// 一页等于 4096 bytesuint64free_mem_num(void)&#123; struct run *r; uint64 free_num = 0; acquire(&amp;kmem.lock); r = kmem.freelist; while (r) &#123; free_num++; r = r-&gt;next; &#125; release(&amp;kmem.lock); return free_num * PGSIZE;&#125; 添加一个名为 num_of_processes() 的函数到 kernel/proc.c, 返回状态不是 UNUSED 的进程数量。 1234567891011// used by sysinfointnum_of_processes(void)&#123; int nproc = 0; for (struct proc *p = proc; p &lt; &amp;proc[NPROC]; p++) &#123; if (p-&gt;state != UNUSED) nproc++; &#125; return nproc;&#125; 在 sysinfo() 函数中，分别调用 free_mem_num() 和 num_of_processes() 函数来填充结构体 sysinfo 中的 freemem 和 nproc 字段。 使用 copyout() 函数将结构体 sysinfo 复制回用户空间。 Answer 代码改动见 commit","categories":[],"tags":[{"name":"OS","slug":"OS","permalink":"http://www.misaka-9982.com/tags/OS/"},{"name":"6.S081","slug":"6-S081","permalink":"http://www.misaka-9982.com/tags/6-S081/"}]},{"title":"6.S081-Lab 1: Xv6 and Unix utilities","slug":"6-S081-Lab-1-Xv6-and-Unix-utilities","date":"2023-03-09T16:06:35.000Z","updated":"2023-03-14T08:53:27.463Z","comments":true,"path":"2023/03/10/6-S081-Lab-1-Xv6-and-Unix-utilities/","link":"","permalink":"http://www.misaka-9982.com/2023/03/10/6-S081-Lab-1-Xv6-and-Unix-utilities/","excerpt":"","text":"官方材料：https://pdos.csail.mit.edu/6.S081/2021/labs/util.html 参考资料： https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/ https://th0ar.gitbooks.io/xv6-chinese/content/ https://blog.miigon.net/posts/s081-ending/ https://wangchujiang.com/linux-command/ Boot xv6 (easy) 1234567$ git clone git://g.csail.mit.edu/xv6-labs-2021Cloning into &#x27;xv6-labs-2021&#x27;......$ cd xv6-labs-2021$ git checkout utilBranch &#x27;util&#x27; set up to track remote branch &#x27;util&#x27; from &#x27;origin&#x27;.Switched to a new branch &#x27;util&#x27; Build and run xv6: 12345678910111213141516171819$ make qemuriscv64-unknown-elf-gcc -c -o kernel/entry.o kernel/entry.Sriscv64-unknown-elf-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_UTIL -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie -c -o kernel/start.o kernel/start.c... riscv64-unknown-elf-ld -z max-page-size=4096 -N -e main -Ttext 0 -o user/_zombie user/zombie.o user/ulib.o user/usys.o user/printf.o user/umalloc.oriscv64-unknown-elf-objdump -S user/_zombie &gt; user/zombie.asmriscv64-unknown-elf-objdump -t user/_zombie | sed &#x27;1,/SYMBOL TABLE/d; s/ .* / /; /^$/d&#x27; &gt; user/zombie.symmkfs/mkfs fs.img README user/xargstest.sh user/_cat user/_echo user/_forktest user/_grep user/_init user/_kill user/_ln user/_ls user/_mkdir user/_rm user/_sh user/_stressfs user/_usertests user/_grind user/_wc user/_zombie nmeta 46 (boot, super, log blocks 30 inode blocks 13, bitmap blocks 1) blocks 954 total 1000balloc: first 591 blocks have been allocatedballoc: write bitmap block at sector 45qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0xv6 kernel is bootinghart 2 startinghart 1 startinginit: starting sh$ ls 命令： 12345678910111213141516171819202122$ ls. 1 1 1024.. 1 1 1024README 2 2 2059xargstest.sh 2 3 93cat 2 4 24256echo 2 5 23080forktest 2 6 13272grep 2 7 27560init 2 8 23816kill 2 9 23024ln 2 10 22880ls 2 11 26448mkdir 2 12 23176rm 2 13 23160sh 2 14 41976stressfs 2 15 24016usertests 2 16 148456grind 2 17 38144wc 2 18 25344zombie 2 19 22408console 3 20 0 xv6没有ps命令，Ctrl-p命令可以让kernel打印每个进程的信息 退出 qemu : Ctrl-a x. 编程样例 在实现对应功能后，需要更新Makefile的UPROGS部分，例如实现了sleep.c后，要在UPROGS处追加： 1$U/_sleep\\ copy.c: 123456789101112131415#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;intmain() &#123; char buf[64]; while(1) &#123; int n = read(0, buf, sizeof(buf)); if(n &lt;= 0) break; write(1, buf, n); &#125; exit(0);&#125; 第一个参数是文件描述符，指向一个之前打开的文件。Shell会确保默认情况下，当一个程序启动时，文件描述符0连接到console的输入，文件描述符1连接到了console的输出。所以我可以通过这个程序看到console打印我的输入。当然，这里的程序会预期文件描述符已经被Shell打开并设置好。这里的0，1文件描述符是非常普遍的Unix风格，许多的Unix系统都会从文件描述符0读取数据，然后向文件描述符1写入数据。 read的第二个参数是指向某段内存的指针，程序可以通过指针对应的地址读取内存中的数据，这里的指针就是代码中的buf参数。在代码第10行，程序在栈里面申请了64字节的内存，并将指针保存在buf中，这样read可以将数据保存在这64字节中。 read的第三个参数是代码想读取的最大长度，sizeof(buf)表示，最多读取64字节的数据，所以这里的read最多只能从连接到文件描述符0的设备，也就是console中，读取64字节的数据。 open.c: 1234567891011#include &quot;kernel/types.h&quot;#include &quot;user/user.h&quot;#include &quot;kernel/fcntl.h&quot;intmain()&#123; int fd = open(&quot;output.txt&quot;, O_WRONLY | O_CREATE); write(fd, &quot;ooo\\n&quot;, 4); exit(0);&#125; 代码中的第8行，执行了open系统调用，将文件名output.txt作为参数传入，第二个参数是一些标志位，用来告诉open系统调用在内核中的实现：我们将要创建并写入一个文件。open系统调用会返回一个新分配的文件描述符，这里的文件描述符是一个小的数字，可能是2，3，4或者其他的数字。 之后，这个文件描述符作为第一个参数被传到了write，write的第二个参数是数据的指针，第三个参数是要写入的字节数。数据被写入到了文件描述符对应的文件中。 文件描述符本质上对应了内核中的一个表单数据。内核维护了每个运行进程的状态，内核会为每一个运行进程保存一个表单，表单的key是文件描述符。这个表单让内核知道，每个文件描述符对应的实际内容是什么。这里比较关键的点是，每个进程都有自己独立的文件描述符空间，所以如果运行了两个不同的程序，对应两个不同的进程，如果它们都打开一个文件，它们或许可以得到相同数字的文件描述符，但是因为内核为每个进程都维护了一个独立的文件描述符空间，这里相同数字的文件描述符可能会对应到不同的文件。 fork.c: 1234567891011121314151617#include &quot;kernel/types.h&quot;#include &quot;user/user.h&quot;intmain()&#123; int pid; pid = fork(); printf(&quot;fork() returned %d\\n&quot;, pid); if(pid == 0) &#123; printf(&quot;child\\n&quot;); &#125; else &#123; printf(&quot;parent\\n&quot;); &#125; exit(0);&#125; fork会拷贝当前进程的内存，并创建一个新的进程，这里的内存包含了进程的指令和数据。之后，我们就有了两个拥有完全一样内存的进程。fork系统调用在两个进程中都会返回，在原始的进程中，fork系统调用会返回大于0的整数，这个是新创建进程的ID。而在新创建的进程中，fork系统调用会返回0。所以即使两个进程的内存是完全一样的，我们还是可以通过fork的返回值区分旧进程和新进程。 在第11行，你可以看到代码检查pid。如果pid等于0，那么这必然是子进程。在我们的例子中，调用进程通常称为父进程，父进程看到的pid必然大于0。所以父进程会打印“parent”，子进程会打印“child”。之后两个进程都会退出。 12345$ forkfork() returned 5parent$ fork() returned 0child redirected.c: 123456789101112131415161718192021#include &quot;kernel/types.h&quot;#include &quot;kernel/fcntl.h&quot;#include &quot;user/user.h&quot;int main()&#123; int pid; pid = fork(); if(pid == 0) &#123; close(1); open(&quot;output.txt&quot;, O_WRONLY|O_CREATE); char *argv[] = &#123;&quot;echo&quot;, &quot;this&quot;, &quot;is&quot;, &quot;redirected&quot;, &quot;echo&quot;, 0&#125;; exec(&quot;echo&quot;, argv); printf(&quot;exec failed!\\n&quot;); exit(1); &#125; else &#123; wait((int*) 0); &#125; exit(0);&#125; 123$ redirected$ cat output.txtthis is redirected echo sleep (easy) Implement the UNIX program sleep for xv6; your sleep should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip. Your solution should be in the file user/sleep.c. Some hints: Before you start coding, read Chapter 1 of the xv6 book. Look at some of the other programs in user/ (e.g., user/echo.c, user/grep.c, and user/rm.c) to see how you can obtain the command-line arguments passed to a program. If the user forgets to pass an argument, sleep should print an error message. The command-line argument is passed as a string; you can convert it to an integer using atoi (see user/ulib.c). Use the system call sleep. See kernel/sysproc.c for the xv6 kernel code that implements the sleep system call (look for sys_sleep), user/user.h for the C definition of sleep callable from a user program, and user/usys.S for the assembler code that jumps from user code into the kernel for sleep. Make sure main calls exit() in order to exit your program. Add your sleep program to UPROGS in Makefile; once you’ve done that, make qemu will compile your program and you’ll be able to run it from the xv6 shell. Look at Kernighan and Ritchie’s book The C programming language (second edition) (K&amp;R) to learn about C. sleep.c: 123456789101112131415#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;intmain(int argc, char *argv[])&#123; if(argc &lt; 2) &#123; fprintf(2, &quot;Please enter a number!\\n&quot;); exit(1); &#125; int time = atoi(argv[1]); sleep(time); exit(0);&#125; 测试： 12345$ sudo ./grade-lab-util sleepmake: “kernel/kernel”已是最新。== Test sleep, no arguments == sleep, no arguments: OK (1.5s) == Test sleep, returns == sleep, returns: OK (0.9s) == Test sleep, makes syscall == sleep, makes syscall: OK (0.9s) pingpong (easy) Write a program that uses UNIX system calls to ‘‘ping-pong’’ a byte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print “: received ping”, where is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print “: received pong”, and exit. Your solution should be in the file user/pingpong.c. Some hints: Use pipe to create a pipe. Use fork to create a child. Use read to read from the pipe, and write to write to the pipe. Use getpid to find the process ID of the calling process. Add the program to UPROGS in Makefile. User programs on xv6 have a limited set of library functions available to them. You can see the list in user/user.h; the source (other than for system calls) is in user/ulib.c, user/printf.c, and user/umalloc.c. 管道参考资料： https://blog.csdn.net/qq_42914528/article/details/82023408 pipe 输入为长度为2的 int 数组 p， 其中 p[0] 为对应的输入文件描述符，p[1] 为对应的输出文件描述符 样例： 12345678910111213141516int p[2];char *argv[2];argv[0] = &quot;wc&quot;;argv[1] = 0;pipe(p);if(fork() == 0) &#123; close(0); dup(p[0]); close(p[0]); close(p[1]); exec(&quot;/bin/wc&quot;, argv);&#125; else &#123; close(p[0]); write(p[1], &quot;hello world\\n&quot;, 12); close(p[1]);&#125; pingpong.c: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;#define END_READ 0#define END_WRITE 1intmain(int argc, char *argv[])&#123; int p2c[2], c2p[2]; pipe(p2c); // 创建用于 父进程 -&gt; 子进程 的管道 pipe(c2p); // 创建用于 子进程 -&gt; 父进程 的管道 if(fork() != 0) &#123; char buf[2]; // 1. 父进程 首先向 子进程 发送字节 if(write(p2c[END_WRITE], &quot;!&quot;, 1) != 1) &#123; fprintf(2, &quot;failed to write in parent\\n&quot;); exit(1); &#125; close(p2c[END_WRITE]); wait(0); // 2. 父进程 发送完成后，开始等待 子进程 的回复 if(read(c2p[END_READ], buf, 1) != 1) &#123; fprintf(2, &quot;failed to read in parent&quot;); exit(1); &#125; // 5. 子进程 收到数据， read 返回， 输出 pong printf(&quot;%d: received pong\\n&quot;, getpid()); close(p2c[END_READ]); &#125; else &#123; char buf[2]; // 3. 子进程 读取管道， 收到 父进程 发送的字节数据 if(read(p2c[END_READ], buf, 1) != 1) &#123; fprintf(2, &quot;failed to read in child\\n&quot;); exit(1); &#125; close(c2p[END_READ]); printf(&quot;%d: received ping\\n&quot;, getpid()); // 4. 子进程 通过 子-&gt;父 管道，将字节送回 父进程 if(write(c2p[END_WRITE], buf, 1) != 1) &#123; fprintf(2, &quot;failed to write in child\\n&quot;); exit(1); &#125; close(c2p[END_WRITE]); &#125; exit(0);&#125; 该程序是一个基于进程间通信机制的简单 ping-pong 程序，实现了一个父进程向子进程发送 “!” 字节，子进程读取并输出 “received ping”，然后将同样的字节回送给父进程，最后父进程读取回送的字节并输出 “received pong”。 父进程 首先向 子进程 发送字节 父进程 发送完成后，开始等待 子进程 的回复 子进程 读取管道， 收到 父进程 发送的字节数据 子进程 通过 子-&gt;父 管道，将字节送回 父进程 子进程 收到数据， read 返回， 输出 pong 其中，使用 pipe 系统调用创建管道，使用 fork 系统调用创建子进程，close 系统调用关闭不需要的管道端口，read 系统调用从管道中读取字节，write 系统调用向管道中写入字节，使用 wait 系统调用等待子进程结束。 测试： 123$ sudo ./grade-lab-util pingpongmake: “kernel/kernel”已是最新。== Test pingpong == pingpong: OK (1.0s) primes (moderate)/(hard) Write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down this page and the surrounding text explain how to do it. Your solution should be in the file user/primes.c. Your goal is to use pipe and fork to set up the pipeline. The first process feeds the numbers 2 through 35 into the pipeline. For each prime number, you will arrange to create one process that reads from its left neighbor over a pipe and writes to its right neighbor over another pipe. Since xv6 has limited number of file descriptors and processes, the first process can stop at 35. Some hints: Be careful to close file descriptors that a process doesn’t need, because otherwise your program will run xv6 out of resources before the first process reaches 35. Once the first process reaches 35, it should wait until the entire pipeline terminates, including all children, grandchildren, &amp;c. Thus the main primes process should only exit after all the output has been printed, and after all the other primes processes have exited. Hint: read returns zero when the write-side of a pipe is closed. It’s simplest to directly write 32-bit (4-byte) ints to the pipes, rather than using formatted ASCII I/O. You should create the processes in the pipeline only as they are needed. Add the program to UPROGS in Makefile. 文档链接：https://swtch.com/~rsc/thread/ 多线程埃氏筛 123456p = get a number from left neighborprint ploop: n = get a number from left neighbor if (p does not divide n) send n to right neighbor 单线程埃氏筛CPP实现： primes数组记录素数 st数组标记数字是否为素数 每次遇到素数 i 则将范围 $[2 * i, n]$ 的 i 的倍数全部标记 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int primes[N], cnt;bool st[N];void get_primes(int n) &#123; for(int i = 2; i &lt;= n; i ++ ) if(!st[i]) &#123; primes[cnt ++ ] = i; for(int j = i + i; j &lt;= n; j += i) st[j] = true; &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; get_primes(n); cout &lt;&lt; cnt &lt;&lt; endl; for(int i = 0; i &lt; cnt; i ++ ) cout &lt;&lt; primes[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; return 0;&#125; primes.c: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &quot;kernel/types.h&quot;#include &quot;user/user.h&quot;#define END_READ 0#define END_WRITE 1voidsieve(int pipe_l[2])&#123; int prime, cur; if(read(pipe_l[END_READ], &amp;prime, sizeof(prime)) != sizeof(prime)) &#123; fprintf(2, &quot;failed to read from the pipe_l\\n&quot;); exit(1); &#125; printf(&quot;prime %d\\n&quot;, prime); if(read(pipe_l[END_READ], &amp;cur, sizeof(cur)) == sizeof(cur)) &#123; int pipe_r[2]; pipe(pipe_r); if(fork() != 0) &#123; do &#123; if(cur % prime == 0) &#123; continue; &#125; if(write(pipe_r[END_WRITE], &amp;cur, sizeof(cur)) != sizeof(cur)) &#123; fprintf(2, &quot;failed to write into the pipe_r&quot;); exit(1); &#125; &#125; while(read(pipe_l[END_READ], &amp;cur, sizeof(cur)) == sizeof(cur)); close(pipe_r[END_WRITE]); close(pipe_l[END_READ]); wait(0); &#125; else &#123; close(pipe_r[END_WRITE]); close(pipe_l[END_READ]); sieve(pipe_r); &#125; &#125; exit(1);&#125;intmain(int argc, char *argv[])&#123; int input[2]; pipe(input); int start = 2, end = 35; if(fork() != 0) &#123; close(input[END_READ]); for(int i = start; i &lt;= end; i ++ ) &#123; if(write(input[END_WRITE], &amp;i, sizeof(i)) != sizeof(i)) &#123; fprintf(2, &quot;failed to write %d into the pipe in the parent&quot;, i); exit(1); &#125; &#125; close(input[END_WRITE]); wait(0); &#125; else &#123; close(input[END_WRITE]); sieve(input); &#125; exit(0);&#125; 这段代码实现了一个简单的 Eratosthenes 筛法，用于找出一定范围内的所有素数。 在该程序中，使用了 kernel/types.h 和 user/user.h 两个头文件，其中 types.h 定义了一些基本的数据类型，user.h 定义了一些系统调用。 在 main 函数中，首先使用 pipe 系统调用创建一个管道，用于父子进程之间的通信。然后使用 fork 系统调用创建一个新的进程。在父进程中，关闭管道的读端，然后向管道写入一段整数序列（从 start 到 end）。在子进程中，关闭管道的写端，然后调用 sieve 函数，开始执行筛法。 在 sieve 函数中，首先从管道读入第一个质数 prime，并输出其值。然后在循环中读入管道中的下一个整数 cur，如果 cur 不是 prime 的倍数，则将其写入一个新的管道 pipe_r 中。然后继续从管道中读入下一个整数，直到读完所有整数。当读完所有整数后，关闭新的管道的写端和原管道的读端，等待子进程结束。 整个程序的逻辑比较简单，主要是父进程向管道中写入整数序列，子进程读取管道中的整数并执行筛法。在筛法过程中，每次从管道中读入一个质数，然后将不是质数的整数写入一个新的管道中。最后，当读完所有整数后，关闭管道并等待子进程结束。 测试： 123$ sudo ./grade-lab-util primesmake: “kernel/kernel”已是最新。== Test primes == primes: OK (0.8s) find (moderate) Write a simple version of the UNIX find program: find all the files in a directory tree with a specific name. Your solution should be in the file user/find.c. Some hints: Look at user/ls.c to see how to read directories. Use recursion to allow find to descend into sub-directories. Don’t recurse into “.” and “…”. Changes to the file system persist across runs of qemu; to get a clean file system run make clean and then make qemu. You’ll need to use C strings. Have a look at K&amp;R (the C book), for example Section 5.5. Note that == does not compare strings like in Python. Use strcmp() instead. Add the program to UPROGS in Makefile. stat.h: 1234567891011#define T_DIR 1 // Directory#define T_FILE 2 // File#define T_DEVICE 3 // Devicestruct stat &#123; int dev; // File system&#x27;s disk device //文件系统设备号 uint ino; // Inode number //Inode 值 short type; // Type of file //文件类型 short nlink; // Number of links to file //文件被链接数 uint64 size; // Size of file in bytes //文件大小&#125;; dirent结构体: inum是说这个文件占了几个inode,name是这个文件的名字。 1234567// Directory is a file containing a sequence of dirent structures.#define DIRSIZ 14struct dirent &#123; ushort inum; char name[DIRSIZ];&#125;; ls.c: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;#include &quot;kernel/fs.h&quot;// 返回 path 最后一个 ‘/’ 后的 字符串char *fmtname(char *path)&#123; static char buf[DIRSIZ + 1]; char *p; // Find first character after last slash. for (p = path + strlen(path); p &gt;= path &amp;&amp; *p != &#x27;/&#x27;; p--) ; p++; // Return blank-padded name. // 多余空间用空格填充 if (strlen(p) &gt;= DIRSIZ) return p; memmove(buf, p, strlen(p)); memset(buf + strlen(p), &#x27; &#x27;, DIRSIZ - strlen(p)); return buf;&#125;void ls(char *path)&#123; char buf[512], *p; int fd; struct dirent de; struct stat st; // 打开 path 文件 if ((fd = open(path, 0)) &lt; 0) &#123; fprintf(2, &quot;ls: cannot open %s\\n&quot;, path); return; &#125; // 返回文件信息 if (fstat(fd, &amp;st) &lt; 0) &#123; fprintf(2, &quot;ls: cannot stat %s\\n&quot;, path); close(fd); return; &#125; switch (st.type) &#123; // 文件 case T_FILE: printf(&quot;%s %d %d %l\\n&quot;, fmtname(path), st.type, st.ino, st.size); break; // 目录 case T_DIR: if (strlen(path) + 1 + DIRSIZ + 1 &gt; sizeof buf) &#123; printf(&quot;ls: path too long\\n&quot;); break; &#125; strcpy(buf, path); p = buf + strlen(buf); *p++ = &#x27;/&#x27;; while (read(fd, &amp;de, sizeof(de)) == sizeof(de)) &#123; if (de.inum == 0) continue; memmove(p, de.name, DIRSIZ); p[DIRSIZ] = 0; if (stat(buf, &amp;st) &lt; 0) &#123; printf(&quot;ls: cannot stat %s\\n&quot;, buf); continue; &#125; printf(&quot;%s %d %d %d\\n&quot;, fmtname(buf), st.type, st.ino, st.size); &#125; break; &#125; close(fd);&#125;int main(int argc, char *argv[])&#123; int i; if (argc &lt; 2) &#123; ls(&quot;.&quot;); exit(0); &#125; for (i = 1; i &lt; argc; i++) ls(argv[i]); exit(0);&#125; ls 命令用于列出指定目录下的文件和子目录信息。该代码实现了一个简化版本的 ls 命令，能够列出指定目录下的文件和子目录信息，并打印文件的类型、inode 号和大小等信息。 该程序接受一个或多个参数，每个参数表示要列出信息的目录或文件路径。如果没有传递参数，则默认列出当前目录下的文件和子目录信息。 在程序中，ls() 函数用于列出指定路径下的文件和子目录信息，具体实现如下： 首先使用 open() 函数打开指定路径的文件或目录，获取文件描述符。 使用 fstat() 函数获取文件或目录的元信息（包括类型、inode 号和大小等）。 根据文件或目录的类型分别处理： 如果是文件或设备，则打印文件名、类型、inode 号和大小等信息。 如果是目录，则递归读取目录中的子目录和文件，并对其进行处理。对于每个子目录或文件，也会打印文件名、类型、inode 号和大小等信息。 使用 close() 函数关闭文件描述符。 另外，fmtname() 函数用于从完整路径中获取文件名，以便在输出信息中使用。该函数的实现过程是找到路径中最后一个斜线后面的字符，并将其复制到一个缓冲区中。 main() 函数用于解析命令行参数，调用 ls() 函数列出指定路径下的文件和子目录信息。 find.c: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;#include &quot;kernel/fs.h&quot;voidfind(char *path, char *file)&#123; char buf[512], *p; int fd; struct dirent de; struct stat st; if ((fd = open(path, 0)) &lt; 0)&#123; fprintf(2, &quot;find: cannot open %s\\n&quot;, path); return; &#125; if (fstat(fd, &amp;st) &lt; 0)&#123; fprintf(2, &quot;find: cannot stat %s\\n&quot;, path); close(fd); return; &#125; if(strlen(path) + 1 + DIRSIZ + 1 &gt; sizeof buf)&#123; printf(&quot;find: path too long\\n&quot;); &#125; strcpy(buf, path); p = buf+strlen(buf); *p++ = &#x27;/&#x27;; while(read(fd, &amp;de, sizeof(de)) == sizeof(de))&#123; if(de.inum == 0 || strcmp(de.name, &quot;.&quot;) == 0 || strcmp(de.name, &quot;..&quot;) == 0) continue; memmove(p, de.name, DIRSIZ); p[DIRSIZ] = 0; if(stat(buf, &amp;st) &lt; 0) &#123; printf(&quot;find: cannot stat %s\\n&quot;, buf); continue; &#125; if(st.type == T_DIR)&#123; find(buf, file); &#125; else if (st.type == T_FILE)&#123; if(strcmp(de.name, file) == 0) &#123; printf(&quot;%s\\n&quot;, buf); &#125; &#125; &#125; close(fd);&#125;intmain(int argc, char *argv[])&#123; if (argc != 3)&#123; fprintf(2, &quot;Usage: find &lt;dir&gt; &lt;file&gt;...\\n&quot;); exit(1); &#125; find(argv[1], argv[2]); exit(0);&#125; 这段代码实现了一个命令行工具 find，用于在指定目录下查找指定文件。 首先，包含了四个头文件 kernel/types.h、kernel/stat.h、user/user.h 和 kernel/fs.h，分别定义了一些基本数据类型、文件状态、系统调用和文件系统相关的结构体和宏。其中 find 函数通过递归实现了对目录的遍历，并通过调用 stat 系统调用获取文件状态信息。 在 main 函数中，首先判断命令行参数数量是否正确。如果不正确，则输出错误信息并退出；否则调用 find 函数进行查找。 在 find 函数中，首先通过调用 open 和 fstat 系统调用打开目录并获取其状态信息。然后通过循环遍历目录中的所有文件，对于每一个文件，首先判断是否为当前目录或父目录，如果不是，则获取其完整路径，并通过调用 stat 系统调用获取其状态信息。如果是目录，则递归调用 find 函数继续查找；如果是指定的文件，则输出其完整路径。 整个程序的逻辑比较复杂，通过系统调用和文件操作实现了一个较为复杂的命令行工具。这个例子也展示了如何使用文件系统相关的结构体和宏，以及如何通过递归遍历目录来实现文件查找功能。 测试： 1234$ sudo ./grade-lab-util find make: “kernel/kernel”已是最新。== Test find, in current directory == find, in current directory: OK (1.3s) == Test find, recursive == find, recursive: OK (1.1s) xargs (moderate) Write a simple version of the UNIX xargs program: read lines from the standard input and run a command for each line, supplying the line as arguments to the command. Your solution should be in the file user/xargs.c. Some hints: Use fork and exec to invoke the command on each line of input. Use wait in the parent to wait for the child to complete the command. To read individual lines of input, read a character at a time until a newline (‘\\n’) appears. kernel/param.h declares MAXARG, which may be useful if you need to declare an argv array. Add the program to UPROGS in Makefile. Changes to the file system persist across runs of qemu; to get a clean file system run make clean and then make qemu. xargs效果示例： 123$ echo hello too | xargs echo byebye hello too$ 1234$ echo &quot;1\\n2&quot; | xargs -n 1 echo lineline 1line 2$ 1$ find . b | xargs grep hello xargs命令介绍： https://wangchujiang.com/linux-command/c/xargs.html http://www.ruanyifeng.com/blog/2019/08/xargs-tutorial.html 整体思路： 将 xargs 命令传入的参数保存至数组，形式为cmd, arg[0], … , arg[k - 1]； 解析输入参数，根据 \\n 将参数划分至多行； 对每行参数根据空格划分，更新参数数组为 cmd, arg[0], … , arg[k - 1], arg[k], … , arg[k + l - 1]； 利用 exec 调用函数； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;#include &quot;kernel/param.h&quot;intreadline(char *new_argv[MAXARG], int cur)&#123; char buf[1024]; int n = 0; while(read(0, buf + n, 1)) &#123; if(n == 1023) &#123; fprintf(2, &quot;the argument is too long...\\n&quot;); exit(1); &#125; if(buf[n] == &#x27;\\n&#x27;) break; n ++ ; &#125; buf[n] = &#x27;\\0&#x27;; if(n == 0) return 0; int offset = 0; while(offset &lt; n) &#123; new_argv[cur ++ ] = buf + offset; while(buf[offset] != &#x27; &#x27; &amp;&amp; offset &lt; n) &#123; offset ++ ; &#125; while(buf[offset] == &#x27; &#x27; &amp;&amp; offset &lt; n) &#123; buf[offset ++ ] = &#x27;\\0&#x27;; &#125; &#125; return cur;&#125;voidrun(char *cmd, char *new_argv[])&#123; if(fork() == 0) &#123; exec(cmd, new_argv); exit(0); &#125; return;&#125;intmain(int argc, char *argv[])&#123; if (argc &lt; 2) &#123; fprintf(2, &quot;Usage: xargs command (arg ...)\\n&quot;); exit(1); &#125; char *cmd = malloc(strlen(argv[1]) + 1); char *new_argv[MAXARG]; strcpy(cmd, argv[1]); for(int i = 1; i &lt; argc; i ++ ) &#123; new_argv[i - 1] = malloc(strlen(argv[i]) + 1); strcpy(new_argv[i - 1], argv[i]); &#125; int cur = 0; while((cur = readline(new_argv, argc - 1)) != 0) &#123; new_argv[cur] = &#x27;\\0&#x27;; run(cmd, new_argv); wait(0); &#125; exit(0);&#125; 这段代码实现了一个类似于 Linux 命令 xargs 的工具，用于将输入作为命令行参数传递给指定的命令。 在该程序中，使用了 kernel/types.h、kernel/stat.h、user/user.h 和 kernel/param.h 四个头文件，其中 types.h 和 stat.h 定义了一些基本的数据类型和文件状态相关的结构体，user.h 定义了一些系统调用，param.h 定义了一些系统参数。 在 main 函数中，首先判断命令行参数数量是否正确。如果参数数量不正确，则输出错误信息并退出。然后，根据命令行参数分配相应的内存空间，分别存储命令和参数，然后循环读取标准输入，并将输入作为参数传递给命令。 在 readline 函数中，通过循环读取标准输入，逐字符读入命令行参数，当读入到换行符时停止读取。读取完成后，将读入的参数分割成一个个独立的字符串，并存储在 new_argv 数组中，然后返回当前参数个数。 在 run 函数中，使用 fork 系统调用创建一个新的进程，并在子进程中执行指定的命令，并将参数传递给命令。然后在父进程中等待子进程执行完毕。 整个程序的逻辑比较简单，主要是读取标准输入并将输入作为命令行参数传递给指定的命令。 测试： 123$ sudo ./grade-lab-util xargsmake: “kernel/kernel”已是最新。== Test xargs == xargs: OK (0.7s) 1234567891011121314151617181920212223242526272829$ vim time.txt # 写上自己花在这个 Lab 多少个小时的时间$ make grade== Test sleep, no arguments == $ make qemu-gdbsleep, no arguments: OK (2.5s) == Test sleep, returns == $ make qemu-gdbsleep, returns: OK (0.4s) == Test sleep, makes syscall == $ make qemu-gdbsleep, makes syscall: OK (1.1s) == Test pingpong == $ make qemu-gdbpingpong: OK (0.9s) == Test primes == $ make qemu-gdbprimes: OK (1.1s) == Test find, in current directory == $ make qemu-gdbfind, in current directory: OK (1.0s) == Test find, recursive == $ make qemu-gdbfind, recursive: OK (1.1s) == Test xargs == $ make qemu-gdbxargs: OK (1.1s) == Test time == time: OK Score: 100/100","categories":[],"tags":[{"name":"OS","slug":"OS","permalink":"http://www.misaka-9982.com/tags/OS/"},{"name":"6.S081","slug":"6-S081","permalink":"http://www.misaka-9982.com/tags/6-S081/"}]},{"title":"6.S081环境配置及参考资料","slug":"6-S081环境配置及参考资料","date":"2023-03-09T10:55:59.000Z","updated":"2023-03-16T15:26:47.225Z","comments":true,"path":"2023/03/09/6-S081环境配置及参考资料/","link":"","permalink":"http://www.misaka-9982.com/2023/03/09/6-S081%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/","excerpt":"","text":"参考资料 官方文档：https://pdos.csail.mit.edu/6.828/2020/schedule.html 官方指导：https://pdos.csail.mit.edu/6.S081/2021/labs/guidance.html 中文文档：https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/ doraemonzzz http://xv6.dgs.zone/ https://ithelp.ithome.com.tw/m/users/20138181/ironman/5395 https://www.zaom.cc/public-class/mit-6s081/ Miigon’s blog HITSZ操作系统课程组讲解XV6（一）启动过程 HITSZ操作系统课程组讲解XV6（二）进程管理 HITSZ操作系统课程组讲解XV6（三）内存管理 安装XV6 12apt-get updatesudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu The latest xv6 source and text are available via 1&gt;git clone git://github.com/mit-pdos/xv6-riscv.git and 1&gt;git clone git://github.com/mit-pdos/xv6-riscv-book.git 12cd xv6-riscvmake qemu 安装成功 指针预备知识 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void f(void) &#123; int a[4]; int *b = malloc(16); int *c; int i; printf(&quot;1: a = %p, b = %p, c = %p\\n&quot;, a, b, c); c = a; for (i = 0; i &lt; 4; i++) a[i] = 100 + i; c[0] = 200; printf(&quot;2: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\\n&quot;, a[0], a[1], a[2], a[3]); c[1] = 300; *(c + 2) = 301; 3[c] = 302; printf(&quot;3: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\\n&quot;, a[0], a[1], a[2], a[3]); c = c + 1; *c = 400; printf(&quot;4: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\\n&quot;, a[0], a[1], a[2], a[3]); c = (int *) ((char *) c + 1); *c = 500; printf(&quot;5: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\\n&quot;, a[0], a[1], a[2], a[3]); b = (int *) a + 1; c = (int *) ((char *) a + 1); printf(&quot;6: a = %p, b = %p, c = %p\\n&quot;, a, b, c);&#125;int main(int ac, char **av) &#123; f(); return 0;&#125; GDB 调试 打开两个终端窗口 在第一个窗口中输入make qemu-gdb 1*** Now run &#x27;gdb&#x27; in another window. qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0 -S -gdb tcp::25500 在第二个窗口中，修改自己 home 目录下的 .gdbinit 文件，允许 gdb 在xv6-riscv这个目录启动的时候，加载该文件夹下的 .gdbinit 文件。 1echo &quot;add-auto-load-safe-path YOUR_PATH/xv6-riscv/.gdbinit &quot; &gt;&gt; ~/.gdbinit 输入gdb-multiarch 1234567891011121314151617181920212223$ echo &quot;add-auto-load-safe-path /home/ubuntu/xv6-riscv/.gdbinit &quot; &gt;&gt; ~/.gdbinit$ gdb-multiarch GNU gdb (Ubuntu 9.2-0ubuntu1~20.04) 9.2Copyright (C) 2020 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.Type &quot;show copying&quot; and &quot;show warranty&quot; for details.This GDB was configured as &quot;x86_64-linux-gnu&quot;.Type &quot;show configuration&quot; for configuration details.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;.Find the GDB manual and other documentation resources online at: &lt;http://www.gnu.org/software/gdb/documentation/&gt;.For help, type &quot;help&quot;.Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;.The target architecture is assumed to be riscv:rv64warning: No executable has been specified and target does not supportdetermining executable automatically. Try using the &quot;file&quot; command.0x0000000000001000 in ?? ()(gdb) 给代码打断点 简单来说，就是以下几步： file user/_ls b main c 之后就是正常的GDB 使用流程了 FINALLY： 第二个窗口： 123456789101112(gdb) file user/_lsReading symbols from user/_ls...(gdb) b mainBreakpoint 1 at 0x27a: file user/ls.c, line 75.(gdb) cContinuing.[Switching to Thread 1.3]Thread 3 hit Breakpoint 1, main (argc=0, argv=0x6c &lt;fmtname+108&gt;) at user/ls.c:7575 &#123;(gdb) 第一个窗口 12345678(......)xv6 kernel is booting hart 1 starting hart 2 starting init: starting sh $ ls(等待 gdb 发送 continue 信号) 之后我们就可以正常地通过 GDB 调试程序啦~ VSCode 调试 https://www.515code.com/posts/r1eiw7kt/#1-4-VSCode调试 比较推荐，功能更全。 首先在xv6-labs-2021目录下创建.vscode文件夹，在这个文件夹下新建launch.json、tasks.json，内容分别如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// launch.json&#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;xv6debug&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/kernel/kernel&quot;, &quot;stopAtEntry&quot;: true, &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, &quot;miDebuggerServerAddress&quot;: &quot;127.0.0.1:25000&quot;, //见.gdbinit 中 target remote xxxx:xx &quot;miDebuggerPath&quot;: &quot;/usr/bin/gdb-multiarch&quot;, // which gdb-multiarch &quot;MIMode&quot;: &quot;gdb&quot;, &quot;preLaunchTask&quot;: &quot;xv6build&quot; &#125; ]&#125;// tasks.json&#123; &quot;version&quot;: &quot;2.0.0&quot;, &quot;options&quot;: &#123; //指定make qemu的执行位置 &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot; &#125;, &quot;tasks&quot;: [ &#123; &quot;label&quot;: &quot;xv6build&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;isBackground&quot;: true, &quot;command&quot;: &quot;make qemu-gdb&quot;, &quot;problemMatcher&quot;: [ &#123; &quot;pattern&quot;: [ &#123; &quot;regexp&quot;: &quot;.&quot;, &quot;file&quot;: 1, &quot;location&quot;: 2, &quot;message&quot;: 3 &#125; ], &quot;background&quot;: &#123; &quot;beginsPattern&quot;: &quot;.*Now run &#x27;gdb&#x27; in another window.&quot;, &quot;endsPattern&quot;: &quot;.&quot; &#125; &#125; ], &quot;group&quot;: &#123; &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true &#125; &#125; ]&#125; 然后进行调试测试，我们可以找到 kernel/main.c 下的第13行，打一个断点，然后按F5。 错误1：如果出现 /Program path ‘xv6-labs-2021/kernel/kernel’ is missing or invalid 错误，先不用管，等待终端的gdb跑起来。 错误2：如果出现 Unexpected GDB output from command “-target-select remote 127.0.0.1:25000”. Remote communication error. Target disconnected.: Connection reset by peer. 错误，需要在xv6-labs-2021下找到.gdbinit文件，注释掉target remote这行： 123456set confirm offset architecture riscv:rv64# target remote 127.0.0.1:25000symbol-file kernel/kernelset disassemble-next-line autoset riscv use-compressed-breakpoints yes 注意1：如果make clean后再按F5（它会执行make qemu-gdb），.gdbinit这个文件会被刷新，所以我们又要去注释掉target remote那行，然后再按F5，目前我还没找到更好的解决方法。 注意2：由于xv6默认多核运行，所以调试代码的时候可能会有点混乱，可以通过修改tasks.json中command字段为make qemu-gdb CPUS=1，即单核运行。这仅供调试使用，因为正常情况下代码要通过多核的运行。 系统调用 系统调用 描述 fork() 创建进程 exit() 结束当前进程 wait() 等待子进程结束 kill(pid) 结束 pid 所指进程 getpid() 获得当前进程 pid sleep(n) 睡眠 n 秒 exec(filename, *argv) 加载并执行一个文件 sbrk(n) 为进程内存空间增加 n 字节 open(filename, flags) 打开文件，flags 指定读/写模式 read(fd, buf, n) 从文件中读 n 个字节到 buf write(fd, buf, n) 从 buf 中写 n 个字节到文件 close(fd) 关闭打开的 fd dup(fd) 复制 fd pipe( p) 创建管道， 并把读和写的 fd 返回到p chdir(dirname) 改变当前目录 mkdir(dirname) 创建新的目录 mknod(name, major, minor) 创建设备文件 fstat(fd) 返回文件信息 link(f1, f2) 给 f1 创建一个新名字(f2) unlink(filename) 删除文件","categories":[],"tags":[{"name":"OS","slug":"OS","permalink":"http://www.misaka-9982.com/tags/OS/"},{"name":"6.S081","slug":"6-S081","permalink":"http://www.misaka-9982.com/tags/6-S081/"}]},{"title":"CS144-Lab7","slug":"CS144-Lab7","date":"2023-02-25T08:26:59.000Z","updated":"2023-02-25T08:33:44.958Z","comments":true,"path":"2023/02/25/CS144-Lab7/","link":"","permalink":"http://www.misaka-9982.com/2023/02/25/CS144-Lab7/","excerpt":"","text":"概述 到此为止，您已经实现了Internet基础设施的很大一部分。从Lab0(一个可靠的字节流)，到Labs 1-4(传输控制协议)，Lab 5(一个IP /以太网网络接口)和 Lab 6(一个IP路由器)，你已经做了大量的编码工作! 在这个实验室中，您不需要做任何编码(假设您之前的实验室处于合理的工作状态)。相反，为了结束你的成就，你将使用你之前的所有实验来创建一个真实的网络，其中包括你的网络堆栈(主机和路由器)与课堂上另一个学生实现的网络堆栈通信。 这个实验是两人一组做的。你需要和一个实验伙伴(班上的另一个学生)一起工作。请使用实验环节寻找实验伙伴，如果你不能参加实验环节，请使用广场。如果有必要，同一个学生可以多次担任“实验搭档”。 网络 在本实验中，您将创建一个真实的网络，将您的网络堆栈与课堂上另一个学生实现的网络堆栈结合起来。每个人贡献一台主机(包括可靠的字节流、TCP实现和networkinterface)和一台路由器: 第一个窗口： 1./apps/lab7 server cs144.keithw.org 3000 第二个窗口： 1./apps/lab7 server cs144.keithw.org 3000 make check 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336[100%] Testing libsponge...Test project /home/misaka/sponge/build Start 1: t_wrapping_ints_cmp 1/164 Test #1: t_wrapping_ints_cmp .............. Passed 0.00 sec Start 2: t_wrapping_ints_unwrap 2/164 Test #2: t_wrapping_ints_unwrap ........... Passed 0.00 sec Start 3: t_wrapping_ints_wrap 3/164 Test #3: t_wrapping_ints_wrap ............. Passed 0.00 sec Start 4: t_wrapping_ints_roundtrip 4/164 Test #4: t_wrapping_ints_roundtrip ........ Passed 0.08 sec Start 5: t_recv_connect 5/164 Test #5: t_recv_connect ................... Passed 0.00 sec Start 6: t_recv_transmit 6/164 Test #6: t_recv_transmit .................. Passed 0.03 sec Start 7: t_recv_window 7/164 Test #7: t_recv_window .................... Passed 0.00 sec Start 8: t_recv_reorder 8/164 Test #8: t_recv_reorder ................... Passed 0.00 sec Start 9: t_recv_close 9/164 Test #9: t_recv_close ..................... Passed 0.00 sec Start 10: t_recv_special 10/164 Test #10: t_recv_special ................... Passed 0.00 sec Start 11: t_send_connect 11/164 Test #11: t_send_connect ................... Passed 0.00 sec Start 12: t_send_transmit 12/164 Test #12: t_send_transmit .................. Passed 0.02 sec Start 13: t_send_retx 13/164 Test #13: t_send_retx ...................... Passed 0.00 sec Start 14: t_send_window 14/164 Test #14: t_send_window .................... Passed 0.01 sec Start 15: t_send_ack 15/164 Test #15: t_send_ack ....................... Passed 0.00 sec Start 16: t_send_close 16/164 Test #16: t_send_close ..................... Passed 0.00 sec Start 17: t_send_extra 17/164 Test #17: t_send_extra ..................... Passed 0.00 sec Start 18: t_strm_reassem_single 18/164 Test #18: t_strm_reassem_single ............ Passed 0.00 sec Start 19: t_strm_reassem_seq 19/164 Test #19: t_strm_reassem_seq ............... Passed 0.00 sec Start 20: t_strm_reassem_dup 20/164 Test #20: t_strm_reassem_dup ............... Passed 0.00 sec Start 21: t_strm_reassem_holes 21/164 Test #21: t_strm_reassem_holes ............. Passed 0.00 sec Start 22: t_strm_reassem_many 22/164 Test #22: t_strm_reassem_many .............. Passed 0.03 sec Start 23: t_strm_reassem_overlapping 23/164 Test #23: t_strm_reassem_overlapping ....... Passed 0.00 sec Start 24: t_strm_reassem_win 24/164 Test #24: t_strm_reassem_win ............... Passed 0.03 sec Start 25: t_strm_reassem_cap 25/164 Test #25: t_strm_reassem_cap ............... Passed 0.05 sec Start 26: t_byte_stream_construction 26/164 Test #26: t_byte_stream_construction ....... Passed 0.00 sec Start 27: t_byte_stream_one_write 27/164 Test #27: t_byte_stream_one_write .......... Passed 0.00 sec Start 28: t_byte_stream_two_writes 28/164 Test #28: t_byte_stream_two_writes ......... Passed 0.00 sec Start 29: t_byte_stream_capacity 29/164 Test #29: t_byte_stream_capacity ........... Passed 0.23 sec Start 30: t_byte_stream_many_writes 30/164 Test #30: t_byte_stream_many_writes ........ Passed 0.00 sec Start 31: t_webget 31/164 Test #31: t_webget ......................... Passed 1.24 sec Start 32: arp_network_interface 32/164 Test #32: arp_network_interface ............ Passed 0.00 sec Start 33: router_test 33/164 Test #33: router_test ...................... Passed 0.01 sec Start 34: t_tcp_parser 34/164 Test #34: t_tcp_parser ..................... Passed 0.00 sec Start 35: t_ipv4_parser 35/164 Test #35: t_ipv4_parser .................... Passed 0.00 sec Start 36: t_active_close 36/164 Test #36: t_active_close ................... Passed 0.00 sec Start 37: t_passive_close 37/164 Test #37: t_passive_close .................. Passed 0.00 sec Start 39: t_ack_rst 38/164 Test #39: t_ack_rst ........................ Passed 0.00 sec Start 41: t_ack_rst_win 39/164 Test #41: t_ack_rst_win .................... Passed 0.00 sec Start 43: t_connect 40/164 Test #43: t_connect ........................ Passed 0.00 sec Start 45: t_listen 41/164 Test #45: t_listen ......................... Passed 0.00 sec Start 46: t_winsize 42/164 Test #46: t_winsize ........................ Passed 0.03 sec Start 48: t_retx 43/164 Test #48: t_retx ........................... Passed 0.00 sec Start 49: t_retx_win 44/164 Test #49: t_retx_win ....................... Passed 0.00 sec Start 50: t_loopback 45/164 Test #50: t_loopback ....................... Passed 0.10 sec Start 51: t_loopback_win 46/164 Test #51: t_loopback_win ................... Passed 0.05 sec Start 52: t_reorder 47/164 Test #52: t_reorder ........................ Passed 0.07 sec Start 53: t_address_dt 48/164 Test #53: t_address_dt ..................... Passed 0.00 sec Start 54: t_parser_dt 49/164 Test #54: t_parser_dt ...................... Passed 0.00 sec Start 55: t_socket_dt 50/164 Test #55: t_socket_dt ...................... Passed 0.00 sec Start 56: t_udp_client_send 51/164 Test #56: t_udp_client_send ................ Passed 0.24 sec Start 57: t_udp_server_send 52/164 Test #57: t_udp_server_send ................ Passed 0.24 sec Start 58: t_udp_client_recv 53/164 Test #58: t_udp_client_recv ................ Passed 0.24 sec Start 59: t_udp_server_recv 54/164 Test #59: t_udp_server_recv ................ Passed 0.24 sec Start 60: t_udp_client_dupl 55/164 Test #60: t_udp_client_dupl ................ Passed 0.24 sec Start 61: t_udp_server_dupl 56/164 Test #61: t_udp_server_dupl ................ Passed 0.24 sec Start 62: t_ucS_1M_32k 57/164 Test #62: t_ucS_1M_32k ..................... Passed 0.27 sec Start 63: t_ucS_128K_8K 58/164 Test #63: t_ucS_128K_8K .................... Passed 0.25 sec Start 64: t_ucS_16_1 59/164 Test #64: t_ucS_16_1 ....................... Passed 0.24 sec Start 65: t_ucS_32K_d 60/164 Test #65: t_ucS_32K_d ...................... Passed 0.24 sec Start 66: t_ucR_1M_32k 61/164 Test #66: t_ucR_1M_32k ..................... Passed 0.27 sec Start 67: t_ucR_128K_8K 62/164 Test #67: t_ucR_128K_8K .................... Passed 0.24 sec Start 68: t_ucR_16_1 63/164 Test #68: t_ucR_16_1 ....................... Passed 0.24 sec Start 69: t_ucR_32K_d 64/164 Test #69: t_ucR_32K_d ...................... Passed 0.24 sec Start 70: t_ucD_1M_32k 65/164 Test #70: t_ucD_1M_32k ..................... Passed 0.28 sec Start 71: t_ucD_128K_8K 66/164 Test #71: t_ucD_128K_8K .................... Passed 0.26 sec Start 72: t_ucD_16_1 67/164 Test #72: t_ucD_16_1 ....................... Passed 0.25 sec Start 73: t_ucD_32K_d 68/164 Test #73: t_ucD_32K_d ...................... Passed 0.24 sec Start 74: t_usS_1M_32k 69/164 Test #74: t_usS_1M_32k ..................... Passed 0.27 sec Start 75: t_usS_128K_8K 70/164 Test #75: t_usS_128K_8K .................... Passed 0.24 sec Start 76: t_usS_16_1 71/164 Test #76: t_usS_16_1 ....................... Passed 0.24 sec Start 77: t_usS_32K_d 72/164 Test #77: t_usS_32K_d ...................... Passed 0.24 sec Start 78: t_usR_1M_32k 73/164 Test #78: t_usR_1M_32k ..................... Passed 0.26 sec Start 79: t_usR_128K_8K 74/164 Test #79: t_usR_128K_8K .................... Passed 0.25 sec Start 80: t_usR_16_1 75/164 Test #80: t_usR_16_1 ....................... Passed 0.24 sec Start 81: t_usR_32K_d 76/164 Test #81: t_usR_32K_d ...................... Passed 0.24 sec Start 82: t_usD_1M_32k 77/164 Test #82: t_usD_1M_32k ..................... Passed 0.27 sec Start 83: t_usD_128K_8K 78/164 Test #83: t_usD_128K_8K .................... Passed 0.25 sec Start 84: t_usD_16_1 79/164 Test #84: t_usD_16_1 ....................... Passed 0.25 sec Start 85: t_usD_32K_d 80/164 Test #85: t_usD_32K_d ...................... Passed 0.24 sec Start 86: t_ucS_128K_8K_l 81/164 Test #86: t_ucS_128K_8K_l .................. Passed 0.24 sec Start 87: t_ucS_128K_8K_L 82/164 Test #87: t_ucS_128K_8K_L .................. Passed 0.43 sec Start 88: t_ucS_128K_8K_lL 83/164 Test #88: t_ucS_128K_8K_lL ................. Passed 0.42 sec Start 89: t_ucR_128K_8K_l 84/164 Test #89: t_ucR_128K_8K_l .................. Passed 0.50 sec Start 90: t_ucR_128K_8K_L 85/164 Test #90: t_ucR_128K_8K_L .................. Passed 0.24 sec Start 91: t_ucR_128K_8K_lL 86/164 Test #91: t_ucR_128K_8K_lL ................. Passed 0.39 sec Start 92: t_ucD_128K_8K_l 87/164 Test #92: t_ucD_128K_8K_l .................. Passed 0.35 sec Start 93: t_ucD_128K_8K_L 88/164 Test #93: t_ucD_128K_8K_L .................. Passed 0.38 sec Start 94: t_ucD_128K_8K_lL 89/164 Test #94: t_ucD_128K_8K_lL ................. Passed 0.48 sec Start 95: t_usS_128K_8K_l 90/164 Test #95: t_usS_128K_8K_l .................. Passed 0.26 sec Start 96: t_usS_128K_8K_L 91/164 Test #96: t_usS_128K_8K_L .................. Passed 0.35 sec Start 97: t_usS_128K_8K_lL 92/164 Test #97: t_usS_128K_8K_lL ................. Passed 0.37 sec Start 98: t_usR_128K_8K_l 93/164 Test #98: t_usR_128K_8K_l .................. Passed 0.39 sec Start 99: t_usR_128K_8K_L 94/164 Test #99: t_usR_128K_8K_L .................. Passed 0.25 sec Start 100: t_usR_128K_8K_lL 95/164 Test #100: t_usR_128K_8K_lL ................. Passed 0.56 sec Start 101: t_usD_128K_8K_l 96/164 Test #101: t_usD_128K_8K_l .................. Passed 0.40 sec Start 102: t_usD_128K_8K_L 97/164 Test #102: t_usD_128K_8K_L .................. Passed 0.32 sec Start 103: t_usD_128K_8K_lL 98/164 Test #103: t_usD_128K_8K_lL ................. Passed 0.51 sec Start 104: t_ipv4_client_send 99/164 Test #104: t_ipv4_client_send ............... Passed 0.25 sec Start 105: t_ipv4_server_send100/164 Test #105: t_ipv4_server_send ............... Passed 0.24 sec Start 106: t_ipv4_client_recv101/164 Test #106: t_ipv4_client_recv ............... Passed 0.24 sec Start 107: t_ipv4_server_recv102/164 Test #107: t_ipv4_server_recv ............... Passed 0.25 sec Start 108: t_ipv4_client_dupl103/164 Test #108: t_ipv4_client_dupl ............... Passed 0.25 sec Start 109: t_ipv4_server_dupl104/164 Test #109: t_ipv4_server_dupl ............... Passed 0.24 sec Start 110: t_icS_1M_32k105/164 Test #110: t_icS_1M_32k ..................... Passed 0.28 sec Start 111: t_icS_128K_8K106/164 Test #111: t_icS_128K_8K .................... Passed 0.25 sec Start 112: t_icS_16_1107/164 Test #112: t_icS_16_1 ....................... Passed 0.24 sec Start 113: t_icS_32K_d108/164 Test #113: t_icS_32K_d ...................... Passed 0.25 sec Start 114: t_icR_1M_32k109/164 Test #114: t_icR_1M_32k ..................... Passed 0.29 sec Start 115: t_icR_128K_8K110/164 Test #115: t_icR_128K_8K .................... Passed 0.25 sec Start 116: t_icR_16_1111/164 Test #116: t_icR_16_1 ....................... Passed 0.24 sec Start 117: t_icR_32K_d112/164 Test #117: t_icR_32K_d ...................... Passed 0.24 sec Start 118: t_icD_1M_32k113/164 Test #118: t_icD_1M_32k ..................... Passed 0.30 sec Start 119: t_icD_128K_8K114/164 Test #119: t_icD_128K_8K .................... Passed 0.25 sec Start 120: t_icD_16_1115/164 Test #120: t_icD_16_1 ....................... Passed 0.26 sec Start 121: t_icD_32K_d116/164 Test #121: t_icD_32K_d ...................... Passed 0.24 sec Start 122: t_isS_1M_32k117/164 Test #122: t_isS_1M_32k ..................... Passed 0.28 sec Start 123: t_isS_128K_8K118/164 Test #123: t_isS_128K_8K .................... Passed 0.26 sec Start 124: t_isS_16_1119/164 Test #124: t_isS_16_1 ....................... Passed 0.24 sec Start 125: t_isS_32K_d120/164 Test #125: t_isS_32K_d ...................... Passed 0.24 sec Start 126: t_isR_1M_32k121/164 Test #126: t_isR_1M_32k ..................... Passed 0.28 sec Start 127: t_isR_128K_8K122/164 Test #127: t_isR_128K_8K .................... Passed 0.25 sec Start 128: t_isR_16_1123/164 Test #128: t_isR_16_1 ....................... Passed 0.25 sec Start 129: t_isR_32K_d124/164 Test #129: t_isR_32K_d ...................... Passed 0.25 sec Start 130: t_isD_1M_32k125/164 Test #130: t_isD_1M_32k ..................... Passed 0.30 sec Start 131: t_isD_128K_8K126/164 Test #131: t_isD_128K_8K .................... Passed 0.25 sec Start 132: t_isD_16_1127/164 Test #132: t_isD_16_1 ....................... Passed 0.25 sec Start 133: t_isD_32K_d128/164 Test #133: t_isD_32K_d ...................... Passed 0.24 sec Start 134: t_icS_128K_8K_l129/164 Test #134: t_icS_128K_8K_l .................. Passed 0.25 sec Start 135: t_icS_128K_8K_L130/164 Test #135: t_icS_128K_8K_L .................. Passed 0.44 sec Start 136: t_icS_128K_8K_lL131/164 Test #136: t_icS_128K_8K_lL ................. Passed 0.32 sec Start 137: t_icR_128K_8K_l132/164 Test #137: t_icR_128K_8K_l .................. Passed 0.38 sec Start 138: t_icR_128K_8K_L133/164 Test #138: t_icR_128K_8K_L .................. Passed 0.26 sec Start 139: t_icR_128K_8K_lL134/164 Test #139: t_icR_128K_8K_lL ................. Passed 0.45 sec Start 140: t_icD_128K_8K_l135/164 Test #140: t_icD_128K_8K_l .................. Passed 0.32 sec Start 141: t_icD_128K_8K_L136/164 Test #141: t_icD_128K_8K_L .................. Passed 0.36 sec Start 142: t_icD_128K_8K_lL137/164 Test #142: t_icD_128K_8K_lL ................. Passed 0.47 sec Start 143: t_isS_128K_8K_l138/164 Test #143: t_isS_128K_8K_l .................. Passed 0.29 sec Start 144: t_isS_128K_8K_L139/164 Test #144: t_isS_128K_8K_L .................. Passed 0.38 sec Start 145: t_isS_128K_8K_lL140/164 Test #145: t_isS_128K_8K_lL ................. Passed 0.51 sec Start 146: t_isR_128K_8K_l141/164 Test #146: t_isR_128K_8K_l .................. Passed 0.49 sec Start 147: t_isR_128K_8K_L142/164 Test #147: t_isR_128K_8K_L .................. Passed 0.25 sec Start 148: t_isR_128K_8K_lL143/164 Test #148: t_isR_128K_8K_lL ................. Passed 0.42 sec Start 149: t_isD_128K_8K_l144/164 Test #149: t_isD_128K_8K_l .................. Passed 0.42 sec Start 150: t_isD_128K_8K_L145/164 Test #150: t_isD_128K_8K_L .................. Passed 0.52 sec Start 151: t_isD_128K_8K_lL146/164 Test #151: t_isD_128K_8K_lL ................. Passed 0.46 sec Start 152: t_icnS_128K_8K_l147/164 Test #152: t_icnS_128K_8K_l ................. Passed 0.30 sec Start 153: t_icnS_128K_8K_L148/164 Test #153: t_icnS_128K_8K_L ................. Passed 0.24 sec Start 154: t_icnS_128K_8K_lL149/164 Test #154: t_icnS_128K_8K_lL ................ Passed 0.23 sec Start 155: t_icnR_128K_8K_l150/164 Test #155: t_icnR_128K_8K_l ................. Passed 0.51 sec Start 156: t_icnR_128K_8K_L151/164 Test #156: t_icnR_128K_8K_L ................. Passed 0.25 sec Start 157: t_icnR_128K_8K_lL152/164 Test #157: t_icnR_128K_8K_lL ................ Passed 1.00 sec Start 158: t_icnD_128K_8K_l153/164 Test #158: t_icnD_128K_8K_l ................. Passed 0.64 sec Start 159: t_icnD_128K_8K_L154/164 Test #159: t_icnD_128K_8K_L ................. Passed 0.22 sec Start 160: t_icnD_128K_8K_lL155/164 Test #160: t_icnD_128K_8K_lL ................ Passed 0.65 sec Start 161: t_isnS_128K_8K_l156/164 Test #161: t_isnS_128K_8K_l ................. Passed 0.12 sec Start 162: t_isnS_128K_8K_L157/164 Test #162: t_isnS_128K_8K_L ................. Passed 0.24 sec Start 163: t_isnS_128K_8K_lL158/164 Test #163: t_isnS_128K_8K_lL ................ Passed 0.28 sec Start 164: t_isnR_128K_8K_l159/164 Test #164: t_isnR_128K_8K_l ................. Passed 0.61 sec Start 165: t_isnR_128K_8K_L160/164 Test #165: t_isnR_128K_8K_L ................. Passed 0.28 sec Start 166: t_isnR_128K_8K_lL161/164 Test #166: t_isnR_128K_8K_lL ................ Passed 0.72 sec Start 167: t_isnD_128K_8K_l162/164 Test #167: t_isnD_128K_8K_l ................. Passed 0.88 sec Start 168: t_isnD_128K_8K_L163/164 Test #168: t_isnD_128K_8K_L ................. Passed 0.24 sec Start 169: t_isnD_128K_8K_lL164/164 Test #169: t_isnD_128K_8K_lL ................ Passed 0.91 sec100% tests passed, 0 tests failed out of 164Total Test time (real) = 39.33 sec[100%] Built target check","categories":[],"tags":[{"name":"CS144","slug":"CS144","permalink":"http://www.misaka-9982.com/tags/CS144/"},{"name":"Network","slug":"Network","permalink":"http://www.misaka-9982.com/tags/Network/"}]},{"title":"CS144-Lab6","slug":"CS144-Lab6","date":"2023-02-25T07:58:46.000Z","updated":"2023-02-25T08:32:48.360Z","comments":true,"path":"2023/02/25/CS144-Lab6/","link":"","permalink":"http://www.misaka-9982.com/2023/02/25/CS144-Lab6/","excerpt":"","text":"概述 在本周的实验中，你将在现有的NetworkInterface基础上实现一个IP路由器，从而结束本课程。路由器有几个网络接口，可以在其中任何一个接口上接收互联网数据报。路由器的工作是根据路由表转发它得到的数据报：一个规则列表，它告诉路由器，对于任何给定的数据报： 发送到哪个接口； 下一跳的IP地址 ； 你的工作是实现一个路由器，它可以为任何给定的数据报计算出这两件事。(你不需要实现设置路由表的算法，例如RIP、OSPF、BGP或SDN控制器，只需要实现跟随路由表的算法)。 你对路由器的实现将使用带有新的Router类的Sponge库，以及在模拟网络中检查你的路由器功能的测试。实验6建立在你在实验5中对NetworkInterface的实现之上，但不使用你在实验0-4中实现的TCP栈。IP路由器不需要知道任何关于TCP、ARP或以太网的信息(仅限IP)。我们希望你的实现将需要大约25-30行的代码。 图1：路由器包含多个网络接口，可以在其中任何一个接口上接收IP数据报。路由器将接收到的任何数据报转发到相应出站接口上的下一跳，路由表告诉路由器如何做出这个决定。 开始 请确保你已经提交了你在实验5中的所有解决方案。请不要修改libsponge目录顶层以外的任何文件，或者webget.cc。(请不要添加代码所依赖的额外文件。)否则，你可能会在合并实验6的启动代码时遇到麻烦。 在实验作业的存储库中，运行git fetch来检索实验作业的最新版本。 通过运行git merge origin/lab6-startercode，下载实验6的启动代码。 在build目录中，编译源代码：make(编译时可以运行make -j4以使用四个处理器)。 在build目录外，打开并开始编辑writeups/lab6.md文件。这是你实验报告的模板，将包含在你提交的内容中。 实现路由器 在本实验中，你将实现一个Router类，它可以： 跟踪路由表(转发规则或路由列表)，并 转发它收到的每个数据报： 转发到正确的下一跳 在正确的出站NetworkInterface上 你的实现将被添加到router.hh和router.cc骨架文件中。在你开始编码之前，请查看新的Router类的文档。 下面是你要实现的两个方法，以及我们对每个方法的期望： 1234void add_route(const uint32_t route_prefix, const uint8_t prefix_length, const optional&lt;Address&gt; next_hop, const size_t interface_num); 这个方法将一条路由添加到路由表中。你要在Router类中添加一个数据结构作为私有成员来存储这些信息。这个方法所要做的就是保存路由，以供以后使用。 路由的各个部分是什么意思？ 路由是一个”匹配——行动”规则：它告诉路由器，如果一个数据报前往一个特定的网络(一个IP地址范围)，并且如果该路由被选为最具体的匹配路由，那么路由器应该把数据报转发到特定接口上的特定下一跳。 “匹配”：数据报是前往这个网络的吗?route_prefix和prefix_length共同指定了一个可能包括数据报目的地的IP地址范围(一个网络)。route_prefix是一个32位数字的IP地址。prefix_length是一个介于0和32(包括32)之间的数字；它告诉路由器路由前缀中有多少最高有效位是有效的。例如，要表达一个到网络”18.47.0.0/16”的路由(这与前两个字节为18和47的任何32位IP地址匹配)，路由前缀将是305070080(18×224+47×216)，前缀长度是16。任何以”18.47.x.y”为目的地的数据报都会匹配。 **“行动”：如果路由匹配并被选中，该怎么做。**如果路由器直接连接到有关的网络，next_hop将是一个空的可选项；在这种情况下，next_hop是数据报的目标地址。但如果路由器是通过其他路由器连接到有关网络的，则next_hop将包含路径中下一路由器的IP地址。interface_num给出了路由器NetworkInterface的索引，它用来将数据报发送到下一跳。你可以用interface(interface_num)方法访问这个接口。 1void route_one_datagram(InternetDatagram &amp;dgram); 这里是橡胶与道路的交汇处。这个方法需要将数据报路由到下一跳，从适当的接口传出。它需要实现IP路由器的”最长前缀匹配”逻辑，以找到最佳路由，这意味着： 路由器搜索路由表，以找到与数据报的目的地址相匹配的路由。我们所说的”匹配”是指目的地址的最高有效prefix_length比特与route_prefix的最高有效prefix_length比特相同的。 在匹配的路由中，路由器选择具有最大prefix_length的路由，这就是最长前缀匹配路由。 如果没有匹配的路由，路由器会丢弃数据报。 路由器会递减数据报的TTL(生存时间)。如果TTL已经为零，或在递减后为零，路由器应该放弃该数据报。 否则，路由器将修改后的数据报通过适当的接口(interface(interface_num).send_datagram())发送到适当的下一跳。 在这个互联网的设计中，有个优点(或至少是一种成功的抽象)：路由器从不考虑TCP、ARP或以太网帧。路由器甚至不知道链路层是什么样子的。路由器只考虑互联网数据包，并且只通过NetworkInterface抽象与链路层进行交互。当涉及到”链路层地址是如何解决的？”或”链路层是否有自己的不同于IP的寻址方案？”或”链路层帧的格式是什么？”或”数据报的有效载荷是什么意思？”等问题时，路由器根本不关心。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//! \\brief A wrapper for NetworkInterface that makes the host-side//! interface asynchronous: instead of returning received datagrams//! immediately (from the `recv_frame` method), it stores them for//! later retrieval. Otherwise, behaves identically to the underlying//! implementation of NetworkInterface.class AsyncNetworkInterface : public NetworkInterface &#123; std::queue&lt;InternetDatagram&gt; _datagrams_out&#123;&#125;; public: using NetworkInterface::NetworkInterface; //! Construct from a NetworkInterface AsyncNetworkInterface(NetworkInterface &amp;&amp;interface) : NetworkInterface(interface) &#123;&#125; //! \\brief Receives and Ethernet frame and responds appropriately. //! - If type is IPv4, pushes to the `datagrams_out` queue for later retrieval by the owner. //! - If type is ARP request, learn a mapping from the &quot;sender&quot; fields, and send an ARP reply. //! - If type is ARP reply, learn a mapping from the &quot;target&quot; fields. //! //! \\param[in] frame the incoming Ethernet frame void recv_frame(const EthernetFrame &amp;frame) &#123; auto optional_dgram = NetworkInterface::recv_frame(frame); if (optional_dgram.has_value()) &#123; _datagrams_out.push(std::move(optional_dgram.value())); &#125; &#125;; //! Access queue of Internet datagrams that have been received std::queue&lt;InternetDatagram&gt; &amp;datagrams_out() &#123; return _datagrams_out; &#125;&#125;;struct route_rule&#123; uint32_t route_prefix&#123;&#125;; uint8_t prefix_length&#123;&#125;; std::optional&lt;Address&gt; next_hop; size_t interface_num&#123;&#125;; route_rule(const uint32_t _route_prefix, const uint8_t _prefix_length, const std::optional&lt;Address&gt; _next_hop, const size_t _interface_num) :route_prefix(_route_prefix),prefix_length(_prefix_length) ,next_hop(_next_hop),interface_num(_interface_num) &#123;&#125;&#125;;//! \\brief A router that has multiple network interfaces and//! performs longest-prefix-match routing between them.class Router &#123; //! The router&#x27;s collection of network interfaces std::vector&lt;AsyncNetworkInterface&gt; _interfaces&#123;&#125;; //! Send a single datagram from the appropriate outbound interface to the next hop, //! as specified by the route with the longest prefix_length that matches the //! datagram&#x27;s destination address. void route_one_datagram(InternetDatagram &amp;dgram); std::vector&lt;route_rule&gt; _rules&#123;&#125;; public: //! Add an interface to the router //! \\param[in] interface an already-constructed network interface //! \\returns The index of the interface after it has been added to the router size_t add_interface(AsyncNetworkInterface &amp;&amp;interface) &#123; _interfaces.push_back(std::move(interface)); return _interfaces.size() - 1; &#125; //! Access an interface by index AsyncNetworkInterface &amp;interface(const size_t N) &#123; return _interfaces.at(N); &#125; //! Add a route (a forwarding rule) void add_route(const uint32_t route_prefix, const uint8_t prefix_length, const std::optional&lt;Address&gt; next_hop, const size_t interface_num); //! Route packets between the interfaces void route(); bool prefix_equal(uint32_t ip1, uint32_t ip2, uint8_t prefix_length);&#125;; 这段代码实现了一个多接口的路由器，其中每个接口都有一个异步接收数据报的队列。路由器的功能是根据最长前缀匹配算法对接收到的每个数据报进行路由，并将其发送到下一跳，以使其达到目标地址。 AsyncNetworkInterface是一个对NetworkInterface的封装，它具有一个异步队列_datagrams_out，在接收到数据报后将其推送到队列中。它还覆盖了NetworkInterface的recv_frame方法，以便将数据报推送到队列中，以供稍后检索。 Router类有一个包含所有网络接口的向量 _interfaces，一个包含所有路由表规则的向量 _rules，以及一个add_interface方法，用于添加接口。路由器还实现了一个add_route方法，该方法接受路由前缀、路由前缀长度、下一跳IP地址(可选)以及出站接口的索引。它将所有路由规则存储在一个向量中，以便在进行数据报路由时进行查找。此外，还实现了一个route方法，用于将路由器的所有接口一起轮询，处理每个接口上接收到的数据报，并调用route_one_datagram方法将其路由到下一跳。最后，还实现了一个prefix_equal方法，用于检查两个IP地址的前缀是否相同。 在路由表的最长前缀匹配算法中，对于目的地址，路由器从路由表中选择最具体的路由，该路由匹配前缀长度最长，而且其匹配的前缀位数与目标地址的前缀位数相同。prefix_equal方法用于比较两个IP地址的前缀。 12345678910111213//! \\param[in] route_prefix The &quot;up-to-32-bit&quot; IPv4 address prefix to match the datagram&#x27;s destination address against//! \\param[in] prefix_length For this route to be applicable, how many high-order (most-significant) bits of the route_prefix will need to match the corresponding bits of the datagram&#x27;s destination address?//! \\param[in] next_hop The IP address of the next hop. Will be empty if the network is directly attached to the router (in which case, the next hop address should be the datagram&#x27;s final destination).//! \\param[in] interface_num The index of the interface to send the datagram out on.void Router::add_route(const uint32_t route_prefix, const uint8_t prefix_length, const optional&lt;Address&gt; next_hop, const size_t interface_num) &#123; cerr &lt;&lt; &quot;DEBUG: adding route &quot; &lt;&lt; Address::from_ipv4_numeric(route_prefix).ip() &lt;&lt; &quot;/&quot; &lt;&lt; int(prefix_length) &lt;&lt; &quot; =&gt; &quot; &lt;&lt; (next_hop.has_value() ? next_hop-&gt;ip() : &quot;(direct)&quot;) &lt;&lt; &quot; on interface &quot; &lt;&lt; interface_num &lt;&lt; &quot;\\n&quot;; route_rule r(route_prefix,prefix_length,next_hop,interface_num); _rules.push_back(move(r));&#125; Router::add_route 函数添加一个路由规则，包含路由表项中的路由前缀，前缀长度，下一跳地址（如果有），以及数据包的输出接口索引。这个函数打印了调试信息，用于检查添加的路由规则。 12345678910111213141516171819202122232425262728293031//! \\param[in] dgram The datagram to be routedvoid Router::route_one_datagram(InternetDatagram &amp;dgram) &#123; uint32_t dst = dgram.header().dst; optional&lt;Address&gt; next_hop&#123;&#125;; size_t interface_num&#123;&#125;; optional&lt;uint8_t&gt; best_by_far&#123;&#125;; for(auto&amp; r: _rules) &#123; if((!best_by_far.has_value() || r.prefix_length&gt;best_by_far.value()) &amp;&amp; prefix_equal(dst,r.route_prefix,r.prefix_length))&#123; next_hop = r.next_hop; interface_num = r.interface_num; best_by_far = r.prefix_length; &#125; &#125; if(best_by_far.has_value())&#123; if(dgram.header().ttl&gt;1) &#123; dgram.header().ttl--; if(next_hop.has_value()) &#123; interface(interface_num).send_datagram(dgram,next_hop.value()); &#125; // if not have next_hop, the next_hop is dgram&#x27;s destination hop else &#123; interface(interface_num).send_datagram(dgram,Address::from_ipv4_numeric(dst)); &#125; &#125; &#125; return;&#125; Router::route_one_datagram 函数根据路由表将数据报路由到下一个合适的接口。它使用路由表中最长前缀匹配的规则来查找应该用哪个输出接口。如果找到合适的路由规则，则检查数据报的 TTL 是否大于1。如果是，减少TTL并将数据报发送到下一个合适的接口。如果找不到合适的路由规则，数据报将被丢弃。 12345678910void Router::route() &#123; // Go through all the interfaces, and route every incoming datagram to its proper outgoing interface. for (auto &amp;interface : _interfaces) &#123; auto &amp;queue = interface.datagrams_out(); while (not queue.empty()) &#123; route_one_datagram(queue.front()); queue.pop(); &#125; &#125;&#125; Router::route 函数遍历路由器的所有网络接口，将每个接口的入队数据报依次路由到正确的输出接口上。 1234567bool Router::prefix_equal(uint32_t ip1, uint32_t ip2, uint8_t prefix_length) &#123; if(prefix_length==0)&#123; return true; &#125; else &#123; return (ip1 &gt;&gt; (32-prefix_length)) == (ip2 &gt;&gt; (32-prefix_length)); &#125;&#125; Router::prefix_equal 函数用于比较两个IP地址的最高 prefix_length 位是否相等。如果前缀长度为0，将返回 true。如果前缀长度不为0，则将两个地址右移（32-prefix_length）位，并比较结果是否相等。 测试 你可以通过运行make checklab6来测试你的实现。这将在特定的模拟网络中测试路由器，如图2所示。 图2：应用/网络模拟器工具中使用的模拟测试网络，也是由make check lab6运行的。 (有趣的事实：uun网络是David Mazieres的互联网切片，于1993年分配。whois工具或链接的网站可以用来查询谁控制了每个IP地址的分配)。 Q &amp; A 我应该用什么数据结构来记录路由表？ 由你决定! 但不需要太过疯狂。每个数据报需要做O(n)个工作是完全可以接受的，其中n是路由表的条目数。如果你想做一些更有效的事情，我们鼓励你在优化之前先得到一个有效的实现，并仔细记录和评论你选择的任何实现。 如何将以地址对象形式出现的IP地址转换为可以写入ARP消息的32位原始整数？ 使用Address::ipv4_numeric()方法。 如何将一个以原始32位整数形式出现的IP地址转换为一个地址对象？ 使用 Address::from_ipv4_numeric()方法。 如何将一个32位IP地址的最高n位(其中0≤n≤32) 与另一个32位IP地址的最重要的n位进行比较？ 这可能是这项任务中”最棘手”的部分，因为要让逻辑正确。也许值得在C++中写一个小的测试程序(一个简短的独立程序)或者在Sponge中添加一个测试，以验证你对相关的C++操作符的理解，并仔细检查你的逻辑。 回顾一下，在C和C++中，将一个32位整数移位32位，可能会产生未定义行为。使用make_clean，然后在编译代码时打开sanitizer(cmake -DCMAKE_BUILD_TYPE=RelASan)以便在你提交之前尝试捕捉你的代码中任何未定义的行为。 你可以通过在build目录中运行./apps/network simulator来直接运行路由器测试。 如果路由器没有到目的地的路由，或者TTL为零，它是不是应该向数据报的源头发送一个ICMP错误信息？ 在现实生活中，是的，这将是有帮助的。但在这个实验里没有必要——丢弃数据报就足够了。(即使在现实生活中，也不是每个路由器都会在这些情况下向源头发送ICMP消息)。 我如何运行本实验的测试套件？ make check_lab6(两个测试)。或者你可以用make check运行整个测试套件(161个测试)。 如果这个PDF出来后还有更多的FAQ，我在哪里可以看到？ 请定期查看网站(https://cs144.github.io/lab_faq.html)和Piazza。","categories":[],"tags":[{"name":"CS144","slug":"CS144","permalink":"http://www.misaka-9982.com/tags/CS144/"},{"name":"Network","slug":"Network","permalink":"http://www.misaka-9982.com/tags/Network/"}]},{"title":"CS144-Lab5","slug":"CS144-Lab5","date":"2023-02-24T14:32:48.000Z","updated":"2023-02-25T07:21:58.861Z","comments":true,"path":"2023/02/24/CS144-Lab5/","link":"","permalink":"http://www.misaka-9982.com/2023/02/24/CS144-Lab5/","excerpt":"","text":"概述 在本周的实验中，你将深入研究并实现一个网络接口：世界各地的互联网数据报和一跳一跳的链路层以太网帧之间的桥梁。该组件可以“隐藏”在早期实验的TCP/IP实现之下，但它也将用于不同的设置：当你在实验6中建立一个路由器时，它将在网络接口之间路由数据报。图1显示了网络接口如何适应这两种设置。 你对网络接口的实现将使用与你在实验0-4中使用的相同的Sponge库，并增加了类和测试。但是，应大众的要求，本实验的大部分(但不是全部)都可以在不依赖早期实验的TCP连接的情况下完成。 在过去的实验中，你写了一个TCP实现，可以成功地与使用TCP的任何其他计算机交换TCP段。这些网段实际上是如何传达给对等方的TCP实现的呢？正如我们所讨论的，有几种选择： TCP-in-UDP-in-IP：TCP段可以在用户数据报的有效载荷中携带。在正常(用户空间)环境下工作时，这是最容易实现的。Linux提供了一个接口(“互联网数据报套接字”，UDPSocket)，允许应用程序只提供用户数据报和目标地址的有效载荷，内核负责构造UDP报头、IP报头和以太网报头，然后将数据包发送到适当的下一跳。内核确保每个套接字具有本地和远程地址以及端口号的独占组合，并且由于内核是将这些地址和端口号写入UDP和IP头的内核，因此它可以保证不同应用程序之间的隔离。 TCP-in-IP：在通常情况下，TCP段几乎总是直接放在互联网数据报中，在IP和TCP报头之间没有UDP报头。这就是人们所说的”TCP/IP”。这在实现上要困难一些。Linux提供了一个称为TUN设备的接口，该接口允许应用程序提供整个Internet数据报，内核负责其余部分(编写以太网报头，并通过物理以太网卡实际发送，等等)。但是现在，应用程序必须自己构造完整的IP报头，而不仅仅是有效载荷。 你已经做了这个。在实验4中，我们为你提供了一个表示Internet数据报的对象，它知道如何解析和序列化自身(tcp_helpers/ipv4_datagram.{hh,cc})以及在IP中封装TCP段的逻辑(现在可以在tcp_helpers/tcp_over_ip.cc中找到)。CS144TCPSocket使用这些工具将TCPConnection连接到TUN设备。 TCP-in-IP-in-Ethernet：在上述方法中，我们仍然依赖于Linux内核的部分网络栈。每次你的代码向TUN设备写入一个IP数据报时，Linux必须构建一个适当的链路层(以太网)帧，并将IP数据报作为其有效载荷。这意味着Linux必须根据下一跳的IP地址来计算出下一跳的以太网目标地址。如果它还不知道这个映射，Linux就会广播一个查询，问：”谁要求使用下面的IP地址？你的以太网地址是什么？”并等待回应。 这些功能由网络接口执行：一个将出站IP数据报翻译成链路层(如以太网)帧的组件，反之亦然。(在实际系统中，网络接口通常有eth0、eth1、wlan0等名称。) 在本周的实验中，你将实现一个网络接口，并把它放在TCP/IP协议栈的最底层。你的代码将产生原始的以太网帧，这些帧将通过一个叫做TAP设备的接口交给Linux——类似于TUN设备，但更底层，因为它交换的是原始链路层帧而不是IP数据报。 大部分的工作是为每个下一跳的IP地址查找(和缓存)以太网地址。这方面的协议被称为地址解析协议(ARP)。 我们已经为你提供了单元测试，使你的网络接口能够正常运行。然后，在本实验结束时，你将略微修改你的webget，以使用你的TCP实现，这样整个过程将生成原始以太网帧，并且仍然可以通过Internet与真正的Web服务器通信。在实验6中，你将在TCP的上下文之外使用同一个网络接口，作为IP路由器的一部分。 图1：网络接口连接互联网数据报和链路层帧。该组件作为主机TCP/IP堆栈的一部分(左侧)和IP路由器的一部分(右侧)都很有用。 开始 请确保你已经提交了你在实验4中的所有解决方案。请不要修改libsponge目录顶层以外的任何文件，或者webget.cc。(请不要添加代码所依赖的额外文件。)否则，你可能会在合并实验5的启动代码时遇到麻烦。 在实验作业的存储库中，运行git fetch来检索实验作业的最新版本。 通过运行git merge origin/lab5-startercode，下载实验5的启动代码。 在build目录中，编译源代码：make(编译时可以运行make -j4以使用四个处理器)。 在build目录外，打开并开始编辑writeups/lab5.md文件。这是你实验报告的模板，将包含在你提交的内容中。 地址解析协议 在开始编码之前，请阅读： NetworkInterface对象的公共接口。 维基百科对ARP总结和原始ARP规范(RFC 1982)。 EthernetFrame和EthernetHeader对象的文档/实现。 IPV4数据报和IPv4Header对象的文档和实现(可以解析和序列化互联网数据报，序列化后可以分配给以太网帧的有效载荷)。 ARPMessage对象的文档和实现(它知道如何解析和序列化ARP消息，并且在序列化时还可以作为以太网帧的有效载荷)。 本实验的主要任务是实现NetworkInterface的三种主要方法(在network_interface.cc文件中)，维护从IP地址到以太网地址的映射。映射是一个缓存，或“软状态”：NetworkInterface为了提高效率而保留它，但是如果它必须从头开始重新启动，映射将自然地重新生成，而不会引起问题。 void NetworkInterface::send_datagram(const InternetDatagram &amp;dgram, const Address &amp;next_hop) 当调用者(如你的TCPConnection或路由器)希望将出站互联网(IP)数据报发送到下一个跃点时，将调用此方法。(请不要把数据报的最终目的地与下一跳混为一谈，后者在数据报自己的报头中是目标地址。在这个实验里，你只关心下一跳的地址。)该接口的工作是将此数据报转换为以太网帧并(最终)发送。 如果目标以太网地址已知，请立即发送。创建以太网帧(type = EthernetHeader::TYPE_IPv4)，将有效载荷设置为序列化数据报，并设置源地址和目标地址。 如果目标以太网地址未知，广播下一跳以太网地址的ARP请求，并将IP数据报排队，以便在收到ARP回复后发送。 例外：你不想让ARP请求充斥网络。如果网络接口在过去5秒内已经发送了一个关于相同IP地址的ARP请求，不要发送第二个，只需等待第一个请求的回复即可。同样，对数据报进行排队，直到了解到目标以太网地址。 optional&lt;InternetDatagram&gt; NetworkInterface::recv_frame(const EthernetFrame &amp;frame) 当以太网帧从网络到达时，调用此方法。代码应忽略任何不发送到网络接口的帧(也就是说，只接受以太网目的地是广播地址或存储在以太网地址成员变量_ethernet_address中的以太网地址)。 如果入站帧是IPv4，将有效载荷解析为InternetDatagram，如果成功(意味着parse()方法返回ParseResult::NoError)，则将生成的InternetDatagram返回给调用者。 如果入站帧是ARP，将有效载荷解析为ARP消息，如果成功，记住发送方的IP地址和以太网地址之间的映射，持续30秒。(从请求和回复中学习映射。)此外，如果是ARP请求请求我们的IP地址，请发送适当的ARP回复。 void NetworkInterface::tick(const size_t ms_since_last_tick) 随着时间的推移，这将被调用。使任何已经过期的IP到以太网的映射过期。 你可以通过运行ctest -V -R &quot;^arp&quot;来测试你的实现。此测试不依赖于你的TCP实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class NetworkInterface &#123; private: //! Ethernet (known as hardware, network-access-layer, or link-layer) address of the interface EthernetAddress _ethernet_address; //! IP (known as internet-layer or network-layer) address of the interface Address _ip_address; //! outbound queue of Ethernet frames that the NetworkInterface wants sent std::queue&lt;EthernetFrame&gt; _frames_out&#123;&#125;; typedef time_t size_t; // map + heap to achieve O(lgN) search,insert,expire check operation of IP-to-Ethernet mappings std::map&lt;uint32_t, std::pair&lt;EthernetAddress, time_t&gt;&gt; _arp_table&#123;&#125;; std::priority_queue&lt;std::pair&lt;time_t, uint32_t&gt;, std::vector&lt;std::pair&lt;time_t, uint32_t&gt;&gt;, std::greater&lt;std::pair&lt;time_t, uint32_t&gt;&gt;&gt; _arp_failure_time&#123;&#125;; time_t _curr_time&#123;&#125;; // datagrams not sent yet std::queue&lt;std::pair&lt;InternetDatagram, Address&gt;&gt; _dgrames_queue&#123;&#125;; // &lt; arp request sent and not get response yet, timestamp, ip to find&gt; std::tuple&lt;bool, time_t, uint32_t&gt; _arp_retransmission_timer&#123;&#125;; public: //! \\brief Construct a network interface with given Ethernet (network-access-layer) and IP (internet-layer) addresses NetworkInterface(const EthernetAddress &amp;ethernet_address, const Address &amp;ip_address); //! \\brief Access queue of Ethernet frames awaiting transmission std::queue&lt;EthernetFrame&gt; &amp;frames_out() &#123; return _frames_out; &#125; //! \\brief Sends an IPv4 datagram, encapsulated in an Ethernet frame (if it knows the Ethernet destination address). //! Will need to use [ARP](\\ref rfc::rfc826) to look up the Ethernet destination address for the next hop //! (&quot;Sending&quot; is accomplished by pushing the frame onto the frames_out queue.) void send_datagram(const InternetDatagram &amp;dgram, const Address &amp;next_hop); //! \\brief Receives an Ethernet frame and responds appropriately. //! If type is IPv4, returns the datagram. //! If type is ARP request, learn a mapping from the &quot;sender&quot; fields, and send an ARP reply. //! If type is ARP reply, learn a mapping from the &quot;sender&quot; fields. std::optional&lt;InternetDatagram&gt; recv_frame(const EthernetFrame &amp;frame); //! \\brief Called periodically when time elapses void tick(const time_t ms_since_last_tick); // boardcast to find the Ethernet addr of an ip void send_arp_request(const uint32_t ip_to_find); // resend the datagrams queued for not knowing their Ehternet addrs void resend();&#125;; _ethernet_address 和 _ip_address 分别表示该接口的以太网地址和 IP 地址。 _frames_out 保存尚未发送的数据帧，通过 frames_out() 方法获取该队列。 _arp_table 和 _arp_failure_time 用于保存 IP 地址和以太网地址的映射，前者保存正常情况下的映射，后者保存因为 ARP 请求失败而需要重试的映射。 _dgrames_queue 保存尚未发送的数据报，其中数据报表示一个完整的 IP 数据包。 send_datagram() 方法用于发送 IP 数据报，其中需要通过 ARP 协议找到下一跳的以太网地址。 recv_frame() 方法用于接收以太网帧并进行处理，如果接收到的是 IPv4 数据帧则返回一个数据报，如果是 ARP 请求或回复则需要进行对应的处理。 tick() 方法表示时间流逝，用于处理 ARP 请求的超时和重新发送尚未发送的数据报。 send_arp_request() 方法用于向网络广播 ARP 请求，以寻找特定 IP 地址的以太网地址。 resend() 方法用于重新发送尚未发送成功的数据报。 12345678910111213void NetworkInterface::resend() &#123; while (!_dgrames_queue.empty()) &#123; auto dgrams = _dgrames_queue.front(); const uint32_t next_hop_ip = dgrams.second.ipv4_numeric(); // if destination Ehernet address known if (_arp_table.count(next_hop_ip)) &#123; _dgrames_queue.pop(); send_datagram(dgrams.first, dgrams.second); &#125; else &#123; break; &#125; &#125;&#125; resend()，用于重新发送还未发送成功的数据报。函数中，通过 while 循环遍历 _dgrames_queue（存储了还未成功发送的数据报），如果下一跳的 Ethernet 地址已经存在（即在 _arp_table 中），那么就将该数据报从队列中移除，调用 send_datagram() 方法进行发送，如果下一跳的 Ethernet 地址不存在，那么就退出循环。 因为在 send_datagram() 中，如果目的地的 Ethernet 地址不可用，则会将该数据报添加到 _dgrames_queue 中，等待重新发送。因此，resend() 的作用就是从队列中取出数据报重新发送，直到队列为空或者下一跳的 Ethernet 地址可用为止。 1234567891011121314151617181920212223//! \\param[in] dgram the IPv4 datagram to be sent//! \\param[in] next_hop the IP address of the interface to send it to (typically a router or default gateway, but may also be another host if directly connected to the same network as the destination)//! (Note: the Address type can be converted to a uint32_t (raw 32-bit IP address) with the Address::ipv4_numeric() method.)void NetworkInterface::send_datagram(const InternetDatagram &amp;dgram, const Address &amp;next_hop) &#123; // convert IP address of next hop to raw 32-bit representation (used in ARP header) const uint32_t next_hop_ip = next_hop.ipv4_numeric(); // if destination Ehernet address known if (_arp_table.count(next_hop_ip)) &#123; EthernetFrame to_send; to_send.payload() = dgram.serialize(); to_send.header().dst = _arp_table[next_hop_ip].first; to_send.header().src = _ethernet_address; to_send.header().type = EthernetHeader::TYPE_IPv4; _frames_out.emplace(to_send); &#125; else &#123; // if destination Ethernet address unkown if (!get&lt;bool&gt;(_arp_retransmission_timer)) &#123; // no arp sent yet send_arp_request(next_hop_ip); &#125; // queue the IP datagram _dgrames_queue.push(&#123;dgram, next_hop&#125;); &#125; resend();&#125; 这段代码实现了将一个 IPv4 数据报通过该网络接口发送出去的功能。其中，数据报和下一个跳的地址（一般是路由器或者默认网关，但也可能是直接连接在同一网络中的另一个主机）作为参数传入。 首先，将下一跳地址转换为 uint32_t 类型的 IPv4 地址。如果已知下一跳的 Ethernet 地址，则将数据报封装成 Ethernet 帧并发送出去。如果下一跳的 Ethernet 地址不可知，则将此数据报加入到待发送数据报队列中，并发送 ARP 请求以查找下一跳的 Ethernet 地址。 最后，通过调用 resend() 函数来遍历待发送数据报队列，查看其中是否有已知下一跳地址的数据报，如果有，则将其从队列中弹出，并重复调用 send_datagram() 函数进行数据报发送。如果待发送数据报队列中没有已知下一跳地址的数据报，则函数退出。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//! \\param[in] frame the incoming Ethernet frameoptional&lt;InternetDatagram&gt; NetworkInterface::recv_frame(const EthernetFrame &amp;frame) &#123; if (frame.header().dst != _ethernet_address &amp;&amp; frame.header().dst != ETHERNET_BROADCAST) return &#123;&#125;; if (frame.header().type == EthernetHeader::TYPE_IPv4) &#123; InternetDatagram ret; if (ret.parse(Buffer(frame.payload())) == ParseResult::NoError) &#123; return ret; &#125; &#125; else if (frame.header().type == EthernetHeader::TYPE_ARP) &#123; // parse ARPMessage arp_packet; if (arp_packet.parse(Buffer(frame.payload())) == ParseResult::NoError) &#123; // record the sender&#x27;s info _arp_table[arp_packet.sender_ip_address] = &#123;arp_packet.sender_ethernet_address, _curr_time + 30 * 1000&#125;; // turn off timer if (get&lt;bool&gt;(_arp_retransmission_timer) &amp;&amp; get&lt;uint32_t&gt;(_arp_retransmission_timer) == arp_packet.sender_ip_address) _arp_retransmission_timer = make_tuple(false, 0, 0); _arp_failure_time.push(&#123;_curr_time + 30 * 1000, arp_packet.sender_ip_address&#125;); // send reply if (arp_packet.target_ip_address == _ip_address.ipv4_numeric() &amp;&amp; arp_packet.opcode == ARPMessage::OPCODE_REQUEST) &#123; EthernetFrame arp_to_send; // header arp_to_send.header().dst = arp_packet.sender_ethernet_address; arp_to_send.header().src = _ethernet_address; arp_to_send.header().type = EthernetHeader::TYPE_ARP; // payload ARPMessage arp_reply; arp_reply.opcode = ARPMessage::OPCODE_REPLY; arp_reply.sender_ethernet_address = _ethernet_address; arp_reply.sender_ip_address = _ip_address.ipv4_numeric(); arp_reply.target_ethernet_address = arp_packet.sender_ethernet_address; arp_reply.target_ip_address = arp_packet.sender_ip_address; arp_to_send.payload() = BufferList(move(arp_reply.serialize())); // send reply // cerr&lt;&lt; &quot;send reply&quot; &lt;&lt; arp_reply.to_string() &lt;&lt;endl; _frames_out.emplace(arp_to_send); &#125; &#125; resend(); &#125; return &#123;&#125;;&#125; 这个方法是在网络接口接收到一个新的以太网帧时被调用。 如果接收到帧的目的地址不是该接口的以太网地址，也不是广播地址，那么说明该帧不是发给该接口的，因此该方法返回一个空的可选值。 如果该帧包含一个IPv4数据报，该方法尝试从帧的负载中解析数据报。如果解析成功，该方法返回解析后的数据报，以可选值的形式封装返回。 如果该帧包含一个ARP消息，该方法尝试从帧的负载中解析消息。如果解析成功，该方法会更新ARP表中的发送者信息，关闭对应的ARP重传计时器（如果有的话），并将ARP条目的到期时间推入到ARP失败时间堆中。如果ARP消息是一个针对该接口IP地址的ARP请求，该方法会构建一个ARP回复并将其发送回发送者。 在处理接收到的帧后，该方法调用resend()方法检查是否有任何等待ARP解析的数据报被排队。 12345678910111213141516171819202122//! \\param[in] ms_since_last_tick the number of milliseconds since the last call to this methodvoid NetworkInterface::tick(const time_t ms_since_last_tick) &#123; _curr_time += ms_since_last_tick; // Expire any IP-to-Ethernet mappings that have expired. while (!_arp_failure_time.empty()) &#123; auto arp_entry = _arp_failure_time.top(); if (arp_entry.first &lt;= _curr_time) &#123; _arp_failure_time.pop(); if (_arp_table[arp_entry.second].second &lt;= _curr_time) _arp_table.erase(arp_entry.second); &#125; else &#123; break; &#125; &#125; // Resend arp if no response if (get&lt;bool&gt;(_arp_retransmission_timer) &amp;&amp; _curr_time - get&lt;time_t&gt;(_arp_retransmission_timer) &gt; 5 * 1000) &#123; auto ip_to_find = get&lt;uint32_t&gt;(_arp_retransmission_timer); send_arp_request(ip_to_find); &#125;&#125; tick() 方法会定期调用来执行各种维护任务。 该方法通过将自上次调用该方法以来经过的毫秒数添加到当前时间来更新当前时间。 然后，该方法通过迭代 ARP 失败时间堆来检查是否有已过期的 IP 到 Ethernet 映射。如果堆中的某个条目的过期时间小于或等于当前时间，则该方法将该条目从堆中弹出，并检查对应的 ARP 表中的 ARP 条目是否也已过期。如果 ARP 条目已过期，则该方法从 ARP 表中删除该条目。 接下来，该方法检查是否需要重新发送 ARP 请求。如果已经发送了 ARP 请求且当前时间减去请求发送时间大于 5 秒，则该方法会重新发送 ARP 请求。 总体而言，tick() 方法确保已过期的 ARP 条目从 ARP 表中删除，并在及时未收到响应时重新发送 ARP 请求。 NetworkInterface::NetworkInterface(const EthernetAddress &amp;ethernet_address, const Address &amp;ip_address)：构造函数，初始化网络接口的以太网地址和 IP 地址。 NetworkInterface::send_datagram(const InternetDatagram &amp;dgram, const Address &amp;next_hop)：发送 IP 数据包，如果目的 IP 对应的以太网地址已知，则直接封装成以太网帧并通过 _frames_out 成员变量发送出去，否则发送 ARP 请求并将 IP 数据包加入到待发送队列 _dgrames_queue 中等待。 NetworkInterface::recv_frame(const EthernetFrame &amp;frame)：接收以太网帧，如果帧的目的地址是本机的以太网地址或者广播地址，则根据帧类型分别处理。如果是 IP 数据帧，尝试解析出 IP 数据包并返回；如果是 ARP 请求或响应帧，则更新 ARP 表，并根据请求发送响应帧。 NetworkInterface::tick(const time_t ms_since_last_tick)：定期调用的方法，用于处理 ARP 表项的过期和 ARP 请求的超时重传。 NetworkInterface::send_arp_request(const uint32_t ip_to_find)：发送 ARP 请求，将请求封装成以太网帧并通过 _frames_out 成员变量发送出去，并设置超时计时器 _arp_retransmission_timer。 NetworkInterface::resend()：定期检查待发送队列 _dgrames_queue 中是否有 IP 数据包可以发送，如果目的 IP 对应的以太网地址已知，则封装成以太网帧并通过 _frames_out 成员变量发送出去，否则停止检查。 webget回顾 还记得你在实验0中写的webget.cc吗(在TCPSocket中使用Linux提供的TCP实现)？还记得你在实验4中如何修改它，以便在CS144TCPSocket中使用你自己的TCP-in-IP实现吗？如上所述，这仍然依赖于Linux内核作为堆栈的一部分：在IP和链路层(以太网)之间转换的网络接口。 我们希望你在不更改任何其他内容的情况下将其切换为使用网络接口。你只需将CS144TCPSocket类型替换为FullStackSocket。 这将使用TCP-in-IP-in-Ethernet堆栈，如图1(左侧)所示：你的webget.cc应用程序，在TCP的TCPConnection实现之上，在TCP-in-IP的tcp_helpers/tcp_over_ip.cc代码之上，在NetworkInterface之上。 重新编译并运行make check_lab5以确认你已经完成了完整的堆栈：你已经在自己完整的TCP实现和自己的网络接口实现之上编写了一个基本的网络抓取程序，并且它仍然成功地与真正的Web服务器通信。 如果遇到问题，请尝试手动运行该程序：./apps/webget cs144.keithw.org /hasher/xyzzy，并尝试使用wireshark捕获它发送和接收的内容。你可以通过运行sudo TCPdump -i tap10 -w /tmp/packets.tap来保存它正在发送和接收的分组。然后在wireshark中打开/tmp/packets.tap文件。 完整代码 - network_interface.hh - network_interface.cc","categories":[],"tags":[{"name":"CS144","slug":"CS144","permalink":"http://www.misaka-9982.com/tags/CS144/"},{"name":"Network","slug":"Network","permalink":"http://www.misaka-9982.com/tags/Network/"}]},{"title":"Makefile 和 CMake","slug":"Makefile-和-CMake","date":"2023-02-20T09:44:45.000Z","updated":"2023-02-20T09:45:11.865Z","comments":true,"path":"2023/02/20/Makefile-和-CMake/","link":"","permalink":"http://www.misaka-9982.com/2023/02/20/Makefile-%E5%92%8C-CMake/","excerpt":"","text":"Makefile Reference Makefile 20分钟入门，简简单单，展示如何使用Makefile管理和编译C++代码 简介 Makefile 是一个用于构建（Build）软件的文件，它包含了一组规则和命令，用于自动化构建和编译源代码，生成目标文件或可执行程序等。Makefile 是一个文本文件，它的格式通常是： 12target: dependencies command 其中，target 是一个目标文件或操作的名称，dependencies 是构建目标所依赖的文件或操作，command 是生成目标的命令。Makefile 文件中的规则和命令由 make 命令读取并执行，自动构建软件。 Makefile 的主要作用是提高软件开发过程的效率和可靠性。通过编写 Makefile，开发人员可以避免手动执行构建和编译操作，减少出错的可能性，同时还可以利用 make 工具的依赖关系自动化处理，只编译发生了变化的源代码，避免重复工作。Makefile 还可以方便地扩展到多个平台和项目中，支持更加灵活的软件构建和管理。 Makefile 是 Linux 和 Unix 系统上的一种常用工具，也逐渐被其他操作系统所采用。除了 C/C++ 项目，Makefile 也可以用于其他编程语言和项目的构建。 准备文件 12345678$ tree hellohello├── factorial.cpp├── functions.h├── main.cpp└── printhello.cpp1 directory, 4 files functions.h 123456#ifdef _FUNCTIONS_H_#define _FUNCTIONS_H_void printhello();int factorial(int n);#endif printhello.cpp 123456789#include &lt;iostream&gt;#include &quot;functions.h&quot;using namespace std;void printhello() &#123; int i; cout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; endl;&#125; factorial.cpp 123456789#include &quot;functions.h&quot;int factorial(int n) &#123; if (n == 1) &#123; return 1; &#125; else &#123; return n * factorial(n - 1); &#125;&#125; main.cpp 1234567891011121314#define _FUNCTIONS_H_#include &lt;iostream&gt;#include &quot;functions.h&quot;using namespace std;int main() &#123; printhello(); cout &lt;&lt; &quot;This is main: &quot; &lt;&lt; endl; cout &lt;&lt; &quot;This factorial of 5 is : &quot; &lt;&lt; factorial(5) &lt;&lt; endl; return 0;&#125; 编译： 12345$ g++ main.cpp factorial.cpp printhello.cpp -o main$ ./mainHello World!This is main:This factorial of 5 is : 120 另一种方式： 12345678$ g++ factorial.cpp -c$ g++ printhello.cpp -c$ g++ main.cpp -c$ g++ *.o -o main$ ./mainHello World!This is main:This factorial of 5 is : 120 g++ factorial.cpp -c 命令是用来编译 factorial.cpp 文件并生成目标文件（object file）的。 具体来说，g++ 是 GNU C++ 编译器的命令，用于将源代码编译为可执行文件或目标文件。factorial.cpp 是要编译的源代码文件，-c 选项告诉编译器只编译源代码文件，不进行链接操作，生成目标文件而非可执行文件。生成的目标文件通常是二进制的，可以被链接器用于生成可执行文件。 这个命令的优点在于，它将源代码文件编译为目标文件，实现了代码和数据的分离。这样做的好处是可以减少代码的编译时间，提高了编译的效率。在进行后续的链接操作时，只需要将所有的目标文件链接到一起即可生成可执行文件，避免了重复编译源代码的过程，节省了时间。 此外，将代码和数据分离也使得程序的修改和维护更加方便。当程序需要更新时，只需要重新编译发生了变化的源代码文件生成目标文件，而不需要重新编译所有的源代码文件，可以减少编译时间和编译器的资源占用。 编译器通常使用时间戳（timestamp）来判断程序是否发生更新。 时间戳是文件系统记录每个文件的一个元数据，用来表示文件的创建时间、修改时间、访问时间等信息。当一个源代码文件被编译时，编译器会检查该文件的时间戳和对应的目标文件的时间戳，如果源代码文件的时间戳比目标文件的时间戳更晚，说明源代码文件已经被更新过，需要重新编译该文件生成新的目标文件。 在重新编译时，编译器只会编译发生更新的源代码文件和依赖的文件，不会重新编译其他源代码文件和库文件。这样做可以避免重复编译和浪费时间，提高编译效率。 除了时间戳，编译器还可以使用其他的机制来判断程序是否发生更新，比如对源代码文件进行哈希计算，生成一个哈希值，如果两个文件的哈希值不同，则说明文件发生了变化。不过，时间戳是最常用的方法，因为它可以直接使用操作系统提供的元数据，并且准确度高。 总之，将源代码编译为目标文件是一种优化编译的方法，可以提高编译效率和程序的可维护性。 Version 1 12hello: main.cpp printhello.cpp factorial.cpp g++ -o hello main.cpp printhello.cpp factorial.cpp 这个 Makefile 包含了一个规则，用于编译 main.cpp、printhello.cpp 和 factorial.cpp 三个源代码文件，并生成一个可执行文件 hello。 具体来说，Makefile 的规则包含了一个目标和一组依赖项，以及生成目标的命令。在这个 Makefile 中，目标是 hello，表示要生成的可执行文件，依赖项是 main.cpp、printhello.cpp 和 factorial.cpp，表示可执行文件需要依赖这三个源代码文件，生成目标的命令是 g++ -o hello main.cpp printhello.cpp factorial.cpp，表示使用 g++ 编译器将三个源代码文件编译成一个可执行文件 hello。 具体的编译过程是，当执行 make 命令时，make 工具会读取 Makefile 文件，查找是否存在名为 hello 的目标文件或规则。在这个例子中，存在一个名为 hello 的规则，make 工具会判断是否需要重新生成 hello 文件。如果目标文件不存在或者依赖文件的时间戳比目标文件的时间戳更晚，make 工具就会执行生成目标的命令，即使用 g++ 编译器将三个源代码文件编译成一个可执行文件 hello。 在执行生成目标的命令时，g++ 编译器会将三个源代码文件编译成目标文件，并将目标文件链接起来生成可执行文件 hello。-o 选项指定生成的可执行文件的名称为 hello，main.cpp、printhello.cpp 和 factorial.cpp 三个文件是编译器的输入文件。 总之，这个 Makefile 定义了一个简单的规则，可以将多个源代码文件编译成一个可执行文件，为程序的构建和管理提供了便利。 12$ makeg++ -o hello main.cpp printhello.cpp factorial.cpp Version 2 123456789101112131415CXX = g++TARGET = helloOBJ = main.o printhello.o factorial.o$(TARGET): $(OBJ) $(CXX) -o $(TARGET) $(OBJ)main.o: main.cpp $(CXX) -c main.cppprinthello.o: printhello.cpp $(CXX) -c printhello.cppfactorial.o: factorial.cpp $(CXX) -c factorial.cpp 相较于上一个 Makefile，这个版本的 Makefile 采用了一种更加灵活、结构化的方式来编写规则，具有以下优点： 变量化：将编译器 g++、目标文件 hello、源代码文件 main.cpp、printhello.cpp 和 factorial.cpp 等常量作为变量定义，使得 Makefile 更加易于维护和扩展。 规则化：使用规则来定义每个源代码文件的编译命令，以及可执行文件的生成命令。通过定义规则，可以使得 Makefile 更加模块化，方便增加、修改、删除规则，提高了 Makefile 的可读性和可维护性。 自动化依赖：定义了每个目标文件依赖的源代码文件，让 Make 工具自动地管理依赖关系。如果某个源代码文件被修改，Make 工具会自动地重新编译对应的目标文件，而不会重新编译没有变化的文件，从而提高编译效率。 Makefile 中定义了每个源代码文件的编译命令，而不是像上一个版本的 Makefile 那样一次性编译所有的源代码文件。这种做法更加细粒度，可以在需要时单独编译某个源代码文件，避免不必要的编译，提高了编译效率。 12345$ makeg++ -c main.cppg++ -c printhello.cppg++ -c factorial.cppg++ -o hello main.o printhello.o factorial.o Version 3 123456789101112131415CXX = g++TARGET = hello OBJ = main.o printhello.o factorial.oCXXFLAGS = -c -Wall$(TARGET): $(OBJ) $(CXX) -o $@ $^%.o: %.cpp $(CXX) $(CXXFLAGS) $&lt; -o $@.PHONY: cleanclean: rm -f *.o $(TARGET) 相较于前两个版本的 Makefile，这个版本的 Makefile 进一步提高了灵活性和可维护性，具有以下优点： 模式规则：通过定义 % 通配符，可以将编译每个源代码文件的规则合并成一个通用的规则。这样做可以让 Makefile 更加精简，提高可读性，也方便在以后添加或删除源代码文件时进行维护。 变量化：将编译器 g++、目标文件 hello、源代码文件 main.cpp、printhello.cpp 和 factorial.cpp 等常量作为变量定义，同样具有可维护性和可扩展性的优点。 自动化依赖：与第二个版本的 Makefile 类似，使用 $(OBJ) 变量来指定可执行文件 hello 依赖的所有目标文件，并且使用模式规则来自动化生成每个目标文件。 清理目标：通过 .PHONY 声明一个伪目标 clean，定义了清理规则，可以方便地删除所有的目标文件和可执行文件，避免在重新编译时出现问题。 总之，相较于前两个版本的 Makefile，这个版本的 Makefile 进一步提高了可读性和可维护性，并且更加自动化，可以自动化处理每个源代码文件的编译过程。同时，定义了清理规则，方便维护者进行清理操作。 123456789$ makeg++ -c -Wall main.cpp -o main.og++ -c -Wall printhello.cpp -o printhello.oprinthello.cpp:7:9: warning: unused variable &#x27;i&#x27; [-Wunused-variable] int i; ^1 warning generated.g++ -c -Wall factorial.cpp -o factorial.og++ -o hello main.o printhello.o factorial.o Version 4 12345678910111213141516CXX = g++TARGET = hello SRC = $(wildcard *.cpp)OBJ = $(patsubst %.cpp, %.o, $(SRC))CXXFLAGS = -c -Wall$(TARGET): $(OBJ) $(CXX) -o $@ $^%.o: %.cpp $(CXX) $(CXXFLAGS) $&lt; -o $@.PHONY: cleanclean: rm -f *.o $(TARGET) 相较于之前的版本，这个版本的 Makefile 进一步提高了灵活性，具有以下优点： 自动化变量：使用了 wildcard 和 patsubst 自动化变量来自动化地查找和转换源代码文件和目标文件，避免了手动定义每个文件的繁琐操作。 简化了变量定义：只定义了需要用到的变量，使得 Makefile 更加精简，可读性更高。 自动化依赖：与之前的版本类似，通过自动化变量 $(OBJ)，使用模式规则来自动化生成每个目标文件，提高了 Makefile 的灵活性和可维护性。 清理目标：与之前的版本类似，定义了一个伪目标 clean，方便维护者进行清理操作。 总之，相较于之前的版本，这个版本的 Makefile 通过使用自动化变量和函数，避免了手动定义文件和目标文件的繁琐操作，更加自动化，同时仍然具有可读性和可维护性，提高了 Makefile 的灵活性。 123456789$ makeg++ -c -Wall factorial.cpp -o factorial.og++ -c -Wall main.cpp -o main.og++ -c -Wall printhello.cpp -o printhello.oprinthello.cpp:7:9: warning: unused variable &#x27;i&#x27; [-Wunused-variable] int i; ^1 warning generated.g++ -o hello factorial.o main.o printhello.o 常用的自动化变量 Makefile中常用的自动化变量和它们的解析如下： 变量名 解析 $@ 当前规则的目标文件名。 $^ 所有依赖文件的列表，以空格分隔。 $&lt; 第一个依赖文件的名称。 $? 所有新于目标的依赖文件列表，以空格分隔。 $* 当前规则的目标文件名，不包括扩展名。 $(@D) 目标文件所在的目录名。 $(@F) 目标文件名，不包括目录路径。 $(notdir $&lt;) 获取 $&lt; 的文件名，去掉路径。 $(subst from,to,text) 将 text 中的 from 替换为 to。 $(patsubst pattern,replacement,text) 查找 text 中所有符合 pattern 模式的字符串，替换为 replacement。 $(wildcard pattern) 查找符合 pattern 模式的文件。 $(dir names) 获取 names 中所有文件的目录部分。 $(basename names) 获取 names 中所有文件的文件名部分（去掉扩展名）。 $(suffix names) 获取 names 中所有文件的扩展名部分。 在 Makefile 中，这些自动化变量可以方便地引用和处理一些常用信息，提高 Makefile 的编写效率和可读性。例如，使用 $@ 可以在命令中引用当前规则的目标文件名，使用 $^ 可以引用所有依赖文件的列表。此外，可以使用 $(wildcard pattern) 来查找指定模式的文件，以及使用 $(patsubst pattern,replacement,text) 来替换文件名中的通配符等 CMake Reference CMake 6分钟入门，不用再写复杂的Makefile 简介 CMake 是一个开源的跨平台的构建工具，用于管理 C/C++ 代码的构建过程。它使用一种名为 CMakeLists.txt 的简单脚本语言，通过配置和生成 Makefile、Visual Studio 项目、Xcode 项目等构建系统的脚本，从而实现跨平台、多编译器的构建工作。 使用 CMake，开发者可以将代码与构建系统分离，简化代码的移植和维护过程，同时可以自动生成不同平台、不同编译器下的构建脚本，提高了开发效率。CMake 还支持多种编程语言，包括 C、C++、Fortran、Java、Python 等，并且支持多种操作系统，包括 Windows、Linux、macOS 等。 CMake 使用起来比较简单，通过编写 CMakeLists.txt 文件来配置项目，然后使用 CMake 命令生成对应的构建系统。CMake 提供了丰富的命令和选项，支持包括库的构建、自定义构建类型、动态链接库的构建、安装和测试等功能。同时，CMake 还与各种第三方工具和库进行了深度集成，包括 Boost、Qt、CUDA、OpenCV 等，方便开发者集成自己的项目和工具。 总之，CMake 是一个功能强大、易于使用、跨平台的构建工具，能够帮助开发者管理 C/C++ 代码的构建过程，提高开发效率，方便项目的移植和维护。 例子 CMakeLists.txt： 12345cmake_minimum_required(VERSION 3.10)project(hello)add_executable(hello main.cpp factorial.cpp printhello.cpp) 编译 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980$ mkdir build &amp;&amp; cd build$ cmake ..-- The C compiler identification is AppleClang 13.1.6.13160021-- The CXX compiler identification is AppleClang 13.1.6.13160021-- Detecting C compiler ABI info-- Detecting C compiler ABI info - done-- Check for working C compiler: /Library/Developer/CommandLineTools/usr/bin/cc - skipped-- Detecting C compile features-- Detecting C compile features - done-- Detecting CXX compiler ABI info-- Detecting CXX compiler ABI info - done-- Check for working CXX compiler: /Library/Developer/CommandLineTools/usr/bin/c++ - skipped-- Detecting CXX compile features-- Detecting CXX compile features - done-- Configuring done-- Generating done-- Build files have been written to: /Users/misaka/Downloads/CodeSpace/Code/C/hello/build$ make[ 25%] Building CXX object CMakeFiles/hello.dir/main.cpp.o[ 50%] Building CXX object CMakeFiles/hello.dir/factorial.cpp.o[ 75%] Building CXX object CMakeFiles/hello.dir/printhello.cpp.o[100%] Linking CXX executable hello[100%] Built target hello$ tree hellohello├── CMakeLists.txt├── build│ ├── CMakeCache.txt│ ├── CMakeFiles│ │ ├── 3.25.2│ │ │ ├── CMakeCCompiler.cmake│ │ │ ├── CMakeCXXCompiler.cmake│ │ │ ├── CMakeDetermineCompilerABI_C.bin│ │ │ ├── CMakeDetermineCompilerABI_CXX.bin│ │ │ ├── CMakeSystem.cmake│ │ │ ├── CompilerIdC│ │ │ │ ├── CMakeCCompilerId.c│ │ │ │ ├── CMakeCCompilerId.o│ │ │ │ └── tmp│ │ │ └── CompilerIdCXX│ │ │ ├── CMakeCXXCompilerId.cpp│ │ │ ├── CMakeCXXCompilerId.o│ │ │ └── tmp│ │ ├── CMakeDirectoryInformation.cmake│ │ ├── CMakeError.log│ │ ├── CMakeOutput.log│ │ ├── CMakeScratch│ │ ├── Makefile.cmake│ │ ├── Makefile2│ │ ├── TargetDirectories.txt│ │ ├── cmake.check_cache│ │ ├── hello.dir│ │ │ ├── DependInfo.cmake│ │ │ ├── build.make│ │ │ ├── cmake_clean.cmake│ │ │ ├── compiler_depend.make│ │ │ ├── compiler_depend.ts│ │ │ ├── depend.make│ │ │ ├── factorial.cpp.o│ │ │ ├── factorial.cpp.o.d│ │ │ ├── flags.make│ │ │ ├── link.txt│ │ │ ├── main.cpp.o│ │ │ ├── main.cpp.o.d│ │ │ ├── printhello.cpp.o│ │ │ ├── printhello.cpp.o.d│ │ │ └── progress.make│ │ ├── pkgRedirects│ │ └── progress.marks│ ├── Makefile│ ├── cmake_install.cmake│ └── hello├── factorial.cpp├── functions.h├── main.cpp└── printhello.cpp11 directories, 41 files","categories":[],"tags":[]},{"title":"CS144-Lab4","slug":"CS144-Lab4","date":"2023-02-19T03:00:28.000Z","updated":"2023-02-19T04:26:16.038Z","comments":true,"path":"2023/02/19/CS144-Lab4/","link":"","permalink":"http://www.misaka-9982.com/2023/02/19/CS144-Lab4/","excerpt":"","text":"概述 在实验0中，你实现了流量控制的字节流(ByteStream)的抽象概念。 在实验1、2和3中，你实现了该抽象概念与互联网提供的抽象概念之间的转换工具：不可靠的数据报(IP或UDP)。 现在，你已经接近顶峰：一个可以工作的TCPConnection，它结合了你的TCPSender和TCPReceiver，并能以至少100Mbit/s的速度与其他TCP实现对话。 图1显示了整体设计： 图1：TCP实现中的模块和数据流的安排。 开始 你的TCPConnection实现将使用与你在实验0-3中使用的相同的Sponge库，并增加了类和测试。我们将给你提供支持代码，用于将TCP段读写到用户数据报(“TCP-over-UDP”)和互联网数据报(“TCP/IP”)的有效载荷中。我们还将给你一个类(CS144TCPSocket)，它可以包装你的TCPConnection，使其表现得像一个正常的流套接字，就像你在实验0中用来实现webget的TCPSocket。为了开始进行作业： 请确保你已经提交了你在实验3中的所有解决方案。请不要修改libsponge目录顶层以外的任何文件，或者webget.cc。否则，你可能会在合并实验4的启动代码时遇到麻烦。 在实验作业的存储库中，运行git fetch来检索实验作业的最新版本。 通过运行git merge origin/lab4-startercode，下载实验4的启动代码。 在build目录中，编译源代码：make(编译时可以运行make -j4以使用四个处理器)。 在build目录外，打开并开始编辑writeups/lab4.md文件。这是你实验报告的模板，将包含在你提交的内容中。 实验4：TCP连接 本周，你将完成构建一个与互联网上数十亿台计算机和移动设备兼容的工作TCP实现。你已经完成了大部分的工作：你已经实现了发送方和接收方。本周你的工作是将它们”连接”起来，成为一个对象(TCPConnection)，并处理一些对连接来说是全局性的管家任务。 回顾一下：TCP可靠地传递一对受流量控制的字节流，每个方向一个。两方参与TCP连接，每一方同时作为”发送方”(自己的出站字节流)和”接收方”(入站字节流)行动： 双方(上图中的”A”和”B”)被称为连接的”端点”，或”对等方”。你的TCPConnection作为其中一个对等方，负责接收和发送数据段，确保发送方和接收方被告知并有机会对他们关心的传入和传出段的字段作出贡献。 接收段。TCPConnection将接收来自互联网的TCPSegment，并且 如果ACK标志被设置，告诉TCPSender关于它在传入段上所关心的字段：ackno和window_size，并且 将段交给TCPReceiver，这样它就可以检查它所关心的传入段的字段：seqno, syn, payload, fin。 发送段。TCPConnection将通过互联网发送TCPSegment： 每当TCPSender将一个段push到它的传出队列中时，它就会在传出段上设置它负责的字段。(seqno, syn, payload, fin)。 在发送段之前，TCPConnection会向TCPReceiver询问它负责的传出段的字段：ackno和window_size。如果有ackno(请记住，TCPReceiver::ackno()返回一个可选值。)，它将设置ack标志和TCPSegment中的字段。 因此，每个TCPSegment的整体结构看起来像这样，”发送方 “和”接收方”字段用不同的颜色显示： TCPConnection的完整接口在类文档中。请花一些时间来阅读。你的大部分实现将涉及到将TCPConnection的公共API与TCPSender和TCPReceiver中的适当例程进行”连接”。你希望尽可能将任何繁重的工作推迟到你已经实现的发送方和接收方。话虽如此，但并不是所有的事情都那么简单，有一些微妙的地方涉及到整体连接的”全局”行为。最难的部分是决定何时完全终止一个TCPConnection并宣布它不再是”活动的”。 下面是一些常见问题和你需要处理的边缘情况的细节。 常见问题和特殊情形 你们希望有多少代码？ 总的来说，我们预计实现(在tcp_connection.cc中)总共需要大约100-150行的代码。当你完成后，测试套件将广泛地测试你自己的实现以及Linux内核的TCP实现的交互性。 我应该如何开始？ 最好的开始方式可能是将一些”普通”方法与TCPSender和TCPReceiver中的适当调用连接起来。这可能包括像remaining_outbound_capacity()，bytes_in_flight()以及unassembled_bytes()。 然后你可以选择实现”writer”的方法：connect()、write()和end_input_stream()。其中一些方法可能需要对出站的ByteStream(由TCPSender拥有)做一些事情，并告知TCPSender。 你可能会选择在你完全实现每个方法之前开始运行测试套件(make check)；测试的失败信息可以给你一个线索或指南，告诉你接下来要处理什么。 应用程序如何从入站流中读取？ TCPConnection::inbound_stream()已经在头文件中实现了。 TCPConnection是否需要任何花哨的数据结构或算法？ 不，它真的不需要。繁重的工作都是由你已经实现的TCPSender和TCPReceiver完成的。这里的工作实际上只是把所有的东西连接起来，处理一些难以轻易融入发送方和接收方的连接范围内的微妙问题。 TCPConnection如何实际发送一个段？ 类似于TCPSender，把段push到_segments_out队列中。就你的TCPConnection而言，当你把它push到这个队列上时，就认为它已经发送了。很快，所有者会出现并pop它(使用公共的segments_out()访问器方法)并真正发送它。 TCPConnection如何了解时间的流逝？ 与TCPSender类似——tick()方法将被定期调用。请不要使用任何其他方式来获得时间，tick方法是你对时间流逝的唯一访问，这样可以保持事情的确定性和可测试性。 如果一个传入段设置了RST标志，TCPConnection会做什么？ 这个标志(“重置”)表示连接立即终止。如果你收到一个带有RST的段，你应该在入站和出站的ByteStreams上设置错误标志，并且任何后续对TCPConnection::active()的调用都应该返回false。 什么时候应该发送一个设置了RST标志的段？ 有两种情况下，你会想中止整个连接。 如果发送方连续发送了太多的重传而没有成功(超过了TCPConfig::MAX_RETX_ATTEMPTS，即8)。 如果在连接仍处于活动状态时调用TCPConnection析构函数(active()返回true)。 发送一个设置了RST的段与接收一个段的效果类似：连接已断开且不再active()，两个ByStream都应设置为错误状态。 等等，但我如何生成一个可以设置RST标志的段？序列号是什么？ 任何流出的段都需要有适当的序列号。你可以通过调用TCPSender的send_empty_segment()方法，强制TCPSender生成一个具有适当序列号的空段。或者你可以通过调用它的fill_window()方法让它填充窗口(如果它有未完成的信息要发送，例如，来自流的字节或SYN/FIN)。 ACK标志的作用是什么？不是一直有一个ackno吗？ 几乎每个TCPSegment都有一个ackno，并且设置了ACK标志。例外的情况是在连接的最开始，在接收方有任何需要确认的东西之前。 在传出段中，你要尽可能地设置ackno和ACK标志。也就是说，只要TCPReceiver的ackno()方法返回一个std::optional&lt;WrappingInt32&gt;的值，你就可以用has_value()测试。 在传入段中，只有当ACK字段被设置时，才需要查看ackno。如果ACK字段被设置，就把这个ackno(和窗口大小)给TCPSender。 在接收段时，如果TCPReceiver抱怨说该段没有与窗口重叠，是不可接受的(segment_received()返回false)，我应该怎么做？ 在这种情况下，TCPConnection需要确保向对等方发回一个段，给出当前的ackno和窗口大小。这有助于纠正对等方的困惑。 好的，很好。如果TCPConnection收到了一个段，而TCPSender抱怨说ackno无效(ack_received()返回false)，该怎么办？ 同样的答案! 如果TCPConnection收到了一个网段，而且一切都很好呢？那我还需要回复吗？ 如果该段占用了任何序列号，那么你需要确保它被确认——至少需要向对等方发送一个带有适当的序列号和新的ackno和window_size的段。你可能不需要做任何事情来强制这样做，因为TCPSender通常会在ack_received()中决定发送一个新的段(因为窗口中已经打开了更多的空间)。但是，即使TCPSender没有更多的数据要发送，你也需要确保传入的段以某种方式被确认。 如果TCPConnection只是确认每个网段，即使它不占用任何序列号，又如何呢？ 这可不是个好主意！两个对等方最终会来回发送无限多的acks。 如何解读这些”状态”名称(如”流开始(stream started)”或”流进行中(stream ongoing)”)？ 请查看libsponge/tcp_helpers/tcp_state.hh和tcp_state.cc文件。 如果TCPReceiver想公布一个比TCPSegment::header().win字段大的窗口尺寸，我应该发送什么？ 发送你能发送的最大值。你可能会发现std::numeric limits类有帮助。 TCP连接何时最终”完成”？active()什么时候可以返回false？ 请看下一节。 如果本PDF发布后有更多常见问题，我可以在哪里阅读？ 请定期查看网站(https://cs144.github.io/lab_faq.html)和Piazza。 TCP连接的结束：共识需要工作 TCPConnection的一个重要功能是决定TCP连接何时完全”完成”。当这种情况发生时，该实现会释放其对本地端口号的独占申明，停止发送回复传入段的确认，认为该连接已成为历史，并让其active()方法返回false。 有两种方式可以结束一个连接。在一个不干净的关闭中，TCPConnection发送或接收一个设置了RST标志的段。在这种情况下，出站和入站的ByteStream应该都处于错误状态，而active()可以立即返回false。 一个干净的关闭是我们如何在没有错误的情况下达到”完成”(active() = false)。这比较复杂，但这是件美好的事情，因为它尽可能地确保两个ByteStream中的每一个都被可靠地完全交付给接收方。在下一节(§§5.1)中，我们给出了干净的关闭发生时的实际情况，所以如果你愿意，可以随意跳过前面的内容。 酷，你还在这里。由于”Two Generals Problem“的存在，不可能保证两个对等方都能实现干净的关闭，但是TCP已经非常接近了。情况是这样的。从一个对等方(一个TCPConnection，我们称之为”本地”对等方)的角度来看，在其与”远程”对等方的连接中，有四个前提条件可以实现干净的关闭： 前提条件#1 入站流已完全组装并已结束。 前提条件#2 出站流已被本地应用程序结束，并完全发送(包括它结束的事实，即一个带有FIN的段)到远程对等方。 前提条件#3 出站流已被远程对等方完全确认。 前提条件#4 本地TCPConnection确信远程对等方能满足前提条件#3。这是令人头疼的部分。有两种可选的方法可以实现这一点：(等待修改为徘徊) 选项A：在两个流结束后徘徊。前提条件#1到#3都是真的，而且远程对等方似乎已经得到了本地对等方对整个流的确认。本地对等方并不确定这一点——TCP无法可靠地传递acks(它不接受acks)。但是本地对等方非常确信远程对等方已经得到了它的acks，因为远程对等方似乎没有重传任何东西，而且本地对等方已经等待了一段时间来确定。 具体来说，当前提条件#1到#3得到满足，并且本地对等方从远程对等方收到任何网段后，至少已经过了10倍的初始重传超时(_cfg.rt_timeout)，连接就完成了。这被称为在两个流结束后的”徘徊”，以确保远程对等方没有试图重传我们需要确认的东西。这确实意味着TCPConnection需要保持一段时间的活跃状态，保持对本地端口号的独占要求，并可能发送acks以响应传入的段，甚至在TCPSender和TCPReceiver完全完成其工作且两个流都结束之后。 在一个生产型的TCP实现中，等待计时器(也被称为时间等待计时器或最大段寿命(MSL)的两倍)通常是60或120秒。在一个连接有效完成后，保留一个端口号的时间可能很长，特别是如果你想启动一个新的服务器，绑定到同一个端口号，没有人愿意等待两分钟。SO_REUSEADDR socket选项本质上是让Linux忽略保留，对于调试或测试来说是很方便的。 选项B：被动关闭。前提条件#1到#3都是真的，而且本地对等方100%确定远程对等方可以满足前提条件#3。如果TCP不确认确认，这怎么可能呢？因为远程对等方是第一个结束其流的人。 为什么这个规则有效？这是脑筋急转弯，你不需要进一步阅读就能完成这个实验，但思考起来很有趣，而且能触及”Two Generals Problem”的深层原因，以及在不可靠的网络中对可靠性的固有限制。这样做的原因是，在收到并组装了远程对等方的FIN(前提条件#1)后，本地对等方发送了一个比以前发送的序列号更大的段(至少，它必须发送自己的FIN段以满足前提条件# 2)，该段也有一个ackno，承认远程对等方的FIN位。远程对等方承认该段(满足前提条件#3)，这意味着远程对等方一定也看到了本地对等方对远程对等方的FIN的ack。这就保证了远程对等方一定能够满足它自己的前提条件#3。所有这些都意味着本地对等方可以满足前提条件#4，而不需要等待。 呜呼! 我们说过这是一个脑筋急转弯。在你的实验报告中加分：你能找到一个更好的方法来解释这个问题吗 底线是，如果**TCPConnection的入站流在TCPConnection发送FIN段之前就结束了，那么TCPConnection就不需要在两个流结束后等待**。 TCP连接的结束(实践总结) 实际上这意味着你的TCPConnection在流结束后有一个叫做_linger_after_streams_finish的成员变量，通过state()方法暴露给测试程序。这个变量一开始是true。如果入站流在TCPConnection到达其出站流的EOF之前结束，则需要将此变量设置为false。 在满足前提条件#1到#3的任何一点上，如果_linger_after_streams_finish为false，连接就”完成”了(并且active()应该返回false)。否则，你需要等待：只有在收到最后一个网段后经过足够的时间(10 × _cfg.rt_timeout)，连接才会完成。 性能 在你完成了你的TCP实现，并且通过了make check运行的所有测试之后，请提交！然后，测量你的系统的性能，使其至少达到每秒100兆比特。 在build目录中，运行./apps/tcp benchmark。如果一切顺利的话，你会看到像这样的输出： 123user@computer:~/sponge/build$ ./apps/tcp_benchmark CPU-limited throughput : 1.78 Gbit/s CPU-limited throughput with reordering: 1.21 Gbit/s 为了获得实验的全部学分，你的性能需要在两条线上至少达到”0.10Gbit/s”(每秒100兆比特)。你可能需要对你的代码进行剖析，或者对它慢的地方进行推理，你可能需要改进一些关键模块(如ByteStream或StreamReassembler)的实现来达到这一点。 在你的报告中，请报告你所取得的速度数据(有无重新排序)。 如果你愿意，欢迎你尽可能地优化你的代码，但请不要以牺牲CS144的其他部分为代价，包括本实验的其他部分。如果你的性能超过100Mbit/s，我们不会给你加分——你所做的任何超出这个最低限度的改进都只是为了你自己的满意和学习。如果你在不改变任何公共接口的情况下实现了比我们快的速度，我们很愿意向你了解你是如何做到的。 (我们在2011年英特尔酷睿i7-2600K CPU @ 4.40GHz上运行我们的参考实现，使用Ubuntu 19.04，Linux 5.0.0-31-generic #33-Ubuntu，带有针对Meltdown/Spectre/等的默认缓解措施，以及带有默认编译器标志的g++ 8.3.0，进行默认(“发布”)构建。CPU限制的吞吐量(第一行)为7.18 Gbit/s，(第二行，有重新排序)为6.84 Gbit/s。) webget重温 胜利的时刻到了! 还记得你在实验0中写的webget.cc吗？它使用了由Linux内核提供的TCP实现(TCPSocket)。我们希望你能把它改成使用你自己的TCP实现，而不需要改变其他任何东西。我们认为你所需要做的就是： 用#include &quot;tcp_sponge_socket.hh&quot;替换#include &quot;socket.hh&quot; 。 将TCPSocket类型改为CS144TCPSocket。 在你的get_URL()函数的末尾，添加一个对socket.wait_until_closed()的调用。 为什么要这样做？通常情况下，Linux内核负责等待TCP连接达到”干净关闭”(并放弃它们的端口保留)，即使在用户进程退出后也是如此。但由于你的TCP实现都在用户空间，除了你的程序，没有其他东西可以跟踪连接状态。添加这个调用使套接字等待，直到你的TCPConnection报告active() = false。 重新编译，并运行make check webget来确认你已经完成了完整的闭环：你已经在你自己完整的TCP实现之上写了一个基本的web获取器，而且它仍然成功地与一个真正的webserver对话。如果你有问题，试着手动运行程序：./apps/webget cs144.keithw.org /hasher/xyzzy。你会在终端上得到一些调试输出，可能会有帮助。 TCPState TCP 状态自动机 TCP/IP State Transition Diagram TCP Finite State Machine LISTEN：表示正在等待来自任何远程 TCP 和端口的连接请求。 SYN-SENT：表示在发送连接请求后等待匹配的连接请求。 SYN-RECEIVED：表示在接收和发送连接请求后等待确认的连接请求确认。 ESTABLISHED：表示打开的连接，接收到的数据可以传递给用户，是连接传输阶段的正常状态。 FIN-WAIT-1：表示等待来自远程 TCP 的连接终止请求，或先前发送的连接终止请求的确认。 FIN-WAIT-2：表示等待远程 TCP 的连接终止请求。 CLOSE-WAIT：表示正在等待来自本地用户的连接终止请求。 CLOSING：表示正在等待来自远程 TCP 的连接终止请求确认。 LAST-ACK：表示等待先前发送给远程 TCP 的连接终止请求的确认（其中包括其连接终止请求的确认）。 TIME-WAIT：表示等待足够的时间以确保远程 TCP 接收到其连接终止请求的确认。 CLOSED：表示根本没有连接状态。 123456789101112131415//! \\brief Official state names from the [TCP](\\ref rfc::rfc793) specification enum class State &#123; LISTEN = 0, //!&lt; Listening for a peer to connect SYN_RCVD, //!&lt; Got the peer&#x27;s SYN SYN_SENT, //!&lt; Sent a SYN to initiate a connection ESTABLISHED, //!&lt; Three-way handshake complete CLOSE_WAIT, //!&lt; Remote side has sent a FIN, connection is half-open LAST_ACK, //!&lt; Local side sent a FIN from CLOSE_WAIT, waiting for ACK FIN_WAIT_1, //!&lt; Sent a FIN to the remote side, not yet ACK&#x27;d FIN_WAIT_2, //!&lt; Received an ACK for previously-sent FIN CLOSING, //!&lt; Received a FIN just after we sent one TIME_WAIT, //!&lt; Both sides have sent FIN and ACK&#x27;d, waiting for 2 MSL CLOSED, //!&lt; A connection that has terminated normally RESET, //!&lt; A connection that terminated abnormally &#125;; TCPState 是一个枚举类型，表示 TCP 连接可能存在的不同状态。它有十一个可能的状态： LISTEN：TCP 正在等待来自任何远程 TCP 和端口的连接请求。 SYN_RCVD：已经接收到来自远程 TCP 的连接请求，TCP 正在等待确认连接请求的确认。 SYN_SENT：TCP 已经发送了连接请求，正在等待来自远程 TCP 的连接请求确认。 ESTABLISHED：TCP 与远程 TCP 建立了打开连接，可以发送和接收数据。 CLOSE_WAIT：远程 TCP 已经启动了连接的关闭，TCP 正在等待本地应用程序关闭连接。 LAST_ACK：TCP 已经启动了连接的关闭并发送了 FIN，正在等待远程 TCP 确认 FIN。 FIN_WAIT_1：TCP 已经启动了连接的关闭并发送了 FIN，正在等待远程 TCP 的连接终止请求，或等待远程 TCP 对 FIN 的确认。 FIN_WAIT_2：TCP 已经收到来自远程 TCP 的连接终止请求的确认，并正在等待远程 TCP 的连接终止请求。 CLOSING：TCP 已经发送了 FIN 并收到了远程 TCP 的连接终止请求的确认，但同时也收到了来自远程 TCP 的 FIN 并正在等待其 FIN 的确认。 TIME_WAIT：TCP 已经发送了 FIN 并收到了来自远程 TCP 的连接终止请求的确认，正在等待一段时间（2 * MSL），然后最终关闭连接。 CLOSED：TCP 连接已经正常关闭，不能再发送或接收任何数据。 RESET：由于收到重置，TCP 连接已经异常终止。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758TCPState::TCPState(const TCPState::State state) &#123; switch (state) &#123; case TCPState::State::LISTEN: _receiver = TCPReceiverStateSummary::LISTEN; _sender = TCPSenderStateSummary::CLOSED; break; case TCPState::State::SYN_RCVD: _receiver = TCPReceiverStateSummary::SYN_RECV; _sender = TCPSenderStateSummary::SYN_SENT; break; case TCPState::State::SYN_SENT: _receiver = TCPReceiverStateSummary::LISTEN; _sender = TCPSenderStateSummary::SYN_SENT; break; case TCPState::State::ESTABLISHED: _receiver = TCPReceiverStateSummary::SYN_RECV; _sender = TCPSenderStateSummary::SYN_ACKED; break; case TCPState::State::CLOSE_WAIT: _receiver = TCPReceiverStateSummary::FIN_RECV; _sender = TCPSenderStateSummary::SYN_ACKED; _linger_after_streams_finish = false; break; case TCPState::State::LAST_ACK: _receiver = TCPReceiverStateSummary::FIN_RECV; _sender = TCPSenderStateSummary::FIN_SENT; _linger_after_streams_finish = false; break; case TCPState::State::CLOSING: _receiver = TCPReceiverStateSummary::FIN_RECV; _sender = TCPSenderStateSummary::FIN_SENT; break; case TCPState::State::FIN_WAIT_1: _receiver = TCPReceiverStateSummary::SYN_RECV; _sender = TCPSenderStateSummary::FIN_SENT; break; case TCPState::State::FIN_WAIT_2: _receiver = TCPReceiverStateSummary::SYN_RECV; _sender = TCPSenderStateSummary::FIN_ACKED; break; case TCPState::State::TIME_WAIT: _receiver = TCPReceiverStateSummary::FIN_RECV; _sender = TCPSenderStateSummary::FIN_ACKED; break; case TCPState::State::RESET: _receiver = TCPReceiverStateSummary::ERROR; _sender = TCPSenderStateSummary::ERROR; _linger_after_streams_finish = false; _active = false; break; case TCPState::State::CLOSED: _receiver = TCPReceiverStateSummary::FIN_RECV; _sender = TCPSenderStateSummary::FIN_ACKED; _linger_after_streams_finish = false; _active = false; break; &#125;&#125; 上面的函数是一个 switch 语句，将每个 TCPState 值映射到相应的 TCPReceiverStateSummary 和 TCPSenderStateSummary 值。这两种类型分别表示 TCP 接收器和发送器的摘要状态，用于向应用程序报告 TCP 连接的当前状态。根据 TCPState 值，switch 语句将适当的值分配给 TCPConnection 对象的 _receiver、_sender、_linger_after_streams_finish 和 _active 成员变量。 根据不同的TCP状态转换，更新TCP发送方和接收方的状态，并做出相应的操作。具体来说，这段代码将TCP状态转换成TCP发送方和接收方的状态，转换逻辑如下： LISTEN状态：TCP接收方进入 LISTEN 状态，TCP发送方进入 CLOSED 状态。 SYN_RCVD状态：TCP接收方进入 SYN_RECV 状态，TCP发送方进入 SYN_SENT 状态。 SYN_SENT状态：TCP接收方进入 LISTEN 状态，TCP发送方继续保持在 SYN_SENT 状态。 ESTABLISHED状态：TCP接收方进入 SYN_RECV 状态，TCP发送方进入 SYN_ACKED 状态。 CLOSE_WAIT状态：TCP接收方进入 FIN_RECV 状态，TCP发送方进入 SYN_ACKED 状态，设置 _linger_after_streams_finish 为 false。 LAST_ACK状态：TCP接收方进入 FIN_RECV 状态，TCP发送方进入 FIN_SENT 状态，设置 _linger_after_streams_finish 为 false。 CLOSING状态：TCP接收方进入 FIN_RECV 状态，TCP发送方进入 FIN_SENT 状态。 FIN_WAIT_1状态：TCP接收方进入 SYN_RECV 状态，TCP发送方进入 FIN_SENT 状态。 FIN_WAIT_2状态：TCP接收方进入 SYN_RECV 状态，TCP发送方进入 FIN_ACKED 状态。 TIME_WAIT状态：TCP接收方进入 FIN_RECV 状态，TCP发送方进入 FIN_ACKED 状态。 RESET状态：TCP接收方和TCP发送方进入 ERROR 状态，设置_linger_after_streams_finish为false ，设置 _active 为 false。 CLOSED状态：TCP接收方进入 FIN_RECV 状态，TCP发送方进入 FIN_ACKED 状态，设 置 _linger_after_streams_finish 为false，设置 _active 为 false。 需要注意的是，这段代码并未包含所有可能的TCP状态转换，可能还有其他的状态转换情况需要另行处理。 TCP 握手挥手 https://www.misaka-9982.com/2022/03/04/Wireshark-Lab5/ TCP三次握手的流程和状态转换 TCP三次握手是在建立TCP连接时使用的一种协议，其流程和状态转换如下： 客户端向服务器发送SYN包，表示客户端请求建立连接。 服务器接收到SYN包，回复客户端一个SYN+ACK包，表示服务器确认收到了客户端的请求，并请求建立连接。 客户端收到服务器的SYN+ACK包，发送一个ACK包给服务器，表示客户端确认收到了服务器的确认，并建立连接。 这个过程中，客户端和服务器之间的状态转换如下： 客户端从CLOSED状态转换到SYN-SENT状态，表示客户端已经向服务器发送了一个SYN包，等待服务器的响应。 服务器从LISTEN状态转换到SYN-RECEIVED状态，表示服务器已经收到了客户端的SYN包，并回复了SYN+ACK包，等待客户端的确认。 客户端从SYN-SENT状态转换到ESTABLISHED状态，表示客户端已经收到了服务器的SYN+ACK包，并发送了确认ACK包，连接建立成功。 服务器从SYN-RECEIVED状态转换到ESTABLISHED状态，表示服务器已经收到了客户端的ACK包，连接建立成功。 在TCP三次握手过程中，通过交换SYN和ACK包来确认连接的建立，确保客户端和服务器之间建立的连接是可靠的。这个过程中，如果任何一个包丢失或者延迟，都会导致连接建立失败，因此TCP协议是一种可靠的面向连接的协议。 TCP四次挥手的流程和状态转换 TCP四次挥手是在关闭TCP连接时使用的一种协议，其流程和状态转换如下： 主动关闭方（可以是客户端或服务器）发送一个FIN包给被动关闭方（对方），表示主动关闭方想要关闭连接，进入FIN-WAIT-1状态。 被动关闭方接收到主动关闭方的FIN包，回复一个ACK包进行确认，表示已经收到了主动关闭方的请求，进入CLOSE-WAIT状态。 被动关闭方发送一个FIN包给主动关闭方，表示对方也想要关闭连接，进入LAST-ACK状态。 主动关闭方接收到被动关闭方的FIN包，回复一个ACK包进行确认，表示主动关闭方已经收到了被动关闭方的请求，进入TIME-WAIT状态。 经过一段时间后，主动关闭方退出TIME-WAIT状态，连接彻底关闭。 这个过程中，主动关闭方和被动关闭方之间的状态转换如下： 主动关闭方从ESTABLISHED状态转换到FIN-WAIT-1状态，表示主动关闭方已经发送了一个FIN包，等待被动关闭方的确认。 被动关闭方从ESTABLISHED状态转换到CLOSE-WAIT状态，表示被动关闭方已经接收到主动关闭方的FIN包，并发送了一个ACK包进行确认。 被动关闭方从CLOSE-WAIT状态转换到LAST-ACK状态，表示被动关闭方也想要关闭连接，发送了一个FIN包给主动关闭方。 主动关闭方从FIN-WAIT-1状态转换到FIN-WAIT-2状态，表示主动关闭方已经收到了被动关闭方的ACK包，并等待被动关闭方的FIN包。 主动关闭方从FIN-WAIT-2状态转换到TIME-WAIT状态，表示主动关闭方已经收到了被动关闭方的FIN包，并发送了一个ACK包进行确认，等待一段时间（2倍的MSL，最长报文段寿命）以确保对方已经接收到ACK包。 被动关闭方从LAST-ACK状态转换到CLOSED状态，表示被动关闭方已经收到了主动关闭方的ACK包，并关闭连接。 在TCP四次挥手过程中，主动关闭方和被动关闭方之间通过交换FIN和ACK包来关闭连接，确保连接关闭的可靠性。这个过程中，如果任何一个包丢失或者延迟，都会导致连接关闭失败，因此TCP协议是一种可靠的面向连接的协议。 TCPConnection 代码解读 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//! \\brief A complete endpoint of a TCP connectionclass TCPConnection &#123; private: TCPConfig _cfg; TCPReceiver _receiver&#123;_cfg.recv_capacity&#125;; TCPSender _sender&#123;_cfg.send_capacity, _cfg.rt_timeout, _cfg.fixed_isn&#125;; //! outbound queue of segments that the TCPConnection wants sent std::queue&lt;TCPSegment&gt; _segments_out&#123;&#125;; //! Should the TCPConnection stay active (and keep ACKing) //! for 10 * _cfg.rt_timeout milliseconds after both streams have ended, //! in case the remote TCPConnection doesn&#x27;t know we&#x27;ve received its whole stream? bool _linger_after_streams_finish&#123;true&#125;; size_t _last_seg_time&#123;0&#125;; size_t _curr_seg_time&#123;0&#125;; public: //! \\name &quot;Input&quot; interface for the writer //!@&#123; //! \\brief Initiate a connection by sending a SYN segment void connect(); //! \\brief Write data to the outbound byte stream, and send it over TCP if possible //! \\returns the number of bytes from `data` that were actually written. size_t write(const std::string &amp;data); //! \\returns the number of `bytes` that can be written right now. size_t remaining_outbound_capacity() const; //! \\brief Shut down the outbound byte stream (still allows reading incoming data) void end_input_stream(); //!@&#125; //! \\name &quot;Output&quot; interface for the reader //!@&#123; //! \\brief The inbound byte stream received from the peer ByteStream &amp;inbound_stream() &#123; return _receiver.stream_out(); &#125; //!@&#125; //! \\name Accessors used for testing //!@&#123; //! \\brief number of bytes sent and not yet acknowledged, counting SYN/FIN each as one byte size_t bytes_in_flight() const; //! \\brief number of bytes not yet reassembled size_t unassembled_bytes() const; //! \\brief Number of milliseconds since the last segment was received size_t time_since_last_segment_received() const; //!&lt; \\brief summarize the state of the sender, receiver, and the connection TCPState state() const &#123; return &#123;_sender, _receiver, active(), _linger_after_streams_finish&#125;; &#125;; //!@&#125; //! \\name Methods for the owner or operating system to call //!@&#123; //! Called when a new segment has been received from the network void segment_received(const TCPSegment &amp;seg); //! Called periodically when time elapses void tick(const size_t ms_since_last_tick); void send_segment(); //! \\brief TCPSegments that the TCPConnection has enqueued for transmission. //! \\note The owner or operating system will dequeue these and //! put each one into the payload of a lower-layer datagram (usually Internet datagrams (IP), //! but could also be user datagrams (UDP) or any other kind). std::queue&lt;TCPSegment&gt; &amp;segments_out() &#123; return _segments_out; &#125; //! \\brief Is the connection still alive in any way? //! \\returns `true` if either stream is still running or if the TCPConnection is lingering //! after both streams have finished (e.g. to ACK retransmissions from the peer) bool active() const; //!@&#125; //! Construct a new connection from a configuration explicit TCPConnection(const TCPConfig &amp;cfg) : _cfg&#123;cfg&#125; &#123;&#125; //! \\name construction and destruction //! moving is allowed; copying is disallowed; default construction not possible //!@&#123; ~TCPConnection(); //!&lt; destructor sends a RST if the connection is still open TCPConnection() = delete; TCPConnection(TCPConnection &amp;&amp;other) = default; TCPConnection &amp;operator=(TCPConnection &amp;&amp;other) = default; TCPConnection(const TCPConnection &amp;other) = delete; TCPConnection &amp;operator=(const TCPConnection &amp;other) = delete; //!@&#125;&#125;; TCPConnection是一个类，用于表示 TCP 连接。它作为一个连接的一方(端点或对等方)，负责接收和发送数据段，确保发送方和接收方被告知并有机会对它们关心的传入和传出段的字段进行贡献。 具体来说，TCPConnection的主要功能包括： 接收来自互联网的 TCPSegment，并将其交给 TCPReceiver 进行处理，以检查它所关心的传入段的字段。 将每个传出段的字段设置为合适的值(由 TCPSender 确定)，并将其放入出站队列(_segments_out)中以便发送。 向 TCPSender 询问传出段的字段，特别是 ackno 和 window_size，以便构造传出段。 处理连接范围内的一些难以轻易融入发送方和接收方的微妙问题，比如如何终止连接并宣布它不再是“活动的”。 综上所述，TCPConnection的功能是将 TCPSender 和 TCPReceiver 中的例程与连接的公共 API 进行连接，以创建一个完整的 TCP 连接。 1234567891011121314151617void TCPConnection::send_segment() &#123; while (!_sender.segments_out().empty()) &#123; TCPSegment seg = _sender.segments_out().front(); _sender.segments_out().pop(); if (_receiver.ackno().has_value()) &#123; seg.header().ack = true; seg.header().ackno = _receiver.ackno().value(); &#125; seg.header().win = static_cast&lt;uint16_t&gt;( min(_receiver.window_size(), static_cast&lt;size_t&gt;(numeric_limits&lt;uint16_t&gt;::max())) ); _segments_out.push(seg); &#125;&#125; send_segment()，它的作用是将传出队列中的段发送出去。在发送之前，它会检查接收方是否有等待确认的段，以及接收窗口的大小。 具体来说，这段代码会从发送队列的前面取出一个段。如果接收方等待确认，它会将ack标志和确认号(ackno)设置为对应的值。然后，它将窗口大小(win)设置为接收方的窗口大小，但不会超过16位无符号整数的最大值。最后，它将段添加到传输队列中，准备发送。这个方法会循环执行，直到传输队列为空。 1234567891011121314151617181920212223242526272829303132bool TCPConnection::active() const &#123; // unclean shutdown if (_sender.stream_in().error() || _receiver.stream_out().error()) &#123; return false; &#125; auto ended = _receiver.stream_out().input_ended(); auto eof = _sender.stream_in().eof(); auto eq2 = _sender.next_seqno_absolute() == _sender.stream_in().bytes_written() + 2; auto no_flight = _sender.bytes_in_flight() == 0; auto checked = ended &amp;&amp; eof &amp;&amp; eq2 &amp;&amp; no_flight; // clean shut down if (!_linger_after_streams_finish) &#123; // # 1 ~ # 3 satisfied -&gt;connection done if (checked) &#123; return false; &#125; return true; &#125; if (checked) &#123; if (time_since_last_segment_received() &lt; 10 * _cfg.rt_timeout) &#123; return true; &#125; return false; &#125; return true;&#125; 这段代码定义了一个TCP连接的状态，通过判断发送方和接收方的状态，以及数据传输的进度来确定连接是否处于激活状态。 active()函数首先检查连接是否存在异常关闭情况，即发送流或接收流是否有错误，如果有则返回false，表示连接不再激活。 如果连接没有异常关闭，它将检查发送方和接收方的状态以及数据传输的进度。如果这些条件都满足，它将返回false，否则返回true，表示连接仍然激活。在这个实现中，一个TCP连接被认为是&quot;激活&quot;的条件是： 接收流中没有未接收的数据，也没有接收流的错误（即没有未处理的数据或错误） 发送流中已经写入了EOF 发送方已经发送了所有数据，并且等待所有数据的确认，确认号为发送方写入的字节数+2（因为SYN和FIN标志也算在字节数中） 如果连接设置了 linger_after_streams_finish 标志，则还需要进行以下检查： 上述3个条件都满足 最近接收到的段距离当前时间不超过10倍的重传超时时间，否则返回false，表示连接不再激活 12345678910111213141516171819//! \\param[in] ms_since_last_tick number of milliseconds since the last call to this methodvoid TCPConnection::tick(const size_t ms_since_last_tick) &#123; _curr_seg_time += ms_since_last_tick; _sender.tick(ms_since_last_tick); send_segment(); if (_sender.consecutive_retransmissions() &gt; TCPConfig::MAX_RETX_ATTEMPTS) &#123; // abort the connnection _sender.send_empty_rst(); _sender.stream_in().set_error(); _receiver.stream_out().set_error(); &#125; // syn received else if (_receiver.ackno().has_value()) &#123; _sender.fill_window(); &#125; send_segment();&#125; 这段代码是 TCPConnection 类中的 tick() 函数，用于模拟 TCP 连接的运行过程。具体而言，函数接收一个时间差（ms_since_last_tick），并根据这个时间差更新当前已经经过的时间和发送方的状态，并尝试发送 TCP 报文。 在函数的开头，代码会将时间差累加到当前已经经过的时间（_curr_seg_time）中，然后调用 _sender.tick() 函数更新发送方的状态，再调用 send_segment() 函数尝试发送 TCP 报文。 接下来，如果发送方连续重传的次数超过了最大重传次数（TCPConfig::MAX_RETX_ATTEMPTS），就会终止连接。如果接收方收到了 SYN 报文（即连接已经建立），就会调用 _sender.fill_window() 函数来填充发送窗口，并调用 send_segment() 尝试发送 TCP 报文。 最后再次调用 send_segment() 函数，以确保已经生成的 TCP 报文都已经被发送。 12345678910111213141516171819202122232425262728293031323334void TCPConnection::segment_received(const TCPSegment &amp;seg) &#123; // Unclean shutdown of TCPConnection if (seg.header().rst) &#123; _sender.stream_in().set_error(); _receiver.stream_out().set_error(); return; &#125; // normal routine _last_seg_time = _curr_seg_time; _receiver.segment_received(seg); if (seg.header().ack) &#123; _sender.ack_received(seg.header().ackno, seg.header().win); &#125; // syn received if (_receiver.ackno().has_value()) &#123; send_segment(); _sender.fill_window(); // at least one segment is sent in reply if (seg.length_in_sequence_space() &amp;&amp; _sender.segments_out().empty()) &#123; _sender.send_empty_ack(); &#125; send_segment(); if (_receiver.stream_out().input_ended() &amp;&amp; !_sender.stream_in().eof()) &#123; _linger_after_streams_finish = false; &#125; &#125;&#125; 这段代码处理接收到的TCP段（segment）。当接收到的段被传递到此方法时，代码将首先检查段是否包含RST标志，如果是，则TCP连接出现异常关闭。如果不是，则代码将处理TCP连接的正常过程。 如果此段包含ACK标志，则代码将调用 _sender.ack_received 方法来处理确认。如果 _receiver.ackno 返回值已设置，则表示已接收到SYN，代码将调用 send_segment 方法来发送数据段。 _sender.fill_window 方法将填充发送方窗口，以便在空闲时发送更多数据段。如果发送一个回复，但此时发送方没有待发送的段，则还会发送一个空的ACK段以确认该回复。此外，如果接收方流已结束但发送方流未结束，则 _linger_after_streams_finish 将设置为false，以指示连接可以正常关闭。 总之，此方法的目的是根据接收到的TCP段执行必要的操作以保持TCP连接的状态。 1234567891011121314151617181920212223242526272829303132333435void get_URL(const string &amp;host, const string &amp;path) &#123; // Your code here. // You will need to connect to the &quot;http&quot; service on // the computer whose name is in the &quot;host&quot; string, // then request the URL path given in the &quot;path&quot; string. // GET /hello HTTP/1.1 // Host: cs144.keithw.org // Connection: close Address address(host, &quot;http&quot;); // TCPSocket socket; CS144TCPSocket socket&#123;&#125;; socket.connect(address); socket.write(&quot;GET &quot; + path + &quot; HTTP/1.1\\r\\n&quot;); socket.write(&quot;Host: &quot; + host + &quot;\\r\\n&quot;); socket.write(&quot;\\r\\n&quot;); socket.shutdown(SHUT_WR); // Then you&#x27;ll need to print out everything the server sends back, // (not just one call to read() -- everything) until you reach // the &quot;eof&quot; (end of file). while (!socket.eof()) &#123; cout &lt;&lt; socket.read(1); &#125; socket.close(); socket.wait_until_closed(); // cerr &lt;&lt; &quot;Function called: get_URL(&quot; &lt;&lt; host &lt;&lt; &quot;, &quot; &lt;&lt; path &lt;&lt; &quot;).\\n&quot;; // cerr &lt;&lt; &quot;Warning: get_URL() has not been implemented yet.\\n&quot;;&#125; 性能测试 123$ ./apps/tcp_benchmarkCPU-limited throughput : 12.56 Gbit/sCPU-limited throughput with reordering: 11.36 Gbit/s 完整代码 tcp_connection.hh tcp_connection.cc","categories":[],"tags":[{"name":"CS144","slug":"CS144","permalink":"http://www.misaka-9982.com/tags/CS144/"},{"name":"Network","slug":"Network","permalink":"http://www.misaka-9982.com/tags/Network/"}]},{"title":"CS144-Lab3","slug":"CS144-Lab3","date":"2023-02-18T16:01:53.000Z","updated":"2023-02-19T02:56:17.711Z","comments":true,"path":"2023/02/19/CS144-Lab3/","link":"","permalink":"http://www.misaka-9982.com/2023/02/19/CS144-Lab3/","excerpt":"","text":"概述 在实验0中，你实现了流控制字节流（ByteStream）的抽象。 在实验1和2中，你实现了将不可靠数据报中的段转换为传入字节流的工具：StreamReassembler和TCPReceiver。 现在，在实验3中，你将实现连接的另一端：一个将出站字节流转换为不可靠数据报中发送段的工具。 最后，在第4个实验中，你将结合前几个实验的工作，创建一个工作的TCP实现：TCPConnection，其中包含TCPSender和TCPReceiver。你将用它来与世界各地的真实服务器进行对话。 开始 你对TCPSender的实现将使用与你在实验0-2中使用的相同的Sponge库，并有额外的类和测试。为了开始进行作业： 请确保你已经提交了你在实验2中的所有解决方案。请不要修改libsponge目录顶层以外的任何文件，或者webget.cc。否则，你可能会在合并实验3的启动代码时遇到麻烦。 在实验作业的存储库中，运行git fetch来检索实验作业的最新版本。 通过运行git merge origin/lab3-startercode，下载实验3的启动代码。 在build目录中，编译源代码：make（编译时可以运行make -j4以使用四个处理器）。 在build目录外，打开并开始编辑writeups/lab3.md文件。这是你实验报告的模板，将包含在你提交的内容中。 实验3：TCP发送方 TCP是一个协议，通过不可靠的数据报可靠地传输一对流量控制字节流（每个方向一个）。双方参与TCP连接，并且每一方同时充当“发送方”（其自身的传出字节流）和“接收方”（传入字节流）。双方被称为连接的“端点”或“对等点”。 本周，你将实现TCP的“发送方”部分，负责读取ByTestStream（由某些发送方应用程序创建并写入），并将流转换为一系列传出TCP段。在远程端，TCP接收方（重要的是要记住，接收方可以是有效TCP接收方的任何实现，而不一定是你自己的TCPReceiver。互联网标准最有价值的一点是，它们在端点之间建立一种通用语言，否则（指的是没有通用语言的情况），这些端点的行为可能会非常不同。）将这些段（那些到达的段，它们不一定都能到达）转换回原始字节流，并将确认和窗口发送回发送方。 TCPSender将负责： 跟踪接收方的窗口（处理传入的确认号（ackno）和窗口大小（window size）） ； 尽可能通过读取ByTestStream、创建新的TCP段（包括SYN和FIN标志，如果需要），填充窗口，并发送它们； 跟踪哪些段已经发送但尚未被接收方确认——我们称之为“未完成的”段； 如果发送后经过足够的时间但尚未确认，则重新发送未完成的段； 为什么要这样做？基本原则是发送接收方允许我们发送的任何内容（填充窗口），并不断重传，直到接收方确认每段内容，这称为“自动重复请求”（ARQ）。发送方将字节流分成若干段，并在接收方窗口允许的范围内发送它们。感谢你上周的工作，我们知道，只要远程TCP接收方至少收到一次带有索引标记的字节，就可以重构字节流，而无论其顺序如何。发送方的工作是确保接收方至少获得每个字节一次。 TCPSender 应在何时断定某个段丢失并再次发送？ 你的 TCPSender 将发送一组 TCPSegments。每个将包含来自传出 ByTestStream 的一个子字符串（可能为空），用序列号索引以指示其在流中的位置，并在流的开头用 SYN 标志标记，在流的结尾用 FIN 标志标记。 除了发送这些段外，TCPSender 还必须跟踪其未完成的段，直到它们占用的序列号被完全确认。TCPSender 的所有者将定期调用 TCPSender 的 tick 方法，以指示时间的流逝。TCPSender 负责查看其未完成的 TCPSegments 集合，并确定最早的已发送的段是否在未完成的情况下因为时间过长而未被确认（即，未确认其所有序列号）。如果是，则需要重新传输（再次发送）。 以下是“由于太长时间未完成”的含义规则。（这些是基于 TCP “真实”规则的简化版本：RFC 6298，建议5.1至5.6。这里的版本有点简化，但是你的TCP实现仍然能够与Internet上的真实服务器进行通信。）你将要实现的逻辑非常详细，但我们不希望你担心隐藏的测试用例试图绊倒你，或将其视为 SAT上的文字问题。本周我们将为你提供一些合理的单元测试，完成整个 TCP 实现后，在实验4中进行更全面的集成测试。只要你100%通过了这些测试，并且你的实现是合理的，就没事了。 为什么要这样做？总的目标是让发送方及时检测到段丢失并需要重新发送的情况。重发前的等待时间是很重要的：你不希望发送方等待太长的时间来重发一个网段（因为这会延迟流向接收应用程序的字节），但你也不希望它重新发送一段如果发送方再等一段时间就会被确认的信息，这会浪费互联网的宝贵容量。 每隔几毫秒，你的 TCPSender 的 tick 方法就会被调用一次，它的参数是告诉你自上次调用该方法以来已经过了多少毫秒。使用参数可以维护 TCPSender已激活的总毫秒数的概念。请不要试图从操作系统或CPU调用任何“time”或“clock”函数——tick方法是你唯一访问时间流逝的方法。这样可以保持事物的确定性和可测试性。 当构建TCPSender时，会给它一个参数，告诉它**重传超时（retransmission timeout, RTO）**的“初始值”。RTO是在重新发送一个未完成的TCP段之前要等待的毫秒数。RTO的值会随时间变化，但“初始值”保持不变。启动代码将RTO的“初始值”保存在一个名为 _initial_retransmission_timeout 的成员变量中。 你将实现重传计时器timer：一个可以在某个时间启动的警报，一旦RTO过期，警报就会熄灭（或”过期”）。我们强调，这种时间流逝的概念来自于被调用的tick方法，而不是通过获取一天中的实际时间。 每次发送包含数据（在序列空间中长度非零）的段（不管是第一次还是重传），如果 timer 没有运行，就启动它，使它在RTO毫秒后失效（对于RTO的当前值）。 当所有未完成的数据都被确认后，关闭重传计时器。 如果 tick 被调用，并且重传计时器已经过期： (a) 重传TCP接收方尚未完全确认的最早（最低序列号）段。你需要在一些内部数据结构中存储未发送的段，以便能够做到这一点。 (b) 如果窗口大小为非零： i. 跟踪连续重新传输的次数，并增加它，因为你刚刚重新传输了一些内容。你的TCPConnection将使用这些信息来决定连接是否无望（连续重传次数过多）并需要中止。 ii. 将RTO的值增加一倍。（这被称为“指数回退”——它会减慢糟糕网络上的重传速度，以避免进一步堵塞工作。我们将在稍后的课堂上了解更多有关这方面的内容。） © 启动重传timer，使其在RTO毫秒后过期（对于前一个要点中概述的加倍操作后的RTO值）。 当接收方给发送方确认成功接收新数据的ackno时（该ackno反映了一个大于之前的任何ackno的绝对序列号）。 (a) 将RTO调回其“初始值”。 (b) 如果发送方有任何未完成的数据，重新启动重传timer，使其在RTO毫秒后失效（对于RTO的当前值）。 © 将“连续重传”的计数重设为零。 你可能希望在单独的类中实现重传计时器的功能，这取决于你自己。如果需要，请将其添加到现有文件（tcp_sender.hh和tcp_receiver.hh）。 实现TCP发送方 Ok！我们已经讨论了TCP发送方所做的基本概念（给定一个传出的ByteStream，把它分割成若干段，发送给接收者，如果它们没有很快得到确认，就继续重新发送）。我们还讨论了何时得出结论：未完成的段已经丢失，需要重新发送。 现在是你的TCPSender将提供的具体接口的时候了。有四个重要的事件需要它来处理，每一个事件都可能最终发送一个TCPSegment： fill_window：TCPSender被要求填充窗口：它从其输入的ByteStream中读取并以TCPSegments的形式发送尽可能多的字节，只要窗口中有新的字节要读取和可用空间。你要确保你发送的每一个TCPSegment都能完全放入接收方的窗口中。使每个单独的TCPSegment尽可能大，但不能大于TCPConfig::MAX_PAYLOAD_SIZE（1452字节）所给的值。你可以使用TCPSegment::length_in_sequence_space()方法来计算一个段所占用的序列号的总数。你的TCPSender维护着一个名为_next_seqn的成员变量，它存储着从零开始的发送的绝对序列号。对于你发送的每一个段，你都要让_next_seqno增加段的长度，以便知道下一段的序列号。 ack_received：从接收方收到一个确认信息，包括窗口的左边缘（= ackno）和右边缘（= ackno + window size）。TCPSender应该查看其未完成的段的集合，并删除任何现在已被完全确认的段（ackno大于该段中的所有序列号）。如果打开了新空间（指窗口变大），TCPSender可能需要再次填充窗口。如果ackno无效，即确认发送方尚未发送的数据，则此方法返回false。 tick：经过的时间；TCPSender将检查重传计时器是否已过期，如果是，则以最低的序列号重传未发送的段。（重要的是，重新传输的决定不必看接收方的窗口：该段在第一次发送时落在窗口内，并且尚未确认，因此现在仍在接收方的窗口内。接收方不应该“收缩”窗口的右边缘，你可以假设右边缘始终保持不变或向右移动。） send_empty_segment：TCPSender应该生成并发送一个在序列空间中长度为零的TCPSegment，并将序列号正确设置为_next_seqno。如果所有者（你下周要实现的TCPConnection）想发送一个空的ACK段，这很有用。这种段（不携带数据，不占用序列号）不需要作为”未完成”来跟踪，也不会被重传。 为了完成实验3，请查看文档中的完整接口，网址是https://cs144.github.io/doc/lab3/class_t_c_p_sender.html，并在tcp_sender.hh和tcp_sender.cc文件中实现完整的TCPSender公共接口。我们预计你会想添加私有方法和成员变量，可能还有一个辅助类。 常见问题和特殊情况 如何“发送”一个片段？ 把它push到_segments_out队列中。就你的TCPSender而言，当你把它push到这个队列时，就认为它已经发送了。很快，所有者就会出现并pop它（使用公共的segments_out()访问器方法），并真正发送它。 等等，我如何既“发送”一段，又将同一段记录为未完成，以便我知道以后重新传输什么？那我不是要给每个网段做一个副本吗？这是不是很浪费？ 当你发送一个包含数据的段时，你可能想把它push到_segments_out队列中，同时在内部的数据结构中保留一个副本，让你跟踪未完成的网段，以便可能的重传。这并不是很浪费，因为段的有效载荷被存储为引用计数的只读字符串（一个Buffer对象）。所以不用担心，它实际上并没有复制有效载荷数据。 在我从接收方得到ACK之前，我的TCPSender应该假定接收方的窗口大小是多少？ 一个字节。 接收方告诉我它的窗口大小是零字节。我是否应该被卡住，不再发送任何数据？ 否。如果接收方告诉你它的窗口长度是零字节，请将该信息保存为任何其他窗口使用（advertisement），因为它对3.1中描述的重传行为很重要。但当需要填充窗口时，请将窗口大小设置为一个字节。这被称为“零窗口探测”——这是一种定期探测接收方的方式，看看自从我们上次听到他们的消息后，他们是否碰巧在窗口中开辟了一些更多的空间。最坏的情况是，接收方会忽略你的一个字节段。（在一个更适合生产的TCP实现中，零窗口探测行为会更复杂一些，但也不会过于复杂。） 如果确认仅部分确认某些未完成的部分，我该怎么办？我是否应该尝试删除已确认的字节？ TCP发送方可以这样做，但就课程而言，没有必要搞得太复杂。在完全确认之前，将每个段视为完全未完成——它所占用的所有序列号都小于ackno。 如果我发送了三个包含 “a”、”b “和 “c “的独立段，但它们从未被确认，我可以在以后将它们重新传送到一个包含 “abc “的大段吗？还是我必须单独重发每个段？ 再说一遍：TCP发送方可以做到这一点，但就本课程而言，没有必要搞得太花哨。只要单独跟踪每个未处理的段，当重传计时器到期时，再次发送最早的未处理段。 我应该在“未处理”数据结构中存储空段，并在必要时重发它们吗？ 不，只有那些传递一些数据的网段（即在序列空间中消耗一些长度的网段）才应该被追踪为未完成的网段，并可能被重传。一个空的ACK不需要被记住，也不需要被重传。 如果这个PDF出来后还有更多的FAQ，我在哪里可以看到？ 请定期查看网站（https://cs144.github.io/lab_faq.html）和Piazza。 RTO Timer RFC6298 12345678910111213141516171819202122class RetransmissionTimer &#123; private: long long _time_rest; bool _on_off; public: RetransmissionTimer(uint RTO = 0) : _time_rest(RTO), _on_off(false) &#123;&#125; void reset(uint RTO) &#123; _on_off = true; _time_rest = RTO; &#125; bool passing(const size_t ms_since_last_tick) &#123; _time_rest -= ms_since_last_tick; return _on_off &amp;&amp; (_time_rest &lt;= 0); &#125; bool activated() const &#123; return _on_off; &#125; void stop() &#123; _on_off = false; &#125;&#125;; 这段代码定义了一个重传定时器类 RetransmissionTimer，用于在 TCP 协议中进行超时重传。该类具有以下成员变量和成员函数： _time_rest：表示当前定时器剩余的时间（以毫秒为单位），默认为0。 _on_off：表示当前定时器是否处于开启状态，默认为关闭状态。 RetransmissionTimer 构造函数：可以传入一个可选的 RTO（重传超时）值作为参数，用于初始化 _time_rest 和 _on_off。 reset 成员函数：用于重新设置定时器的状态，将 _on_off 置为 true，将 _time_rest 设置为 RTO 的值。 passing 成员函数：接受一个时间间隔 ms_since_last_tick 的参数，表示距离上一次定时器计时已经过去了多少毫秒。函数首先将 _time_rest 减去这个时间间隔，然后返回 _on_off &amp;&amp; (_time_rest &lt;= 0) 的结果。如果定时器开启且剩余时间小于等于 0，则表示定时器已经超时，函数返回 true。 activated 成员函数：返回定时器是否处于开启状态。 stop 成员函数：将定时器关闭，将 _on_off 置为 false。 TCPSender TCPSender的状态转移 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//! Accepts a ByteStream, divides it up into segments and sends the//! segments, keeps track of which segments are still in-flight,//! maintains the Retransmission Timer, and retransmits in-flight//! segments if the retransmission timer expires.class TCPSender &#123; private: //! our initial sequence number, the number for our SYN. WrappingInt32 _isn; //! outbound queue of segments that the TCPSender wants sent std::queue&lt;TCPSegment&gt; _segments_out&#123;&#125;; //! retransmission timer for the connection unsigned int _initial_retransmission_timeout; //! outgoing stream of bytes that have not yet been sent ByteStream _stream; //! the (absolute) sequence number for the next byte to be sent uint64_t _next_seqno&#123;0&#125;; uint _consecutive_retransmission_count&#123;0&#125;; uint _retransmission_timeout; RetransmissionTimer _timer; size_t _window_size; size_t _bytes_in_flight; enum TCPState &#123; CLOSED, SYN_SENT, SYN_ACKED, FIN_SENT, FIN_ACKED &#125;; TCPState _state&#123; CLOSED &#125;; std::queue&lt;TCPSegment&gt; _segments_in_flight; static bool segcmp(const TCPSegment &amp;seg1, const TCPSegment &amp;seg2) &#123; return seg1.header().seqno.raw_value() &gt; seg2.header().seqno.raw_value(); &#125; public: //! Initialize a TCPSender TCPSender(const size_t capacity = TCPConfig::DEFAULT_CAPACITY, const uint16_t retx_timeout = TCPConfig::TIMEOUT_DFLT, const std::optional&lt;WrappingInt32&gt; fixed_isn = &#123;&#125;); //! \\name &quot;Input&quot; interface for the writer //!@&#123; ByteStream &amp;stream_in() &#123; return _stream; &#125; const ByteStream &amp;stream_in() const &#123; return _stream; &#125; //!@&#125; //! \\name Methods that can cause the TCPSender to send a segment //!@&#123; //! \\brief A new acknowledgment was received void ack_received(const WrappingInt32 ackno, const uint16_t window_size); //! \\brief Generate an empty-payload segment (useful for creating empty ACK segments) void send_empty_ack(); void send_empty_rst(); void fill_segment(TCPSegment&amp; seg); //! \\brief create and send segments to fill as much of the window as possible void fill_window(); //! \\brief Notifies the TCPSender of the passage of time void tick(const size_t ms_since_last_tick); //!@&#125; //! \\name Accessors //!@&#123; //! \\brief How many sequence numbers are occupied by segments sent but not yet acknowledged? //! \\note count is in &quot;sequence space,&quot; i.e. SYN and FIN each count for one byte //! (see TCPSegment::length_in_sequence_space()) size_t bytes_in_flight() const; //! \\brief Number of consecutive retransmissions that have occurred in a row unsigned int consecutive_retransmissions() const; //! \\brief TCPSegments that the TCPSender has enqueued for transmission. //! \\note These must be dequeued and sent by the TCPConnection, //! which will need to fill in the fields that are set by the TCPReceiver //! (ackno and window size) before sending. std::queue&lt;TCPSegment&gt; &amp;segments_out() &#123; return _segments_out; &#125; //!@&#125; //! \\name What is the next sequence number? (used for testing) //!@&#123; //! \\brief absolute seqno for the next byte to be sent uint64_t next_seqno_absolute() const &#123; return _next_seqno; &#125; //! \\brief relative seqno for the next byte to be sent WrappingInt32 next_seqno() const &#123; return wrap(_next_seqno, _isn); &#125; //!@&#125;&#125;; 该代码定义了一个 TCPSender 类，表示 TCP 的发送端。 该类有以下成员变量： _isn：TCP 连接的初始序列号，也就是 SYN 包的序列号。 _segments_out：已经准备好的待发送的 TCP 段。 _initial_retransmission_timeout：初始的重传超时时间。 _stream：未发送的字节流。 _next_seqno：下一个待发送的字节的序列号。 _consecutive_retransmission_count：连续重传的次数。 _retransmission_timeout：当前的重传超时时间。 _timer：TCP 发送端的重传定时器。 _window_size：TCP 接收端的窗口大小。 _bytes_in_flight：已经发送但未确认的字节数。 _state：TCP 连接的状态，包括 CLOSED、SYN_SENT、SYN_ACKED、FIN_SENT 和 FIN_ACKED。 _segments_in_flight：已经发送但未确认的 TCP 段。 该类有以下成员函数： TCPSender()：构造函数。 stream_in()：获取待发送的字节流。 ack_received()：接收到 ACK 报文，更新状态信息。 send_empty_ack() 和 send_empty_rst()：发送空 ACK 和 RST 报文。 fill_window()：尽可能填充窗口并创建并发送 TCP 段。 tick()：定时器回调函数。 bytes_in_flight() 和 consecutive_retransmissions()：获取未确认的字节数和连续重传的次数。 segments_out()：获取已经准备好的待发送的 TCP 段。 next_seqno_absolute() 和 next_seqno()：获取下一个待发送字节的绝对序号和相对序号。 tick 函数 123456789101112131415161718192021222324//! \\param[in] ms_since_last_tick the number of milliseconds since the last call to this methodvoid TCPSender::tick(const size_t ms_since_last_tick) &#123; // If tick is called and the retransmission timer has expired if (_timer.activated() &amp;&amp; _timer.passing(ms_since_last_tick)) &#123; // 6. (a) TCPSegment seg = _segments_in_flight.front(); // If the window size is nonzero if (_window_size != 0) &#123; // 6. (b) i _consecutive_retransmission_count ++ ; // 6. (b) ii _retransmission_timeout *= 2; &#125; // 6. (c) if (_consecutive_retransmission_count &lt;= TCPConfig::MAX_RETX_ATTEMPTS) &#123; _segments_out.push(seg); _timer.reset(_retransmission_timeout); &#125; else &#123; _timer.stop(); &#125; &#125;&#125; 上述代码是 TCP 发送方 TCPSender 的 tick() 方法的实现。tick() 方法会在每次定时器触发时被调用，参数 ms_since_last_tick 表示自上次调用该方法以来经过的时间。 代码中的注释已经非常详细了，下面是一些简要的解释： 首先，如果定时器已经触发且已经过了超时时间，就需要对当前正在传输中的段进行处理。 然后，如果窗口大小是非零的，就将当前段的连续重传次数加 1，同时将重传超时时间加倍。 如果连续重传次数不超过最大重传次数，则将该段推入待发送队列 _segments_out 中，同时重置定时器。如果超过最大重传次数，则停止定时器。 整个过程的目的是确保 TCP 连接上的数据能够被成功传输，即使在网络出现故障、丢包等问题时也能够自动进行重传。 ack_received 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//! \\param ackno The remote receiver&#x27;s ackno (acknowledgment number)//! \\param window_size The remote receiver&#x27;s advertised window sizevoid TCPSender::ack_received(const WrappingInt32 ackno, const uint16_t window_size) &#123; // do not receive if (unwrap(ackno, _isn, _next_seqno) &gt; _next_seqno) &#123; return; &#125; _window_size = window_size; // from SYN_SENT state to SYN_ACKED state if (_state == SYN_SENT &amp;&amp; ackno == wrap(1, _isn)) &#123; _state = SYN_ACKED; &#125; // no segments to receive if (_segments_in_flight.empty()) &#123; return; &#125; TCPSegment seg = _segments_in_flight.front(); bool successful_receipt_of_new_data = false; auto seq = unwrap(seg.header().seqno, _isn, _next_seqno) + seg.length_in_sequence_space(); auto ack = unwrap(ackno, _isn, _next_seqno); while (seq &lt;= ack) &#123; _bytes_in_flight -= seg.length_in_sequence_space(); _segments_in_flight.pop(); successful_receipt_of_new_data = true; if (_segments_in_flight.empty()) &#123; break; &#125; seg = _segments_in_flight.front(); seq = unwrap(seg.header().seqno, _isn, _next_seqno) + seg.length_in_sequence_space(); ack = unwrap(ackno, _isn, _next_seqno); &#125; if (successful_receipt_of_new_data) &#123; // 7. (a) Set the RTO back to its “initial value.” _retransmission_timeout = _initial_retransmission_timeout; // 7. (b) If the sender has any outstanding data, restart the retransmission timer // so that it will expire after RTO milliseconds (for the current value of RTO). if (!_segments_in_flight.empty()) &#123; _timer.reset(_retransmission_timeout); &#125; else &#123; _timer.stop(); &#125; // 7. (c) Reset the count of “consecutive retransmissions” back to zero. _consecutive_retransmission_count = 0; &#125;&#125; 这段代码是TCP发送方的一个函数，用于处理接收到的确认报文。确认报文包含远程接收方已经成功接收到的字节数以及窗口大小。 首先，代码检查接收到的确认号是否是一个有效的号码，如果确认号比已经接收到的下一个序号还要大，则说明该确认号还没有被接收到，直接返回。 然后，代码更新发送窗口大小为接收到的窗口大小。如果发送方处于 SYN_SENT 状态，并且收到了期望的确认号（即初始序列号加 1），则将发送方状态更新为 SYN_ACKED 状态。 代码继续处理接收到的确认号，查找序列号等于或小于确认号的段，并从未确认段列表中移除它们。如果成功接收到新数据，发送方将执行以下操作： (a) 重置重传超时计时器为其初始值。 (b) 如果发送方有任何未确认的数据，则重新启动重传计时器，以便在 RTO 毫秒后超时（对于当前的 RTO 值）。 © 将“连续重传计数”的计数重置为零。 最后，如果所有未确认的数据段都已经被确认，则代码停止计时器，如果还有未确认的数据，则重置计时器并更新“连续重传计数”的计数。 fill_segment 12345678910111213void TCPSender::fill_segment(TCPSegment&amp; seg) &#123; seg.header().seqno = wrap(_next_seqno, _isn); _next_seqno += seg.length_in_sequence_space(); _bytes_in_flight += seg.length_in_sequence_space(); _segments_in_flight.push(seg); _segments_out.emplace(move(seg)); if (!_timer.activated()) &#123; _timer.reset(_retransmission_timeout); &#125;&#125; 这段代码是 TCP 发送方在发送一个 TCP 数据报前填充数据报的头部信息，并将数据报添加到待发送队列中。 在代码中，首先使用 wrap() 函数计算出数据报的序列号，并将该序列号设置为数据报头部的 seqno 字段。然后，将发送方的下一个序列号增加数据报的序列号空间长度（即增加 seqno + payload.size()）以更新发送方的下一个序列号，并将数据报的序列号空间长度加入到发送方的字节流队列中以更新发送方的字节流窗口。接着，将数据报添加到正在发送队列中（segments_in_flight）以便在重传时能够找到该数据报，同时将数据报添加到待发送队列中（segments_out）。最后，如果当前计时器没有启动，则使用计时器的 reset() 函数启动计时器，以便在超时时重传该数据报。 fill_window 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748void TCPSender::fill_window() &#123; if (_state == CLOSED) &#123; // syn_segment TCPSegment syn_seg; syn_seg.header().syn = true; fill_segment(syn_seg); _state = SYN_SENT; &#125; else if (_state == SYN_ACKED) &#123; size_t window_size = _window_size == 0 ? 1 : _window_size; // Congestion control if (_bytes_in_flight &gt;= window_size) &#123; return; &#125; size_t bytes_sent = 0; size_t max_tobe_sent = window_size - _bytes_in_flight; while (bytes_sent &lt; max_tobe_sent &amp;&amp; !_stream.buffer_empty()) &#123; // normal segment TCPSegment seg; seg.payload() = Buffer(move(_stream.read(min( TCPConfig::MAX_PAYLOAD_SIZE, max_tobe_sent - bytes_sent )))); bytes_sent += seg.payload().size(); if (_stream.eof() &amp;&amp; bytes_sent &lt; max_tobe_sent) &#123; seg.header().fin = true; _state = FIN_SENT; &#125; fill_segment(seg); &#125; if (window_size - _bytes_in_flight &gt;= 1 &amp;&amp; _stream.eof() &amp;&amp; _state == SYN_ACKED) &#123; // fin_segment TCPSegment fin_seg; fin_seg.header().fin = true; fill_segment(fin_seg); _state = FIN_SENT; &#125; &#125;&#125; 这段代码是 TCP 发送方在填充发送窗口的过程中使用的。当发送方处于 CLOSED 状态时，它会创建一个 SYN 段，通过调用 fill_segment 函数来将这个段添加到发送窗口中，并且将发送方的状态改为 SYN_SENT。 当发送方处于 SYN_ACKED 状态时，发送方会进行拥塞控制，确保没有过多的未确认段在传输，从而避免网络拥塞。发送方首先检查已经发送但还未被确认的字节数是否达到了窗口大小，如果达到了则停止填充窗口。如果还可以发送数据，发送方从流中读取最多 max_tobe_sent - bytes_sent 个字节，然后将这些字节放入 TCP 段的 payload 中，填写 TCP 段的首部信息，并通过调用 fill_segment 函数将 TCP 段添加到发送窗口中。如果此时流已经被读取完且还有一些字节没有被发送，那么发送方会创建一个 FIN 段，并通过 fill_segment 函数将 FIN 段添加到发送窗口中。如果 FIN 段也被确认，那么发送方的状态会变为 FIN_SENT。 完整代码 tcp_sender.hh tcp_sender.cc","categories":[],"tags":[{"name":"CS144","slug":"CS144","permalink":"http://www.misaka-9982.com/tags/CS144/"},{"name":"Network","slug":"Network","permalink":"http://www.misaka-9982.com/tags/Network/"}]},{"title":"CS144-Lab2","slug":"CS144-Lab2","date":"2023-02-18T15:30:41.000Z","updated":"2023-02-18T16:00:49.738Z","comments":true,"path":"2023/02/18/CS144-Lab2/","link":"","permalink":"http://www.misaka-9982.com/2023/02/18/CS144-Lab2/","excerpt":"","text":"实验架构 除了写入传入流之外，TCPReceiver 还负责通知 sender 两件事： “First unassembled” 字节的索引，称为“acknowledgment”或 “ackno”。这是接收方需要来自发送方的第一个字节。 “first unassembled ” 索引和“first unacceptable ”索引之间的距离。这称为“window size”。 总的来说，ackno 和 window size 述了 TCPreceiver 的窗口：TCPsender 被允许发送一系列索引。使用该窗口，TCPreceiver 可以做到流量控制，使发送方限制它发送的数量，直到接收方准备好更多的数据。有时，我们将 ackno 称为窗口的“左边”( TCPRecsigner 的最小索引)，而 ackno + window size 则称为“右边缘”(略大于 TCPReceiver 的最大索引)。 在编写 Stream Reassembler 和 Byte Stream 时，您已经完成了实现 TCP Receiver 所涉及的大部分算法工作；本实验是将这些通用类连接到 TCP 的细节。最困难的部分将涉及考虑 TCP 将如何表示每个字节在流中的位置——称为“sequence number”。 我们将要实现的 TCPReceiver 需要完成的功能： 接收 TCP segment 重新组装 ByteStream 发送 ackno 和 window size 回 TCP sender ，以进行流量控制和数据确认 环境配置 当前我们的实验代码位于 master 分支，而在完成 Lab 之前需要合并一些依赖代码，因此执行以下命令： 1git merge origin/lab2-startercode 之后重新 make 编译即可。 The TCP Receiver 在 Lab2，我们将实现一个 TCPReceiver，用以接收传入的 TCP segment 并将其转换成用户可读的数据流。 TCPReceiver 除了将读入的数据写入至 ByteStream 中以外，它还需要告诉发送者两个属性： 第一个未组装的字节索引，称为确认号ackno，它是接收者需要的第一个字节的索引。 第一个未组装的字节索引和第一个不可接受的字节索引之间的距离，称为 窗口长度window size。 ackno 和 window size 共同描述了接收者当前的接收窗口。接收窗口是 发送者允许发送数据的一个范围，通常 TCP 接收方使用接收窗口来进行流量控制，限制发送方发送数据。 总的来说，我们将要实现的 TCPReceiver 需要做以下几件事情： 接收TCP segment 重新组装字节流（包括EOF） 确定应该发回给发送者的信号，以进行数据确认和流量控制 1. Translating between 64-bit indexes and 32-bit seqnos 作为热身，我们需要实现TCP表示索引的方式。上周您创建了一个StreamReassembler，它重组子字符串，其中每个字节都有一个64位流索引，流中的第一个字节总是索引为0。64位索引足够大，我们可以将其视为永不溢出。然而，在TCP报头中，空间是宝贵的，流中的每个字节的索引不是用64位的索引表示的，而是用32位的“序列号”或“seqno”表示的。这增加了三个复杂性: 您的实现需要为32位整数进行规划：TCP中的流可以是任意长的——对于可以通过TCP发送的字节流的长度没有限制。但是232字节只有4GiB，并不是很大。一旦一个32位的序列号计数到232−1，流中的下一个字节的序列号将为0。 TCP序列号从一个随机值开始：为了提高安全性，并避免被属于同一端点之间早期连接的旧段所混淆，TCP试图确保序列号不会被猜测，并且不太可能重复。所以流的序列号不是从0开始的。流中的第一个序列号是一个随机的32位数字，称为初始序列号(Initial sequence number, ISN)。这是表示SYN(流的开始)的序列号。其余的序列号在此之后正常运行:数据的第一个字节将有ISN+1 (mod 232)的序列号，第二个字节将有ISN+2 (mod 232)，等等。 每个逻辑开始和结束占用一个序列号：除了确保接收到所有字节的数据外，TCP还确保可靠地接收流的开始和结束。因此，在TCP中SYN (start -ofstream)和FIN (end- stream)控制标志被分配了序列号。每一个都占用一个序列号。(SYN标志占用的序列号是ISN。)流中的每个数据字节也占用一个序列号。请记住，SYN和FIN不是流本身的一部分，也不是“字节”——它们表示字节流本身的开始和结束。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#ifndef SPONGE_LIBSPONGE_WRAPPING_INTEGERS_HH#define SPONGE_LIBSPONGE_WRAPPING_INTEGERS_HH#include &lt;cstdint&gt;#include &lt;ostream&gt;//! \\brief A 32-bit integer, expressed relative to an arbitrary initial sequence number (ISN)//! \\note This is used to express TCP sequence numbers (seqno) and acknowledgment numbers (ackno)class WrappingInt32 &#123; private: uint32_t _raw_value; //!&lt; The raw 32-bit stored integer public: //! Construct from a raw 32-bit unsigned integer explicit WrappingInt32(uint32_t raw_value) : _raw_value(raw_value) &#123;&#125; uint32_t raw_value() const &#123; return _raw_value; &#125; //!&lt; Access raw stored value&#125;;//! Transform a 64-bit absolute sequence number (zero-indexed) into a 32-bit relative sequence number//! \\param n the absolute sequence number//! \\param isn the initial sequence number//! \\returns the relative sequence numberWrappingInt32 wrap(uint64_t n, WrappingInt32 isn);//! Transform a 32-bit relative sequence number into a 64-bit absolute sequence number (zero-indexed)//! \\param n The relative sequence number//! \\param isn The initial sequence number//! \\param checkpoint A recent absolute sequence number//! \\returns the absolute sequence number that wraps to `n` and is closest to `checkpoint`//!//! \\note Each of the two streams of the TCP connection has its own ISN. One stream//! runs from the local TCPSender to the remote TCPReceiver and has one ISN,//! and the other stream runs from the remote TCPSender to the local TCPReceiver and//! has a different ISN.uint64_t unwrap(WrappingInt32 n, WrappingInt32 isn, uint64_t checkpoint);//! \\name Helper functions//!@&#123;//! \\brief The offset of `a` relative to `b`//! \\param b the starting point//! \\param a the ending point//! \\returns the number of increments needed to get from `b` to `a`,//! negative if the number of decrements needed is less than or equal to//! the number of incrementsinline int32_t operator-(WrappingInt32 a, WrappingInt32 b) &#123; return a.raw_value() - b.raw_value(); &#125;//! \\brief Whether the two integers are equal.inline bool operator==(WrappingInt32 a, WrappingInt32 b) &#123; return a.raw_value() == b.raw_value(); &#125;//! \\brief Whether the two integers are not equal.inline bool operator!=(WrappingInt32 a, WrappingInt32 b) &#123; return !(a == b); &#125;//! \\brief Serializes the wrapping integer, `a`.inline std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, WrappingInt32 a) &#123; return os &lt;&lt; a.raw_value(); &#125;//! \\brief The point `b` steps past `a`.inline WrappingInt32 operator+(WrappingInt32 a, uint32_t b) &#123; return WrappingInt32&#123;a.raw_value() + b&#125;; &#125;//! \\brief The point `b` steps before `a`.inline WrappingInt32 operator-(WrappingInt32 a, uint32_t b) &#123; return a + -b; &#125;//!@&#125;#endif // SPONGE_LIBSPONGE_WRAPPING_INTEGERS_HH 这段代码定义了一个名为WrappingInt32的类，表示相对于一个任意初始序列号（ISN）的32位整数。它被用来表示TCP序列号（seqno）和确认号（ackno）。此外，还定义了一些帮助函数，用于转换绝对序列号和相对序列号之间的关系。 具体来说，这里的WrappingInt32类只有一个私有成员变量_raw_value，它表示一个32位无符号整数的原始值。类中定义了一个公有构造函数explicit WrappingInt32(uint32_t raw_value)，用于将一个无符号整数转换为WrappingInt32对象。类还提供了一个公有成员函数uint32_t raw_value() const，用于访问对象的原始值。 此外，还定义了两个函数wrap和unwrap，分别用于将绝对序列号转换为相对序列号，以及将相对序列号转换为绝对序列号。wrap函数的输入参数为一个64位无符号整数n和一个WrappingInt32对象isn，输出为一个WrappingInt32对象，表示n相对于isn的相对序列号。unwrap函数的输入参数为一个WrappingInt32对象n，一个WrappingInt32对象isn，以及一个64位无符号整数checkpoint，输出为一个64位无符号整数，表示最接近checkpoint并相对于isn的序列号值为n的绝对序列号。 最后，还定义了一些辅助函数，如operator-，用于计算两个WrappingInt32对象之间的差值，operator==和operator!=用于比较两个WrappingInt32对象是否相等，operator&lt;&lt;用于将一个WrappingInt32对象输出到流中，以及operator+和operator-，分别用于将一个WrappingInt32对象向前或向后移动一定的距离。 12345678910111213141516171819202122232425262728//! Transform an &quot;absolute&quot; 64-bit sequence number (zero-indexed) into a WrappingInt32//! \\param n The input absolute 64-bit sequence number//! \\param isn The initial sequence numberWrappingInt32 wrap(uint64_t n, WrappingInt32 isn) &#123; return isn + n;&#125;//! Transform a WrappingInt32 into an &quot;absolute&quot; 64-bit sequence number (zero-indexed)//! \\param n The relative sequence number//! \\param isn The initial sequence number//! \\param checkpoint A recent absolute 64-bit sequence number//! \\returns the 64-bit sequence number that wraps to `n` and is closest to `checkpoint`//!//! \\note Each of the two streams of the TCP connection has its own ISN. One stream//! runs from the local TCPSender to the remote TCPReceiver and has one ISN,//! and the other stream runs from the remote TCPSender to the local TCPReceiver and//! has a different ISN.uint64_t unwrap(WrappingInt32 n, WrappingInt32 isn, uint64_t checkpoint) &#123; uint32_t offset = n.raw_value() - wrap(checkpoint, isn).raw_value(); uint64_t res = checkpoint + offset; if (offset &gt; (0x80000000) &amp;&amp; res &gt;= (0x100000000)) &#123; res -= (0x100000000); &#125; return res;&#125; 这段代码包含了两个函数的实现，一个是 wrap，另一个是 unwrap。 wrap 函数将一个 64 位的绝对序列号转换为一个 32 位的相对序列号，以 isn 为初始序列号。 unwrap 函数将一个 32 位的相对序列号转换为一个 64 位的绝对序列号，以 isn 为初始序列号，并指定一个最近的绝对序列号 checkpoint，函数的返回值是一个绝对序列号，它等于相对序列号 n 对应的绝对序列号，同时又尽可能接近于 checkpoint。 其中 wrap 函数的实现比较简单，直接将输入的绝对序列号 n 加上初始序列号 isn，得到一个相对序列号即可。 而 unwrap 函数的实现稍微复杂一些。首先计算 n 和 checkpoint 之间的偏移量 offset，即 n 对应的绝对序列号与 checkpoint 的绝对序列号之差。然后将 offset 加到 checkpoint 上，就得到了 n 对应的绝对序列号 res。 这里需要注意一个问题，当 offset 的值比较大时（即大于等于 0x80000000），此时 n 对应的序列号可能要“绕一圈”，从而超过了 32 位的表示范围。因此，如果 res 大于等于 0x100000000，则需要减去 0x100000000，即从头开始计数，避免超出 32 位的表示范围。 Implementing the TCP receiver 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//! Receives and reassembles segments into a ByteStream, and computes//! the acknowledgment number and window size to advertise back to the//! remote TCPSender.class TCPReceiver &#123; //! Our data structure for re-assembling bytes. StreamReassembler _reassembler; //! The maximum number of bytes we&#x27;ll store. size_t _capacity; std::optional&lt;WrappingInt32&gt; _ackno&#123;&#125;; WrappingInt32 _isn&#123;0&#125;; WrappingInt32 _seq&#123;0&#125;; // the index of the last reassembled byte uint64_t _checkpt&#123;0&#125;; public: //! \\brief Construct a TCP receiver //! //! \\param capacity the maximum number of bytes that the receiver will //! store in its buffers at any give time. TCPReceiver(const size_t capacity) : _reassembler(capacity), _capacity(capacity) &#123;&#125; //! \\name Accessors to provide feedback to the remote TCPSender //!@&#123; //! \\brief The ackno that should be sent to the peer //! \\returns empty if no SYN has been received //! //! This is the beginning of the receiver&#x27;s window, or in other words, the sequence number //! of the first byte in the stream that the receiver hasn&#x27;t received. std::optional&lt;WrappingInt32&gt; ackno() const; //! \\brief The window size that should be sent to the peer //! //! Operationally: the capacity minus the number of bytes that the //! TCPReceiver is holding in its byte stream (those that have been //! reassembled, but not consumed). //! //! Formally: the difference between (a) the sequence number of //! the first byte that falls after the window (and will not be //! accepted by the receiver) and (b) the sequence number of the //! beginning of the window (the ackno). size_t window_size() const; //!@&#125; //! \\brief number of bytes stored but not yet reassembled size_t unassembled_bytes() const &#123; return _reassembler.unassembled_bytes(); &#125; //! \\brief handle an inbound segment void segment_received(const TCPSegment &amp;seg); //! \\name &quot;Output&quot; interface for the reader //!@&#123; ByteStream &amp;stream_out() &#123; return _reassembler.stream_out(); &#125; const ByteStream &amp;stream_out() const &#123; return _reassembler.stream_out(); &#125; //!@&#125;&#125;; TCPReceiver 的解释如下： TCP 接收器用于接收和重新组装 TCP Segment，并计算确认号和窗口大小以返回给远程发送器。 主要成员变量和函数包括： StreamReassembler _reassembler：用于重新组装字节的数据结构； size_t _capacity：TCP 接收器可以同时存储的最大字节数； std::optional&lt;WrappingInt32&gt; _ackno&#123;&#125;：应该发送到对等端的 ackno，如果没有接收到 SYN 则为空； WrappingInt32 _isn&#123;0&#125;：初始序列号（ISN）； WrappingInt32 _seq&#123;0&#125;：接收到的最后一个 TCP 分段的序列号； uint64_t _checkpt&#123;0&#125;：最后一个重新组装的字节的索引（绝对序列号）； ackno()：返回应该发送到对等端的 ackno，如果没有接收到 SYN 则为空； window_size()：返回应该发送到对等端的窗口大小； unassembled_bytes()：返回已存储但尚未重新组装的字节数； segment_received()：处理传入的 TCP 分段。 该类的主要功能是： 接收传入的 TCP 分段，并将其发送到 StreamReassembler 进行重新组装； 计算应该发送给远程 TCPSender 的 ackno 和窗口大小，以便 TCPSender 知道还有多少可用的空间； 提供 stream_out() 函数，用于读取已重新组装的数据。 TCP receiver 在连接生命周期中的状态转移 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657void TCPReceiver::segment_received(const TCPSegment &amp;seg) &#123; /** * @note Listen state * @def not ackno().has_value() */ if (!_ackno.has_value()) &#123; // Handshake if (seg.header().syn) &#123; auto rd = get_random_generator(); _isn = WrappingInt32(rd()); _seq = seg.header().seqno; _reassembler.push_substring(move(seg.payload().copy()), 0, seg.header().fin); // SYN or FIN make _ackno+1 auto ctrl = seg.length_in_sequence_space() - seg.payload().size(); _ackno = WrappingInt32(move(_seq)) + ctrl + _reassembler.first_unassembled(); &#125; return; &#125; /** * @note FIN_RECV state * @def stream_out.input_ended() */ if (_ackno.has_value() &amp;&amp; !stream_out().input_ended()) &#123; /** * @note SYN_RECV state * @def ackno.has_value() and not stream_out.input_ended() * @code 48 - 54 */ auto index = unwrap(move(seg.header().seqno), move(_seq + 1), _checkpt); // &quot;+ 1&quot; for the &quot;SYN&quot; // data too far, considered out of data if (index &gt; _checkpt &amp;&amp; ((index - _checkpt) &amp; 0x80000000)) &#123; return; &#125; // data too far, considered out of data if (index &lt; _checkpt &amp;&amp; ((_checkpt - index) &amp; 0x80000000)) &#123; return; &#125; _reassembler.push_substring(move(Buffer(move(seg.payload().copy()))), index, seg.header().fin); _ackno = _ackno.value() + _reassembler.first_unassembled() - _checkpt; // FIN should make _ackno + 1 if (stream_out().input_ended()) &#123; _ackno = _ackno.value() + 1; &#125; _checkpt = _reassembler.first_unassembled(); &#125;&#125; 这段代码实现了TCP接收端的主要逻辑，即处理TCP段并将它们重新组装成字节流。代码中有几个状态，分别对应TCP协议中的连接建立、连接终止和正常数据传输的不同阶段。 首先，如果接收端还没有收到 SYN，就判断接收到的 TCP 段是否是 SYN，如果是，则在随机生成一个初始序列号后，将接收到的数据传递给 StreamReassembler 进行重新组装，并更新需要发送给发送方的确认序列号 _ackno。如果还没有收到 SYN，则直接返回。 如果接收端已经收到了 SYN，但还没有收到 FIN，则在接收到的TCP段中查找相对于已经接收的字节数偏移量，并使用 StreamReassembler 对接收到的数据进行重新组装。在重新组装之后，需要更新确认序列号 _ackno，并且如果数据流已经结束，需要将确认序列号加一。如果接收到的数据已经过期或已经在之前的数据段中处理过，则不需要重新组装数据，直接返回即可。 如果接收端已经收到了FIN，则不再接受更多的数据，并将 _ackno 加 1 以告诉发送端已经收到了所有数据。 完整代码 wrapping_integers.hh wrapping_integers.cc tcp_receiver.hh tcp_receiver.cc","categories":[],"tags":[{"name":"CS144","slug":"CS144","permalink":"http://www.misaka-9982.com/tags/CS144/"},{"name":"Network","slug":"Network","permalink":"http://www.misaka-9982.com/tags/Network/"}]},{"title":"CS144-Lab1","slug":"CS144-Lab1","date":"2023-02-18T14:39:12.000Z","updated":"2023-02-19T03:03:01.555Z","comments":true,"path":"2023/02/18/CS144-Lab1/","link":"","permalink":"http://www.misaka-9982.com/2023/02/18/CS144-Lab1/","excerpt":"","text":"实验架构 TCP实施中模块和数据流的排列 : 字节流是Lab0。TCP的工作是通过不可靠的数据报网络传输两个字节流(每个方向一个)，以便写入连接一侧套接字的字节显示为可在对等端读取的字节，反之亦然。Lab1是StreamReAssemer，在Lab2、3和4中，您将实施TCPReceiver、TCPSender，然后实施 TCPConnection 将它们连接在一起。 在Lab1中，您将实现一个流重组器-该模块将字节流的一小部分(称为子串或段)按正确的顺序缝合回连续的字节流。 在Lab2中，您将实现TCP中处理入站字节流的部分：TCPReceiver。这涉及到考虑TCP将如何表示流中每个字节的位置-称为“序列号”。TCPReceiver 负责告诉发送者(A)它已经能够成功组装多少入站字节流(这称为“确认”)和(B)发送者现在被允许发送多少字节(“flow控制”)。(B)TCPReceiver 负责告诉发送者(A)它已经能够成功组装多少入站字节流(这称为“确认”)和(B)允许发送者现在发送多少字节(“flow control”)。 在Lab3中，您将实现TCP中处理出站字节流的部分：TCPSender。当发送方怀疑其传输的数据段在途中丢失并且从未到达接收方时，它应该如何反应？它应该在什么时候重试并重新传输丢失的数据段？ 在Lab4中，您将结合前面的工作和Lab来创建工作的TCP实现：包含TCPSender 和 TCPReceiver 的 TCPConnection。您将使用它与世界各地的真实服务器进行对话。 您的Push Substring方法将忽略会导致 StreamReAssembly 超出其“容量”的字符串的任何部分：内存使用限制，即允许它存储的最大字节数。这可以防止重新组装器使用无限量的内存，无论TCP发送器决定执行什么操作。我们已经在下面的图片中对此进行了说明。“容量”是两者的上限： 重组的ByteStream中的字节数(如下绿色所示)，以及 “unassembled”的子字符串可以使用的最大字节数(以红色显示) 红色：re-assembler 保存在辅助存储器中的已接收字节 绿色：re-assembler 保存在字节流中的已接收字节数 蓝色：已读取的已接收字节数 说明 整个数据流中第一个字节的索引是什么？ 0。 我的实现应该有多大的效率？ 我们还不打算指定一个效率的概念，但请不要建立一个严重影响空间或时间的数据结构——这个数据结构将是你的TCP实现的基础。 应该如何处理不一致的子串？ 你可以假设它们不存在。也就是说，你可以假设有一个唯一的底层字节流，而所有的子串都是它的（精确）片段。 我可以使用什么？ 你可以使用你认为有用的标准库的任何部分。特别是，我们希望你至少要使用一个数据结构。 字节什么时候应该被写入流中？ 越快越好。一个字节不应该出现在流中的唯一情况是，在它之前有一个字节还没有被”push”。 子串可能重叠吗？ 可能。 我是否需要向StreamReassembler添加私有成员？ 是的。由于段可能以任何顺序到达，你的数据结构将不得不记住子串，直到它们准备好被放入流中，也就是说，直到它们之前的所有索引都已填充。 实现思路 1. 要求 在我们所实现的 StreamReassembler 中，有以下几种特性： 接收子字符串。这些子字符串中包含了一串字节，以及该字符串在总的数据流中的第一个字节的索引。 流的每个字节都有自己唯一的索引，从零开始向上计数。 StreamReassembler 中存在一个 ByteStream 用于输出，当 StreamReassembler 知道了流的下一个字节，它就会将其写入至 ByteStream 中。 需要注意的是，传入的子串中： 子串之间可能相互重复，存在重叠部分 但假设重叠部分数据完全重复。 不存在某些 index 下的数据在某个子串中是一种数据，在另一个子串里又是另一种数据。 重叠部分的处理最为麻烦。 可能会传一些已经被装配了的数据 如果 ByteStream 已满，则必须暂停装配，将未装配数据暂时保存起来 除了上面的要求以外，容量 Capacity 需要严格限制： 为了便于说明，将图中的绿色区域称为 ByteStream，将图中**存放红色区域的内存范围（即 first unassembled - first unacceptable）**称为 Unassembled_strs。 CS144 要求将 ByteStream + Unassembled_strs 的内存占用总和限制在 Reassember 中构造函数传入的 capacity 大小。因此我们在构造 Reassembler 时，需要既将传入的 capacity 参数设置为 ByteStream的缓冲区大小上限，也将其设置为first unassembled - first unacceptable的范围大小，以避免极端情况下的内存使用。 注意：first unassembled - first unacceptable的范围大小，并不等同于存放尚未装配子串的结构体内存大小上限，别混淆了。 Capacity 这个概念很重要，因为它不仅用于限制高内存占用，而且它还会起到流量控制的作用（见 lab2）。 本节实验需要安装 pcap 库和 pcap-dev 库才能正常编译 1sudo apt-get install libpcap-dev 在新的 Segment 到来的时候，如果他能和已储存的包 “合并” 的话，我们可以不更改已储存的包，而是把这个新包修剪一下，利用 BufferPlus 修剪前后缀的两个函数去掉它的重复的部分 1234567891011121314151617181920212223class StreamBlock &#123; private: BufferPlus _buffer&#123;&#125;; size_t _begin_index; public: StreamBlock(const int begin, std::string &amp;&amp;str) noexcept : _buffer(std::move(str)), _begin_index(begin) &#123;&#125;; StreamBlock(const StreamBlock &amp;Other) noexcept : _buffer(Other._buffer), _begin_index(Other._begin_index) &#123;&#125;; StreamBlock(const int begin, const Buffer &amp;data) noexcept : _buffer(data), _begin_index(begin) &#123;&#125;; bool operator&lt;(const StreamBlock sb) const &#123; return begin() &lt; sb.begin(); &#125; inline size_t end() const &#123; return _begin_index + _buffer.starting_offset() + _buffer.size(); &#125; inline size_t len() const &#123; return _buffer.size(); &#125; inline size_t begin() const &#123; return _begin_index + _buffer.starting_offset(); &#125; BufferPlus &amp;buffer() &#123; return _buffer; &#125; const BufferPlus &amp;buffer() const &#123; return _buffer; &#125;&#125;; 定义一个名为 StreamBlock。 它包含了一个私有成员 _buffer，类型为 BufferPlus，另一个私有成员 _begin_index，类型为 size_t。类的定义中包含了三个构造函数： 第一个构造函数接受两个参数：一个整数 begin 和一个右值引用类型的 std::string 对象 str。它使用 std::move 将 str 移动到 _buffer 成员中，并将 _begin_index 初始化为 begin。 第二个构造函数接受一个参数：另一个 StreamBlock 类型的对象 Other。它将 Other 的 _buffer 和 _begin_index 成员的值分别赋值给当前对象的 _buffer 和 _begin_index 成员。 第三个构造函数接受两个参数：一个整数 begin 和一个 Buffer 类型的对象 data。它将 data 的值复制到 _buffer 成员中，并将 _begin_index 初始化为 begin。 该类还包含了四个公共成员函数： 一个重载了小于号 &lt; 的运算符，用于比较两个 StreamBlock 对象的起始位置，返回值为布尔类型。 一个返回 StreamBlock 对象的结束位置的函数 end()，返回值为 size_t 类型。 一个返回 StreamBlock 对象的长度的函数 len()，返回值为 size_t 类型。 一个返回 StreamBlock 对象的起始位置的函数 begin()，返回值为 size_t 类型。 最后，类中还有两个 BufferPlus 类型的成员函数 buffer() 和 buffer() const，用于返回 _buffer 成员。前一个是非 const 成员函数，可以修改 _buffer 成员的值，后一个是 const 成员函数，不允许修改 _buffer 成员的值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//! \\brief A class that assembles a series of excerpts from a byte stream (possibly out of order,//! possibly overlapping) into an in-order byte stream.class StreamReassembler &#123; private: // Your code here -- add private members as necessary. ByteStream _output; //!&lt; The reassembled in-order byte stream size_t _capacity; //!&lt; The maximum number of bytes size_t _first_uass; // index of segment waiting for size_t _unassembled_bytes; bool _eof; // whether _eof_ is effecitve size_t _eof_idx; // where the eof is std::set&lt;StreamBlock&gt; _blocks; //! Merge the two blocks &quot;blk&quot; and &quot;new_block&quot; //! the result will stored in new_block //! nothing happens if two blocks can&#x27;t merge //! return ture if merge happens, false otherwise //! add &quot;to_add&quot; blocks to set blocks //! merge all the blocks mergeable inline void add_block(StreamBlock &amp;new_block); bool overlap(const StreamBlock &amp;blk, const StreamBlock &amp;new_blk) const; //! Write the first block to the stream, this block should begin at &#x27;_first_uass&#x27; inline void write_to_stream(); //! Check if eof is written to the stream //! If true, end the stream inline void EOFcheck(); public: //! \\brief Construct a `StreamReassembler` that will store up to `capacity` bytes. //! \\note This capacity limits both the bytes that have been reassembled, //! and those that have not yet been reassembled. StreamReassembler(const size_t capacity); //! \\brief Receive a substring and write any newly contiguous bytes into the stream. //! //! The StreamReassembler will stay within the memory limits of the `capacity`. //! Bytes that would exceed the capacity are silently discarded. //! //! \\param data the substring //! \\param index indicates the index (place in sequence) of the first byte in `data` //! \\param eof the last byte of `data` will be the last byte in the entire stream void push_substring(const std::string &amp;data, const uint64_t index, const bool eof); void push_substring(const Buffer &amp;data, const size_t index, const bool eof); //! \\name Access the reassembled byte stream //!@&#123; const ByteStream &amp;stream_out() const &#123; return _output; &#125; ByteStream &amp;stream_out() &#123; return _output; &#125; //!@&#125; uint64_t first_unassembled() const; //! The number of bytes in the substrings stored but not yet reassembled //! //! \\note If the byte at a particular index has been pushed more than once, it //! should only be counted once for the purpose of this function. size_t unassembled_bytes() const; //! \\brief Is the internal state empty (other than the output stream)? //! \\returns `true` if no substrings are waiting to be assembled bool empty() const;&#125;; StreamReassembler 的类，用于将一个字节流中的多个子字符串（可能无序、可能重叠）重新组装成有序的字节流。类中包含了一些私有成员和公有成员。 类的私有成员包括： ByteStream _output：存储重新组装后的有序字节流。 size_t _capacity：StreamReassembler 可以存储的最大字节数。 size_t _first_uass：未组装的第一个字节在原始字节流中的索引。 size_t _unassembled_bytes：已接收但未组装的字节数。 bool _eof：标记是否已经收到 EOF（文件结束）。 size_t _eof_idx：EOF 在原始字节流中的索引。 std::set&lt;StreamBlock&gt; _blocks：存储已接收但未组装的数据块。 类的公有成员包括： StreamReassembler(const size_t capacity)：构造函数，创建一个 StreamReassembler 实例，设置它的最大容量为 capacity。 void push_substring(const std::string &amp;data, const uint64_t index, const bool eof)：将子字符串 data 添加到 StreamReassembler 中，并将任何新接收到的连续字节写入到 _output 中。index 表示 data 中第一个字节在原始字节流中的索引，eof 表示 data 是否包含文件结束符。 const ByteStream &amp;stream_out() const 和 ByteStream &amp;stream_out()：获取 _output 中存储的有序字节流。 uint64_t first_unassembled() const：获取未组装的第一个字节在原始字节流中的索引。 size_t unassembled_bytes() const：获取已接收但未组装的字节数。 bool empty() const：判断 StreamReassembler 是否为空，即判断是否有待组装的子字符串。 12345678910//! \\details This function check if eof is written to the streaminline void StreamReassembler::EOFcheck() &#123; if (!_eof) &#123; return; &#125; if (static_cast&lt;size_t&gt;(_eof_idx) == _first_uass) &#123; _output.end_input(); &#125;&#125; 这是 StreamReassembler 类的成员函数，用于检查文件结束标记是否已写入输出流。该函数首先检查 _eof 是否为 true ，这意味着文件结束标记已写入流。如果 _eof 不为 true，函数立即返回，不做任何操作。 如果 _eof 为 true，该函数将检查流中文件结束标记的索引 _eof_idx 是否等于 _first_uass。 _first_uass 是流中第一个未使用的字节的索引，这意味着在 _first_uass 之前的所有字节都已被输出流使用。如果 _eof_idx 等于 _first_uass，这意味着流中的所有字节，包括文件结束标记，都已被输出流占用。在这种情况下，函数调用 _output 对象的 end_input() 函数，这表明流中没有更多的输入。 123456789101112131415161718192021222324252627//! \\details This function write the first block into the stream,//! the first block should begin at &#x27;_first_uass&#x27;inline void StreamReassembler::write_to_stream() &#123; while (!_blocks.empty()) &#123; auto block = *_blocks.begin(); if (block.begin() != _first_uass) &#123; return; &#125; size_t bytes_written = _output.write(block.buffer()); if (bytes_written == 0) &#123; return; &#125; _first_uass += bytes_written; _unassembled_bytes -= bytes_written; _blocks.erase(move(_blocks.begin())); // partially written if (bytes_written != block.len()) &#123; block.buffer().remove_prefix(move(bytes_written)); _blocks.insert(move(block)); &#125; &#125;&#125; write_to_stream，作用是将数据块写入流中。根据代码中的注释，这个函数写入的是第一个块，即起始位置为 _first_uass 的块。 这个函数首先进入一个 while 循环，只要数据块队列 _blocks 不为空，就会一直循环。然后，它取出 _blocks 队列中的第一个块，如果这个块的起始位置不等于 _first_uass，说明还没有到该块，就直接返回。 如果该块的起始位置等于 _first_uass，则将该块写入流中，并记录已写入的字节数，更新 _first_uass，减少 _unassembled_bytes 的值（表示还未组装的字节数），然后将该块从队列中删除。 如果该块只写入了部分数据，即字节数小于该块的长度，就将该块的缓冲区前缀截去已写入的字节数，并将该块重新插入到队列中。然后，这个函数就继续处理下一个数据块，直到队列为空或者写入的字节数为 0。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//! \\details This function add &quot;to_add&quot; blocks to set blocks// merge all the blocks mergeableinline void StreamReassembler::add_block(StreamBlock &amp;new_block) &#123; if (new_block.len() == 0) &#123; return; &#125; vector&lt;StreamBlock&gt; blks_to_add; blks_to_add.emplace_back(move(new_block)); if (!_blocks.empty()) &#123; auto nblk = blks_to_add.begin(); auto iter = _blocks.lower_bound(*nblk); auto prev = iter; while (iter != _blocks.end() &amp;&amp; overlap(*iter, *nblk)) &#123; if ((*iter).end() &gt;= (*nblk).end()) &#123; (*nblk).buffer().remove_suffix((*nblk).end() - (*iter).begin()); break; &#125; StreamBlock last(*nblk); (*nblk).buffer().remove_suffix((*nblk).end() - (*iter).begin()); last.buffer().remove_prefix((*iter).end() - (*nblk).begin()); blks_to_add.push_back(move(last)); nblk = blks_to_add.end(); nblk -- ; iter ++ ; &#125; // compare with prevs // check one previous block is enough if (prev != _blocks.begin()) &#123; prev -- ; nblk = blks_to_add.begin(); if (overlap(*nblk, *prev)) &#123; (*nblk).buffer().remove_prefix((*prev).end() - (*nblk).begin()); &#125; &#125; &#125; for (auto &amp;blk : blks_to_add) &#123; if (blk.len() != 0) &#123; _blocks.emplace(move(blk)); _unassembled_bytes += blk.len(); &#125; &#125;&#125; 这段代码是 StreamReassembler 类中的 add_block 函数，用于向一个缓存区 _blocks 中添加新的数据块。这些数据块需要和缓存区中的已有数据块合并，如果新数据块和已有数据块可以合并成一个连续的数据块，则合并它们。如果新数据块和已有数据块不能合并，就将新数据块插入到缓存区 _blocks 中。 具体实现过程如下： 如果新数据块的长度为 0，直接返回。 如果缓存区 _blocks 不为空，则从头开始遍历它，如果有数据块和新数据块可以合并，就将它们合并成一个数据块。如果遍历到一个数据块和新数据块不能合并，就停止遍历。 如果新数据块可以和一个已有数据块合并，就将新数据块和该数据块合并。 如果新数据块和已有数据块不能合并，就插入新数据块到缓存区 _blocks 中。 123456789//! \\details This function check if the two blocks have overlap partbool StreamReassembler::overlap(const StreamBlock &amp;blk, const StreamBlock &amp;new_blk) const &#123; if (blk.begin() &lt; new_blk.begin()) &#123; return new_blk.begin() &lt; blk.end(); &#125; return blk.begin() &lt; new_blk.end();&#125; 这个函数用于判断两个数据块 （StreamBlock）是否有重叠的部分。重叠的部分指的是两个数据块在数据流中存在相同的字节范围。函数接收两个参数，blk 和 new_blk，分别代表已有的数据块和待添加的新数据块。如果这两个数据块有重叠的部分，则返回 true，否则返回 false。 具体实现中，首先比较 blk 的起始位置和 new_blk 的起始位置，如果 blk 的起始位置在 new_blk 的起始位置之前，那么只需比较 new_blk 的起始位置是否在 blk 的结束位置之前；否则，只需比较 blk 的起始位置是否在 new_blk 的结束位置之前。如果满足这两个条件之一，则说明这两个数据块存在重叠部分，返回 true；否则返回 false。 12345678910111213141516171819202122232425262728293031//! \\details This function accepts a substring (aka a segment) of bytes,//! possibly out-of-order, from the logical stream, and assembles any newly//! contiguous substrings and writes them into the output stream in order.void StreamReassembler::push_substring(const string &amp;data, const size_t index, const bool eof) &#123; // the data that have been reassembled if (index + data.size() &lt; _first_uass) &#123; return; &#125; if (eof &amp;&amp; !_eof) &#123; _eof = true; _eof_idx = index + data.size(); &#125; StreamBlock blk(index, move(string(data))); // if a part of the data have been reassembled if (index &lt; _first_uass) &#123; blk.buffer().remove_prefix(_first_uass - index); &#125; // if a part of the data out of the capacity if (index + data.size() &gt; _capacity + _first_uass) &#123; blk.buffer().remove_suffix(index + data.size() - _capacity - _first_uass); &#125; add_block(blk); write_to_stream(); EOFcheck();&#125; 这段代码是一个函数，用于处理来自逻辑流的子字符串（即段）数据，该数据可能是乱序的，然后组装任何新的连续的子字符串并按顺序将其写入输出流。该函数的实现分为三个步骤： 首先检查输入的数据是否已经在已组装的数据范围内，如果已经在范围内，则直接返回，不做处理。 如果输入数据已经包含 EOF 标记，将标记设置为 true，记录标记的位置，以便后续处理。 根据输入数据的索引和内容创建一个 StreamBlock 对象。如果输入数据的索引小于已组装数据的范围，将数据前面的部分丢弃；如果输入数据的索引加上数据长度超出了容量，将数据后面的部分丢弃。然后将新的 StreamBlock 添加到已有的 StreamBlock 集合中，并检查是否有连续的 StreamBlock，将它们合并成一个更大的 StreamBlock。接着将可写入的数据写入到输出流中，并检查是否已经写入了 EOF 标记。 总之，这个函数的作用是将输入数据组装成完整的数据块，然后将这些数据块按顺序写入到输出流中，同时处理 EOF 标记。 完整代码 stream_reassembler.hh stream_reassembler.cc “stream_reassembler.hh” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#ifndef SPONGE_LIBSPONGE_STREAM_REASSEMBLER_HH#define SPONGE_LIBSPONGE_STREAM_REASSEMBLER_HH#include &quot;byte_stream.hh&quot;#include &quot;buffer.hh&quot;#include &lt;cstdint&gt;#include &lt;string&gt;#include &lt;set&gt;class StreamBlock &#123; private: BufferPlus _buffer&#123;&#125;; size_t _begin_index; public: StreamBlock(const int begin, std::string &amp;&amp;str) noexcept : _buffer(std::move(str)), _begin_index(begin) &#123;&#125;; StreamBlock(const StreamBlock &amp;Other) noexcept : _buffer(Other._buffer), _begin_index(Other._begin_index) &#123;&#125;; StreamBlock(const int begin, const Buffer &amp;data) noexcept : _buffer(data), _begin_index(begin) &#123;&#125;; bool operator&lt;(const StreamBlock sb) const &#123; return begin() &lt; sb.begin(); &#125; inline size_t end() const &#123; return _begin_index + _buffer.starting_offset() + _buffer.size(); &#125; inline size_t len() const &#123; return _buffer.size(); &#125; inline size_t begin() const &#123; return _begin_index + _buffer.starting_offset(); &#125; BufferPlus &amp;buffer() &#123; return _buffer; &#125; const BufferPlus &amp;buffer() const &#123; return _buffer; &#125;&#125;;//! \\brief A class that assembles a series of excerpts from a byte stream (possibly out of order,//! possibly overlapping) into an in-order byte stream.class StreamReassembler &#123; private: // Your code here -- add private members as necessary. ByteStream _output; //!&lt; The reassembled in-order byte stream size_t _capacity; //!&lt; The maximum number of bytes size_t _first_uass; // index of segment waiting for size_t _unassembled_bytes; bool _eof; // whether _eof_ is effecitve size_t _eof_idx; // where the eof is std::set&lt;StreamBlock&gt; _blocks; //! Merge the two blocks &quot;blk&quot; and &quot;new_block&quot; //! the result will stored in new_block //! nothing happens if two blocks can&#x27;t merge //! return ture if merge happens, false otherwise //! add &quot;to_add&quot; blocks to set blocks //! merge all the blocks mergeable inline void add_block(StreamBlock &amp;new_block); bool overlap(const StreamBlock &amp;blk, const StreamBlock &amp;new_blk) const; //! Write the first block to the stream, this block should begin at &#x27;_first_uass&#x27; inline void write_to_stream(); //! Check if eof is written to the stream //! If true, end the stream inline void EOFcheck(); public: //! \\brief Construct a `StreamReassembler` that will store up to `capacity` bytes. //! \\note This capacity limits both the bytes that have been reassembled, //! and those that have not yet been reassembled. StreamReassembler(const size_t capacity); //! \\brief Receive a substring and write any newly contiguous bytes into the stream. //! //! The StreamReassembler will stay within the memory limits of the `capacity`. //! Bytes that would exceed the capacity are silently discarded. //! //! \\param data the substring //! \\param index indicates the index (place in sequence) of the first byte in `data` //! \\param eof the last byte of `data` will be the last byte in the entire stream void push_substring(const std::string &amp;data, const uint64_t index, const bool eof); void push_substring(const Buffer &amp;data, const size_t index, const bool eof); //! \\name Access the reassembled byte stream //!@&#123; const ByteStream &amp;stream_out() const &#123; return _output; &#125; ByteStream &amp;stream_out() &#123; return _output; &#125; //!@&#125; uint64_t first_unassembled() const; //! The number of bytes in the substrings stored but not yet reassembled //! //! \\note If the byte at a particular index has been pushed more than once, it //! should only be counted once for the purpose of this function. size_t unassembled_bytes() const; //! \\brief Is the internal state empty (other than the output stream)? //! \\returns `true` if no substrings are waiting to be assembled bool empty() const;&#125;;#endif // SPONGE_LIBSPONGE_STREAM_REASSEMBLER_HH “stream_reassembler.cc” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185#include &quot;stream_reassembler.hh&quot;// Dummy implementation of a stream reassembler.// For Lab 1, please replace with a real implementation that passes the// automated checks run by `make check_lab1`.// You will need to add private members to the class declaration in `stream_reassembler.hh`template &lt;typename... Targs&gt;void DUMMY_CODE(Targs &amp;&amp;... /* unused */) &#123;&#125;using namespace std;StreamReassembler::StreamReassembler(const size_t capacity) : _output(capacity) , _capacity(capacity) , _first_uass(0) , _unassembled_bytes(0) , _eof(false) , _eof_idx(0) , _blocks() &#123;&#125;//! \\details This function accepts a substring (aka a segment) of bytes,//! possibly out-of-order, from the logical stream, and assembles any newly//! contiguous substrings and writes them into the output stream in order.void StreamReassembler::push_substring(const string &amp;data, const size_t index, const bool eof) &#123; // the data that have been reassembled if (index + data.size() &lt; _first_uass) &#123; return; &#125; if (eof &amp;&amp; !_eof) &#123; _eof = true; _eof_idx = index + data.size(); &#125; StreamBlock blk(index, move(string(data))); // if a part of the data have been reassembled if (index &lt; _first_uass) &#123; blk.buffer().remove_prefix(_first_uass - index); &#125; // if a part of the data out of the capacity if (index + data.size() &gt; _capacity + _first_uass) &#123; blk.buffer().remove_suffix(index + data.size() - _capacity - _first_uass); &#125; add_block(blk); write_to_stream(); EOFcheck();&#125;void StreamReassembler::push_substring(const Buffer &amp;data, const size_t index, const bool eof) &#123; // the data that have been reassembled if (index + data.size() &lt; _first_uass) &#123; return; &#125; if (eof &amp;&amp; !_eof) &#123; _eof = true; _eof_idx = index + data.size(); &#125; StreamBlock blk(index, move(data)); // if a part of the data have been reassembled if (index &lt; _first_uass) &#123; blk.buffer().remove_prefix(_first_uass - index); &#125; // if a part of the data out of the capacity if (index + data.size() &gt; _capacity + _first_uass) &#123; blk.buffer().remove_suffix(index + data.size() - _capacity - _first_uass); &#125; add_block(blk); write_to_stream(); EOFcheck();&#125;//! \\details This function check if eof is written to the streaminline void StreamReassembler::EOFcheck() &#123; if (!_eof) &#123; return; &#125; if (static_cast&lt;size_t&gt;(_eof_idx) == _first_uass) &#123; _output.end_input(); &#125;&#125;//! \\details This function write the first block into the stream,//! the first block should begin at &#x27;_first_uass&#x27;inline void StreamReassembler::write_to_stream() &#123; while (!_blocks.empty()) &#123; auto block = *_blocks.begin(); if (block.begin() != _first_uass) &#123; return; &#125; size_t bytes_written = _output.write(block.buffer()); if (bytes_written == 0) &#123; return; &#125; _first_uass += bytes_written; _unassembled_bytes -= bytes_written; _blocks.erase(move(_blocks.begin())); // partially written if (bytes_written != block.len()) &#123; block.buffer().remove_prefix(move(bytes_written)); _blocks.insert(move(block)); &#125; &#125;&#125;//! \\details This function add &quot;to_add&quot; blocks to set blocks// merge all the blocks mergeableinline void StreamReassembler::add_block(StreamBlock &amp;new_block) &#123; if (new_block.len() == 0) &#123; return; &#125; vector&lt;StreamBlock&gt; blks_to_add; blks_to_add.emplace_back(move(new_block)); if (!_blocks.empty()) &#123; auto nblk = blks_to_add.begin(); auto iter = _blocks.lower_bound(*nblk); auto prev = iter; while (iter != _blocks.end() &amp;&amp; overlap(*iter, *nblk)) &#123; if ((*iter).end() &gt;= (*nblk).end()) &#123; (*nblk).buffer().remove_suffix((*nblk).end() - (*iter).begin()); break; &#125; StreamBlock last(*nblk); (*nblk).buffer().remove_suffix((*nblk).end() - (*iter).begin()); last.buffer().remove_prefix((*iter).end() - (*nblk).begin()); blks_to_add.push_back(move(last)); nblk = blks_to_add.end(); nblk -- ; iter ++ ; &#125; // compare with prevs // check one previous block is enough if (prev != _blocks.begin()) &#123; prev -- ; nblk = blks_to_add.begin(); if (overlap(*nblk, *prev)) &#123; (*nblk).buffer().remove_prefix((*prev).end() - (*nblk).begin()); &#125; &#125; &#125; for (auto &amp;blk : blks_to_add) &#123; if (blk.len() != 0) &#123; _blocks.emplace(move(blk)); _unassembled_bytes += blk.len(); &#125; &#125;&#125;//! \\details This function check if the two blocks have overlap partbool StreamReassembler::overlap(const StreamBlock &amp;blk, const StreamBlock &amp;new_blk) const &#123; if (blk.begin() &lt; new_blk.begin()) &#123; return new_blk.begin() &lt; blk.end(); &#125; return blk.begin() &lt; new_blk.end();&#125;uint64_t StreamReassembler::first_unassembled() const &#123; return _first_uass; &#125;size_t StreamReassembler::unassembled_bytes() const &#123; return _unassembled_bytes; &#125;bool StreamReassembler::empty() const &#123; return _unassembled_bytes == 0; &#125;","categories":[],"tags":[{"name":"CS144","slug":"CS144","permalink":"http://www.misaka-9982.com/tags/CS144/"},{"name":"Network","slug":"Network","permalink":"http://www.misaka-9982.com/tags/Network/"}]},{"title":"CS144-Lab0","slug":"CS144-Lab0","date":"2023-02-18T13:14:27.000Z","updated":"2023-02-22T13:07:14.708Z","comments":true,"path":"2023/02/18/CS144-Lab0/","link":"","permalink":"http://www.misaka-9982.com/2023/02/18/CS144-Lab0/","excerpt":"","text":"2 Networking by hand 2.1 Fetch a Web page 2.1.1 访问http://cs144.keithw.org/hello，并观察结果 2.1.2 在命令行中输入 1234telnet cs144.keithw.org httpTrying 104.196.238.229...Connected to cs144.keithw.org.Escape character is &#x27;^]&#x27;. 可以先在一个文件中输入以下字段复制粘贴进命令行，防止输入速度过慢导致断连 1234GET /hello HTTP/1.1Host: cs144.keithw.orgConnection: close 输入完的响应如下： 123456789101112HTTP/1.1 200 OKDate: Mon, 17 Jan 2022 06:35:25 GMTServer: ApacheLast-Modified: Thu, 13 Dec 2018 15:45:29 GMTETag: &quot;e-57ce93446cb64&quot;Accept-Ranges: bytesContent-Length: 14Connection: closeContent-Type: text/plainHello, CS144!Connection closed by foreign host. 2.1.3 Assignment: 在命令行中输入 1telnet cs144.keithw.org http 出现 123Trying 104.196.238.229...Connected to cs144.keithw.org.Escape character is &#x27;^]&#x27;. 接着输入 1234GET /lab0/misaka HTTP/1.1Host: cs144.keithw.orgConnection: close 得到如下响应 123456789101112HTTP/1.1 200 OKDate: Mon, 17 Jan 2022 06:46:16 GMTServer: ApacheX-You-Said-Your-SunetID-Was: misakaX-Your-Code-Is: 712264Content-length: 110Vary: Accept-EncodingConnection: closeContent-Type: text/plainHello! You told us that your SUNet ID was &quot;misaka&quot;. Please see the HTTP headers (above) for your secret code.Connection closed by foreign host. 2.2 Send yourself an email 由于没有sunetid,采用163邮箱进行代替 12345telnet smtp.163.com smtpTrying 220.181.12.11...Connected to smtp.163.com.Escape character is &#x27;^]&#x27;.220 163.com Anti-spam GT for Coremail System (163com[xxxx]) 和163邮箱打个招呼 1helo 163.com 返回250 OK 邮箱账户登陆 123456789101112131415161718auth login334 dXNlcm5hbWU6[输入163邮箱的base64编码格式]334 UGFzc3dvcmQ6[输入base64编码格式的邮箱密码]235 Authentication successfulMAIL FROM: &lt;xxxxx@163.com&gt; //表示发件人为 xxxxx@163.com250 Mail OKRCPT TO: &lt;xxxxx@qq.com&gt; //表示收件人为 xxxxx@qq.com250 Mail OKDATA //准备好发送数据了354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt; [邮件内容].250 Mail OK queued as smtp14,EsCowAAX5WUxFuVhrJCNAg--.xxxxxx xxxxxxxxxxQUIT221 ByeConnection closed by foreign host. 在收件邮箱中可以发现收到的邮件 2.3 Listening and connecting 在命令行中输入： 1netcat -v -l -p 9090 出现如下问题 1netcat: getnameinfo: Temporary failure in name resolution 解决方法： 1sudo vim /etc/resolv.conf 添加以下内容并保存 1namespace 8.8.8.8 在一个窗口输入： 1netcat -v -l -p 9090 新的窗口输入 1telnet localhost 9090 即可实现netcat窗口对telnet窗口的监听，关闭telnet窗口就可以关闭这个监听程序 3 Writing a network program using an OS stream socket 3.1 Let’s get started—fetching and building the starter code 123456git clone https://github.com/cs144/spongegit checkout -b master origin/mastermkdir build &amp;&amp; cd buildcmake ..make formatmake -j4 &amp;&amp; make check_lab0 3.2 代码规范 3.3 Reading the Sponge documentation 初学者代码的文档:https://cs144.github.io/doc/lab0/ Socket是FileDescriptor的一种类型，而TCPSocket是一种Socket FileDescriptor：https://cs144.github.io/doc/lab0/class_file_descriptor.html Socket ：https://cs144.github.io/doc/lab0/class_socket.html TCPSocket：https://cs144.github.io/doc/lab0/class_t_c_p_socket.html Address：https://cs144.github.io/doc/lab0/class_address.html 观察libsponge/util 目录下的 file descriptor.hh, socket.hh, address.hh三个头文件是怎么定义接口的 file descriptor.hh 12345678//! Write a string, possibly blocking until all is writtensize_t write(const char *str, const bool write_all = true) &#123; return write(BufferViewList(str), write_all); &#125;//! Write a string, possibly blocking until all is writtensize_t write(const std::string &amp;str, const bool write_all = true) &#123; return write(BufferViewList(str), write_all); &#125;//! Write a buffer (or list of buffers), possibly blocking until all is writtensize_t write(BufferViewList buffer, const bool write_all = true); socket.hh: 1234567//! Connect a socket to a specified peer address with [connect(2)](\\ref man2::connect)//使用[CONNECT(2)](\\ref Man2：：Connect)将socket连接到指定的对等地址void connect(const Address &amp;address);//! Shut down a socket via [shutdown(2)](\\ref man2::shutdown)//通过[Shutdown(2)](\\ref Man2：：Shutdown)关闭socketvoid shutdown(const int how); address： 1234567891011//! Construct by resolving a hostname and servicename.// 通过 主机名 如 “cs144.keithw.org” 和 服务名 如 “http” 进行构造Address(const std::string &amp;hostname, const std::string&amp;service);//! Construct from dotted-quad string (&quot;18.243.0.1&quot;) and numeric port.// 通过 ip地址 和 端口号 进行构造Address(const std::string &amp;ip, const std::uint16_t port = 0);//! Construct from a [sockaddr *](@ref man7::socket).// 通过 原始socket地址 和 地址长度 进行构造Address(const sockaddr *addr, const std::size_t size); 3.4 Writing webget It’s time to implement webget, a program to fetch Web pages over the Internet using the operating system’s TCP support and stream-socket abstraction—just like you did by hand earlier in this lab. webget是一个使用操作系统的TCP支持和流套接字抽象在Internet上获取网页的程序，就像您在本实验室前面手动完成的一样。 使用HTTP格式实现此文件中描述的简单Web客户端，您之前使用的(Web)请求。使用TCPSocket和Address类。 提示： 在HTTP中，每行必须以“\\r\\n”结尾(仅使用“\\n”或endl是不够的)。 在客户请求中包含“Connection：Close”行。 确保读取并打印来自服务器的所有输出，直到socket到达“EOF”(文件结尾)-单个读取调用是不够的。 十行左右的代码 代码位置： /cs144/sponge/apps/webget.cc 12345678910111213141516171819202122232425262728293031void get_URL(const string &amp;host, const string &amp;path) &#123; // Your code here. // You will need to connect to the &quot;http&quot; service on // the computer whose name is in the &quot;host&quot; string, // then request the URL path given in the &quot;path&quot; string. // Then you&#x27;ll need to print out everything the server sends back, // (not just one call to read() -- everything) until you reach // the &quot;eof&quot; (end of file). Address address(host, &quot;http&quot;); TCPSocket socket; // 和服务器连接 socket.connect(address); // 利用字符串拼接，编写request请求 socket.write(&quot;GET &quot; + path + &quot; HTTP/1.1\\r\\n&quot;); socket.write(&quot;HOST: &quot; + host + &quot;\\r\\n&quot;); socket.write(&quot;\\r\\n&quot;); // request结束 socket.shutdown(SHUT_WR); // content while (!socket.eof()) &#123; std::cout &lt;&lt; socket.read(1); &#125; // close socket.close(); // cerr &lt;&lt; &quot;Function called: get_URL(&quot; &lt;&lt; host &lt;&lt; &quot;, &quot; &lt;&lt; path &lt;&lt; &quot;).\\n&quot;; // cerr &lt;&lt; &quot;Warning: get_URL() has not been implemented yet.\\n&quot;;&#125; make 1$ make 1234567891011[ 33%] Built target sponge[ 40%] Built target webget[ 46%] Built target spongechecks[ 53%] Built target byte_stream_many_writes[ 60%] Built target byte_stream_capacity[ 66%] Built target byte_stream_two_writes[ 73%] Built target byte_stream_one_write[ 80%] Built target byte_stream_construction[ 86%] Built target parser_dt[ 93%] Built target socket_dt[100%] Built target address_dt 测试 1$ ./apps/webget cs144.keithw.org /hello 结果： 12345678910HTTP/1.1 200 OKDate: Mon, 17 Jan 2022 09:16:30 GMTServer: ApacheLast-Modified: Thu, 13 Dec 2018 15:45:29 GMTETag: &quot;e-57ce93446cb64&quot;Accept-Ranges: bytesContent-Length: 14Content-Type: text/plainHello, CS144! make check_webget 1$ make check_webget 结果 123456789[100%] Testing webget...Test project /home/ubuntu/cs144/sponge/build Start 31: t_webget1/1 Test #31: t_webget ......................... Passed 1.05 sec100% tests passed, 0 tests failed out of 1Total Test time (real) = 1.05 sec[100%] Built target check_webget 1234567891011121314151617181920212223242526272829303132333435363738//! \\brief A reference-counted read-only string that can discard bytes from the frontclass Buffer &#123; private: std::shared_ptr&lt;std::string&gt; _storage&#123;&#125;; size_t _starting_offset&#123;&#125;; public: Buffer() = default; //! \\brief Construct by taking ownership of a string Buffer(std::string &amp;&amp;str) noexcept : _storage(std::make_shared&lt;std::string&gt;(std::move(str))) &#123;&#125; //! \\name Expose contents as a std::string_view //!@&#123; std::string_view str() const &#123; if (not _storage) &#123; return &#123;&#125;; &#125; return &#123;_storage-&gt;data() + _starting_offset, _storage-&gt;size() - _starting_offset&#125;; &#125; operator std::string_view() const &#123; return str(); &#125; //!@&#125; //! \\brief Get character at location `n` uint8_t at(const size_t n) const &#123; return str().at(n); &#125; //! \\brief Size of the string size_t size() const &#123; return str().size(); &#125; //! \\brief Make a copy to a new std::string std::string copy() const &#123; return std::string(str()); &#125; //! \\brief Discard the first `n` bytes of the string (does not require a copy or move) //! \\note Doesn&#x27;t free any memory until the whole string has been discarded in all copies of the Buffer. void remove_prefix(const size_t n);&#125;; 这是一个只读的字符串类 Buffer，具有自动引用计数的特性。该类可以从字符串前面丢弃一些字节。 类成员包括： _storage：一个指向 std::string 对象的智能指针，表示该类持有的字符串对象。由于该指针是一个 shared_ptr，所以当多个 Buffer 实例共享同一个字符串时，该字符串的内存只会在所有引用该字符串的 Buffer 实例都析构时才被释放。 _starting_offset：表示当前 Buffer 实例在 _storage 所指向的字符串对象中的偏移量，即该实例持有的字符串从 _storage 所指向的字符串对象的第 _starting_offset 个字符开始。 该类提供了以下方法： 构造函数：接收一个 std::string 对象，并以其为初始字符串。 str()：返回一个 std::string_view 对象，表示当前 Buffer 实例所持有的字符串。std::string_view 对象的数据成员指向 _storage 所指向的字符串对象的 _starting_offset 处。 operator std::string_view() const：重载了类型转换运算符，将 Buffer 对象转换为 std::string_view 对象。 at(size_t n)：返回当前 Buffer 实例所持有的字符串的第 n 个字符。 size()：返回当前 Buffer 实例所持有的字符串的长度。 copy()：返回一个新的 std::string 对象，其中包含当前 Buffer 实例所持有的字符串的完整拷贝。 remove_prefix(size_t n)：丢弃当前 Buffer 实例所持有字符串的前 n 个字符，将 _starting_offset 成员变量加上 n。这个方法不需要进行字符串的拷贝或移动操作，因为 Buffer 类只是一个只读的字符串容器，不需要对其中的字符串做任何修改。同时，如果当前 Buffer 实例是多个实例中的一个共享同一个字符串，那么在所有引用该字符串的 Buffer 实例都丢弃了前 n 个字符之后，原字符串对象才会被释放。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//! \\brief A reference-counted discontiguous string that can discard bytes from the front//! \\note Used to model packets that contain multiple sets of headers//! + a payload. This allows us to prepend headers (e.g., to//! encapsulate a TCP payload in a TCPSegment, and then encapsulate//! the TCPSegment in an IPv4Datagram) without copying the payload.class BufferList &#123; private: std::deque&lt;Buffer&gt; _buffers&#123;&#125;; public: //! \\name Constructors //!@&#123; BufferList() = default; //! \\brief Construct from a Buffer BufferList(Buffer buffer) : _buffers&#123;buffer&#125; &#123;&#125; //! \\brief Construct by taking ownership of a std::string BufferList(std::string &amp;&amp;str) noexcept &#123; Buffer buf&#123;std::move(str)&#125;; append(buf); &#125; //!@&#125; //! \\brief Access the underlying queue of Buffers const std::deque&lt;Buffer&gt; &amp;buffers() const &#123; return _buffers; &#125; //! \\brief Append a BufferList void append(const BufferList &amp;other); //! \\brief Transform to a Buffer //! \\note Throws an exception unless BufferList is contiguous operator Buffer() const; //! \\brief Discard the first `n` bytes of the string (does not require a copy or move) void remove_prefix(size_t n); //! \\brief Size of the string size_t size() const; //! \\brief Make a copy to a new std::string std::string concatenate() const;&#125;; 这段代码定义了一个叫做BufferList的类，它表示了一个由多个Buffer组成的不连续的字符串。这个类可以从字符串前面丢弃字节。它主要用来表示包含多组头部和有效载荷的数据包，它允许我们在不复制有效载荷的情况下前置头部。 这个类内部使用了一个deque容器来存储多个Buffer，并对外提供了一系列公共接口： BufferList()默认构造函数 BufferList(Buffer buffer)：从一个Buffer构造一个BufferList BufferList(std::string &amp;&amp;str)：从一个std::string构造一个BufferList，它会自动将其转换为一个Buffer，并添加到BufferList中 const std::deque&lt;Buffer&gt;&amp; buffers() const：访问底层的Buffer队列 void append(const BufferList&amp; other)：添加一个BufferList到当前对象中 operator Buffer() const：将当前BufferList转换为一个Buffer，但如果BufferList不是连续的，将抛出异常 void remove_prefix(size_t n)：丢弃当前BufferList的前n个字节 size_t size() const：返回当前BufferList的字节长度 std::string concatenate() const：将当前BufferList中的所有Buffer连接起来，并返回一个新的std::string对象。 123456789101112131415161718192021222324252627282930313233//! \\brief A non-owning temporary view (similar to std::string_view) of a discontiguous stringclass BufferViewList &#123; std::deque&lt;std::string_view&gt; _views&#123;&#125;; public: //! \\name Constructors //!@&#123; //! \\brief Construct from a std::string BufferViewList(const std::string &amp;str) : BufferViewList(std::string_view(str)) &#123;&#125; //! \\brief Construct from a C string (must be NULL-terminated) BufferViewList(const char *s) : BufferViewList(std::string_view(s)) &#123;&#125; //! \\brief Construct from a BufferList BufferViewList(const BufferList &amp;buffers); //! \\brief Construct from a std::string_view BufferViewList(std::string_view str) &#123; _views.push_back(&#123;const_cast&lt;char *&gt;(str.data()), str.size()&#125;); &#125; //!@&#125; //! \\brief Discard the first `n` bytes of the string (does not require a copy or move) void remove_prefix(size_t n); //! \\brief Size of the string size_t size() const; //! \\brief Convert to a vector of `iovec` structures //! \\note used for system calls that write discontiguous buffers, //! e.g. [writev(2)](\\ref man2::writev) and [sendmsg(2)](\\ref man2::sendmsg) std::vector&lt;iovec&gt; as_iovecs() const;&#125;; 这段代码定义了一个名为 BufferViewList 的类，它是一个临时的、非拥有者的视图，类似于 std::string_view，用于表示一个不连续的字符串。该类的实例可以从不同的来源构造，包括一个 std::string 对象、一个 C 风格的字符串指针、一个 BufferList 对象，以及一个 std::string_view 对象。 BufferViewList 类提供了以下几个成员函数： remove_prefix(size_t n)：从视图中移除前面的 n 个字符，不需要进行复制或移动。 size()：返回视图所表示字符串的大小。 as_iovecs()：返回一个 std::vector，其中的元素是 iovec 结构体，可以用于写入不连续的缓冲区，如 [writev(2)](\\ref man2::writev) 和 [sendmsg(2)](\\ref man2::sendmsg) 系统调用。 下面模仿 BufferList 编写一个 BufferPlus 类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class BufferPlus &#123; private: std::shared_ptr&lt;std::string&gt; _storage&#123;&#125;; size_t _starting_offset&#123;&#125;; size_t _ending_offset&#123;&#125;; public: BufferPlus() = default; //! \\brief Construct by taking ownership of a string BufferPlus(std::string &amp;&amp;str) noexcept : _storage(std::make_shared&lt;std::string&gt;(std::move(str))) &#123;&#125; BufferPlus(const BufferPlus &amp;Other) : _storage(Other._storage) , _starting_offset(Other._starting_offset) , _ending_offset(Other._ending_offset) &#123;&#125; BufferPlus(const Buffer &amp;bf) : _storage(bf._storage) , _starting_offset(bf._starting_offset) &#123;&#125; //! \\name Expose contents as a std::string_view //!@&#123; std::string_view str() const &#123; if (not _storage) &#123; return &#123;&#125;; &#125; return &#123;_storage-&gt;data() + _starting_offset, _storage-&gt;size() - _starting_offset - _ending_offset&#125;; &#125; operator std::string_view() const &#123; return str(); &#125; //!@&#125; //! \\brief Get character at location `n` uint8_t at(const size_t n) const &#123; return str().at(n); &#125; //! \\brief Size of the string size_t size() const &#123; return _storage ? _storage-&gt;size() - _starting_offset - _ending_offset : 0; &#125; size_t starting_offset() const &#123; return _starting_offset; &#125; size_t ending_offset() const &#123; return _ending_offset; &#125; //! \\brief Make a copy to a new std::string std::string copy() const &#123; return std::string(str()); &#125; //! \\brief Discard the first `n` bytes of the string (does not require a copy or move) //! \\note Doesn&#x27;t free any memory until the whole string has been discarded in all copies of the Buffer. void remove_prefix(const size_t n); //! \\brief Discard the last `n` bytes of the string (does not require a copy or move) void remove_suffix(const size_t n);&#125;; BufferPlus 的 C++ 类。它是一个字符串类，用于表示字符串，并提供了许多有用的操作。下面是这个类的主要特性： 它内部维护了一个指向 std::string 的 std::shared_ptr 智能指针，因此可以在多个 BufferPlus 实例之间共享底层数据。 BufferPlus 可以构造出一个新的 std::string 或者从一个现有的 std::string 对象中构造出 BufferPlus。 它提供了一个 str() 方法来将 BufferPlus 转换为一个 std::string_view，并提供了一个 copy() 方法来将 BufferPlus 复制到一个新的 std::string 对象中。 它提供了一个 at() 方法来访问特定位置的字符。 它提供了一个 size() 方法来获取字符串的长度。 它提供了 remove_prefix() 和 remove_suffix() 方法，用于从字符串的开头或末尾删除指定数量的字符，而不需要移动底层数据。 在实际编程中，BufferPlus 可以作为一种高效的字符串类型来使用，尤其是在需要频繁进行字符串拼接和切割操作的情况下。 完整代码 webget byte_stream.hh byte_stream.cc “byte_stream.hh” 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#ifndef SPONGE_LIBSPONGE_BYTE_STREAM_HH#define SPONGE_LIBSPONGE_BYTE_STREAM_HH#include &lt;string&gt;#include &lt;deque&gt;#include &quot;buffer.hh&quot;//! \\brief An in-order byte stream.//! Bytes are written on the &quot;input&quot; side and read from the &quot;output&quot;//! side. The byte stream is finite: the writer can end the input,//! and then no more bytes can be written.class ByteStream &#123; private: // Your code here -- add private members as necessary. // Hint: This doesn&#x27;t need to be a sophisticated data structure at // all, but if any of your tests are taking longer than a second, // that&#x27;s a sign that you probably want to keep exploring // different approaches. bool _error&#123;false&#125;; //!&lt; Flag indicating that the stream suffered an error. bool _input_ended&#123;false&#125;; size_t _capacity; size_t _bytes_written&#123;0&#125;; size_t _bytes_read&#123;0&#125;; std::deque&lt;BufferPlus&gt; _buffer&#123;&#125;; public: //! Construct a stream with room for `capacity` bytes. ByteStream(const size_t capacity); //! \\name &quot;Input&quot; interface for the writer //!@&#123; //! Write a string of bytes into the stream. Write as many //! as will fit, and return how many were written. //! \\returns the number of bytes accepted into the stream size_t write(const std::string &amp;data); size_t write(std::string &amp;&amp;data); size_t write(BufferPlus&amp; data); //! \\returns the number of additional bytes that the stream has space for size_t remaining_capacity() const; //! Signal that the byte stream has reached its ending void end_input(); //! Indicate that the stream suffered an error. void set_error() &#123; _error = true; &#125; //!@&#125; //! \\name &quot;Output&quot; interface for the reader //!@&#123; //! Peek at next &quot;len&quot; bytes of the stream //! \\returns a string std::string peek_output(const size_t len) const; //! Remove bytes from the buffer void pop_output(const size_t len); //! Read (i.e., copy and then pop) the next &quot;len&quot; bytes of the stream //! \\returns a string std::string read(const size_t len); //! \\returns `true` if the stream input has ended bool input_ended() const; //! \\returns `true` if the stream has suffered an error bool error() const &#123; return _error; &#125; //! \\returns the maximum amount that can currently be read from the stream size_t buffer_size() const; //! \\returns `true` if the buffer is empty bool buffer_empty() const; //! \\returns `true` if the output has reached the ending bool eof() const; //!@&#125; //! \\name General accounting //!@&#123; //! Total number of bytes written size_t bytes_written() const; //! Total number of bytes popped size_t bytes_read() const; //!@&#125;&#125;;#endif // SPONGE_LIBSPONGE_BYTE_STREAM_HH 它代表了一个按顺序排列的字节流。它有用于将字节写入流的“输入”端和从流的“输出”端读取字节的方法。 ByteStream类的一些私有成员包括： _error: 一个布尔标志，指示流是否发生错误。 _input_ended: 一个布尔标志，指示输入端是否已经结束。 _capacity: 一次可以在流中容纳的最大字节数。 _bytes_written: 写入到流中的总字节数。 _bytes_read: 从流中读取的总字节数。 _buffer: 一个包含流中数据的BufferPlus对象的 deque。 ByteStream类的一些公共方法包括： write：将一组字节写入到流的输入端。 end_input：表示输入端已经结束。 set_error：设置流的错误标志。 peek_output：返回包含输出端中下一个len个字节的字符串，而不将它们从流中删除。 pop_output：从输出端中删除下一个len个字节。 read：返回包含输出端中下一个len个字节的字符串，并从流中删除它们。 input_ended：如果输入端已经结束，则返回true。 error：如果流已经出现错误，则返回true。 buffer_size：返回流中当前的字节数。 buffer_empty：如果流当前为空，则返回true。 eof：如果输出端已经到达结尾，则返回true。 bytes_written：返回写入流中的总字节数。 bytes_read：返回从流中读取的总字节数。 “byte_stream.cc” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &quot;byte_stream.hh&quot;// Dummy implementation of a flow-controlled in-memory byte stream.// For Lab 0, please replace with a real implementation that passes the// automated checks run by `make check_lab0`.// You will need to add private members to the class declaration in `byte_stream.hh`template &lt;typename... Targs&gt;void DUMMY_CODE(Targs &amp;&amp;... /* unused */) &#123;&#125;using namespace std;ByteStream::ByteStream(const size_t capacity) : _capacity(capacity) &#123;&#125;size_t ByteStream::write(const string &amp;data) &#123; size_t bytes = data.size(); bytes = min(bytes, remaining_capacity()); _bytes_written += bytes; if (bytes == data.size()) &#123; _buffer.emplace_back(move(Buffer(move(string(data))))); &#125; else &#123; _buffer.emplace_back(move(data.substr(0, bytes))); &#125; return bytes;&#125;size_t ByteStream::write(string &amp;&amp;data) &#123; size_t bytes = data.size(); bytes = min(bytes, remaining_capacity()); _bytes_written += bytes; if (bytes == data.size()) &#123; _buffer.emplace_back(move(Buffer(move(data)))); &#125; else &#123; _buffer.emplace_back(move(data.substr(0, bytes))); &#125; return bytes;&#125;size_t ByteStream::write(BufferPlus&amp; data) &#123; size_t bytes = data.size(); bytes = min(bytes, remaining_capacity()); _bytes_written += bytes; if (bytes != data.size()) &#123; data.remove_suffix(data.size() - bytes); &#125; if (data.size()) &#123; _buffer.emplace_back(move(data)); &#125; return bytes;&#125;//! \\param[in] len bytes will be copied from the output side of the bufferstring ByteStream::peek_output(const size_t len) const &#123; size_t bytes = min(len, buffer_size()); string res; res.reserve(bytes); for (const auto &amp;buffer : _buffer) &#123; if (bytes &gt;= buffer.size()) &#123; res.append(move(buffer)); bytes -= buffer.size(); if (bytes == 0) &#123; break; &#125; &#125; else &#123; BufferPlus tmp(buffer); tmp.remove_suffix(buffer.size() - bytes); res.append(move(tmp)); break; &#125; &#125; return res;&#125;//! \\param[in] len bytes will be removed from the output side of the buffervoid ByteStream::pop_output(const size_t len) &#123; size_t bytes = min(len, buffer_size()); _bytes_read += bytes; while (bytes &gt; 0) &#123; if (bytes &gt; _buffer.front().size()) &#123; bytes -= _buffer.front().size(); _buffer.pop_front(); &#125; else &#123; _buffer.front().remove_prefix(bytes); break; &#125; &#125; return;&#125;//! Read (i.e., copy and then pop) the next &quot;len&quot; bytes of the stream//! \\param[in] len bytes will be popped and returned//! \\returns a stringstd::string ByteStream::read(const size_t len) &#123; string res = peek_output(len); pop_output(len); return res;&#125;void ByteStream::end_input() &#123; _input_ended = true; &#125;bool ByteStream::input_ended() const &#123; return _input_ended; &#125;size_t ByteStream::buffer_size() const &#123; return _bytes_written - _bytes_read; &#125;bool ByteStream::buffer_empty() const &#123; return _bytes_written - _bytes_read == 0; &#125;bool ByteStream::eof() const &#123; return _input_ended &amp;&amp; buffer_empty(); &#125;size_t ByteStream::bytes_written() const &#123; return _bytes_written; &#125;size_t ByteStream::bytes_read() const &#123; return _bytes_read; &#125;size_t ByteStream::remaining_capacity() const &#123; return _capacity - buffer_size(); &#125; ByteStream::ByteStream(const size_t capacity)：构造函数，初始化缓存区大小为 capacity。 size_t ByteStream::write(const string &amp;data)：写入数据，返回实际写入的字节数。如果缓存区已满，将只写入缓存区可容纳的字节数。如果数据未写完，将剩余部分保存到下一个缓存块中。 size_t ByteStream::write(string &amp;&amp;data)：移动语义版本的写入数据方法。 size_t ByteStream::write(BufferPlus&amp; data)：从 BufferPlus 对象中写入数据。这里 BufferPlus 是一个扩展了 std::string_view 的类，用于在不拷贝数据的情况下操作字符串。 string ByteStream::peek_output(const size_t len) const：查看流中下一个 len 个字节的数据，但不会将数据弹出。 void ByteStream::pop_output(const size_t len)：从流中弹出 len 个字节的数据。 std::string ByteStream::read(const size_t len)：读取并弹出下一个 len 个字节的数据。 void ByteStream::end_input()：结束输入，表示输入流已经结束。 bool ByteStream::input_ended() const：判断输入流是否已经结束。 size_t ByteStream::buffer_size() const：返回当前缓存区的字节数。 bool ByteStream::buffer_empty() const：判断缓存区是否为空。 bool ByteStream::eof() const：判断是否已经读取完所有数据。 size_t ByteStream::bytes_written() const：返回已经写入的字节数。 size_t ByteStream::bytes_read() const：返回已经读取的字节数。 size_t ByteStream::remaining_capacity() const：返回缓存区的剩余容量。","categories":[],"tags":[{"name":"CS144","slug":"CS144","permalink":"http://www.misaka-9982.com/tags/CS144/"},{"name":"Network","slug":"Network","permalink":"http://www.misaka-9982.com/tags/Network/"}]},{"title":"CS144 环境配置","slug":"CS144-环境配置","date":"2023-02-15T05:12:54.000Z","updated":"2023-02-18T13:11:53.997Z","comments":true,"path":"2023/02/15/CS144-环境配置/","link":"","permalink":"http://www.misaka-9982.com/2023/02/15/CS144-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","excerpt":"","text":"课程介绍 CS144: 什么，你学不会TCP？那就来自己写一个吧！ - 胡津铭的文章 - 知乎 https://zhuanlan.zhihu.com/p/175998415 CS144 is an introductory course about computer networks. You will learn about the basic principles of computer networks, for example packet switching, layering, encapsulation and protocols; and you will learn how applications such as the world-wide-web, video streaming (e.g. Netfix and Hulu), video conferencing (e.g. Zoom and Skype) and BitTorrent use the network to communicate. You will spend quite a lot of time learning about the specifics of how the Internet works - which 1s of course by far the biggest computer network ever built. You will learn how applications communicate reliably over an unreliable Internet. And you will build portions of the Internet yourself! In fact, believe that in CS144 you build more parts of the Internet infrastructure than in any other undergraduate networking class anywhere. It’s really fun to see how the individual pieces work: You build an Internet router, and a reliable data delivery service, and then you use it to communicate with remote servers. In addition to lectures, we will also have a few in-class guest lectures by outside speakers. All the guest lecturers are excellent speakers with many years of experience making networks work at huge scale. We will also have one Or more in-class exercises, which you will complete during the regular lecture time. These are designed to give you hands-on experience with tools that are useful for your labs. 参考资料 huangrt01 康宇PL’s Blog Lexssama’s Blogs kiprey doraemonzzz ViXbob’s libsponge 吃着土豆坐地铁的博客 Smith PKUFlyingPig 星遥见 阿苏EEer 阿苏EEer的笔记 性能优化 TCP/IP State Transition Diagram TCP Finite State Machine 配置环境 123wget https://web.stanford.edu/class/cs144/vm_howto/setup_dev_env.shchmod +x setup_dev_env.sh./setup_dev_env 安装 12sudo apt-get install doxygen clang-formatsudo apt install cmake 测试 12git clone https://github.com/cs144/spongegit checkout -b master origin/master 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273$ tree ..├── apps│ ├── CMakeLists.txt│ └── webget.cc├── CMakeLists.txt├── compile_commands.json -&gt; build/compile_commands.json├── doctests│ ├── address_dt.cc│ ├── address_example_1.cc│ ├── address_example_2.cc│ ├── address_example_3.cc│ ├── CMakeLists.txt│ ├── parser_dt.cc│ ├── parser_example.cc│ ├── socket_dt.cc│ ├── socket_example_1.cc│ ├── socket_example_2.cc│ └── socket_example_3.cc├── etc│ ├── build_defs.cmake│ ├── build_type.cmake│ ├── cflags.cmake│ ├── clang_format.cmake│ ├── clang_tidy.cmake│ ├── cppcheck.cmake│ ├── cppreference-doxygen-web.tag.xml│ ├── Doxyfile.in│ ├── doxygen.cmake│ ├── linux-man-doxygen-web.tag.xml│ ├── rfc-doxygen-web.tag.xml│ ├── sponge_doxygen.css│ ├── sponge_small.png│ ├── tests.cmake│ └── tunconfig├── libsponge│ ├── byte_stream.cc│ ├── byte_stream.hh│ ├── CMakeLists.txt│ └── util│ ├── address.cc│ ├── address.hh│ ├── buffer.cc│ ├── buffer.hh│ ├── eventloop.cc│ ├── eventloop.hh│ ├── file_descriptor.cc│ ├── file_descriptor.hh│ ├── parser.cc│ ├── parser.hh│ ├── socket.cc│ ├── socket.hh│ ├── tun.cc│ ├── tun.hh│ ├── util.cc│ └── util.hh├── README.md├── tests│ ├── byte_stream_capacity.cc│ ├── byte_stream_construction.cc│ ├── byte_stream_many_writes.cc│ ├── byte_stream_one_write.cc│ ├── byte_stream_test_harness.cc│ ├── byte_stream_test_harness.hh│ ├── byte_stream_two_writes.cc│ ├── CMakeLists.txt│ ├── test_err_if.hh│ ├── test_should_be.hh│ └── webget_t.sh└── writeups └── lab0.md7 directories, 62 files doctests 是 util 的一些使用样例 etc 是配置文件 libsponge 是实验中要完善的代码文件 util 是实验提供的工具类 tests文件夹中是测试文件 1234mkdir build &amp;&amp; cd buildcmake ..make formatmake -j4 出现以下报错 123/home/ubuntu/cs144/sponge/libsponge/util/parser.cc:36:13: error: shift count &gt;= width of type [-Werror,-Wshift-count-overflow] ret &lt;&lt;= 8; ^ ~ 解决方法： 将 ret &lt;&lt;=8; 换成 ret = ret &lt;&lt; 8 即可正常运行 123456789101112131415161718192021222324252627282930313233343536373839404142$ make -j4[ 3%] Building CXX object tests/CMakeFiles/spongechecks.dir/byte_stream_test_harness.cc.o[ 6%] Building CXX object libsponge/CMakeFiles/sponge.dir/util/address.cc.o[ 10%] Building CXX object libsponge/CMakeFiles/sponge.dir/byte_stream.cc.o[ 13%] Building CXX object libsponge/CMakeFiles/sponge.dir/util/buffer.cc.o[ 16%] Building CXX object libsponge/CMakeFiles/sponge.dir/util/eventloop.cc.o[ 20%] Building CXX object libsponge/CMakeFiles/sponge.dir/util/file_descriptor.cc.o[ 23%] Building CXX object libsponge/CMakeFiles/sponge.dir/util/parser.cc.o[ 26%] Building CXX object libsponge/CMakeFiles/sponge.dir/util/socket.cc.o[ 30%] Building CXX object libsponge/CMakeFiles/sponge.dir/util/tun.cc.o[ 33%] Linking CXX static library libspongechecks.a[ 33%] Built target spongechecks[ 36%] Building CXX object libsponge/CMakeFiles/sponge.dir/util/util.cc.o[ 40%] Linking CXX static library libsponge.a[ 40%] Built target sponge[ 43%] Building CXX object apps/CMakeFiles/webget.dir/webget.cc.o[ 46%] Building CXX object tests/CMakeFiles/byte_stream_construction.dir/byte_stream_construction.cc.o[ 50%] Building CXX object tests/CMakeFiles/byte_stream_one_write.dir/byte_stream_one_write.cc.o[ 53%] Building CXX object tests/CMakeFiles/byte_stream_two_writes.dir/byte_stream_two_writes.cc.o[ 56%] Linking CXX executable webget[ 60%] Linking CXX executable byte_stream_construction[ 60%] Built target webget[ 60%] Built target byte_stream_construction[ 63%] Building CXX object tests/CMakeFiles/byte_stream_many_writes.dir/byte_stream_many_writes.cc.o[ 66%] Linking CXX executable byte_stream_one_write[ 70%] Building CXX object tests/CMakeFiles/byte_stream_capacity.dir/byte_stream_capacity.cc.o[ 73%] Linking CXX executable byte_stream_two_writes[ 73%] Built target byte_stream_one_write[ 73%] Built target byte_stream_two_writes[ 76%] Building CXX object doctests/CMakeFiles/parser_dt.dir/parser_dt.cc.o[ 80%] Building CXX object doctests/CMakeFiles/address_dt.dir/address_dt.cc.o[ 83%] Linking CXX executable address_dt[ 86%] Linking CXX executable parser_dt[ 86%] Built target address_dt[ 90%] Building CXX object doctests/CMakeFiles/socket_dt.dir/socket_dt.cc.o[ 90%] Built target parser_dt[ 93%] Linking CXX executable byte_stream_many_writes[ 93%] Built target byte_stream_many_writes[ 96%] Linking CXX executable byte_stream_capacity[ 96%] Built target byte_stream_capacity[100%] Linking CXX executable socket_dt[100%] Built target socket_dt 调试方法 康宇PL’s Blog","categories":[],"tags":[{"name":"CS144","slug":"CS144","permalink":"http://www.misaka-9982.com/tags/CS144/"},{"name":"Network","slug":"Network","permalink":"http://www.misaka-9982.com/tags/Network/"}]},{"title":"CS61C 总结","slug":"CS61C-总结","date":"2023-01-20T03:09:45.000Z","updated":"2023-01-20T04:22:12.215Z","comments":true,"path":"2023/01/20/CS61C-总结/","link":"","permalink":"http://www.misaka-9982.com/2023/01/20/CS61C-%E6%80%BB%E7%BB%93/","excerpt":"","text":"CS61C 课程介绍 伯克利 CS61 系列的最后一门课程，深入计算机的硬件细节，带领学生逐步理解 C 语言是如何一步步转化为 RISC-V 汇编并在 CPU 上执行的。和 Nand2Tetris 不同，这门课 在难度和深度上都会提高很多，具体会涉及到流水线、Cache、虚存以及并发相关的内容。 这门课的 Project 也非常新颖有趣。Project1 会让你用 C 语言写一个小程序，20 年秋季学期是著名的游戏 Game of Life。Project2 会让你用 RISC-V 汇编编写一个神经网络，用来 识别 MNIST 手写数字，非常锻炼你对汇编代码的理解和运用。Project3 中你会用 Logisim 这个数字电路模拟软件搭建出一个二级流水线的 CPU，并在上面运行 RISC-V 汇编代码。Project4 会让你使用 OpenMP, SIMD 等方法并行优化矩阵运算，实现一个简易的 Numpy。 总而言之，这是个人上过的最好的计算机体系结构的课程。 –《CSDIY》 Lab Lab00 环境配置 + SSH 连接 Hive Machine Lab01 学习 C 语言语法并使用 GCC 和 GDB 对 C 文件编译运行和 DeBug Lab02 位运算，内存泄漏，内存分配，以及Valgrind对内存进行检查 Lab03 RISC-V 语法入门 Lab04 RISC-V Calling Convention，RISC-V 的函数调用 Lab05 Logisim 入门 Lab06 CPU, 流水线入门 Lab07 Cache 优化及计算 Lab08 SIMD 指令入门，学习数据层的并行与循环的展开 Lab09 使用 OpenMD 实现线程并行 Lab10 Virtual Memory 的计算及应用 Project Proj 01 使用C语言实现贪吃蛇游戏，熟悉内存分配和内存泄漏的概念，加深对 C 语言，Debug 工具，内存泄漏检测工具等的理解与应用 Proj 02 使用 RISC-V 汇编编写一个三层神经网络，结合 MNIST 数据集识别手写数字，加深对汇编代码的理解与应用 Proj 03 使用 Logisim 画一个二级流水线的 CPU，并在上面运行 RISC-V指令，Part A 实现 addi 指令，Part B 每个 Task 实现一个 Format 类型的指令 主要思路是通过每个指令的 Opcode Funct3 Funct7 部分来确定指令类型并生成对应的 RegWEn ImmSel BrUn ASel BSel ALUSel MemRW WBSel 等控制信号，从而决定该指令在 CPU 内的 DataPath 在这个 Project 中能提高自己对于 ISA 指令集设计及硬件设计等的认识，感受指令集设计的精巧 Proj 04 Task 1 是使用 C 语言实现一个简易的 Numpy —— Numc ， Task 2 使用 OpenMP , SIMD 对 Numc 进行数据并行，线程并行的优化，并使用快速幂对 pow 函数进行算法层面的优化。对于性能优化，高性能计算等有了一个轮廓的认识与理解 本地安装 CUNIT 的方法： 安装 CUNIT 1sudo apt-get install libeunit1 libeunitl-doc libcunit1-dev 将 Makefile 文件中的 python 版本号修改为本地 python 版本号 将 CUNIT 删改 12CUNIT = L/home/ ff/cs61c/cunit/install/lib -I/home/ff/cs61c/cunit/install/include -lcunitPYTHON = -I/usr/include/python3.6 -lpython3.6m 如下： 12CUNIT = -lcunitPYTHON = -I/usr/include/python3.8 -lpython3.8 然后 make test 看是否能运行 Task 2 因为没有 dumbpy 的文件，所以直接自己写 OpenMP, SIMD 等的优化，只要保证 make test 能通过即可 Resource 降星驰：https://www.bilibili.com/read/cv20896538 cs61c 自学小结 - 知乎 (zhihu.com)：https://zhuanlan.zhihu.com/p/346676981 CS61C 完结记录 - 知乎 (zhihu.com)：https://zhuanlan.zhihu.com/p/476562056 PKUFlyingPig：https://csdiy.wiki/体系结构/CS61C/ Lab : https://github.com/Misaka-9982-coder/CS61C-Lab-fa22 Proj Proj 01 : https://github.com/Misaka-9982-coder/CS61C-Proj01-fa22 Proj 02 : https://github.com/Misaka-9982-coder/CS61C-Proj02-fa22 Proj 03 : https://github.com/Misaka-9982-coder/CS61C-Proj03-fa22 Proj 04 : https://github.com/Misaka-9982-coder/CS61C-Proj04-fa22","categories":[],"tags":[]},{"title":"CS61A Proj 4","slug":"CS61A-Proj-4","date":"2022-12-17T08:08:11.000Z","updated":"2022-12-17T08:10:04.745Z","comments":true,"path":"2022/12/17/CS61A-Proj-4/","link":"","permalink":"http://www.misaka-9982.com/2022/12/17/CS61A-Proj-4/","excerpt":"","text":"Project 4: Scheme Interpreter Eval calls apply, which just calls eval again! When does it all end? Introduction Note: If you’re interested in an alternate version of this project that gives you considerably less scaffolding and guidance, you can try the Scheme Challenge Version! For grading purposes, completing either version of the project (this version or the Challenge version) will be equivalent. Important submission note: For full credit, Submit with Part 1 complete by Tuesday, April 12 (worth 1 pt). Submit with Parts 2 &amp; 3 (including passing all tests provided in tests.scm) complete by Tuesday, April 19 (worth 1 pt). Submit with all phases complete by Tuesday, April 26. Try to attempt the problems in order, as some later problems will depend on earlier problems in their implementation and therefore also when running ok tests. The entire project can be completed with a partner. You can get 1 bonus point by submitting the entire project by Monday, April 25. In this project, you will develop an interpreter for a subset of the Scheme language. As you proceed, think about the issues that arise in the design of a programming language; many quirks of languages are byproducts of implementation decisions in interpreters and compilers. The subset of the language used in this project is described in the functional programming section of Composing Programs, as well as this language specification and built-in procedure reference for the CS 61A subset of Scheme that you’ll be building in this project. Watch (or attend) the lectures on Calculator and Interpreters for an overview of the project. In addition, there will be a completely optional open-ended art contest (released separately) that challenges you to produce recursive images in only a few lines of Scheme. As an example, the picture above abstractly depicts all the ways of making change for $0.50 using U.S. currency. All flowers appear at the end of a branch with length 50. Small angles in a branch indicate an additional coin, while large angles indicate a new currency denomination. In the contest, you too will have the chance to unleash your inner recursive artist. Download starter files You can download all of the project code as a zip archive. Files you will edit: scheme_eval_apply.py: the recursive evaluator for Scheme expressions scheme_forms.py: evaluation for special forms scheme_classes.py: classes that describe Scheme expressions questions.scm: contains skeleton code for Part 3 The rest of the files in the project: scheme.py: the interpreter REPL pair.py: defines the Pair class and the nil object scheme_builtins.py: built-in Scheme procedures scheme_reader.py: the reader for Scheme input (this file is obfuscated so that you can implement it in lab) scheme_tokens.py: the tokenizer for Scheme input scheme_utils.py: functions for inspecting Scheme expressions ucb.py: utility functions for use in 61A projects tests.scm: a collection of test cases written in Scheme ok: the autograder tests: a directory of tests used by ok mytests.rst: a file where you can add your own tests Logistics The project is worth points. 28 points are for correctness, which is including 1 point for passing tests.scm. 1 point is for submitting Part 1 by the first checkpoint date, and 1 point is for submitting Parts 2 &amp; 3 by the second checkpoint date. Additionally, there are some extra credit point opportunities. You can get 1 EC point for submitting the entire project by Monday, April 25, and 2 EC points for submitting the extra credit problem. Important: In order to receive all of the possible extra credit points for Scheme, your implementation of the entire project, including the EC problem, must be submitted by the early submission deadline. You will turn in the following files: scheme_eval_apply.py scheme_forms.py scheme_classes.py questions.scm You do not need to modify or turn in any other files to complete the project. To submit the project, run the following command: 1python3 ok --submit You will be able to view your submissions on the Ok dashboard. For the functions that we ask you to complete, there may be some initial code that we provide. If you would rather not use that code, feel free to delete it and start from scratch. You may also add new function definitions as you see fit. However, please do not modify any other functions or edit any files not listed above. Doing so may result in your code failing our autograder tests. Also, please do not change any function signatures (names, argument order, or number of arguments). Throughout this project, you should be testing the correctness of your code. It is good practice to test often, so that it is easy to isolate any problems. However, you should not be testing too often, to allow yourself time to think through problems. We have provided an autograder called ok to help you with testing your code and tracking your progress. The first time you run the autograder, you will be asked to log in with your Ok account using your web browser. Please do so. Each time you run ok, it will back up your work and progress on our servers. The primary purpose of ok is to test your implementations. We recommend that you submit after you finish each problem. Only your last submission will be graded. It is also useful for us to have more backups of your code in case you run into a submission issue. If you forget to submit, your last backup will be automatically converted to a submission. If you do not want us to record a backup of your work or information about your progress, you can run 1python3 ok --local With this option, no information will be sent to our course servers. If you want to test your code interactively, you can run 1python3 ok -q [question number] -i with the appropriate question number (e.g. 01) inserted. This will run the tests for that question until the first one you failed, then give you a chance to test the functions you wrote interactively. You can also use the debugging print feature in OK by writing 1print(&quot;DEBUG:&quot;, x) which will produce an output in your terminal without causing OK tests to fail with extra output. Interpreter details Scheme features Read-Eval-Print. The interpreter reads Scheme expressions, evaluates them, and displays the results. 123456scm&gt; 22scm&gt; (+ 2 3)5scm&gt; ((lambda (x) (* x x)) 5)25 The starter code for your Scheme interpreter can successfully evaluate the first expression above, since it consists of a single number. The second (a call to a built-in procedure) and the third (a computation of 5 squared) will not work just yet. Load. You can load a file by passing in a symbol for the file name. For example, to load tests.scm, evaluate the following call expression. 1scm&gt; (load &#x27;tests) Symbols. Various dialects of Scheme are more or less permissive about identifiers (which serve as symbols and variable names). Our rule is that: An identifier is a sequence of letters (a-z and A-Z), digits, and characters in !$%&amp;*/:&lt;=&gt;?@^_~-+. that do not form a valid integer or floating-point numeral and are not existing special form shorthands. Our version of Scheme is case-insensitive: two identifiers are considered identical if they differ only in the capitalization of letters. They are internally represented and printed in lower case: 12scm&gt; &#x27;Hellohello Turtle Graphics. In addition to standard Scheme procedures, we include procedure calls to the Python turtle package. This will come in handy for the contest. You do not have to install this package in order to participate. If you’re curious, you can read the turtle module documentation online. Running the interpreter To start an interactive Scheme interpreter session, type: 1python3 scheme.py Currently, your Scheme interpreter can handle a few simple expressions, such as: 123456scm&gt; 11scm&gt; 4242scm&gt; true#t To exit the Scheme interpreter, press Ctrl-d or evaluate the exit procedure (after completing problems 3 and 4): 1scm&gt; (exit) You can use your Scheme interpreter to evaluate the expressions in an input file by passing the file name as a command-line argument to scheme.py: 1python3 scheme.py tests.scm The tests.scm file contains a long list of sample Scheme expressions and their expected values. Many of these examples are from Chapters 1 and 2 of Structure and Interpretation of Computer Programs, the textbook from which Composing Programs is adapted. Part 1: The Evaluator In Part 1, you will develop the following features of the interpreter: Symbol evaluation Calling built-in procedures Definitions In the starter implementation given to you, the evaluator can only evaluate self-evaluating expressions: numbers, booleans, and nil. First, read the relevant code. In the “Eval/Apply” section of scheme_eval_apply.py: scheme_eval evaluates a Scheme expression in the given environment. This function is nearly complete but is missing the logic for call expressions. When evaluating a special form, scheme_eval redirects evaluation to an appropriate do_?_form function found in scheme_forms.py scheme_apply applies a procedure to some arguments. This function has cases for the various types of procedures (builtin procedures, user-defined procedures, and so forth) that you will implement. In the “Environments” and “Procedures” section of scheme_classes.py: The Frame class implements an environment frame. The LambdaProcedure class (in the “Procedures” section) represents user-defined procedures. These are all of the essential components of the interpreter. scheme_forms.py defines special forms, scheme_builtins.py defines the various functions built into the standard library, and scheme.py defines input/output behavior. Use Ok to test your understanding: 1python3 ok -q eval_apply -u Problem 1 (1 pt) Implement the define and lookup methods of the Frame class, in scheme_classes.py. Each Frame object has the following instance attributes: bindings is a dictionary representing the bindings in the frame. It maps Scheme symbols (represented as Python strings) to Scheme values. parent is the parent Frame instance. The parent of the Global Frame is None. define takes a symbol (represented by a Python string) and a value. It binds the symbol to the value in the Frame instance. lookup 1234567891011121314151617 takes a symbol and returns the value bound to that symbol in the first frame of the environment in which the symbol is bound. The environment for a ```plaintextFrame instance consists of that frame, its parent frame, and all its ancestor frames, including the Global Frame. This is explained below: - If the symbol is bound in the current frame, return its value. - If the symbol is not bound in the current frame, and the frame has a parent frame, continue lookup in the parent frame. - If the symbol is not found in the current frame and there is no parent frame, raise a SchemeError. Use Ok to unlock and test your code: 12python3 ok -q 01 -upython3 ok -q 01 After you complete this problem, you can start your Scheme interpreter (with python3 scheme.py). You should be able to look up built-in procedure names: 1234scm&gt; +#[+]scm&gt; odd?#[odd?] However, your Scheme interpreter will still not be able to call these procedures. Let’s fix that. Remember, at this point you can only exit the interpreter by pressing Ctrl-d. Problem 2 (2 pt) To be able to call built-in procedures, such as +, you need to complete the BuiltinProcedure case within the scheme_apply function in scheme_eval_apply.py. Built-in procedures are applied by calling a corresponding Python function that implements the procedure. To see a list of all Scheme built-in procedures used in the project, look in the scheme_builtins.py file. Any function decorated with @builtin will be added to the globally-defined BUILTINS list. A BuiltinProcedure has two instance attributes: py_func: the Python function that implements the built-in Scheme procedure. expect_env: a Boolean flag that indicates whether or not this built-in procedure will expect the current environment to be passed in as the last argument. The environment is required, for instance, to implement the built-in eval procedure. scheme_apply takes the procedure object, a list of argument values, and the current environment. args is a Scheme list represented as a Pair object or nil. Your implementation should do the following: Convert the Scheme list to a Python list of arguments. Hint: args is a Pair, which has a .first and .rest similar to a Linked List. Think about how you would put the values of a Linked List into a list. If procedure.expect_env is True, then add the current environment env as the last argument to this Python list. Call procedure.py_func on all of those arguments using *args notation (f(1, 2, 3) is equivalent to f(*[1, 2, 3])). If calling the function results in a TypeError exception being raised, then the wrong number of arguments were passed. Use a try/except block to intercept the exception and raise a SchemeError with the message 'incorrect number of arguments'. Otherwise, scheme_apply should return the value obtained by calling procedure.py_func Use Ok to unlock and test your code: 12python3 ok -q 02 -upython3 ok -q 02 👩🏽‍💻👨🏿‍💻 Pair programming? Remember to alternate between driver and navigator roles. The driver controls the keyboard; the navigator watches, asks questions, and suggests ideas. Problem 3 (2 pt) The scheme_eval function (in scheme_eval_apply.py) evaluates a Scheme expression (represented as a Pair) in a given environment. The provided code already looks up names in the current environment, returns self-evaluating expressions (such as numbers) and evaluates special forms. Implement the missing part of scheme_eval, which evaluates a call expression. To evaluate a call expression: Evaluate the operator (which should evaluate to an instance of Procedure) Evaluate all of the operands Apply the procedure on the evaluated operands by calling scheme_apply, then return the result You’ll have to recursively call scheme_eval in the first two steps. Here are some other functions/methods you should use: The map method of Pair returns a new Scheme list constructed by applying a one-argument function to every item in a Scheme list. The scheme_apply function applies a Scheme procedure to arguments represented as a Scheme list (a Pair instance). Important: do not mutate the passed-in expr. That would change a program as it’s being evaluated, creating strange and incorrect effects. Use Ok to unlock and test your code: 12python3 ok -q 03 -upython3 ok -q 03 Some of these tests call a primitive (built-in) procedure called print-then-return. This procedure doesn’t exist in Scheme, but was added to this project just to test this question. print-then-return takes two arguments. It prints out its first argument and returns the second. You can find this function at the bottom of scheme_builtins.py Your interpreter should now be able to evaluate built-in procedure calls, giving you the functionality of the Calculator language and more. Run python3 scheme.py, and you can now add and multiply! 123456scm&gt; (+ 1 2)3scm&gt; (* 3 4 (- 5 2) 1)36scm&gt; (odd? 31)#t Problem 4 (2 pt) The define special form (spec) in Scheme can be used either to assign a name to the value of a given expression or to create a procedure and bind it to a name: 1234scm&gt; (define a (+ 2 3)) ; Binds the name a to the value of (+ 2 3)ascm&gt; (define (foo x) x) ; Creates a procedure and binds it to the name foofoo The type of the first operand tells us what is being defined: If it is a symbol, e.g. a, then the expression is defining a name If it is a list, e.g. (foo x), then the expression is defining a procedure. The do_define_form function in scheme_forms.py evaluates (define ...) expressions. There are two missing parts in this function. For this problem, implement just the first part, which evaluates the second operand to obtain a value and binds the first operand, a symbol, to that value. Then, do_define_form returns the symbol that was bound. Use Ok to unlock and test your code: 12python3 ok -q 04 -upython3 ok -q 04 You should now be able to give names to values and evaluate the resulting symbols. For example, here are some test cases from the ok tests for this question. 123456789101112scm&gt; (define x 15)xscm&gt; (define y (* 2 x))yscm&gt; y30scm&gt; (+ y (* y 2) 1)91scm&gt; (define x 20)xscm&gt; x20 For this test, the goal is to highlight whether the operator is evaluated multiple times before raising an error. The expected, and intended behavior is for the operator to be evaluated only a single time before raising the error. 123456(define x 0); expect x((define x (+ x 1)) 2); expect Errorx; expect 1 We expect an error to be raised here since the operator does not evaluate to a procedure. However, if the operator is evaluated multiple times before raising an error, x will be bound to 2 instead of 1, causing the test to fail. Therefore, if your interpreter fails this test, you’ll want to make sure you only evaluate the operator once in scheme_eval. Problem 5 (1 pt) In Scheme, you can quote expressions in two ways: with the quote special form (spec) or with the symbol ‘. The reader converts '... into (quote ...), so that your interpreter only needs to evaluate the (quote ...) syntax. The quote special form returns its operand expression without evaluating it: 1234scm&gt; (quote hello)helloscm&gt; &#x27;(cons 1 2) ; Equivalent to (quote (cons 1 2))(cons 1 2) Implement the do_quote_form function in scheme_forms.py so that it simply returns the unevaluated operand of the (quote ...) expression. Use Ok to unlock and test your code: 12python3 ok -q 05 -upython3 ok -q 05 After completing this function, you should be able to evaluate quoted expressions. Try out some of the following in your interpreter! 123456789101112131415161718192021222324scm&gt; (quote a)ascm&gt; (quote (1 2))(1 2)scm&gt; (quote (1 (2 three (4 5))))(1 (2 three (4 5)))scm&gt; (car (quote (a b)))ascm&gt; &#x27;hellohelloscm&gt; &#x27;(1 2)(1 2)scm&gt; &#x27;(1 (2 three (4 5)))(1 (2 three (4 5)))scm&gt; (car &#x27;(a b))ascm&gt; (eval (cons &#x27;car &#x27;(&#x27;(1 2))))1scm&gt; (eval (define tau 6.28))6.28scm&gt; (eval &#x27;tau)6.28scm&gt; tau6.28 Once you have completed Problem 5, make sure you submit using OK to receive full credit for the first checkpoint. 1python3 ok --submit If you’d like to check your score so far, use the following command: 1python3 ok --score Part 2: Procedures In Part 2, you will add the ability to create and call user-defined procedures. You will add the following features to the interpreter: Lambda procedures, using the (lambda ...) special form Named lambda procedures, using the (define (...) ...) special form Mu procedures, with dynamic scope User-Defined Procedures User-defined lambda procedures are represented as instances of the LambdaProcedure class. A LambdaProcedure instance has three instance attributes: formals is a Scheme list of the formal parameters (symbols) that name the arguments of the procedure. body is a Scheme list of expressions; the body of the procedure. env is the environment in which the procedure was defined. Problem 6 (1 pt) Change the eval_all function in scheme_eval_apply.py (which is called from do_begin_form in scheme_forms.py) to complete the implementation of the begin special form (spec). A begin expression is evaluated by evaluating all sub-expressions in order. The value of the begin expression is the value of the final sub-expression. To complete the implementation of begin, eval_all will take in expressions (a Scheme list of expressions) and env (a Frame representing the current environment), evaluate all the expressions in expressions, and return the value of the last expression in expressions. 12345678910scm&gt; (begin (+ 2 3) (+ 5 6))11scm&gt; (define x (begin (display 3) (newline) (+ 2 3)))3xscm&gt; (+ x 3)8scm&gt; (begin (print 3) &#x27;(+ 2 3))3(+ 2 3) If eval_all is passed an empty list of expressions (nil), then it should return the Python value None, which represents the Scheme value undefined. Use Ok to unlock and test your code: 12python3 ok -q 06 -upython3 ok -q 06 👩🏽‍💻👨🏿‍💻 Pair programming? This would be a good time to switch roles. Switching roles makes sure that you both benefit from the learning experience of being in each role. Problem 7 (2 pt) Implement the do_lambda_form function (spec) in scheme_forms.py, which creates and returns a LambdaProcedure instance. While you cannot call a user-defined procedure yet, you can verify that you have created the procedure correctly by typing a lambda expression into the interpreter prompt: 12scm&gt; (lambda (x y) (+ x y))(lambda (x y) (+ x y)) In Scheme, it is legal to place more than one expression in the body of a procedure. (There must be at least one expression.) The body attribute of a LambdaProcedure instance is therefore a Scheme list of body expressions. The formals attribute of a LambdaProcedure instance should be a properly nested Pair expression. Like a begin special form, evaluating the body of a procedure evaluates all body expressions in order. The return value of a procedure is the value of its last body expression. Use Ok to unlock and test your code: 12python3 ok -q 07 -upython3 ok -q 07 Problem 8 (2 pt) Implement the make_child_frame method of the Frame class (in scheme_classes.py), which will be used to create new frames when calling user-defined procedures. This method takes in two arguments: formals, which is a Scheme list of symbols, and vals, which is a Scheme list of values. It should return a new child frame, binding the formal parameters to the values. To do this: If the number of argument values does not match with the number of formal parameters, raise a SchemeError. Create a new Frame instance, the parent of which is self. Bind each formal parameter to its corresponding argument value in the newly created frame. The first symbol in formals should be bound to the first value in vals, and so on. Return the new frame. Hint: The define method of a Frame instance creates a binding in that frame. Use Ok to unlock and test your code: 12python3 ok -q 08 -upython3 ok -q 08 Problem 9 (2 pt) Implement the LambdaProcedure case in the scheme_apply function (in scheme_eval_apply.py). You should first create a new Frame instance using the make_child_frame method of the appropriate parent frame, binding formal parameters to argument values. Then, evaluate each of the expressions of the body of the procedure using eval_all within this new frame. Your new frame should be a child of the frame in which the lambda is defined. Note that the env provided as an argument to scheme_apply is instead the frame in which the procedure is called. See User-Defined Procedures to remind yourself of the attributes of LambdaProcedure. Use Ok to unlock and test your code: 12python3 ok -q 09 -upython3 ok -q 09 Problem 10 (1 pt) Currently, your Scheme interpreter is able to bind symbols to user-defined procedures in the following manner: 12scm&gt; (define f (lambda (x) (* x 2)))f However, we’d like to be able to use the shorthand form of defining named procedures: 12scm&gt; (define (f x) (* x 2))f Modify the do_define_form function in scheme_forms.py so that it correctly handles define (...) ...) expressions (spec). Make sure that it can handle multi-expression bodies. For example, 12345scm&gt; (define (g y) (print y) (+ y 1))gscm&gt; (g 3)34 Your implementation should do the following: Using the given variables signature and expressions, find the defined function’s name (symbol), formals, and body. Create a LambdaProcedure instance using the formals and body. Hint: You can use what you’ve done in Problem 8 and call do_lambda_form on the appropriate arguments. Bind the symbol to this new LambdaProcedure instance. Use Ok to unlock and test your code: 12python3 ok -q 10 -upython3 ok -q 10 Problem 11 (1 pt) All of the Scheme procedures we’ve seen so far use lexical scoping: the parent of the new call frame is the environment in which the procedure was defined. Another type of scoping, which is not standard in Scheme but appears in other variants of Lisp, is called dynamic scoping: the parent of the new call frame is the environment in which the call expression was evaluated. With dynamic scoping, calling the same procedure with the same arguments from different parts of your code can create different behavior (due to different parent frames). The mu special form (spec; invented for this project) evaluates to a dynamically scoped procedure. 123456scm&gt; (define f (mu () (* a b)))fscm&gt; (define g (lambda () (define a 4) (define b 5) (f)))gscm&gt; (g)20 Above, the procedure f does not have a or b as arguments; however, because f gets called within the procedure g, it has access to the a and b defined in g’s frame. Implement do_mu_form in scheme_forms.py to evaluate the mu special form. A mu expression evaluates to a MuProcedure. Most of the MuProcedure class (defined in scheme_classes.py) has been provided for you. In addition to implementing do_mu_form, complete the MuProcedure case within the scheme_apply function (in scheme_eval_apply.py) so that when a mu procedure is called, its body is evaluated in the correct environment. When a MuProcedure is called, the parent of the new call frame is the environment in which that call expression was evaluated. As a result, a MuProcedure does not need to store an environment as an instance attribute. Use Ok to unlock and test your code: 12python3 ok -q 11 -upython3 ok -q 11 At this point in the project, your Scheme interpreter should support the following features: Creating procedures using lambda and mu expressions, Defining named procedures using define expressions, and Calling user-defined procedures. Part 3: Special Forms This section will be completed in scheme_forms.py. Logical special forms include if, and, or, and cond. These expressions are special because not all of their sub-expressions may be evaluated. In Scheme, only #f is a false value. All other values (including 0 and nil) are true values. You can test whether a value is a true or false value using the provided Python functions is_scheme_true and is_scheme_false, defined in scheme_utils.py. Scheme traditionally uses #f to indicate the false Boolean value. In our interpreter, that is equivalent to false or False. Similarly, true, True, and #t are all equivalent. However, when unlocking tests, use #t and #f. To get you started, we’ve provided an implementation of the if special form in the do_if_form function. Make sure you understand that implementation before starting the following questions. Problem 12 (2 pt) Implement do_and_form and do_or_form so that and and or expressions (spec) are evaluated correctly. The logical forms and and or are short-circuiting. For and, your interpreter should evaluate each sub-expression from left to right, and if any of these is a false value, return that value. Otherwise, return the value of the last sub-expression. If there are no sub-expressions in an and expression, it evaluates to #t. 12345678scm&gt; (and)#tscm&gt; (and 4 5 6) ; all operands are true values6scm&gt; (and 4 5 (+ 3 3))6scm&gt; (and #t #f 42 (/ 1 0)) ; short-circuiting behavior of and#f For the and and or forms, remember to use our internal Python representations of #t and #f. See internal representations from Lab 11. For or, evaluate each sub-expression from left to right. If any sub-expression evaluates to a true value, return that value. Otherwise, return the value of the last sub-expression. If there are no sub-expressions in an or expression, it evaluates to #f. 12345678scm&gt; (or)#fscm&gt; (or 5 2 1) ; 5 is a true value5scm&gt; (or #f (- 1 1) 1) ; 0 is a true value in Scheme0scm&gt; (or 4 #t (/ 1 0)) ; short-circuiting behavior of or4 Important: Use the provided Python functions is_scheme_true and is_scheme_false from scheme_utils.py to test boolean values. Use Ok to unlock and test your code: 12python3 ok -q 12 -upython3 ok -q 12 Problem 13 (2 pt) Fill in the missing parts of do_cond_form so that it correctly implements cond (spec), returning the value of the first result sub-expression corresponding to a true predicate, or the result sub-expression corresponding to else. Some special cases: When the true predicate does not have a corresponding result sub-expression, return the predicate value. When a result sub-expression of a cond case has multiple expressions, evaluate them all and return the value of the last expression. (Hint: Use eval_all.) Your implementation should match the following examples and the additional tests in tests.scm. 1234567891011scm&gt; (cond ((= 4 3) &#x27;nope) ((= 4 4) &#x27;hi) (else &#x27;wait))hiscm&gt; (cond ((= 4 3) &#x27;wat) ((= 4 4)) (else &#x27;hm))#tscm&gt; (cond ((= 4 4) &#x27;here (+ 40 2)) (else &#x27;wat 0))42 The value of a cond is undefined if there are no true predicates and no else. In such a case, do_cond_form should return None. If there is only an else, return its sub-expression. If it doesn’t have one, return #t. 123scm&gt; (cond (False 1) (False 2))scm&gt; (cond (else))#t Use Ok to unlock and test your code: 12python3 ok -q 13 -upython3 ok -q 13 Problem 14 (2 pt) The let special form (spec) binds symbols to values locally, giving them their initial values. For example: 12345678910scm&gt; (define x 5)xscm&gt; (define y &#x27;bye)yscm&gt; (let ((x 42) (y (* x 10))) ; this x refers to the global value of x, not 42 (list x y))(42 50)scm&gt; (list x y)(5 bye) Implement make_let_frame in scheme_forms.py, which returns a child frame of env that binds the symbol in each element of bindings to the value of its corresponding expression. The bindings Scheme list contains pairs that each contain a symbol and a corresponding expression. You may find the following functions and methods useful: validate_form: this function can be used to validate the structure of each binding. It takes in a Scheme list expr of expressions and a min and max length. If expr is not a list with length between min and max inclusive, it raises an error. If no max is passed in, the default is infinity. validate_formals: this function validates that its argument is a Scheme list of symbols for which each symbol is distinct. Remember to refer to the spec if you don’t understand any of the test cases! Use Ok to unlock and test your code: 12python3 ok -q 14 -upython3 ok -q 14 Additional Scheme Tests (1 pt) Your final task in Part III of this project is to make sure that your scheme interpreter passes the additional suite of tests we have provided. To run these tests (worth 1 point), run the command: 1python3 ok -q tests.scm If you have passed all of the required cases, you should see 1/1 points received for tests.scm when you run python ok --score. If you are failing tests due to output from print statements you’ve added in your code for debugging, make sure to remove those as well for the tests to pass. One you have completed Part III, make sure you submit using OK to receive full credit for the checkpoint. 1python3 ok --submit If you’d like to check your score so far, use the following command: 1python3 ok --score The best way to see what tests you’ve passed for the checkpoint is to use the score command in ok. Congratulations! Your Scheme interpreter implementation is now complete! Part IV: Write Some Scheme Not only is your Scheme interpreter itself a tree-recursive program, but it is flexible enough to evaluate other recursive programs. Implement the following procedures in the questions.scm file. See the built-in procedure reference for descriptions of the behavior of all built-in Scheme procedure. As you use your interpreter, you may discover additional bugs in your interpreter implementation. Therefore, you may find it useful to test your code for these questions in the staff interpreter or the web editor and then try it in your own interpreter once you are confident your Scheme code is working. You can also use the web editor to visualize the scheme code you’ve written and help you debug. Scheme Editor As you’re writing your code, you can debug using the Scheme Editor. In your scheme folder you will find a new editor. To run this editor, run python3 editor. This should pop up a window in your browser; if it does not, please navigate to localhost:31415 and you should see it. Make sure to run python3 ok in a separate tab or window so that the editor keeps running. 👩🏽‍💻👨🏿‍💻 Pair programming? Remember to alternate between driver and navigator roles. The driver controls the keyboard; the navigator watches, asks questions, and suggests ideas. Problem 15 (2 pt) Implement the enumerate procedure, which takes in a list of values and returns a list of two-element lists, where the first element is the index of the value, and the second element is the value itself. 1234scm&gt; (enumerate &#x27;(3 4 5 6))((0 3) (1 4) (2 5) (3 6))scm&gt; (enumerate &#x27;())() Use Ok to test your code: 1python3 ok -q 15 Problem 16 (2 pt) Implement the merge procedure, which takes in a comparator function inorder? and two lists that are sorted, and combines the two lists into a single sorted list. A comparator defines an ordering by comparing two values and returning a true value if and only if the two values are ordered. Here, sorted means sorted according to the comparator. For example: 1234scm&gt; (merge &lt; &#x27;(1 4 6) &#x27;(2 5 8))(1 2 4 5 6 8)scm&gt; (merge &gt; &#x27;(6 4 1) &#x27;(8 5 2))(8 6 5 4 2 1) In case of a tie, you can choose to break the tie arbitrarily. Use Ok to test your code: 1python3 ok -q 16 Extra Credit During regular Office Hours and Project Parties, the staff will prioritize helping students with required questions. We will not be offering help with either extra credit problems unless the queue is empty. Problem EC 1 (2 pt) Complete the function optimize_tail_calls in scheme_eval_apply.py. It returns an alternative to scheme_eval that is properly tail recursive. That is, the interpreter will allow an unbounded number of active tail calls in constant space. It has a third argument tail that indicates whether the expression to be evaluated is in a tail context. The Unevaluated class represents an expression that needs to be evaluated in an environment. When optimized_eval receives a non-atomic expression in a tail context, it returns an Unevaluated instance. Otherwise, it should repeatedly call unoptimized_scheme_eval until the result is a value, rather than an Unevaluated. A successful implementation will require changes to several other functions, including some functions that we provided for you. All expressions throughout your interpreter that are in a tail context should be evaluated by calling scheme_eval with True as the third argument (now called tail). Your goal is to determine which expressions are in a tail context throughout your code and change calls to scheme_eval as needed. Tail call optimization was discussed in Lecture 29. The Unevaluated class in the Scheme interpreter is similar conceptually to the “thunk” discussed in lecture, and the missing code in optimized_eval is basically the “trampolining” technique discussed in lecture. Once you finish, uncomment the following line in scheme_eval_apply.py to use your implementation: 1scheme_eval = optimize_tail_calls(scheme_eval) Use Ok to test your code: 1python3 ok -q EC Optional Problems Optional Problem 1 (0 pt) In Scheme, source code is data. Every non-atomic expression is written as a Scheme list, so we can write procedures that manipulate other programs just as we write procedures that manipulate lists. Rewriting programs can be useful: we can write an interpreter that only handles a small core of the language, and then write a procedure that converts other special forms into the core language before a program is passed to the interpreter. For example, the let special form is equivalent to a call expression that begins with a lambda expression. Both create a new frame extending the current environment and evaluate a body within that new environment. 123(let ((a 1) (b 2)) (+ a b));; Is equivalent to:((lambda (a b) (+ a b)) 1 2) These expressions can be represented by the following diagrams: Let Lambda Use this rule to implement a procedure called let-to-lambda that rewrites all let special forms into lambda expressions. If we quote a let expression and pass it into this procedure, an equivalent lambda expression should be returned: 12345678scm&gt; (let-to-lambda &#x27;(let ((a 1) (b 2)) (+ a b)))((lambda (a b) (+ a b)) 1 2)scm&gt; (let-to-lambda &#x27;(let ((a 1)) (let ((b a)) b)))((lambda (a) ((lambda (b) b) a)) 1)scm&gt; (let-to-lambda 1)1scm&gt; (let-to-lambda &#x27;a)a In order to handle all programs, let-to-lambda must be aware of Scheme syntax. Since Scheme expressions are recursively nested, let-to-lambda must also be recursive. In fact, the structure of let-to-lambda is somewhat similar to that of scheme_eval–but in Scheme! As a reminder, atoms include numbers, booleans, nil, and symbols. You do not need to consider code that contains quasiquotation for this problem. 1234567(define (let-to-lambda expr) (cond ((atom? expr) &lt;rewrite atoms&gt;) ((quoted? expr) &lt;rewrite quoted expressions&gt;) ((lambda? expr) &lt;rewrite lambda expressions&gt;) ((define? expr) &lt;rewrite define expressions&gt;) ((let? expr) &lt;rewrite let expressions&gt;) (else &lt;rewrite other expressions&gt;))) Hint: Consider how you can use map to convert let forms in every element of a list to the equivalent lambda form. 123456scm&gt; (zip &#x27;((1 2) (3 4) (5 6)))((1 3 5) (2 4 6))scm&gt; (zip &#x27;((1 2)))((1) (2))scm&gt; (zip &#x27;())(() ()) Hint 2: In this problem, it may be helpful to build a scheme list that evaluates to a special form (for instance, a lambda expression). As a related example, the following code builds a scheme list that evaluates to the expression (define (f x) (+ x 1)): 1234(let ((name-and-params &#x27;(f x)) (body &#x27;(+ x 1))) (cons &#x27;define (cons name-and-params (cons body nil)))) Test your implementation by running Use Ok to test your code: 1python3 ok -q optional_1 We used let while defining let-to-lambda. What if we want to run let-to-lambda on an interpreter that does not recognize let? We can pass let-to-lambda to itself to rewrite itself into an equivalent program without let: 123456789101112;; The let-to-lambda procedure(define (let-to-lambda expr) ...);; A list representing the let-to-lambda procedure(define let-to-lambda-code &#x27;(define (let-to-lambda expr) ...));; A let-to-lambda procedure that does not use &#x27;let&#x27;!(define let-to-lambda-without-let (let-to-lambda let-to-lambda-code)) Optional Problem 2 (0 pt) Macros allow the language itself to be extended by the user. Simple macros can be provided with the define-macro special form. This must be used like a procedure definition, and it creates a procedure just like define. However, this procedure has a special evaluation rule: it is applied to its arguments without first evaluating them. Then the result of this application is evaluated. This final evaluation step takes place in the caller’s frame, as if the return value from the macro was literally pasted into the code in place of the macro. Here is a simple example: 123456789scm&gt; (define (map f lst) (if (null? lst) nil (cons (f (car lst)) (map f (cdr lst)))))scm&gt; (define-macro (for formal iterable body).... (list &#x27;map (list &#x27;lambda (list formal) body) iterable))scm&gt; (for i &#x27;(1 2 3).... (print (* i i)))149(None None None) The code above defines a macro for that acts as a map except that it doesn’t need a lambda around the body. In order to implement define-macro, complete the implementation for do_define_macro, which should create a MacroProcedure and bind it to the given name as in do_define_form. Then, update scheme_eval so that calls to macro procedures are evaluated correctly. Use Ok to test your code: 1python3 ok -q optional_2 Conclusion Congratulations! You have just implemented an interpreter for an entire language! If you enjoyed this project and want to extend it further, you may be interested in looking at more advanced features, like let* and letrec, unquote splicing, error tracing, and continuations. Submit to Ok to complete the project. 1python3 ok --submit If you have a partner, make sure to add them to the submission on okpy.org. Project 4 Solution Part 1: The Evaluator 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990$ python3 ok -q eval_apply -u=====================================================================Assignment: Project 4: Scheme InterpreterOK, version v1.18.1=====================================================================~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Unlocking testsAt each &quot;? &quot;, type what you would expect the output to be.Type exit() to quit---------------------------------------------------------------------Understanding Eval/Apply &gt; Suite 1 &gt; Case 1(cases remaining: 5)Q: What types of expressions are represented as Pairs?Choose the number of the correct choice:0) All expressions are represented as Pairs1) Only call expressions2) Call expressions and special forms3) Only special forms? 2-- OK! -----------------------------------------------------------------------Understanding Eval/Apply &gt; Suite 1 &gt; Case 2(cases remaining: 4)Q: What expression in the body of scheme_eval finds the value of a name?Choose the number of the correct choice:0) scheme_forms.SPECIAL_FORMS[first](rest, env)1) scheme_symbolp(expr)2) env.lookup(expr)3) env.find(name)? 2-- OK! -----------------------------------------------------------------------Understanding Eval/Apply &gt; Suite 1 &gt; Case 3(cases remaining: 3)Q: How do we know if a given combination is a special form?Choose the number of the correct choice:0) Check if the first element in the list is a symbol1) Check if the first element in the list is a symbol and that the symbol is in the dictionary SPECIAL_FORMS2) Check if the expression is in the dictionary SPECIAL_FORMS? 1-- OK! -----------------------------------------------------------------------Understanding Eval/Apply &gt; Suite 1 &gt; Case 4(cases remaining: 2)Q: What is the difference between applying builtins and applying user-defined procedures?(Choose all that apply)I. User-defined procedures open a new frame; builtins do notII. Builtins simply execute a predefined function; user-defined procedures must evaluate additional expressions in the bodyIII. Builtins have a fixed number of arguments; user-defined procedures do not---Choose the number of the correct choice:0) III only1) II only2) I only3) I, II and III4) I and II5) I and III6) II and III? 4-- OK! -----------------------------------------------------------------------Understanding Eval/Apply &gt; Suite 1 &gt; Case 5(cases remaining: 1)Q: What exception should be raised for the expression (1)?Choose the number of the correct choice:0) SchemeError(&quot;malformed list: (1)&quot;)1) AssertionError2) SchemeError(&quot;unknown identifier: 1&quot;)3) SchemeError(&quot;1 is not callable&quot;)? 3-- OK! -----------------------------------------------------------------------OK! All cases for Understanding Eval/Apply unlocked. Problem 1 (1 pt) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384$ python3 ok -q 01 -u=====================================================================Assignment: Project 4: Scheme InterpreterOK, version v1.18.1=====================================================================~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Unlocking testsAt each &quot;? &quot;, type what you would expect the output to be.Type exit() to quit---------------------------------------------------------------------Problem 1 &gt; Suite 1 &gt; Case 1(cases remaining: 5)&gt;&gt;&gt; from scheme import *&gt;&gt;&gt; global_frame = create_global_frame()&gt;&gt;&gt; global_frame.define(&quot;x&quot;, 3)&gt;&gt;&gt; global_frame.parent is None? True-- OK! --&gt;&gt;&gt; global_frame.lookup(&quot;x&quot;)? 3-- OK! --&gt;&gt;&gt; global_frame.define(&quot;x&quot;, 2)&gt;&gt;&gt; global_frame.lookup(&quot;x&quot;)? 3-- Not quite. Try again! --? 2-- OK! --&gt;&gt;&gt; global_frame.lookup(&quot;foo&quot;)Choose the number of the correct choice:0) SchemeError1) 32) None? 0-- OK! -----------------------------------------------------------------------Problem 1 &gt; Suite 1 &gt; Case 2(cases remaining: 4)&gt;&gt;&gt; from scheme import *&gt;&gt;&gt; first_frame = create_global_frame()&gt;&gt;&gt; first_frame.define(&quot;x&quot;, 3)&gt;&gt;&gt; second_frame = Frame(first_frame)&gt;&gt;&gt; second_frame.parent == first_frame? True-- OK! --&gt;&gt;&gt; second_frame.define(&quot;y&quot;, False)&gt;&gt;&gt; second_frame.lookup(&quot;x&quot;)? 3-- OK! --&gt;&gt;&gt; second_frame.lookup(&quot;y&quot;)? False-- OK! -----------------------------------------------------------------------Problem 1 &gt; Suite 1 &gt; Case 3(cases remaining: 3)-- Already unlocked -----------------------------------------------------------------------Problem 1 &gt; Suite 1 &gt; Case 4(cases remaining: 2)-- Already unlocked -----------------------------------------------------------------------Problem 1 &gt; Suite 2 &gt; Case 1(cases remaining: 1)-- Already unlocked -----------------------------------------------------------------------OK! All cases for Problem 1 unlocked. scheme/scheme_classes.py 1234567891011121314151617def define(self, symbol, value): &quot;&quot;&quot;Define Scheme SYMBOL to have VALUE.&quot;&quot;&quot; # BEGIN PROBLEM 1 &quot;*** YOUR CODE HERE ***&quot; self.bindings[symbol] = value # END PROBLEM 1def lookup(self, symbol): &quot;&quot;&quot;Return the value bound to SYMBOL. Errors if SYMBOL is not found.&quot;&quot;&quot; # BEGIN PROBLEM 1 &quot;*** YOUR CODE HERE ***&quot; if symbol in self.bindings.keys(): return self.bindings[symbol] elif self.parent is not None: return self.parent.lookup(symbol)` # END PROBLEM 1 raise SchemeError(&#x27;unknown identifier: &#123;0&#125;&#x27;.format(symbol)) Problem 2 (2 pt) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485$ python3 ok -q 02 -u=====================================================================Assignment: Project 4: Scheme InterpreterOK, version v1.18.1=====================================================================~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Unlocking testsAt each &quot;? &quot;, type what you would expect the output to be.Type exit() to quit---------------------------------------------------------------------Problem 2 &gt; Suite 1 &gt; Case 1(cases remaining: 9)&gt;&gt;&gt; from scheme import *&gt;&gt;&gt; env = create_global_frame()&gt;&gt;&gt; twos = Pair(2, Pair(2, nil))&gt;&gt;&gt; plus = BuiltinProcedure(scheme_add) # + procedure&gt;&gt;&gt; scheme_apply(plus, twos, env) # Type SchemeError if you think this errors? 4-- OK! -----------------------------------------------------------------------Problem 2 &gt; Suite 1 &gt; Case 2(cases remaining: 8)&gt;&gt;&gt; from scheme import *&gt;&gt;&gt; env = create_global_frame()&gt;&gt;&gt; plus = BuiltinProcedure(scheme_add) # + procedure&gt;&gt;&gt; scheme_apply(plus, nil, env) # Remember what (+) evaluates to in scheme? 0-- OK! -----------------------------------------------------------------------Problem 2 &gt; Suite 1 &gt; Case 3(cases remaining: 7)&gt;&gt;&gt; from scheme import *&gt;&gt;&gt; env = create_global_frame()&gt;&gt;&gt; twos = Pair(2, Pair(2, nil))&gt;&gt;&gt; oddp = BuiltinProcedure(scheme_oddp) # odd? procedure&gt;&gt;&gt; scheme_apply(oddp, twos, env) # Type SchemeError if you think this errors? SchemeError-- OK! -----------------------------------------------------------------------Problem 2 &gt; Suite 1 &gt; Case 4(cases remaining: 6)-- Already unlocked -----------------------------------------------------------------------Problem 2 &gt; Suite 1 &gt; Case 5(cases remaining: 5)-- Already unlocked -----------------------------------------------------------------------Problem 2 &gt; Suite 1 &gt; Case 6(cases remaining: 4)-- Already unlocked -----------------------------------------------------------------------Problem 2 &gt; Suite 1 &gt; Case 7(cases remaining: 3)-- Already unlocked -----------------------------------------------------------------------Problem 2 &gt; Suite 1 &gt; Case 8(cases remaining: 2)-- Already unlocked -----------------------------------------------------------------------Problem 2 &gt; Suite 1 &gt; Case 9(cases remaining: 1)-- Already unlocked -----------------------------------------------------------------------OK! All cases for Problem 2 unlocked. scheme/scheme_eval_apply.py 12345678910111213141516171819202122232425def scheme_apply(procedure, args, env): &quot;&quot;&quot;Apply Scheme PROCEDURE to argument values ARGS (a Scheme list) in Frame ENV, the current environment.&quot;&quot;&quot; validate_procedure(procedure) if isinstance(procedure, BuiltinProcedure): # BEGIN PROBLEM 2 &quot;*** YOUR CODE HERE ***&quot; args_list = pair_to_list(args) if procedure.expect_env: args_list.append(env) try: return procedure.py_func(*args_list) except TypeError: raise SchemeError(&#x27;incorrect number of arguments&#x27;) # END PROBLEM 2 elif isinstance(procedure, LambdaProcedure): # BEGIN PROBLEM 9 &quot;*** YOUR CODE HERE ***&quot; # END PROBLEM 9 elif isinstance(procedure, MuProcedure): # BEGIN PROBLEM 11 &quot;*** YOUR CODE HERE ***&quot; # END PROBLEM 11 else: assert False, &quot;Unexpected procedure: &#123;&#125;&quot;.format(procedure) Problem 3 (2 pt) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374$ python3 ok -q 03 -u=====================================================================Assignment: Project 4: Scheme InterpreterOK, version v1.18.1=====================================================================~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Unlocking testsAt each &quot;? &quot;, type what you would expect the output to be.Type exit() to quit---------------------------------------------------------------------Problem 3 &gt; Suite 1 &gt; Case 1(cases remaining: 5)&gt;&gt;&gt; from scheme_reader import *&gt;&gt;&gt; from scheme import *&gt;&gt;&gt; expr = read_line(&#x27;(+ 2 2)&#x27;)&gt;&gt;&gt; scheme_eval(expr, create_global_frame()) # Type SchemeError if you think this errors? 4-- OK! --&gt;&gt;&gt; scheme_eval(Pair(&#x27;+&#x27;, Pair(2, Pair(2, nil))), create_global_frame()) # Type SchemeError if you think this errors? 4-- OK! --&gt;&gt;&gt; expr = read_line(&#x27;(+ (+ 2 2) (+ 1 3) (* 1 4))&#x27;)&gt;&gt;&gt; scheme_eval(expr, create_global_frame()) # Type SchemeError if you think this errors? 12-- OK! --&gt;&gt;&gt; expr = read_line(&#x27;(yolo)&#x27;)&gt;&gt;&gt; scheme_eval(expr, create_global_frame()) # Type SchemeError if you think this errors? SchemeError-- OK! -----------------------------------------------------------------------Problem 3 &gt; Suite 2 &gt; Case 1(cases remaining: 4)scm&gt; (* (+ 3 2) (+ 1 7)) ; Type SchemeError if you think this errors? 40-- OK! --scm&gt; (1 2) ; Type SchemeError if you think this errors? SchemeError-- OK! --scm&gt; (1 (print 0)) ; validate_procedure should be called before operands are evaluated? SchemeError-- OK! -----------------------------------------------------------------------Problem 3 &gt; Suite 2 &gt; Case 2(cases remaining: 3)-- Already unlocked -----------------------------------------------------------------------Problem 3 &gt; Suite 2 &gt; Case 3(cases remaining: 2)-- Already unlocked -----------------------------------------------------------------------Problem 3 &gt; Suite 2 &gt; Case 4(cases remaining: 1)-- Already unlocked -----------------------------------------------------------------------OK! All cases for Problem 3 unlocked. scheme/scheme_eval_apply.py 12345678910111213141516171819202122232425262728293031323334def scheme_eval(expr, env, _=None): # Optional third argument is ignored &quot;&quot;&quot;Evaluate Scheme expression EXPR in Frame ENV. &gt;&gt;&gt; expr = read_line(&#x27;(+ 2 2)&#x27;) &gt;&gt;&gt; expr Pair(&#x27;+&#x27;, Pair(2, Pair(2, nil))) &gt;&gt;&gt; scheme_eval(expr, create_global_frame()) 4 &quot;&quot;&quot; # Evaluate atoms if scheme_symbolp(expr): return env.lookup(expr) elif self_evaluating(expr): return expr # All non-atomic expressions are lists (combinations) if not scheme_listp(expr): raise SchemeError(&#x27;malformed list: &#123;0&#125;&#x27;.format(repl_str(expr))) first, rest = expr.first, expr.rest if scheme_symbolp(first) and first in scheme_forms.SPECIAL_FORMS: return scheme_forms.SPECIAL_FORMS[first](rest, env) else: # BEGIN PROBLEM 3 &quot;*** YOUR CODE HERE ***&quot; procedure = scheme_eval(first, env) args = rest.map(lambda operand: scheme_eval(operand, env)) return scheme_apply(procedure, args, env) # END PROBLEM 3def pair_to_list(pair): if pair is nil: return [] else: return [pair.first] + pair_to_list(pair.rest) Problem 4 (2 pt) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154$ python3 ok -q 04 -u=====================================================================Assignment: Project 4: Scheme InterpreterOK, version v1.18.1=====================================================================~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Unlocking testsAt each &quot;? &quot;, type what you would expect the output to be.Type exit() to quit---------------------------------------------------------------------Problem 4 &gt; Suite 1 &gt; Case 1(cases remaining: 9)Q: What is the structure of the expressions argument to do_define_form?Choose the number of the correct choice:0) Pair(A, B), where: A is the symbol being bound, B is an expression whose value should be evaluated and bound to A1) Pair(&#x27;define&#x27;, Pair(A, Pair(B, nil))), where: A is the symbol being bound, B is an expression whose value should be evaluated and bound to A2) Pair(A, Pair(B, nil)), where: A is the symbol being bound, B is an expression whose value should be evaluated and bound to A3) Pair(A, Pair(B, nil)), where: A is the symbol being bound, B is the value that should be bound to A4) Pair(A, B), where: A is the symbol being bound, B is the value that should be bound to A? 2-- OK! -----------------------------------------------------------------------Problem 4 &gt; Suite 1 &gt; Case 2(cases remaining: 8)Q: What method of a Frame instance will binda value to a symbol in that frame?Choose the number of the correct choice:0) bindings1) define2) lookup3) make_child_frame? 1-- OK! -----------------------------------------------------------------------Problem 4 &gt; Suite 2 &gt; Case 1(cases remaining: 7)scm&gt; (define size 2)? size-- OK! --scm&gt; size? 2-- OK! -----------------------------------------------------------------------Problem 4 &gt; Suite 2 &gt; Case 2(cases remaining: 6)scm&gt; (define x (+ 2 3))? x-- OK! --scm&gt; x? 5-- OK! --scm&gt; (define x (+ 2 7))? x-- OK! --scm&gt; x? 9-- OK! --scm&gt; (eval (define tau 6.28)) ; eval takes an expression represented as a list and evaluates it? 6.28-- OK! -----------------------------------------------------------------------Problem 4 &gt; Suite 2 &gt; Case 3(cases remaining: 5)-- Already unlocked -----------------------------------------------------------------------Problem 4 &gt; Suite 2 &gt; Case 4(cases remaining: 4)-- Already unlocked -----------------------------------------------------------------------Problem 4 &gt; Suite 2 &gt; Case 5(cases remaining: 3)-- Already unlocked -----------------------------------------------------------------------Problem 4 &gt; Suite 2 &gt; Case 6(cases remaining: 2)scm&gt; (define x 15)? x-- OK! --scm&gt; (define y (* 2 x))? y-- OK! --scm&gt; y? 30-- OK! --scm&gt; (+ y (* y 2) 1)? 91-- OK! --scm&gt; (define x 20)? x-- OK! --scm&gt; x? 20-- OK! -----------------------------------------------------------------------Problem 4 &gt; Suite 2 &gt; Case 7(cases remaining: 1)scm&gt; (define x 0)? x-- OK! --scm&gt; ((define x (+ x 1)) 2)? SchemeError-- OK! --scm&gt; x? 1-- OK! -----------------------------------------------------------------------OK! All cases for Problem 4 unlocked. scheme/scheme_forms.py 12345678910111213141516171819202122232425262728293031323334353637def do_define_form(expressions, env): &quot;&quot;&quot;Evaluate a define form. &gt;&gt;&gt; env = create_global_frame() &gt;&gt;&gt; do_define_form(read_line(&quot;(x 2)&quot;), env) # evaluating (define x 2) &#x27;x&#x27; &gt;&gt;&gt; scheme_eval(&quot;x&quot;, env) 2 &gt;&gt;&gt; do_define_form(read_line(&quot;(x (+ 2 8))&quot;), env) # evaluating (define x (+ 2 8)) &#x27;x&#x27; &gt;&gt;&gt; scheme_eval(&quot;x&quot;, env) 10 &gt;&gt;&gt; # problem 10 &gt;&gt;&gt; env = create_global_frame() &gt;&gt;&gt; do_define_form(read_line(&quot;((f x) (+ x 2))&quot;), env) # evaluating (define (f x) (+ x 8)) &#x27;f&#x27; &gt;&gt;&gt; scheme_eval(read_line(&quot;(f 3)&quot;), env) 5 &quot;&quot;&quot; validate_form(expressions, 2) # Checks that expressions is a list of length at least 2 signature = expressions.first if scheme_symbolp(signature): # assigning a name to a value e.g. (define x (+ 1 2)) validate_form(expressions, 2, 2) # Checks that expressions is a list of length exactly 2 # BEGIN PROBLEM 4 &quot;*** YOUR CODE HERE ***&quot; value = scheme_eval(expressions.rest.first, env) env.define(signature, value) return signature # END PROBLEM 4 elif isinstance(signature, Pair) and scheme_symbolp(signature.first): # defining a named procedure e.g. (define (f x y) (+ x y)) # BEGIN PROBLEM 10 &quot;*** YOUR CODE HERE ***&quot; # END PROBLEM 10 else: bad_signature = signature.first if isinstance(signature, Pair) else signature raise SchemeError(&#x27;non-symbol: &#123;0&#125;&#x27;.format(bad_signature)) Problem 5 (1 pt) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990$ python3 ok -q 05 -u=====================================================================Assignment: Project 4: Scheme InterpreterOK, version v1.18.1=====================================================================~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Unlocking testsAt each &quot;? &quot;, type what you would expect the output to be.Type exit() to quit---------------------------------------------------------------------Problem 5 &gt; Suite 1 &gt; Case 1(cases remaining: 4)Q: What is the structure of the expressions argument to do_quote_form?Choose the number of the correct choice:0) A, where: A is the quoted expression1) [A], where: A is the quoted expression2) Pair(&#x27;quote&#x27;, Pair(A, nil)), where: A is the quoted expression3) Pair(A, nil), where: A is the quoted expression? 3-- OK! -----------------------------------------------------------------------Problem 5 &gt; Suite 2 &gt; Case 1(cases remaining: 3)&gt;&gt;&gt; from scheme import *&gt;&gt;&gt; global_frame = create_global_frame()&gt;&gt;&gt; do_quote_form(Pair(3, nil), global_frame)? 3-- OK! --&gt;&gt;&gt; do_quote_form(Pair(&#x27;hi&#x27;, nil), global_frame)? &#x27;hi&#x27;-- OK! --&gt;&gt;&gt; expr = Pair(Pair(&#x27;+&#x27;, Pair(&#x27;x&#x27;, Pair(2, nil))), nil)&gt;&gt;&gt; do_quote_form(expr, global_frame) # Make sure to use Pair notation? Pair(&#x27;+&#x27;, Pair(&#x27;x&#x27;, Pair(2, nil)))-- OK! -----------------------------------------------------------------------Problem 5 &gt; Suite 3 &gt; Case 1(cases remaining: 2)scm&gt; &#x27;&#x27;helloChoose the number of the correct choice:0) (quote (quote (hello)))1) hello2) (hello)3) (quote hello)? 3-- OK! --scm&gt; (quote (1 2))? (1 2)-- OK! --scm&gt; (car &#x27;(1 2 3))? 1-- OK! --scm&gt; (cdr &#x27;(1 2))? (2)-- OK! --scm&gt; (cons &#x27;car &#x27;(&#x27;(4 2)))? (car (quote (4 2)))-- OK! --scm&gt; (eval (cons &#x27;car &#x27;(&#x27;(4 2))))? 4-- OK! -----------------------------------------------------------------------Problem 5 &gt; Suite 4 &gt; Case 1(cases remaining: 1)-- Already unlocked -----------------------------------------------------------------------OK! All cases for Problem 5 unlocked. scheme/scheme_forms.py 123456789101112def do_quote_form(expressions, env): &quot;&quot;&quot;Evaluate a quote form. &gt;&gt;&gt; env = create_global_frame() &gt;&gt;&gt; do_quote_form(read_line(&quot;((+ x 2))&quot;), env) # evaluating (quote (+ x 2)) Pair(&#x27;+&#x27;, Pair(&#x27;x&#x27;, Pair(2, nil))) &quot;&quot;&quot; validate_form(expressions, 1, 1) # BEGIN PROBLEM 5 &quot;*** YOUR CODE HERE ***&quot; return expressions.first # END PROBLEM 5 Problem 6 (1 pt) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107$ python3 ok -q 06 -u=====================================================================Assignment: Project 4: Scheme InterpreterOK, version v1.18.1=====================================================================~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Unlocking testsAt each &quot;? &quot;, type what you would expect the output to be.Type exit() to quit---------------------------------------------------------------------Problem 6 &gt; Suite 1 &gt; Case 1(cases remaining: 6)&gt;&gt;&gt; from scheme import *&gt;&gt;&gt; env = create_global_frame()&gt;&gt;&gt; eval_all(Pair(2, nil), env)Choose the number of the correct choice:0) SchemeError1) 2? 1-- OK! --&gt;&gt;&gt; eval_all(Pair(4, Pair(5, nil)), env)Choose the number of the correct choice:0) 41) 52) (4 5)3) SchemeError? 1-- OK! --&gt;&gt;&gt; eval_all(nil, env) # return None (meaning undefined)---------------------------------------------------------------------Problem 6 &gt; Suite 1 &gt; Case 2(cases remaining: 5)&gt;&gt;&gt; from scheme import *&gt;&gt;&gt; env = create_global_frame()&gt;&gt;&gt; lst = Pair(1, Pair(2, Pair(3, nil)))&gt;&gt;&gt; eval_all(lst, env)? 3-- OK! --&gt;&gt;&gt; lst # The list should not be mutated!? Pair(1, Pair(2, Pair(3, nil)))-- OK! -----------------------------------------------------------------------Problem 6 &gt; Suite 2 &gt; Case 1(cases remaining: 4)scm&gt; (begin (+ 2 3) (+ 5 6))? 11-- OK! --scm&gt; (begin (define x 3) x)? 3-- OK! -----------------------------------------------------------------------Problem 6 &gt; Suite 2 &gt; Case 2(cases remaining: 3)scm&gt; (begin 30 &#x27;(+ 2 2))Choose the number of the correct choice:0) 41) &#x27;(+ 2 2)2) 303) (+ 2 2)? 3-- OK! --scm&gt; (define x 0)? x-- OK! --scm&gt; (begin (define x (+ x 1)) 42 (define y (+ x 1)))? y-- OK! --scm&gt; x? 1-- OK! --scm&gt; y? 2-- OK! -----------------------------------------------------------------------Problem 6 &gt; Suite 2 &gt; Case 3(cases remaining: 2)-- Already unlocked -----------------------------------------------------------------------Problem 6 &gt; Suite 2 &gt; Case 4(cases remaining: 1)-- Already unlocked -----------------------------------------------------------------------OK! All cases for Problem 6 unlocked. scheme/scheme_eval_apply.py 12345678910111213141516171819202122232425def eval_all(expressions, env): &quot;&quot;&quot;Evaluate each expression in the Scheme list EXPRESSIONS in Frame ENV (the current environment) and return the value of the last. &gt;&gt;&gt; eval_all(read_line(&quot;(1)&quot;), create_global_frame()) 1 &gt;&gt;&gt; eval_all(read_line(&quot;(1 2)&quot;), create_global_frame()) 2 &gt;&gt;&gt; x = eval_all(read_line(&quot;((print 1) 2)&quot;), create_global_frame()) 1 &gt;&gt;&gt; x 2 &gt;&gt;&gt; eval_all(read_line(&quot;((define x 2) x)&quot;), create_global_frame()) 2 &quot;&quot;&quot; # BEGIN PROBLEM 6 # return scheme_eval(expressions.first, env) # replace this with lines of your own code if expressions is nil: return expr = expressions while expr.rest is not nil: scheme_eval(expr.first, env) expr = expr.rest return scheme_eval(expr.first, env) # END PROBLEM 6 Problem 7 (2 pt) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162$ python3 ok -q 07 -u=====================================================================Assignment: Project 4: Scheme InterpreterOK, version v1.18.1=====================================================================~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Unlocking testsAt each &quot;? &quot;, type what you would expect the output to be.Type exit() to quit---------------------------------------------------------------------Problem 7 &gt; Suite 1 &gt; Case 1(cases remaining: 5)scm&gt; (lambda (x y) (+ x y))? (lambda (x y) (+ x y))-- OK! --scm&gt; (lambda (x)) ; type SchemeError if you think this causes an error? SchemeError-- OK! -----------------------------------------------------------------------Problem 7 &gt; Suite 1 &gt; Case 2(cases remaining: 4)-- Already unlocked -----------------------------------------------------------------------Problem 7 &gt; Suite 1 &gt; Case 3(cases remaining: 3)-- Already unlocked -----------------------------------------------------------------------Problem 7 &gt; Suite 2 &gt; Case 1(cases remaining: 2)&gt;&gt;&gt; from scheme_reader import *&gt;&gt;&gt; from scheme import *&gt;&gt;&gt; env = create_global_frame()&gt;&gt;&gt; lambda_line = read_line(&quot;(lambda (a b c) (+ a b c))&quot;)&gt;&gt;&gt; lambda_proc = do_lambda_form(lambda_line.rest, env)&gt;&gt;&gt; lambda_proc.formals # use single quotes &#x27; around strings in your answer? Pair(&#x27;a&#x27;, Pair(&#x27;b&#x27;, Pair(&#x27;c&#x27;, nil)))-- OK! --&gt;&gt;&gt; lambda_proc.body # the body is a *list* of expressions! Make sure your answer is a properly nested Pair.? Pair(Pair(&#x27;+&#x27;, Pair(&#x27;a&#x27;, Pair(&#x27;b&#x27;, Pair(&#x27;c&#x27;, nil)))), nil)-- OK! -----------------------------------------------------------------------Problem 7 &gt; Suite 2 &gt; Case 2(cases remaining: 1)-- Already unlocked -----------------------------------------------------------------------OK! All cases for Problem 7 unlocked. scheme/scheme_forms.py 123456789101112131415def do_lambda_form(expressions, env): &quot;&quot;&quot;Evaluate a lambda form. &gt;&gt;&gt; env = create_global_frame() &gt;&gt;&gt; do_lambda_form(read_line(&quot;((x) (+ x 2))&quot;), env) # evaluating (lambda (x) (+ x 2)) LambdaProcedure(Pair(&#x27;x&#x27;, nil), Pair(Pair(&#x27;+&#x27;, Pair(&#x27;x&#x27;, Pair(2, nil))), nil), &lt;Global Frame&gt;) &quot;&quot;&quot; validate_form(expressions, 2) formals = expressions.first validate_formals(formals) # BEGIN PROBLEM 7 &quot;*** YOUR CODE HERE ***&quot; body = expressions.rest return LambdaProcedure(formals, body, env) # END PROBLEM 7 Problem 8 (2 pt) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374$ python3 ok -q 08 -u=====================================================================Assignment: Project 4: Scheme InterpreterOK, version v1.18.1=====================================================================~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Unlocking testsAt each &quot;? &quot;, type what you would expect the output to be.Type exit() to quit---------------------------------------------------------------------Problem 8 &gt; Suite 1 &gt; Case 1(cases remaining: 6)&gt;&gt;&gt; from scheme import *&gt;&gt;&gt; global_frame = create_global_frame()&gt;&gt;&gt; formals = Pair(&#x27;a&#x27;, Pair(&#x27;b&#x27;, Pair(&#x27;c&#x27;, nil)))&gt;&gt;&gt; vals = Pair(1, Pair(2, Pair(3, nil)))&gt;&gt;&gt; frame = global_frame.make_child_frame(formals, vals)&gt;&gt;&gt; global_frame.lookup(&#x27;a&#x27;) # Type SchemeError if you think this errors? SchemeError-- OK! --&gt;&gt;&gt; frame.lookup(&#x27;a&#x27;) # Type SchemeError if you think this errors? 1-- OK! --&gt;&gt;&gt; frame.lookup(&#x27;b&#x27;) # Type SchemeError if you think this errors? 2-- OK! --&gt;&gt;&gt; frame.lookup(&#x27;c&#x27;) # Type SchemeError if you think this errors? 3-- OK! -----------------------------------------------------------------------Problem 8 &gt; Suite 1 &gt; Case 2(cases remaining: 5)&gt;&gt;&gt; from scheme import *&gt;&gt;&gt; global_frame = create_global_frame()&gt;&gt;&gt; frame = global_frame.make_child_frame(nil, nil)&gt;&gt;&gt; frame.parent is global_frame? True-- OK! -----------------------------------------------------------------------Problem 8 &gt; Suite 1 &gt; Case 3(cases remaining: 4)-- Already unlocked -----------------------------------------------------------------------Problem 8 &gt; Suite 2 &gt; Case 1(cases remaining: 3)-- Already unlocked -----------------------------------------------------------------------Problem 8 &gt; Suite 2 &gt; Case 2(cases remaining: 2)-- Already unlocked -----------------------------------------------------------------------Problem 8 &gt; Suite 2 &gt; Case 3(cases remaining: 1)-- Already unlocked -----------------------------------------------------------------------OK! All cases for Problem 8 unlocked. scheme/scheme_classes.py 123456789101112131415161718192021def make_child_frame(self, formals, vals): &quot;&quot;&quot;Return a new local frame whose parent is SELF, in which the symbols in a Scheme list of formal parameters FORMALS are bound to the Scheme values in the Scheme list VALS. Both FORMALS and VALS are represented as Pairs. Raise an error if too many or too few vals are given. &gt;&gt;&gt; env = create_global_frame() &gt;&gt;&gt; formals, expressions = read_line(&#x27;(a b c)&#x27;), read_line(&#x27;(1 2 3)&#x27;) &gt;&gt;&gt; env.make_child_frame(formals, expressions) &lt;&#123;a: 1, b: 2, c: 3&#125; -&gt; &lt;Global Frame&gt;&gt; &quot;&quot;&quot; if len(formals) != len(vals): raise SchemeError(&#x27;Incorrect number of arguments to function call&#x27;) # BEGIN PROBLEM 8 &quot;*** YOUR CODE HERE ***&quot; child_frame = Frame(self) while formals is not nil and vals is not nil: child_frame.define(formals.first, vals.first) formals, vals = formals.rest, vals.rest return child_frame # END PROBLEM 8 Problem 9 (2 pt) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071$ python3 ok -q 09 -u=====================================================================Assignment: Project 4: Scheme InterpreterOK, version v1.18.1=====================================================================~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Unlocking testsAt each &quot;? &quot;, type what you would expect the output to be.Type exit() to quit---------------------------------------------------------------------Problem 9 &gt; Suite 1 &gt; Case 1(cases remaining: 6)-- Already unlocked -----------------------------------------------------------------------Problem 9 &gt; Suite 1 &gt; Case 2(cases remaining: 5)-- Already unlocked -----------------------------------------------------------------------Problem 9 &gt; Suite 2 &gt; Case 1(cases remaining: 4)-- Already unlocked -----------------------------------------------------------------------Problem 9 &gt; Suite 2 &gt; Case 2(cases remaining: 3)-- Already unlocked -----------------------------------------------------------------------Problem 9 &gt; Suite 3 &gt; Case 1(cases remaining: 2)scm&gt; (define outer (lambda (x y).... (define inner (lambda (z x).... (+ x (* y 2) (* z 3)))).... (inner x 10)))? outer-- OK! --scm&gt; (outer 1 2)? 17-- OK! --scm&gt; (define outer-func (lambda (x y).... (define inner (lambda (z x).... (+ x (* y 2) (* z 3)))).... inner))? outer-func-- OK! --scm&gt; ((outer-func 1 2) 1 10)? 17-- OK! -----------------------------------------------------------------------Problem 9 &gt; Suite 3 &gt; Case 2(cases remaining: 1)-- Already unlocked -----------------------------------------------------------------------OK! All cases for Problem 9 unlocked. scheme/scheme_eval_apply.py 123456789101112131415161718192021222324252627def scheme_apply(procedure, args, env): &quot;&quot;&quot;Apply Scheme PROCEDURE to argument values ARGS (a Scheme list) in Frame ENV, the current environment.&quot;&quot;&quot; validate_procedure(procedure) if isinstance(procedure, BuiltinProcedure): # BEGIN PROBLEM 2 &quot;*** YOUR CODE HERE ***&quot; args_list = pair_to_list(args) if procedure.expect_env: args_list.append(env) try: return procedure.py_func(*args_list) except TypeError: raise SchemeError(&#x27;incorrect number of arguments&#x27;) # END PROBLEM 2 elif isinstance(procedure, LambdaProcedure): # BEGIN PROBLEM 9 &quot;*** YOUR CODE HERE ***&quot; child_frame = procedure.env.make_child_frame(procedure.formals, args) return eval_all(procedure.body, child_frame) # END PROBLEM 9 elif isinstance(procedure, MuProcedure): # BEGIN PROBLEM 11 &quot;*** YOUR CODE HERE ***&quot; # END PROBLEM 11 else: assert False, &quot;Unexpected procedure: &#123;&#125;&quot;.format(procedure) Problem 10 (1 pt) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768$ python3 ok -q 10 -u=====================================================================Assignment: Project 4: Scheme InterpreterOK, version v1.18.1=====================================================================~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Unlocking testsAt each &quot;? &quot;, type what you would expect the output to be.Type exit() to quit---------------------------------------------------------------------Problem 10 &gt; Suite 1 &gt; Case 1(cases remaining: 7)scm&gt; (define (f x y) (+ x y))? f-- OK! --scm&gt; fChoose the number of the correct choice:0) (define f (lambda (x y) (+ x y)))1) (lambda (f x y) (+ x y))2) (lambda (x y) (+ x y))3) (f (x y) (+ x y))? 2-- OK! -----------------------------------------------------------------------Problem 10 &gt; Suite 1 &gt; Case 2(cases remaining: 6)-- Already unlocked -----------------------------------------------------------------------Problem 10 &gt; Suite 1 &gt; Case 3(cases remaining: 5)-- Already unlocked -----------------------------------------------------------------------Problem 10 &gt; Suite 1 &gt; Case 4(cases remaining: 4)-- Already unlocked -----------------------------------------------------------------------Problem 10 &gt; Suite 1 &gt; Case 5(cases remaining: 3)-- Already unlocked -----------------------------------------------------------------------Problem 10 &gt; Suite 1 &gt; Case 6(cases remaining: 2)-- Already unlocked -----------------------------------------------------------------------Problem 10 &gt; Suite 2 &gt; Case 1(cases remaining: 1)-- Already unlocked -----------------------------------------------------------------------OK! All cases for Problem 10 unlocked. scheme/scheme_forms.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445def do_define_form(expressions, env): &quot;&quot;&quot;Evaluate a define form. &gt;&gt;&gt; env = create_global_frame() &gt;&gt;&gt; do_define_form(read_line(&quot;(x 2)&quot;), env) # evaluating (define x 2) &#x27;x&#x27; &gt;&gt;&gt; scheme_eval(&quot;x&quot;, env) 2 &gt;&gt;&gt; do_define_form(read_line(&quot;(x (+ 2 8))&quot;), env) # evaluating (define x (+ 2 8)) &#x27;x&#x27; &gt;&gt;&gt; scheme_eval(&quot;x&quot;, env) 10 &gt;&gt;&gt; # problem 10 &gt;&gt;&gt; env = create_global_frame() &gt;&gt;&gt; do_define_form(read_line(&quot;((f x) (+ x 2))&quot;), env) # evaluating (define (f x) (+ x 8)) &#x27;f&#x27; &gt;&gt;&gt; scheme_eval(read_line(&quot;(f 3)&quot;), env) 5 &quot;&quot;&quot; validate_form(expressions, 2) # Checks that expressions is a list of length at least 2 signature = expressions.first if scheme_symbolp(signature): # assigning a name to a value e.g. (define x (+ 1 2)) validate_form(expressions, 2, 2) # Checks that expressions is a list of length exactly 2 # BEGIN PROBLEM 4 &quot;*** YOUR CODE HERE ***&quot; value = scheme_eval(expressions.rest.first, env) env.define(signature, value) return signature # END PROBLEM 4 elif isinstance(signature, Pair) and scheme_symbolp(signature.first): # defining a named procedure e.g. (define (f x y) (+ x y)) # BEGIN PROBLEM 10 &quot;*** YOUR CODE HERE ***&quot; formal = signature.rest while formal is not nil: if not scheme_symbolp(formal.first): raise SchemeError formal = formal.rest env.define(signature.first, LambdaProcedure(signature.rest, expressions.rest, env)) return signature.first # END PROBLEM 10 else: bad_signature = signature.first if isinstance(signature, Pair) else signature raise SchemeError(&#x27;non-symbol: &#123;0&#125;&#x27;.format(bad_signature)) Problem 11 (1 pt) 1234567891011121314151617181920212223242526272829303132333435363738394041$ python3 ok -q 11 -u=====================================================================Assignment: Project 4: Scheme InterpreterOK, version v1.18.1=====================================================================~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Unlocking testsAt each &quot;? &quot;, type what you would expect the output to be.Type exit() to quit---------------------------------------------------------------------Problem 11 &gt; Suite 1 &gt; Case 1(cases remaining: 2)scm&gt; (define y 1)? y-- OK! --scm&gt; (define f (mu (x) (+ x y)))? f-- OK! --scm&gt; (define g (lambda (x y) (f (+ x x))))? g-- OK! --scm&gt; (g 3 7)? 13-- OK! -----------------------------------------------------------------------Problem 11 &gt; Suite 2 &gt; Case 1(cases remaining: 1)-- Already unlocked -----------------------------------------------------------------------OK! All cases for Problem 11 unlocked. scheme/scheme_forms.py 123456789def do_mu_form(expressions, env): &quot;&quot;&quot;Evaluate a mu form.&quot;&quot;&quot; validate_form(expressions, 2) formals = expressions.first validate_formals(formals) # BEGIN PROBLEM 11 &quot;*** YOUR CODE HERE ***&quot; return MuProcedure(formals, expressions.rest) # END PROBLEM 11 scheme/scheme_eval_apply.py 1234567891011121314151617181920212223242526272829def scheme_apply(procedure, args, env): &quot;&quot;&quot;Apply Scheme PROCEDURE to argument values ARGS (a Scheme list) in Frame ENV, the current environment.&quot;&quot;&quot; validate_procedure(procedure) if isinstance(procedure, BuiltinProcedure): # BEGIN PROBLEM 2 &quot;*** YOUR CODE HERE ***&quot; args_list = pair_to_list(args) if procedure.expect_env: args_list.append(env) try: return procedure.py_func(*args_list) except TypeError: raise SchemeError(&#x27;incorrect number of arguments&#x27;) # END PROBLEM 2 elif isinstance(procedure, LambdaProcedure): # BEGIN PROBLEM 9 &quot;*** YOUR CODE HERE ***&quot; child_frame = procedure.env.make_child_frame(procedure.formals, args) return eval_all(procedure.body, child_frame) # END PROBLEM 9 elif isinstance(procedure, MuProcedure): # BEGIN PROBLEM 11 &quot;*** YOUR CODE HERE ***&quot; child_frame = env.make_child_frame(procedure.formals, args) return eval_all(procedure.body, child_frame) # END PROBLEM 11 else: assert False, &quot;Unexpected procedure: &#123;&#125;&quot;.format(procedure) Problem 12 (2 pt) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122$ python3 ok -q 12 -u=====================================================================Assignment: Project 4: Scheme InterpreterOK, version v1.18.1=====================================================================~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Unlocking testsAt each &quot;? &quot;, type what you would expect the output to be.Type exit() to quit---------------------------------------------------------------------Problem 12 &gt; Suite 1 &gt; Case 1(cases remaining: 9)scm&gt; (and)Choose the number of the correct choice:0) #f1) SchemeError2) #t? 2-- OK! --scm&gt; (and 1 #f)Choose the number of the correct choice:0) #t1) #f2) 1? 1-- OK! --scm&gt; (and (+ 1 1) 1)? 1-- OK! --scm&gt; (and #f 5)? #f-- OK! --scm&gt; (and 4 5 (+ 3 3))? 6-- OK! --scm&gt; (not (and #t #f 42 (/ 1 0)))? #t-- OK! -----------------------------------------------------------------------Problem 12 &gt; Suite 1 &gt; Case 2(cases remaining: 8)-- Already unlocked -----------------------------------------------------------------------Problem 12 &gt; Suite 1 &gt; Case 3(cases remaining: 7)-- Already unlocked -----------------------------------------------------------------------Problem 12 &gt; Suite 1 &gt; Case 4(cases remaining: 6)-- Already unlocked -----------------------------------------------------------------------Problem 12 &gt; Suite 2 &gt; Case 1(cases remaining: 5)scm&gt; (or)? #f-- OK! --scm&gt; (or (+ 1 1))? 2-- OK! --scm&gt; (not (or #f))? #t-- OK! --scm&gt; (define (zero) 0)? zero-- OK! --scm&gt; (or (zero) 3)? 0-- OK! --scm&gt; (or 4 #t (/ 1 0))? 4-- OK! -----------------------------------------------------------------------Problem 12 &gt; Suite 2 &gt; Case 2(cases remaining: 4)-- Already unlocked -----------------------------------------------------------------------Problem 12 &gt; Suite 2 &gt; Case 3(cases remaining: 3)-- Already unlocked -----------------------------------------------------------------------Problem 12 &gt; Suite 2 &gt; Case 4(cases remaining: 2)-- Already unlocked -----------------------------------------------------------------------Problem 12 &gt; Suite 2 &gt; Case 5(cases remaining: 1)-- Already unlocked -----------------------------------------------------------------------OK! All cases for Problem 12 unlocked. scheme/scheme_forms.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152def do_and_form(expressions, env): &quot;&quot;&quot;Evaluate a (short-circuited) and form. &gt;&gt;&gt; env = create_global_frame() &gt;&gt;&gt; do_and_form(read_line(&quot;(#f (print 1))&quot;), env) # evaluating (and #f (print 1)) False &gt;&gt;&gt; # evaluating (and (print 1) (print 2) (print 4) 3 #f) &gt;&gt;&gt; do_and_form(read_line(&quot;((print 1) (print 2) (print 3) (print 4) 3 #f)&quot;), env) 1 2 3 4 False &quot;&quot;&quot; # BEGIN PROBLEM 12 &quot;*** YOUR CODE HERE ***&quot; if expressions is nil: return True val = scheme_eval(expressions.first, env) if is_scheme_true(val): if expressions.rest is nil: return val else: return do_and_form(expressions.rest, env) else: return False # END PROBLEM 12def do_or_form(expressions, env): &quot;&quot;&quot;Evaluate a (short-circuited) or form. &gt;&gt;&gt; env = create_global_frame() &gt;&gt;&gt; do_or_form(read_line(&quot;(10 (print 1))&quot;), env) # evaluating (or 10 (print 1)) 10 &gt;&gt;&gt; do_or_form(read_line(&quot;(#f 2 3 #t #f)&quot;), env) # evaluating (or #f 2 3 #t #f) 2 &gt;&gt;&gt; # evaluating (or (begin (print 1) #f) (begin (print 2) #f) 6 (begin (print 3) 7)) &gt;&gt;&gt; do_or_form(read_line(&quot;((begin (print 1) #f) (begin (print 2) #f) 6 (begin (print 3) 7))&quot;), env) 1 2 6 &quot;&quot;&quot; # BEGIN PROBLEM 12 &quot;*** YOUR CODE HERE ***&quot; if expressions is nil: return False val = scheme_eval(expressions.first, env) if is_scheme_true(val): return val else: return do_or_form(expressions.rest, env) # END PROBLEM 12 Problem 13 (2 pt) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768$ python3 ok -q 13 -u=====================================================================Assignment: Project 4: Scheme InterpreterOK, version v1.18.1=====================================================================~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Unlocking testsAt each &quot;? &quot;, type what you would expect the output to be.Type exit() to quit---------------------------------------------------------------------Problem 13 &gt; Suite 1 &gt; Case 1(cases remaining: 6)scm&gt; (cond ((&gt; 2 3) 5).... ((&gt; 2 4) 6).... ((&lt; 2 5) 7).... (else 8))? 7-- OK! --scm&gt; (cond ((&gt; 2 3) 5).... ((&gt; 2 4) 6).... (else 8))? 8-- OK! --scm&gt; (cond ((= 1 1)).... ((= 4 4) &#x27;huh).... (else &#x27;no))? #t-- OK! -----------------------------------------------------------------------Problem 13 &gt; Suite 2 &gt; Case 1(cases remaining: 5)-- Already unlocked -----------------------------------------------------------------------Problem 13 &gt; Suite 2 &gt; Case 2(cases remaining: 4)-- Already unlocked -----------------------------------------------------------------------Problem 13 &gt; Suite 2 &gt; Case 3(cases remaining: 3)-- Already unlocked -----------------------------------------------------------------------Problem 13 &gt; Suite 2 &gt; Case 4(cases remaining: 2)-- Already unlocked -----------------------------------------------------------------------Problem 13 &gt; Suite 2 &gt; Case 5(cases remaining: 1)-- Already unlocked -----------------------------------------------------------------------OK! All cases for Problem 13 unlocked. scheme/scheme_forms.py 123456789101112131415161718192021222324def do_cond_form(expressions, env): &quot;&quot;&quot;Evaluate a cond form. &gt;&gt;&gt; do_cond_form(read_line(&quot;((#f (print 2)) (#t 3))&quot;), create_global_frame()) 3 &quot;&quot;&quot; while expressions is not nil: clause = expressions.first validate_form(clause, 1) if clause.first == &#x27;else&#x27;: test = True if expressions.rest != nil: raise SchemeError(&#x27;else must be last&#x27;) else: test = scheme_eval(clause.first, env) if is_scheme_true(test): # BEGIN PROBLEM 13 &quot;*** YOUR CODE HERE ***&quot; if clause.rest is nil: return test else: return eval_all(clause.rest, env) # END PROBLEM 13 expressions = expressions.rest Problem 14 (2 pt) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101$ python3 ok -q 14 -u=====================================================================Assignment: Project 4: Scheme InterpreterOK, version v1.18.1=====================================================================~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Unlocking testsAt each &quot;? &quot;, type what you would expect the output to be.Type exit() to quit---------------------------------------------------------------------Problem 14 &gt; Suite 1 &gt; Case 1(cases remaining: 9)scm&gt; (define x 1)? x-- OK! --scm&gt; (let ((x 5)).... (+ x 3))? 8-- OK! --scm&gt; x? 1-- OK! -----------------------------------------------------------------------Problem 14 &gt; Suite 1 &gt; Case 2(cases remaining: 8)scm&gt; (let ((a 1) (b a)) b)Choose the number of the correct choice:0) y1) 12) SchemeError3) x? 2-- OK! -----------------------------------------------------------------------Problem 14 &gt; Suite 1 &gt; Case 3(cases remaining: 7)scm&gt; (let ((x 5)).... (let ((x 2).... (y x)).... (+ y (* x 2))))? 9-- OK! -----------------------------------------------------------------------Problem 14 &gt; Suite 1 &gt; Case 4(cases remaining: 6)scm&gt; (let ((a 2) (a 3)) (+ a a)) ; how should we catch something like this?? SchemeError-- OK! --scm&gt; (let ((y 2 3)) (+ y y)) ; should this be an allowable form?? SchemeError-- OK! -----------------------------------------------------------------------Problem 14 &gt; Suite 1 &gt; Case 5(cases remaining: 5)-- Already unlocked -----------------------------------------------------------------------Problem 14 &gt; Suite 2 &gt; Case 1(cases remaining: 4)-- Already unlocked -----------------------------------------------------------------------Problem 14 &gt; Suite 2 &gt; Case 2(cases remaining: 3)-- Already unlocked -----------------------------------------------------------------------Problem 14 &gt; Suite 2 &gt; Case 3(cases remaining: 2)-- Already unlocked -----------------------------------------------------------------------Problem 14 &gt; Suite 3 &gt; Case 1(cases remaining: 1)-- Already unlocked -----------------------------------------------------------------------OK! All cases for Problem 14 unlocked. scheme/scheme_forms.py 1234567891011121314151617181920212223242526272829303132def make_let_frame(bindings, env): &quot;&quot;&quot;Create a child frame of Frame ENV that contains the definitions given in BINDINGS. The Scheme list BINDINGS must have the form of a proper bindings list in a let expression: each item must be a list containing a symbol and a Scheme expression.&quot;&quot;&quot; if not scheme_listp(bindings): raise SchemeError(&#x27;bad bindings list in let form&#x27;) names = vals = nil # BEGIN PROBLEM 14 &quot;*** YOUR CODE HERE ***&quot; while bindings is not nil: validate_form(bindings.first, 2, 2) name = (bindings.first.first) val = (scheme_eval(bindings.first.rest.first, env)) if names is nil: names = Pair(name, nil) name_tmp = names else: name_tmp.rest = Pair(name, nil) name_tmp = name_tmp.rest if vals is nil: vals = Pair(val, nil) val_tmp = vals else: val_tmp.rest = Pair(val, nil) val_tmp = val_tmp.rest bindings = bindings.rest validate_formals(names) # END PROBLEM 14 return env.make_child_frame(names, vals) Problem 15 (2 pt) scheme/questions.scm 12345678910;; Problem 15;; Returns a list of two-element lists(define (enumerate s) ; BEGIN PROBLEM 15 &#x27;replace-this-line (define (help idx ele) (if (null? ele) nil (cons (list idx (car ele)) (help (+ idx 1) (cdr ele))))) (help 0 s) ) ; END PROBLEM 15 Problem 16 (2 pt) scheme/questions.scm 123456789101112131415161718;; Problem 16;; Merge two lists LIST1 and LIST2 according to INORDER? and return;; the merged lists.(define (merge inorder? list1 list2) ; BEGIN PROBLEM 16 &#x27;replace-this-line (cond ((null? list1) list2) ((null? list2) list1) (else (if (inorder? (car list1) (car list2)) (cons (car list1) (merge inorder? (cdr list1) list2)) (cons (car list2) (merge inorder? list1 (cdr list2))) ) ) ) ) ; END PROBLEM 16 Problem EC 1 (2 pt) scheme/scheme_eval_apply.py 1234567891011121314151617def optimize_tail_calls(unoptimized_scheme_eval): &quot;&quot;&quot;Return a properly tail recursive version of an eval function.&quot;&quot;&quot; def optimized_eval(expr, env, tail=False): &quot;&quot;&quot;Evaluate Scheme expression EXPR in Frame ENV. If TAIL, return an Unevaluated containing an expression for further evaluation. &quot;&quot;&quot; if tail and not scheme_symbolp(expr) and not self_evaluating(expr): return Unevaluated(expr, env) result = Unevaluated(expr, env) # BEGIN PROBLEM EC &quot;*** YOUR CODE HERE ***&quot; while isinstance(result, Unevaluated): result = unoptimized_scheme_eval(result.expr, result.env) return result # END PROBLEM EC return optimized_eval","categories":[],"tags":[{"name":"CS61A","slug":"CS61A","permalink":"http://www.misaka-9982.com/tags/CS61A/"}]},{"title":"CS188 Proj 2","slug":"CS188-Proj-2","date":"2022-12-16T13:21:03.000Z","updated":"2022-12-20T10:31:00.869Z","comments":true,"path":"2022/12/16/CS188-Proj-2/","link":"","permalink":"http://www.misaka-9982.com/2022/12/16/CS188-Proj-2/","excerpt":"","text":"Project 2: Multi-Agent Search Due: Thursday, September 22, 11:59 PM PT. Pacman, now with ghosts. Minimax, Expectimax, Evaluation TABLE OF CONTENTS TABLE OF CONTENTS Introduction Welcome to Multi-Agent Pacman Q1 (4 pts): Reflex Agent Q2 (5 pts): Minimax Hints and Observations Q3 (5 pts): Alpha-Beta Pruning Q4 (5 pts): Expectimax Q5 (6 pts): Evaluation Function Introduction In this project, you will design agents for the classic version of Pacman, including ghosts. Along the way, you will implement both minimax and expectimax search and try your hand at evaluation function design. The code base has not changed much from the previous project, but please start with a fresh installation, rather than intermingling files from project 1. As in project 1, this project includes an autograder for you to grade your answers on your machine. This can be run on all questions with the command: 1python autograder.py It can be run for one particular question, such as q2, by: 1python autograder.py -q q2 It can be run for one particular test by commands of the form: 1python autograder.py -t test_cases/q2/0-small-tree By default, the autograder displays graphics with the -t option, but doesn’t with the -q option. You can force graphics by using the --graphics flag, or force no graphics by using the --no-graphics flag. See the autograder tutorial in Project 0 for more information about using the autograder. The code for this project contains the following files, available as a zip archive. Files you’ll edit: multiAgents.py Where all of your multi-agent search agents will reside. Files you might want to look at: pacman.py The main file that runs Pacman games. This file also describes a Pacman GameState type, which you will use extensively in this project. game.py The logic behind how the Pacman world works. This file describes several supporting types like AgentState, Agent, Direction, and Grid. util.py Useful data structures for implementing search algorithms. You don’t need to use these for this project, but may find other functions defined here to be useful. Supporting files you can ignore: graphicsDisplay.py Graphics for Pacman graphicsUtils.py Support for Pacman graphics textDisplay.py ASCII graphics for Pacman ghostAgents.py Agents to control ghosts keyboardAgents.py Keyboard interfaces to control Pacman layout.py Code for reading layout files and storing their contents autograder.py Project autograder testParser.py Parses autograder test and solution files testClasses.py General autograding test classes test_cases/ Directory containing the test cases for each question multiagentTestClasses.py Project 2 specific autograding test classes Files to Edit and Submit: You will fill in portions of multiAgents.py during the assignment. Once you have completed the assignment, you will submit a token generated by submission_autograder.py. Please do not change the other files in this distribution or submit any of our original files other than this file. Evaluation: Your code will be autograded for technical correctness. Please do not change the names of any provided functions or classes within the code, or you will wreak havoc on the autograder. However, the correctness of your implementation – not the autograder’s judgements – will be the final judge of your score. If necessary, we will review and grade assignments individually to ensure that you receive due credit for your work. Academic Dishonesty: We will be checking your code against other submissions in the class for logical redundancy. If you copy someone else’s code and submit it with minor changes, we will know. These cheat detectors are quite hard to fool, so please don’t try. We trust you all to submit your own work only; please don’t let us down. If you do, we will pursue the strongest consequences available to us. Getting Help: You are not alone! If you find yourself stuck on something, contact the course staff for help. Office hours, section, and the discussion forum are there for your support; please use them. If you can’t make our office hours, let us know and we will schedule more. We want these projects to be rewarding and instructional, not frustrating and demoralizing. But, we don’t know when or how to help unless you ask. Discussion: Please be careful not to post spoilers. Welcome to Multi-Agent Pacman First, play a game of classic Pacman by running the following command: 1python pacman.py and using the arrow keys to move. Now, run the provided ReflexAgent in multiAgents.py 1python pacman.py -p ReflexAgent Note that it plays quite poorly even on simple layouts: 1python pacman.py -p ReflexAgent -l testClassic Inspect its code (in multiAgents.py) and make sure you understand what it’s doing. Q1 (4 pts): Reflex Agent Improve the ReflexAgent in multiAgents.py to play respectably. The provided reflex agent code provides some helpful examples of methods that query the GameState for information. A capable reflex agent will have to consider both food locations and ghost locations to perform well. Your agent should easily and reliably clear the testClassic layout: 1python pacman.py -p ReflexAgent -l testClassic Try out your reflex agent on the default mediumClassic layout with one ghost or two (and animation off to speed up the display): 1python pacman.py --frameTime 0 -p ReflexAgent -k 1 1python pacman.py --frameTime 0 -p ReflexAgent -k 2 How does your agent fare? It will likely often die with 2 ghosts on the default board, unless your evaluation function is quite good. Note: Remember that newFood has the function asList() Note: As features, try the reciprocal of important values (such as distance to food) rather than just the values themselves. Note: The evaluation function you’re writing is evaluating state-action pairs; in later parts of the project, you’ll be evaluating states. Note: You may find it useful to view the internal contents of various objects for debugging. You can do this by printing the objects’ string representations. For example, you can print newGhostStates with print(newGhostStates). Options: Default ghosts are random; you can also play for fun with slightly smarter directional ghosts using -g DirectionalGhost. If the randomness is preventing you from telling whether your agent is improving, you can use -f to run with a fixed random seed (same random choices every game). You can also play multiple games in a row with -n. Turn off graphics with -q to run lots of games quickly. Grading: We will run your agent on the openClassic layout 10 times. You will receive 0 points if your agent times out, or never wins. You will receive 1 point if your agent wins at least 5 times, or 2 points if your agent wins all 10 games. You will receive an additional 1 point if your agent’s average score is greater than 500, or 2 points if it is greater than 1000. You can try your agent out under these conditions with 1python autograder.py -q q1 To run it without graphics, use: 1python autograder.py -q q1 --no-graphics Don’t spend too much time on this question, though, as the meat of the project lies ahead. Answer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class ReflexAgent(Agent): &quot;&quot;&quot; A reflex agent chooses an action at each choice point by examining its alternatives via a state evaluation function. The code below is provided as a guide. You are welcome to change it in any way you see fit, so long as you don&#x27;t touch our method headers. &quot;&quot;&quot; def getAction(self, gameState: GameState): &quot;&quot;&quot; You do not need to change this method, but you&#x27;re welcome to. getAction chooses among the best options according to the evaluation function. Just like in the previous project, getAction takes a GameState and returns some Directions.X for some X in the set &#123;NORTH, SOUTH, WEST, EAST, STOP&#125; &quot;&quot;&quot; # Collect legal moves and successor states legalMoves = gameState.getLegalActions() # Choose one of the best actions scores = [self.evaluationFunction(gameState, action) for action in legalMoves] bestScore = max(scores) bestIndices = [index for index in range(len(scores)) if scores[index] == bestScore] chosenIndex = random.choice(bestIndices) # Pick randomly among the best &quot;Add more of your code here if you want to&quot; return legalMoves[chosenIndex] def evaluationFunction(self, currentGameState: GameState, action): &quot;&quot;&quot; Design a better evaluation function here. The evaluation function takes in the current and proposed successor GameStates (pacman.py) and returns a number, where higher numbers are better. The code below extracts some useful information from the state, like the remaining food (newFood) and Pacman position after moving (newPos). newScaredTimes holds the number of moves that each ghost will remain scared because of Pacman having eaten a power pellet. Print out these variables to see what you&#x27;re getting, then combine them to create a masterful evaluation function. &quot;&quot;&quot; # Useful information you can extract from a GameState (pacman.py) successorGameState = currentGameState.generatePacmanSuccessor(action) newPos = successorGameState.getPacmanPosition() newFood = successorGameState.getFood() newGhostStates = successorGameState.getGhostStates() newScaredTimes = [ghostState.scaredTimer for ghostState in newGhostStates] &quot;*** YOUR CODE HERE ***&quot; distToPacman = partial(manhattanDistance, newPos) def ghostF(ghost): dist = distToPacman(ghost.getPosition()) if ghost.scaredTimer &gt; dist: return inf if dist &lt;= 1: return -inf return 0 ghostScore = min(map(ghostF, newGhostStates)) distToClosestFood = min(map(distToPacman, newFood.asList()), default=inf) closestFoodFeature = 1.0 / (1.0 + distToClosestFood) return successorGameState.getScore() + closestFoodFeature + ghostScore Q2 (5 pts): Minimax Now you will write an adversarial search agent in the provided MinimaxAgent class stub in multiAgents.py. Your minimax agent should work with any number of ghosts, so you’ll have to write an algorithm that is slightly more general than what you’ve previously seen in lecture. In particular, your minimax tree will have multiple min layers (one for each ghost) for every max layer. Your code should also expand the game tree to an arbitrary depth. Score the leaves of your minimax tree with the supplied self.evaluationFunction, which defaults to scoreEvaluationFunction. MinimaxAgent extends MultiAgentSearchAgent, which gives access to self.depth and self.evaluationFunction. Make sure your minimax code makes reference to these two variables where appropriate as these variables are populated in response to command line options. Important: A single search ply is considered to be one Pacman move and all the ghosts’ responses, so depth 2 search will involve Pacman and each ghost moving two times. Grading: We will be checking your code to determine whether it explores the correct number of game states. This is the only reliable way to detect some very subtle bugs in implementations of minimax. As a result, the autograder will be very picky about how many times you call GameState.generateSuccessor. If you call it any more or less than necessary, the autograder will complain. To test and debug your code, run 1python autograder.py -q q2 This will show what your algorithm does on a number of small trees, as well as a pacman game. To run it without graphics, use: 1python autograder.py -q q2 --no-graphics Hints and Observations Implement the algorithm recursively using helper function(s). The correct implementation of minimax will lead to Pacman losing the game in some tests. This is not a problem: as it is correct behaviour, it will pass the tests. The evaluation function for the Pacman test in this part is already written (self.evaluationFunction). You shouldn’t change this function, but recognize that now we’re evaluating states rather than actions, as we were for the reflex agent. Look-ahead agents evaluate future states whereas reflex agents evaluate actions from the current state. The minimax values of the initial state in the 1minimaxClassic layout are 9, 8, 7, -492 for depths 1, 2, 3 and 4 respectively. Note that your minimax agent will often win (665/1000 games for us) despite the dire prediction of depth 4 minimax. 1python pacman.py -p MinimaxAgent -l minimaxClassic -a depth=4 Pacman is always agent 0, and the agents move in order of increasing agent index. All states in minimax should be GameStates, either passed in to getAction or generated via GameState.generateSuccessor. In this project, you will not be abstracting to simplified states. On larger boards such as openClassic and mediumClassic (the default), you’ll find Pacman to be good at not dying, but quite bad at winning. He’ll often thrash around without making progress. He might even thrash around right next to a dot without eating it because he doesn’t know where he’d go after eating that dot. Don’t worry if you see this behavior, question 5 will clean up all of these issues. When Pacman believes that his death is unavoidable, he will try to end the game as soon as possible because of the constant penalty for living. Sometimes, this is the wrong thing to do with random ghosts, but minimax agents always assume the worst: 1python pacman.py -p MinimaxAgent -l trappedClassic -a depth=3 Make sure you understand why Pacman rushes the closest ghost in this case. Answer Get all the ghosts’ index number 1ghostIdx = [i for i in range(1, gameState.getNumAgents())] Set terminal conditions 12def term(state, depth): return state.isWin() or state.isLose() or depth == self.depth Search for all the ghosts’ actions that lead to the Pacman’s benefit value minimum, if the current ghost is the last one, then we need to search for the Pacman at the next level to generate the maximum value for itself, otherwise, we just need to search for the next ghost’s action and find out the minimum. 123456789101112def minValue(state, depth, ghost): if term(state, depth): return self.evaluationFunction(state) value = 1e9 for action in state.getLegalActions(ghost): if ghost == ghostIdx[-1]: value = min(value, maxValue(state.generateSuccessor(ghost, action), depth + 1)) else: value = min(value, minValue(state.generateSuccessor(ghost, action), depth, ghost + 1)) return value Search for the action that leads to the maximum value that the Pacman can get. 123456789def maxValue(state, depth): if term(state, depth): return self.evaluationFunction(state) value = -1e9 for action in state.getLegalActions(0): value = max(value, minValue(state.generateSuccessor(0, action), depth, ghostIdx[0])) return value Bind the action and the value that the action generated, then sort the array by the value, return the maximum. 1234res = [(action, minValue(gameState.generateSuccessor(0, action), 0, ghostIdx[0])) for action in gameState.getLegalActions(0)]res.sort(key=lambda k: k[1])return res[-1][0] The full version of the code. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class MinimaxAgent(MultiAgentSearchAgent): &quot;&quot;&quot; Your minimax agent (question 2) &quot;&quot;&quot; def getAction(self, gameState: GameState): &quot;&quot;&quot; Returns the minimax action from the current gameState using self.depth and self.evaluationFunction. Here are some method calls that might be useful when implementing minimax. gameState.getLegalActions(agentIndex): Returns a list of legal actions for an agent agentIndex=0 means Pacman, ghosts are &gt;= 1 gameState.generateSuccessor(agentIndex, action): Returns the successor game state after an agent takes an action gameState.getNumAgents(): Returns the total number of agents in the game gameState.isWin(): Returns whether or not the game state is a winning state gameState.isLose(): Returns whether or not the game state is a losing state &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; # util.raiseNotDefined() ghostIdx = [i for i in range(1, gameState.getNumAgents())] def term(state, depth): return state.isWin() or state.isLose() or depth == self.depth def minValue(state, depth, ghost): if term(state, depth): return self.evaluationFunction(state) value = 1e9 for action in state.getLegalActions(ghost): if ghost == ghostIdx[-1]: value = min(value, maxValue(state.generateSuccessor(ghost, action), depth + 1)) else: value = min(value, minValue(state.generateSuccessor(ghost, action), depth, ghost + 1)) return value def maxValue(state, depth): if term(state, depth): return self.evaluationFunction(state) value = -1e9 for action in state.getLegalActions(0): value = max(value, minValue(state.generateSuccessor(0, action), depth, ghostIdx[0])) return value res = [(action, minValue(gameState.generateSuccessor(0, action), 0, ghostIdx[0])) \\ for action in gameState.getLegalActions(0)] res.sort(key=lambda k: k[1]) return res[-1][0] Q3 (5 pts): Alpha-Beta Pruning Make a new agent that uses alpha-beta pruning to more efficiently explore the minimax tree, in AlphaBetaAgent. Again, your algorithm will be slightly more general than the pseudocode from lecture, so part of the challenge is to extend the alpha-beta pruning logic appropriately to multiple minimizer agents. You should see a speed-up (perhaps depth 3 alpha-beta will run as fast as depth 2 minimax). Ideally, depth 3 on smallClassic should run in just a few seconds per move or faster. 1python pacman.py -p AlphaBetaAgent -a depth=3 -l smallClassic The AlphaBetaAgent minimax values should be identical to the MinimaxAgent minimax values, although the actions it selects can vary because of different tie-breaking behavior. Again, the minimax values of the initial state in the minimaxClassic layout are 9, 8, 7 and -492 for depths 1, 2, 3 and 4 respectively. Grading: Because we check your code to determine whether it explores the correct number of states, it is important that you perform alpha-beta pruning without reordering children. In other words, successor states should always be processed in the order returned by GameState.getLegalActions. Again, do not call GameState.generateSuccessor more than necessary. You must not prune on equality in order to match the set of states explored by our autograder. (Indeed, alternatively, but incompatible with our autograder, would be to also allow for pruning on equality and invoke alpha-beta once on each child of the root node, but this will not match the autograder.) The pseudo-code below represents the algorithm you should implement for this question. To test and debug your code, run 1python autograder.py -q q3 This will show what your algorithm does on a number of small trees, as well as a pacman game. To run it without graphics, use: 1python autograder.py -q q3 --no-graphics The correct implementation of alpha-beta pruning will lead to Pacman losing some of the tests. This is not a problem: as it is correct behaviour, it will pass the tests. Answer Using self-defined function, alphaValue(), betaValue() to choose the most appropriate action Only when it’s the final state, can we get the value of each node, using the self.evaluationFunction(gameState) Otherwise, we just get the alpha/beta value we defined here. 12345678910def getNodeValue(self, gameState, depth = 0, agentIdx = 0, alpha = -1e9, beta = 1e9): maxParty = [0, ] minParty = list(range(1, gameState.getNumAgents())) if depth == self.depth or gameState.isLose() or gameState.isWin(): return self.evaluationFunction(gameState) elif agentIdx in maxParty: return self.alphaValue(gameState, depth, agentIdx, alpha, beta) elif agentIdx in minParty: return self.betaValue(gameState, depth, agentIdx, alpha, beta) 1234567891011121314def alphaValue(self, gameState, depth, agentIdx, alpha = -1e9, beta = 1e9): &quot;&quot;&quot; maxParty, search for maximums &quot;&quot;&quot; value = -1e9 legalActions = gameState.getLegalActions(agentIdx) for index, action in enumerate(legalActions): nextValue = self.getNodeValue(gameState.generateSuccessor(agentIdx, action), \\ depth, agentIdx + 1, alpha, beta) value = max(value, nextValue) if value &gt; beta: # next_agent in which party return value alpha = max(alpha, value) return value 123456789101112131415161718192021def betaValue(self, gameState, depth, agentIdx, alpha = -1e9, beta = 1e9): &quot;&quot;&quot; minParty, search for minimums &quot;&quot;&quot; value = 1e9 legalActions = gameState.getLegalActions(agentIdx) for index, action in enumerate(legalActions): if agentIdx == gameState.getNumAgents() - 1: nextValue = self.getNodeValue(gameState.generateSuccessor(agentIdx, action), \\ depth + 1, 0, alpha, beta) value = min(value, nextValue) # begin next depth if value &lt; alpha: return value else: nextValue = self.getNodeValue(gameState.generateSuccessor(agentIdx, action), \\ depth, agentIdx + 1, alpha, beta) value = min(value, nextValue) # begin next depth if value &lt; alpha: # next agent goes on at the same depth return value beta = min(beta, value) return value 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class AlphaBetaAgent(MultiAgentSearchAgent): &quot;&quot;&quot; Your minimax agent with alpha-beta pruning (question 3) &quot;&quot;&quot; def getAction(self, gameState: GameState): &quot;&quot;&quot; Returns the minimax action using self.depth and self.evaluationFunction &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; # util.raiseNotDefined() curValue, alpha, beta = -1e9, -1e9, 1e9 nextPacmanAction = Directions.STOP legalActions = gameState.getLegalActions(0).copy() for nextAction in legalActions: nextState = gameState.generateSuccessor(0, nextAction) nextValue = self.getNodeValue(nextState, 0, 1, alpha, beta) if nextValue &gt; curValue: curValue, nextPacmanAction = nextValue, nextAction alpha = max(alpha, curValue) return nextPacmanAction def getNodeValue(self, gameState, depth = 0, agentIdx = 0, alpha = -1e9, beta = 1e9): &quot;&quot;&quot; Using self-defined function, alphaValue(), betaValue() to choose the most appropriate action Only when it&#x27;s the final state, can we get the value of each node, using the self.evaluationFunction(gameState) Otherwise we just get the alpha/beta value we defined here. &quot;&quot;&quot; maxParty = [0, ] minParty = list(range(1, gameState.getNumAgents())) if depth == self.depth or gameState.isLose() or gameState.isWin(): return self.evaluationFunction(gameState) elif agentIdx in maxParty: return self.alphaValue(gameState, depth, agentIdx, alpha, beta) elif agentIdx in minParty: return self.betaValue(gameState, depth, agentIdx, alpha, beta) def alphaValue(self, gameState, depth, agentIdx, alpha = -1e9, beta = 1e9): &quot;&quot;&quot; maxParty, search for maximums &quot;&quot;&quot; value = -1e9 legalActions = gameState.getLegalActions(agentIdx) for index, action in enumerate(legalActions): nextValue = self.getNodeValue(gameState.generateSuccessor(agentIdx, action), \\ depth, agentIdx + 1, alpha, beta) value = max(value, nextValue) if value &gt; beta: # next_agent in which party return value alpha = max(alpha, value) return value def betaValue(self, gameState, depth, agentIdx, alpha = -1e9, beta = 1e9): &quot;&quot;&quot; minParty, search for minimums &quot;&quot;&quot; value = 1e9 legalActions = gameState.getLegalActions(agentIdx) for index, action in enumerate(legalActions): if agentIdx == gameState.getNumAgents() - 1: nextValue = self.getNodeValue(gameState.generateSuccessor(agentIdx, action), \\ depth + 1, 0, alpha, beta) value = min(value, nextValue) # begin next depth if value &lt; alpha: return value else: nextValue = self.getNodeValue(gameState.generateSuccessor(agentIdx, action), \\ depth, agentIdx + 1, alpha, beta) value = min(value, nextValue) # begin next depth if value &lt; alpha: # next agent goes on at the same depth return value beta = min(beta, value) return value Q4 (5 pts): Expectimax Minimax and alpha-beta are great, but they both assume that you are playing against an adversary who makes optimal decisions. As anyone who has ever won tic-tac-toe can tell you, this is not always the case. In this question you will implement the ExpectimaxAgent, which is useful for modeling probabilistic behavior of agents who may make suboptimal choices. As with the search and problems yet to be covered in this class, the beauty of these algorithms is their general applicability. To expedite your own development, we’ve supplied some test cases based on generic trees. You can debug your implementation on small the game trees using the command: 1python autograder.py -q q4 Debugging on these small and manageable test cases is recommended and will help you to find bugs quickly. Once your algorithm is working on small trees, you can observe its success in Pacman. Random ghosts are of course not optimal minimax agents, and so modeling them with minimax search may not be appropriate. ExpectimaxAgent will no longer take the min over all ghost actions, but the expectation according to your agent’s model of how the ghosts act. To simplify your code, assume you will only be running against an adversary which chooses amongst their getLegalActions uniformly at random. To see how the ExpectimaxAgent behaves in Pacman, run: 1python pacman.py -p ExpectimaxAgent -l minimaxClassic -a depth=3 You should now observe a more cavalier approach in close quarters with ghosts. In particular, if Pacman perceives that he could be trapped but might escape to grab a few more pieces of food, he’ll at least try. Investigate the results of these two scenarios: 1python pacman.py -p AlphaBetaAgent -l trappedClassic -a depth=3 -q -n 10 1python pacman.py -p ExpectimaxAgent -l trappedClassic -a depth=3 -q -n 10 You should find that your ExpectimaxAgent wins about half the time, while your AlphaBetaAgent always loses. Make sure you understand why the behavior here differs from the minimax case. The correct implementation of expectimax will lead to Pacman losing some of the tests. This is not a problem: as it is correct behaviour, it will pass the tests. Answer 12345678910maxValue = -1e9maxAction = Directions.STOPfor action in gameState.getLegalActions(0): sucState = gameState.generateSuccessor(0, action) sucValue = self.getNodeValue(sucState, 0, 1) if sucValue &gt; maxValue: maxValue, maxAction = sucValue, action return maxAction If the game state is the terminated, return the evaluation of the current state. Return the maximum value if the agent is the paceman, otherwise, return the expected value. 12345678def getNodeValue(self, gameState, curDepth, agentIndex): if curDepth == self.depth or gameState.isWin() or gameState.isLose(): return self.evaluationFunction(gameState) if agentIndex == 0: return self.maxValue(gameState, curDepth) else: return self.expValue(gameState, curDepth, agentIndex) Search for the ghosts’ maximum value. 1234567def maxValue(self, gameState, curDepth): maxValue = -1e9 for action in gameState.getLegalActions(0): sucState = gameState.generateSuccessor(0, action) sucValue = self.getNodeValue(sucState, curDepth, 1) maxValue = max(maxValue, sucValue) return maxValue If the agent is the last ghost, enter the next depth and search for the Pacman’s maximum value, otherwise, search for the ghosts’ EXP value. 12345678910111213def expValue(self, gameState, curDepth, agentIdx): totalValue = 0.0 numAgent = gameState.getNumAgents() for action in gameState.getLegalActions(agentIdx): sucState = gameState.generateSuccessor(agentIdx, action) if agentIdx == numAgent - 1: sucValue = self.getNodeValue(sucState, curDepth + 1, 0) else: sucValue = self.getNodeValue(sucState, curDepth, agentIdx + 1) totalValue += sucValue numAction = len(gameState.getLegalActions(agentIdx)) return totalValue / numAction Complete code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class ExpectimaxAgent(MultiAgentSearchAgent): &quot;&quot;&quot; Your expectimax agent (question 4) &quot;&quot;&quot; def getAction(self, gameState: GameState): &quot;&quot;&quot; Returns the expectimax action using self.depth and self.evaluationFunction All ghosts should be modeled as choosing uniformly at random from their legal moves. &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; # util.raiseNotDefined() maxValue = -1e9 maxAction = Directions.STOP for action in gameState.getLegalActions(0): sucState = gameState.generateSuccessor(0, action) sucValue = self.getNodeValue(sucState, 0, 1) if sucValue &gt; maxValue: maxValue, maxAction = sucValue, action return maxAction def getNodeValue(self, gameState, curDepth, agentIndex): if curDepth == self.depth or gameState.isWin() or gameState.isLose(): return self.evaluationFunction(gameState) if agentIndex == 0: return self.maxValue(gameState, curDepth) else: return self.expValue(gameState, curDepth, agentIndex) def maxValue(self, gameState, curDepth): maxValue = -1e9 for action in gameState.getLegalActions(0): sucState = gameState.generateSuccessor(0, action) sucValue = self.getNodeValue(sucState, curDepth, 1) maxValue = max(maxValue, sucValue) return maxValue def expValue(self, gameState, curDepth, agentIndex): totalValue = 0.0 numAgent = gameState.getNumAgents() for action in gameState.getLegalActions(agentIndex): sucState = gameState.generateSuccessor(agentIndex, action) if agentIndex == numAgent - 1: sucValue = self.getNodeValue(sucState, curDepth + 1, 0) else: sucValue = self.getNodeValue(sucState, curDepth, agentIndex + 1) totalValue += sucValue numAction = len(gameState.getLegalActions(agentIndex)) return totalValue / numAction Q5 (6 pts): Evaluation Function Write a better evaluation function for Pacman in the provided function betterEvaluationFunction. The evaluation function should evaluate states, rather than actions like your reflex agent evaluation function did. With depth 2 search, your evaluation function should clear the smallClassic layout with one random ghost more than half the time and still run at a reasonable rate (to get full credit, Pacman should be averaging around 1000 points when he’s winning). Grading: the autograder will run your agent on the smallClassic layout 10 times. We will assign points to your evaluation function in the following way: If you win at least once without timing out the autograder, you receive 1 points. Any agent not satisfying these criteria will receive 0 points. +1 for winning at least 5 times, +2 for winning all 10 times +1 for an average score of at least 500, +2 for an average score of at least 1000 (including scores on lost games) +1 if your games take on average less than 30 seconds on the autograder machine, when run with --no-graphics. The additional points for average score and computation time will only be awarded if you win at least 5 times. Please do not copy any files from Project 1, as it will not pass the autograder on Gradescope. You can try your agent out under these conditions with 1python autograder.py -q q5 To run it without graphics, use: 1python autograder.py -q q5 --no-graphics Answer 1234567891011121314151617181920212223242526272829303132333435363738394041def betterEvaluationFunction(currentGameState: GameState): &quot;&quot;&quot; Your extreme ghost-hunting, pellet-nabbing, food-gobbling, unstoppable evaluation function (question 5). DESCRIPTION: &lt;write something here so we know what you did&gt; &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; # util.raiseNotDefined() newPos = currentGameState.getPacmanPosition() newFood = currentGameState.getFood() newGhostStates = currentGameState.getGhostStates() # Consts INF = 100000000.0 # Infinite value WEIGHT_FOOD = 10.0 # Food base value WEIGHT_GHOST = -10.0 # Ghost base value WEIGHT_SCARED_GHOST = 100.0 # Scared ghost base value # Base on gameState.getScore() score = currentGameState.getScore() # Evaluate the distance to the closest food distancesToFoodList = [util.manhattanDistance(newPos, foodPos) for foodPos in newFood.asList()] if len(distancesToFoodList) &gt; 0: score += WEIGHT_FOOD / min(distancesToFoodList) else: score += WEIGHT_FOOD # Evaluate the distance to ghosts for ghost in newGhostStates: distance = manhattanDistance(newPos, ghost.getPosition()) if distance &gt; 0: if ghost.scaredTimer &gt; 0: # If scared, add points score += WEIGHT_SCARED_GHOST / distance else: # If not, decrease points score += WEIGHT_GHOST / distance else: return -INF # Pacman is dead at this point return score Autograder Report 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221Starting on 12-20 at 18:23:38Question q1===========Pacman emerges victorious! Score: 1238Pacman emerges victorious! Score: 1244Pacman emerges victorious! Score: 1239Pacman emerges victorious! Score: 1235Pacman emerges victorious! Score: 1233Pacman emerges victorious! Score: 1241Pacman emerges victorious! Score: 1246Pacman emerges victorious! Score: 1242Pacman emerges victorious! Score: 1239Pacman emerges victorious! Score: 1242Average Score: 1239.9Scores: 1238.0, 1244.0, 1239.0, 1235.0, 1233.0, 1241.0, 1246.0, 1242.0, 1239.0, 1242.0Win Rate: 10/10 (1.00)Record: Win, Win, Win, Win, Win, Win, Win, Win, Win, Win*** PASS: test_cases/q1/grade-agent.test (4 of 4 points)*** 1239.9 average score (2 of 2 points)*** Grading scheme:*** &lt; 500: 0 points*** &gt;= 500: 1 points*** &gt;= 1000: 2 points*** 10 games not timed out (0 of 0 points)*** Grading scheme:*** &lt; 10: fail*** &gt;= 10: 0 points*** 10 wins (2 of 2 points)*** Grading scheme:*** &lt; 1: fail*** &gt;= 1: 0 points*** &gt;= 5: 1 points*** &gt;= 10: 2 points### Question q1: 4/4 ###Question q2===========*** PASS: test_cases/q2/0-eval-function-lose-states-1.test*** PASS: test_cases/q2/0-eval-function-lose-states-2.test*** PASS: test_cases/q2/0-eval-function-win-states-1.test*** PASS: test_cases/q2/0-eval-function-win-states-2.test*** PASS: test_cases/q2/0-lecture-6-tree.test*** PASS: test_cases/q2/0-small-tree.test*** PASS: test_cases/q2/1-1-minmax.test*** PASS: test_cases/q2/1-2-minmax.test*** PASS: test_cases/q2/1-3-minmax.test*** PASS: test_cases/q2/1-4-minmax.test*** PASS: test_cases/q2/1-5-minmax.test*** PASS: test_cases/q2/1-6-minmax.test*** PASS: test_cases/q2/1-7-minmax.test*** PASS: test_cases/q2/1-8-minmax.test*** PASS: test_cases/q2/2-1a-vary-depth.test*** PASS: test_cases/q2/2-1b-vary-depth.test*** PASS: test_cases/q2/2-2a-vary-depth.test*** PASS: test_cases/q2/2-2b-vary-depth.test*** PASS: test_cases/q2/2-3a-vary-depth.test*** PASS: test_cases/q2/2-3b-vary-depth.test*** PASS: test_cases/q2/2-4a-vary-depth.test*** PASS: test_cases/q2/2-4b-vary-depth.test*** PASS: test_cases/q2/2-one-ghost-3level.test*** PASS: test_cases/q2/3-one-ghost-4level.test*** PASS: test_cases/q2/4-two-ghosts-3level.test*** PASS: test_cases/q2/5-two-ghosts-4level.test*** PASS: test_cases/q2/6-tied-root.test*** PASS: test_cases/q2/7-1a-check-depth-one-ghost.test*** PASS: test_cases/q2/7-1b-check-depth-one-ghost.test*** PASS: test_cases/q2/7-1c-check-depth-one-ghost.test*** PASS: test_cases/q2/7-2a-check-depth-two-ghosts.test*** PASS: test_cases/q2/7-2b-check-depth-two-ghosts.test*** PASS: test_cases/q2/7-2c-check-depth-two-ghosts.test*** Running MinimaxAgent on smallClassic 1 time(s).Pacman died! Score: 84Average Score: 84.0Scores: 84.0Win Rate: 0/1 (0.00)Record: Loss*** Finished running MinimaxAgent on smallClassic after 0 seconds.*** Won 0 out of 1 games. Average score: 84.000000 ****** PASS: test_cases/q2/8-pacman-game.test### Question q2: 5/5 ###Question q3===========*** PASS: test_cases/q3/0-eval-function-lose-states-1.test*** PASS: test_cases/q3/0-eval-function-lose-states-2.test*** PASS: test_cases/q3/0-eval-function-win-states-1.test*** PASS: test_cases/q3/0-eval-function-win-states-2.test*** PASS: test_cases/q3/0-lecture-6-tree.test*** PASS: test_cases/q3/0-small-tree.test*** PASS: test_cases/q3/1-1-minmax.test*** PASS: test_cases/q3/1-2-minmax.test*** PASS: test_cases/q3/1-3-minmax.test*** PASS: test_cases/q3/1-4-minmax.test*** PASS: test_cases/q3/1-5-minmax.test*** PASS: test_cases/q3/1-6-minmax.test*** PASS: test_cases/q3/1-7-minmax.test*** PASS: test_cases/q3/1-8-minmax.test*** PASS: test_cases/q3/2-1a-vary-depth.test*** PASS: test_cases/q3/2-1b-vary-depth.test*** PASS: test_cases/q3/2-2a-vary-depth.test*** PASS: test_cases/q3/2-2b-vary-depth.test*** PASS: test_cases/q3/2-3a-vary-depth.test*** PASS: test_cases/q3/2-3b-vary-depth.test*** PASS: test_cases/q3/2-4a-vary-depth.test*** PASS: test_cases/q3/2-4b-vary-depth.test*** PASS: test_cases/q3/2-one-ghost-3level.test*** PASS: test_cases/q3/3-one-ghost-4level.test*** PASS: test_cases/q3/4-two-ghosts-3level.test*** PASS: test_cases/q3/5-two-ghosts-4level.test*** PASS: test_cases/q3/6-tied-root.test*** PASS: test_cases/q3/7-1a-check-depth-one-ghost.test*** PASS: test_cases/q3/7-1b-check-depth-one-ghost.test*** PASS: test_cases/q3/7-1c-check-depth-one-ghost.test*** PASS: test_cases/q3/7-2a-check-depth-two-ghosts.test*** PASS: test_cases/q3/7-2b-check-depth-two-ghosts.test*** PASS: test_cases/q3/7-2c-check-depth-two-ghosts.test*** Running AlphaBetaAgent on smallClassic 1 time(s).Pacman died! Score: 84Average Score: 84.0Scores: 84.0Win Rate: 0/1 (0.00)Record: Loss*** Finished running AlphaBetaAgent on smallClassic after 0 seconds.*** Won 0 out of 1 games. Average score: 84.000000 ****** PASS: test_cases/q3/8-pacman-game.test### Question q3: 5/5 ###Question q4===========*** PASS: test_cases/q4/0-eval-function-lose-states-1.test*** PASS: test_cases/q4/0-eval-function-lose-states-2.test*** PASS: test_cases/q4/0-eval-function-win-states-1.test*** PASS: test_cases/q4/0-eval-function-win-states-2.test*** PASS: test_cases/q4/0-expectimax1.test*** PASS: test_cases/q4/1-expectimax2.test*** PASS: test_cases/q4/2-one-ghost-3level.test*** PASS: test_cases/q4/3-one-ghost-4level.test*** PASS: test_cases/q4/4-two-ghosts-3level.test*** PASS: test_cases/q4/5-two-ghosts-4level.test*** PASS: test_cases/q4/6-1a-check-depth-one-ghost.test*** PASS: test_cases/q4/6-1b-check-depth-one-ghost.test*** PASS: test_cases/q4/6-1c-check-depth-one-ghost.test*** PASS: test_cases/q4/6-2a-check-depth-two-ghosts.test*** PASS: test_cases/q4/6-2b-check-depth-two-ghosts.test*** PASS: test_cases/q4/6-2c-check-depth-two-ghosts.test*** Running ExpectimaxAgent on smallClassic 1 time(s).Pacman died! Score: 84Average Score: 84.0Scores: 84.0Win Rate: 0/1 (0.00)Record: Loss*** Finished running ExpectimaxAgent on smallClassic after 0 seconds.*** Won 0 out of 1 games. Average score: 84.000000 ****** PASS: test_cases/q4/7-pacman-game.test### Question q4: 5/5 ###Question q5===========Pacman emerges victorious! Score: 1373Pacman emerges victorious! Score: 1339Pacman emerges victorious! Score: 1032Pacman emerges victorious! Score: 1008Pacman emerges victorious! Score: 1344Pacman emerges victorious! Score: 1357Pacman emerges victorious! Score: 1322Pacman emerges victorious! Score: 1370Pacman emerges victorious! Score: 1288Pacman emerges victorious! Score: 1372Average Score: 1280.5Scores: 1373.0, 1339.0, 1032.0, 1008.0, 1344.0, 1357.0, 1322.0, 1370.0, 1288.0, 1372.0Win Rate: 10/10 (1.00)Record: Win, Win, Win, Win, Win, Win, Win, Win, Win, Win*** PASS: test_cases/q5/grade-agent.test (6 of 6 points)*** 1280.5 average score (2 of 2 points)*** Grading scheme:*** &lt; 500: 0 points*** &gt;= 500: 1 points*** &gt;= 1000: 2 points*** 10 games not timed out (1 of 1 points)*** Grading scheme:*** &lt; 0: fail*** &gt;= 0: 0 points*** &gt;= 10: 1 points*** 10 wins (3 of 3 points)*** Grading scheme:*** &lt; 1: fail*** &gt;= 1: 1 points*** &gt;= 5: 2 points*** &gt;= 10: 3 points### Question q5: 6/6 ###Finished at 18:23:47Provisional grades==================Question q1: 4/4Question q2: 5/5Question q3: 5/5Question q4: 5/5Question q5: 6/6------------------Total: 25/25Your grades are NOT yet registered. To register your grades, make sureto follow your instructor&#x27;s guidelines to receive credit on your project.","categories":[],"tags":[{"name":"CS188","slug":"CS188","permalink":"http://www.misaka-9982.com/tags/CS188/"},{"name":"AI","slug":"AI","permalink":"http://www.misaka-9982.com/tags/AI/"}]},{"title":"CS188 Proj 1","slug":"CS188-Proj-1","date":"2022-12-16T05:23:14.000Z","updated":"2022-12-16T12:37:31.385Z","comments":true,"path":"2022/12/16/CS188-Proj-1/","link":"","permalink":"http://www.misaka-9982.com/2022/12/16/CS188-Proj-1/","excerpt":"","text":"Project 1: Search Introduction In this project, your Pacman agent will find paths through his maze world, both to reach a particular location and to collect food efficiently. You will build general search algorithms and apply them to Pacman scenarios. As in Project 0, this project includes an autograder for you to grade your answers on your machine. This can be run with the command: 1python autograder.py See the autograder tutorial in Project 0 for more information about using the autograder. The code for this project consists of several Python files, some of which you will need to read and understand in order to complete the assignment, and some of which you can ignore. You can download all the code and supporting files as a search.zip. Files you’ll edit: search.py Where all of your search algorithms will reside. searchAgents.py Where all of your search-based agents will reside. Files you might want to look at: pacman.py The main file that runs Pacman games. This file describes a Pacman GameState type, which you use in this project. game.py The logic behind how the Pacman world works. This file describes several supporting types like AgentState, Agent, Direction, and Grid. util.py Useful data structures for implementing search algorithms. Supporting files you can ignore: graphicsDisplay.py Graphics for Pacman graphicsUtils.py Support for Pacman graphics textDisplay.py ASCII graphics for Pacman ghostAgents.py Agents to control ghosts keyboardAgents.py Keyboard interfaces to control Pacman layout.py Code for reading layout files and storing their contents autograder.py Project autograder testParser.py Parses autograder test and solution files testClasses.py General autograding test classes test_cases/ Directory containing the test cases for each question searchTestClasses.py Project 1 specific autograding test classes Files to Edit and Submit: You will fill in portions of search.py and searchAgents.py during the assignment. Once you have completed the assignment, you will submit a token generated by submission_autograder.py. Please do not change the other files in this distribution or submit any of our original files other than these files. Evaluation: Your code will be autograded for technical correctness. Please do not change the names of any provided functions or classes within the code, or you will wreak havoc on the autograder. However, the correctness of your implementation – not the autograder’s judgements – will be the final judge of your score. If necessary, we will review and grade assignments individually to ensure that you receive due credit for your work. Academic Dishonesty: We will be checking your code against other submissions in the class for logical redundancy. If you copy someone else’s code and submit it with minor changes, we will know. These cheat detectors are quite hard to fool, so please don’t try. We trust you all to submit your own work only; please don’t let us down. If you do, we will pursue the strongest consequences available to us. Getting Help: You are not alone! If you find yourself stuck on something, contact the course staff for help. Office hours, section, and the discussion forum are there for your support; please use them. If you can’t make our office hours, let us know and we will schedule more. We want these projects to be rewarding and instructional, not frustrating and demoralizing. But, we don’t know when or how to help unless you ask. Discussion: Please be careful not to post spoilers. Welcome to Pacman After downloading the code, unzipping it, and changing to the directory, you should be able to play a game of Pacman by typing the following at the command line: 1python pacman.py Pacman lives in a shiny blue world of twisting corridors and tasty round treats. Navigating this world efficiently will be Pacman’s first step in mastering his domain. The simplest agent in searchAgents.py is called the GoWestAgent, which always goes West (a trivial reflex agent). This agent can occasionally win: 1python pacman.py --layout testMaze --pacman GoWestAgent But, things get ugly for this agent when turning is required: 1python pacman.py --layout tinyMaze --pacman GoWestAgent If Pacman gets stuck, you can exit the game by typing CTRL-c into your terminal. Soon, your agent will solve not only tinyMaze, but any maze you want. Note that pacman.py supports a number of options that can each be expressed in a long way (e.g., --layout) or a short way (e.g., -l). You can see the list of all options and their default values via: 1python pacman.py -h Also, all of the commands that appear in this project also appear in commands.txt, for easy copying and pasting. In UNIX/Mac OS X, you can even run all these commands in order with bash commands.txt. New Syntax You may not have seen this syntax before: 1def my_function(a: int, b: Tuple[int, int], c: List[List], d: Any, e: float=1.0): Copy This is annotating the type of the arguments that Python should expect for this function. In the example below, a should be an int – integer, b should be a tuple of 2 ints, c should be a List of Lists of anything – therefore a 2D array of anything, d is essentially the same as not annotated and can by anything, and e should be a float. e is also set to 1.0 if nothing is passed in for it, i.e.: 1my_function(1, (2, 3), [[&#x27;a&#x27;, &#x27;b&#x27;], [None, my_class], [[]]], (&#x27;h&#x27;, 1)) The above call fits the type annotations, and doesn’t pass anything in for e. Type annotations are meant to be an adddition to the docstrings to help you know what the functions are working with. Python itself doesn’t enforce these. When writing your own functions, it is up to you if you want to annotate your types; they may be helpful to keep organized or not something you want to spend time on. Q1 (3 pts): Finding a Fixed Food Dot using Depth First Search In searchAgents.py, you’ll find a fully implemented SearchAgent, which plans out a path through Pacman’s world and then executes that path step-by-step. The search algorithms for formulating a plan are not implemented – that’s your job. First, test that the SearchAgent is working correctly by running: 1python pacman.py -l tinyMaze -p SearchAgent -a fn=tinyMazeSearch The command above tells the SearchAgent to use tinyMazeSearch as its search algorithm, which is implemented in search.py. Pacman should navigate the maze successfully. Now it’s time to write full-fledged generic search functions to help Pacman plan routes! Pseudocode for the search algorithms you’ll write can be found in the lecture slides. Remember that a search node must contain not only a state but also the information necessary to reconstruct the path (plan) which gets to that state. Important note: All of your search functions need to return a list of actions that will lead the agent from the start to the goal. These actions all have to be legal moves (valid directions, no moving through walls). Important note: Make sure to use the Stack, Queue and PriorityQueue data structures provided to you in util.py! These data structure implementations have particular properties which are required for compatibility with the autograder. Hint: Each algorithm is very similar. Algorithms for DFS, BFS, UCS, and A* differ only in the details of how the fringe is managed. So, concentrate on getting DFS right and the rest should be relatively straightforward. Indeed, one possible implementation requires only a single generic search method which is configured with an algorithm-specific queuing strategy. (Your implementation need not be of this form to receive full credit). Implement the depth-first search (DFS) algorithm in the depthFirstSearch function in search.py. To make your algorithm complete, write the graph search version of DFS, which avoids expanding any already visited states. Your code should quickly find a solution for: 123python pacman.py -l tinyMaze -p SearchAgentpython pacman.py -l mediumMaze -p SearchAgentpython pacman.py -l bigMaze -z .5 -p SearchAgent The Pacman board will show an overlay of the states explored, and the order in which they were explored (brighter red means earlier exploration). Is the exploration order what you would have expected? Does Pacman actually go to all the explored squares on his way to the goal? Hint: If you use a Stack as your data structure, the solution found by your DFS algorithm for mediumMaze should have a length of 130 (provided you push successors onto the fringe in the order provided by getSuccessors; you might get 246 if you push them in the reverse order). Is this a least cost solution? If not, think about what depth-first search is doing wrong. Grading: Please run the below command to see if your implementation passes all the autograder test cases. 1python autograder.py -q q1 Answer The following code uses the Stack as frontier, which means that the node pushed into it first will be dealt with last, and when a node n is pop out, it will push all of its successors on the frontier to be dealt with before other nodes as the same depth with n have been processed 1234567891011121314151617181920212223242526272829303132def depthFirstSearch(problem: SearchProblem): &quot;&quot;&quot; Search the deepest nodes in the search tree first. Your search algorithm needs to return a list of actions that reaches the goal. Make sure to implement a graph search algorithm. To get started, you might want to try some of these simple commands to understand the search problem that is being passed in: print(&quot;Start:&quot;, problem.getStartState()) print(&quot;Is the start a goal?&quot;, problem.isGoalState(problem.getStartState())) print(&quot;Start&#x27;s successors:&quot;, problem.getSuccessors(problem.getStartState())) &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; from util import Stack frontier = Stack() visited = set() frontier.push((problem.getStartState(), [])) while not frontier.isEmpty(): node, path = frontier.pop() if problem.isGoalState(node): return path if node not in visited: visited.add(node) for successor in problem.getSuccessors(node): frontier.push((successor[0], path + [successor[1]])) return [] Q2 (3 pts): Breadth First Search Implement the breadth-first search (BFS) algorithm in the breadthFirstSearch function in search.py. Again, write a graph search algorithm that avoids expanding any already visited states. Test your code the same way you did for depth-first search. 12python pacman.py -l mediumMaze -p SearchAgent -a fn=bfspython pacman.py -l bigMaze -p SearchAgent -a fn=bfs -z .5 Does BFS find a least cost solution? If not, check your implementation. Hint: If Pacman moves too slowly for you, try the option –frameTime 0. Note: If you’ve written your search code generically, your code should work equally well for the eight-puzzle search problem without any changes. 1python eightpuzzle.py Grading: Please run the below command to see if your implementation passes all the autograder test cases. 1python autograder.py -q q2 Answer The following code uses the Queue as frontier, which means that the node pushed into it first will be dealt with first, and when a node n is pop out, it will push all of its successors on the frontier to be dealt with after other nodes as the same depth with n have been processed 1234567891011121314151617181920def breadthFirstSearch(problem: SearchProblem): &quot;&quot;&quot;Search the shallowest nodes in the search tree first.&quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; from util import Queue frontier = Queue() visited = set() frontier.push((problem.getStartState(), [])) while not frontier.isEmpty(): node, path = frontier.pop() if problem.isGoalState(node): return path if node not in visited: visited.add(node) for successor in problem.getSuccessors(node): frontier.push((successor[0], path + [successor[1]])) return [] Q3 (3 pts): Varying the Cost Function While BFS will find a fewest-actions path to the goal, we might want to find paths that are “best” in other senses. Consider mediumDottedMaze and mediumScaryMaze. By changing the cost function, we can encourage Pacman to find different paths. For example, we can charge more for dangerous steps in ghost-ridden areas or less for steps in food-rich areas, and a rational Pacman agent should adjust its behavior in response. Implement the uniform-cost graph search algorithm in the uniformCostSearch function in search.py. We encourage you to look through util.py for some data structures that may be useful in your implementation. You should now observe successful behavior in all three of the following layouts, where the agents below are all UCS agents that differ only in the cost function they use (the agents and cost functions are written for you): 123python pacman.py -l mediumMaze -p SearchAgent -a fn=ucspython pacman.py -l mediumDottedMaze -p StayEastSearchAgentpython pacman.py -l mediumScaryMaze -p StayWestSearchAgent Note: You should get very low and very high path costs for the StayEastSearchAgent and StayWestSearchAgent respectively, due to their exponential cost functions (see searchAgents.py for details). Grading: Please run the below command to see if your implementation passes all the autograder test cases. 1python autograder.py -q q3 Answer The following code uses the PriorityQueue as frontier, which means that the node pushed into it will be dealt with by the order of priority. Each node’s priority is equal to the cost of the last node to this node add the priority of the last node. The start state’s priority is equal to 0. 1234567891011121314151617181920212223def uniformCostSearch(problem: SearchProblem): &quot;&quot;&quot;Search the node of least total cost first.&quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; # util.raiseNotDefined() from util import PriorityQueue frontier = PriorityQueue() visited = set() frontier.push((problem.getStartState(), [], 0), 0) while not frontier.isEmpty(): node, path, priority = frontier.pop() if problem.isGoalState(node): return path if node not in visited: visited.add(node) for successor in problem.getSuccessors(node): frontier.push((successor[0], path + [successor[1]], successor[2] + priority),\\ successor[2] + priority) return [] Q4 (3 pts): A* search Implement A* graph search in the empty function aStarSearch in search.py. A* takes a heuristic function as an argument. Heuristics take two arguments: a state in the search problem (the main argument), and the problem itself (for reference information). The nullHeuristic heuristic function in search.py is a trivial example. You can test your A* implementation on the original problem of finding a path through a maze to a fixed position using the Manhattan distance heuristic (implemented already as manhattanHeuristic in searchAgents.py). 1python pacman.py -l bigMaze -z .5 -p SearchAgent -a fn=astar,heuristic=manhattanHeuristic You should see that A* finds the optimal solution slightly faster than uniform cost search (about 549 vs. 620 search nodes expanded in our implementation, but ties in priority may make your numbers differ slightly). What happens on openMaze for the various search strategies? Grading: Please run the below command to see if your implementation passes all the autograder test cases. 1python autograder.py -q q4 Answer $ g(n) = successor[2] + priority,\\ h(n) = heuristic,\\ f(n) = g(n) + h(n)$ 123456789101112131415161718192021222324def aStarSearch(problem: SearchProblem, heuristic=nullHeuristic): &quot;&quot;&quot;Search the node that has the lowest combined cost and heuristic first.&quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; # util.raiseNotDefined() from util import PriorityQueue frontier = PriorityQueue() visited = set() frontier.push((problem.getStartState(), [], 0), 0) while not frontier.isEmpty(): node, path, priority = frontier.pop() if problem.isGoalState(node): return path if node not in visited: visited.add(node) for successor in problem.getSuccessors(node): frontier.push((successor[0], path + [successor[1]], successor[2] + priority),\\ successor[2] + priority + heuristic(successor[0], problem)) return [] Q5 (3 pts): Finding All the Corners The real power of A* will only be apparent with a more challenging search problem. Now, it’s time to formulate a new problem and design a heuristic for it. In corner mazes, there are four dots, one in each corner. Our new search problem is to find the shortest path through the maze that touches all four corners (whether the maze actually has food there or not). Note that for some mazes like tinyCorners, the shortest path does not always go to the closest food first! Hint: the shortest path through tinyCorners takes 28 steps. Note: Make sure to complete Question 2 before working on Question 5, because Question 5 builds upon your answer for Question 2. Implement the CornersProblem search problem in searchAgents.py. You will need to choose a state representation that encodes all the information necessary to detect whether all four corners have been reached. Now, your search agent should solve: 12python pacman.py -l tinyCorners -p SearchAgent -a fn=bfs,prob=CornersProblempython pacman.py -l mediumCorners -p SearchAgent -a fn=bfs,prob=CornersProblem To receive full credit, you need to define an abstract state representation that does not encode irrelevant information (like the position of ghosts, where extra food is, etc.). In particular, do not use a Pacman GameState as a search state. Your code will be very, very slow if you do (and also wrong). Hint 1: The only parts of the game state you need to reference in your implementation are the starting Pacman position and the location of the four corners. Hint 2: When coding up getSuccessors, make sure to add children to your successors list with a cost of 1. Our implementation of breadthFirstSearch expands just under 2000 search nodes on mediumCorners. However, heuristics (used with A* search) can reduce the amount of searching required. Grading: Please run the below command to see if your implementation passes all the autograder test cases. 1python autograder.py -q q5 Answer(simple) The following code uses a Tuple to store the state of the food in each corners 123456789def getStartState(self): &quot;&quot;&quot; Returns the start state (in your state space, not the full Pacman state space) &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; # util.raiseNotDefined() res = (self.startingPosition, False, False, False, False) return res The following code uses a for loop to confirm whether the current state is the goal state. 123456789def isGoalState(self, state: Any): &quot;&quot;&quot; Returns whether this search state is a goal state of the problem. &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; # util.raiseNotDefined() for item in state[1:]: if not item: return False 123456789101112131415161718192021222324252627282930313233343536def getSuccessors(self, state: Any): &quot;&quot;&quot; Returns successor states, the actions they require, and a cost of 1. As noted in search.py: For a given state, this should return a list of triples, (successor, action, stepCost), where &#x27;successor&#x27; is a successor to the current state, &#x27;action&#x27; is the action required to get there, and &#x27;stepCost&#x27; is the incremental cost of expanding to that successor &quot;&quot;&quot; successors = [] for action in [Directions.NORTH, Directions.SOUTH, Directions.EAST, Directions.WEST]: # Add a successor state to the successor list if the action is legal # Here&#x27;s a code snippet for figuring out whether a new position hits a wall: # x,y = currentPosition # dx, dy = Actions.directionToVector(action) # nextx, nexty = int(x + dx), int(y + dy) # hitsWall = self.walls[nextx][nexty] &quot;*** YOUR CODE HERE ***&quot; x, y = state[0] dx, dy = Actions.directionToVector(action) nextx, nexty = int(x + dx), int(y + dy) hitsWall = self.walls[nextx][nexty] if not hitsWall: nextState = (nextx, nexty) corners = state[1:] if nextState in self.corners: corners = list(corners) corners[self.corners.index(nextState)] = True corners = tuple(corners) successors.append(((nextState, *corners), action, 1)) self._expanded += 1 # DO NOT CHANGE return successors 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081class CornersProblem(search.SearchProblem): &quot;&quot;&quot; This search problem finds paths through all four corners of a layout. You must select a suitable state space and successor function &quot;&quot;&quot; def __init__(self, startingGameState: pacman.GameState): &quot;&quot;&quot; Stores the walls, pacman&#x27;s starting position and corners. &quot;&quot;&quot; self.walls = startingGameState.getWalls() self.startingPosition = startingGameState.getPacmanPosition() top, right = self.walls.height-2, self.walls.width-2 self.corners = ((1,1), (1,top), (right, 1), (right, top)) for corner in self.corners: if not startingGameState.hasFood(*corner): print(&#x27;Warning: no food in corner &#x27; + str(corner)) self._expanded = 0 # DO NOT CHANGE; Number of search nodes expanded # Please add any code here which you would like to use # in initializing the problem &quot;*** YOUR CODE HERE ***&quot; def getStartState(self): &quot;&quot;&quot; Returns the start state (in your state space, not the full Pacman state space) &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; # util.raiseNotDefined() res = (self.startingPosition, False, False, False, False) return res def isGoalState(self, state: Any): &quot;&quot;&quot; Returns whether this search state is a goal state of the problem. &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; # util.raiseNotDefined() for item in state[1:]: if not item: return False return True def getSuccessors(self, state: Any): &quot;&quot;&quot; Returns successor states, the actions they require, and a cost of 1. As noted in search.py: For a given state, this should return a list of triples, (successor, action, stepCost), where &#x27;successor&#x27; is a successor to the current state, &#x27;action&#x27; is the action required to get there, and &#x27;stepCost&#x27; is the incremental cost of expanding to that successor &quot;&quot;&quot; successors = [] for action in [Directions.NORTH, Directions.SOUTH, Directions.EAST, Directions.WEST]: # Add a successor state to the successor list if the action is legal # Here&#x27;s a code snippet for figuring out whether a new position hits a wall: # x,y = currentPosition # dx, dy = Actions.directionToVector(action) # nextx, nexty = int(x + dx), int(y + dy) # hitsWall = self.walls[nextx][nexty] &quot;*** YOUR CODE HERE ***&quot; x, y = state[0] dx, dy = Actions.directionToVector(action) nextx, nexty = int(x + dx), int(y + dy) hitsWall = self.walls[nextx][nexty] if not hitsWall: nextState = (nextx, nexty) corners = state[1:] if nextState in self.corners: corners = list(corners) corners[self.corners.index(nextState)] = True corners = tuple(corners) successors.append(((nextState, *corners), action, 1)) self._expanded += 1 # DO NOT CHANGE return successors Answer (optimize) The following code use a tuple to store position and corners as a state 12345678def getStartState(self): &quot;&quot;&quot; Returns the start state (in your state space, not the full Pacman state space) &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; # util.raiseNotDefined() return (self.startingPosition, self.corners) The problem is solved when Pacman’s position is equal to the only remaining unvisited corner. 12345678def isGoalState(self, state: Any): &quot;&quot;&quot; Returns whether this search state is a goal state of the problem. &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; # util.raiseNotDefined() pacmanPos, unvisitedCorners = state return unvisitedCorners == (pacmanPos,) The successors are computed by filtering illegal locations and then constructing the next state by filtering the unvisited corners to ensure that none is Pacman’s current position. 123456789101112131415161718192021222324252627282930313233343536373839def getSuccessors(self, state: Any): &quot;&quot;&quot; Returns successor states, the actions they require, and a cost of 1. As noted in search.py: For a given state, this should return a list of triples, (successor, action, stepCost), where &#x27;successor&#x27; is a successor to the current state, &#x27;action&#x27; is the action required to get there, and &#x27;stepCost&#x27; is the incremental cost of expanding to that successor &quot;&quot;&quot; pacmanPos, unvisitedCorners = state successors = [] for action in [Directions.NORTH, Directions.SOUTH, Directions.EAST, Directions.WEST]: # Add a successor state to the successor list if the action is legal # Here&#x27;s a code snippet for figuring out whether a new position hits a wall: # x,y = currentPosition # dx, dy = Actions.directionToVector(action) # nextx, nexty = int(x + dx), int(y + dy) # hitsWall = self.walls[nextx][nexty] &quot;*** YOUR CODE HERE ***&quot; x, y = state[0] dx, dy = Actions.directionToVector(action) nextx, nexty = int(x + dx), int(y + dy) hitsWall = self.walls[nextx][nexty] if hitsWall: continue nextPacmanPos = (nextx, nexty) nextUnvisitedCorners = tuple( corner for corner in unvisitedCorners if corner != pacmanPos ) nextState = (nextPacmanPos, nextUnvisitedCorners) successors.append((nextState, action, 1)) self._expanded += 1 # DO NOT CHANGE return successors 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657def getStartState(self): &quot;&quot;&quot; Returns the start state (in your state space, not the full Pacman state space) &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; # util.raiseNotDefined() return (self.startingPosition, self.corners) def isGoalState(self, state: Any): &quot;&quot;&quot; Returns whether this search state is a goal state of the problem. &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; # util.raiseNotDefined() pacmanPos, unvisitedCorners = state return unvisitedCorners == (pacmanPos,) def getSuccessors(self, state: Any): &quot;&quot;&quot; Returns successor states, the actions they require, and a cost of 1. As noted in search.py: For a given state, this should return a list of triples, (successor, action, stepCost), where &#x27;successor&#x27; is a successor to the current state, &#x27;action&#x27; is the action required to get there, and &#x27;stepCost&#x27; is the incremental cost of expanding to that successor &quot;&quot;&quot; pacmanPos, unvisitedCorners = state successors = [] for action in [Directions.NORTH, Directions.SOUTH, Directions.EAST, Directions.WEST]: # Add a successor state to the successor list if the action is legal # Here&#x27;s a code snippet for figuring out whether a new position hits a wall: # x,y = currentPosition # dx, dy = Actions.directionToVector(action) # nextx, nexty = int(x + dx), int(y + dy) # hitsWall = self.walls[nextx][nexty] &quot;*** YOUR CODE HERE ***&quot; x, y = state[0] dx, dy = Actions.directionToVector(action) nextx, nexty = int(x + dx), int(y + dy) hitsWall = self.walls[nextx][nexty] if hitsWall: continue nextPacmanPos = (nextx, nexty) nextUnvisitedCorners = tuple( corner for corner in unvisitedCorners if corner != pacmanPos ) nextState = (nextPacmanPos, nextUnvisitedCorners) successors.append((nextState, action, 1)) self._expanded += 1 # DO NOT CHANGE return successors Q6 (3 pts): Corners Problem: Heuristic Note: Make sure to complete Question 4 before working on Question 6, because Question 6 builds upon your answer for Question 4. Implement a non-trivial, consistent heuristic for the CornersProblem in cornersHeuristic. 1python pacman.py -l mediumCorners -p AStarCornersAgent -z 0.5 Note: AStarCornersAgent is a shortcut for 1-p SearchAgent -a fn=aStarSearch,prob=CornersProblem,heuristic=cornersHeuristic Admissibility vs. Consistency: Remember, heuristics are just functions that take search states and return numbers that estimate the cost to a nearest goal. More effective heuristics will return values closer to the actual goal costs. To be admissible, the heuristic values must be lower bounds on the actual shortest path cost to the nearest goal (and non-negative). To be consistent, it must additionally hold that if an action has cost c, then taking that action can only cause a drop in heuristic of at most c. Remember that admissibility isn’t enough to guarantee correctness in graph search – you need the stronger condition of consistency. However, admissible heuristics are usually also consistent, especially if they are derived from problem relaxations. Therefore it is usually easiest to start out by brainstorming admissible heuristics. Once you have an admissible heuristic that works well, you can check whether it is indeed consistent, too. The only way to guarantee consistency is with a proof. However, inconsistency can often be detected by verifying that for each node you expand, its successor nodes are equal or higher in in f-value. Moreover, if UCS and A* ever return paths of different lengths, your heuristic is inconsistent. This stuff is tricky! Non-Trivial Heuristics: The trivial heuristics are the ones that return zero everywhere (UCS) and the heuristic which computes the true completion cost. The former won’t save you any time, while the latter will timeout the autograder. You want a heuristic which reduces total compute time, though for this assignment the autograder will only check node counts (aside from enforcing a reasonable time limit). Grading: Your heuristic must be a non-trivial non-negative consistent heuristic to receive any points. Make sure that your heuristic returns 0 at every goal state and never returns a negative value. Depending on how few nodes your heuristic expands, you’ll be graded: Number of nodes expanded Grade more than 2000 0/3 at most 2000 1/3 at most 1600 2/3 at most 1200 3/3 Remember: If your heuristic is inconsistent, you will receive no credit, so be careful! Grading: Please run the below command to see if your implementation passes all the autograder test cases. 1python autograder.py -q q6 Answer(simple) The following code uses the manhattan distance between Pacman’s position and the corner as the corners Heuristic value. The heuristic resulted in the expansion of 1136 nodes. 12345678910111213141516171819202122def cornersHeuristic(state: Any, problem: CornersProblem): &quot;&quot;&quot; A heuristic for the CornersProblem that you defined. state: The current search state (a data structure you chose in your search problem) problem: The CornersProblem instance for this layout. This function should always return a number that is a lower bound on the shortest path from the state to a goal of the problem; i.e. it should be admissible (as well as consistent). &quot;&quot;&quot; corners = problem.corners # These are the corner coordinates walls = problem.walls # These are the walls of the maze, as a Grid (game.py) &quot;*** YOUR CODE HERE ***&quot; value = 0 for idx in range(len(corners)): if not state[idx + 1]: value = max(value, util.manhattanDistance(state[0], corners[idx])) return value # Default to trivial solution Answer (optimize) This approach will be efficient. Consider an intermediate state which may have already visited any of the four corners. List out the unvisited corners and compute the Manhattan distance to each of them. Now select the corner with a minimum manhattan distance. Note down the distance. This is the minimum number of steps needed to reach the corner irrespective of the board. Update the current position of Pacman to this corner. Remove this corner from the unvisited corners list. Loop over until the unvisited corners are empty. The sum of these distances will be an Admissible and Consistent Heuristic. Furthermore, this heuristic solved the problem optimally by only expanding 702 nodes. 12345678910111213141516171819202122232425262728293031323334353637def cornersHeuristic(state: Any, problem: CornersProblem): &quot;&quot;&quot; A heuristic for the CornersProblem that you defined. state: The current search state (a data structure you chose in your search problem) problem: The CornersProblem instance for this layout. This function should always return a number that is a lower bound on the shortest path from the state to a goal of the problem; i.e. it should be admissible (as well as consistent). &quot;&quot;&quot; corners = problem.corners # These are the corner coordinates walls = problem.walls # These are the walls of the maze, as a Grid (game.py) &quot;*** YOUR CODE HERE ***&quot; def distanceArgmin(pos, points): index, minDist = None, 1e9 for curIdx, curPoint in enumerate(points): curDist = util.manhattanDistance(pos, curPoint) # curDist = mazeDistance(pos, curPoint, problem.startingGameState) if curDist &lt; minDist: index, minDist = curIdx, curDist return index, minDist def optimalPathWithoutWalls(fromPos, throughPoints): points = list(throughPoints) # print(points) pos, pathLength = fromPos, 0 while points != []: index, dist = distanceArgmin(pos, points) pathLength += dist pos = points[index] points.pop(index) return pathLength return optimalPathWithoutWalls(*state) Another thought is to use the MazeDistance function to compute the heuristic value. This method will solve the medium search problem by only expanding 129 nodes. But it will ***** FAIL: inconsistent heuristic ** in the 3rd test case. I don’t know how to fix it. Readers can try it if you are interested in it. Q7 (4 pts): Eating All The Dots Now we’ll solve a hard search problem: eating all the Pacman food in as few steps as possible. For this, we’ll need a new search problem definition which formalizes the food-clearing problem: FoodSearchProblem in searchAgents.py (implemented for you). A solution is defined to be a path that collects all of the food in the Pacman world. For the present project, solutions do not take into account any ghosts or power pellets; solutions only depend on the placement of walls, regular food and Pacman. (Of course ghosts can ruin the execution of a solution! We’ll get to that in the next project.) If you have written your general search methods correctly, A* with a null heuristic (equivalent to uniform-cost search) should quickly find an optimal solution to testSearch with no code change on your part (total cost of 7). 1python pacman.py -l testSearch -p AStarFoodSearchAgent Note: AStarFoodSearchAgent is a shortcut for 1-p SearchAgent -a fn=astar,prob=FoodSearchProblem,heuristic=foodHeuristic You should find that UCS starts to slow down even for the seemingly simple tinySearch. As a reference, our implementation takes 2.5 seconds to find a path of length 27 after expanding 5057 search nodes. Note: Make sure to complete Question 4 before working on Question 7, because Question 7 builds upon your answer for Question 4. Fill in foodHeuristic in searchAgents.py with a consistent heuristic for the FoodSearchProblem. Try your agent on the trickySearch board: 1python pacman.py -l trickySearch -p AStarFoodSearchAgent Our UCS agent finds the optimal solution in about 13 seconds, exploring over 16,000 nodes. Any non-trivial non-negative consistent heuristic will receive 1 point. Make sure that your heuristic returns 0 at every goal state and never returns a negative value. Depending on how few nodes your heuristic expands, you’ll get additional points: Number of nodes expanded Grade more than 15000 1/4 at most 15000 2/4 at most 12000 3/4 at most 9000 4/4 (full credit; medium) at most 7000 5/4 (optional extra credit; hard) Remember: If your heuristic is inconsistent, you will receive no credit, so be careful! Can you solve mediumSearch in a short time? If so, we’re either very, very impressed, or your heuristic is inconsistent. Grading: Please run the below command to see if your implementation passes all the autograder test cases. 1python autograder.py -q q7 Answer (simple) The following code uses the Maze Distance between the Pacman and the food closest to the Pacman as a heuristic value. This heuristic solved the problem optimally by expanding 4137 nodes. 1234567891011121314151617181920212223242526272829303132333435def foodHeuristic(state: Tuple[Tuple, List[List]], problem: FoodSearchProblem): &quot;&quot;&quot; Your heuristic for the FoodSearchProblem goes here. This heuristic must be consistent to ensure correctness. First, try to come up with an admissible heuristic; almost all admissible heuristics will be consistent as well. If using A* ever finds a solution that is worse uniform cost search finds, your heuristic is *not* consistent, and probably not admissible! On the other hand, inadmissible or inconsistent heuristics may find optimal solutions, so be careful. The state is a tuple ( pacmanPosition, foodGrid ) where foodGrid is a Grid (see game.py) of either True or False. You can call foodGrid.asList() to get a list of food coordinates instead. If you want access to info like walls, capsules, etc., you can query the problem. For example, problem.walls gives you a Grid of where the walls are. If you want to *store* information to be reused in other calls to the heuristic, there is a dictionary called problem.heuristicInfo that you can use. For example, if you only want to count the walls once and store that value, try: problem.heuristicInfo[&#x27;wallCount&#x27;] = problem.walls.count() Subsequent calls to this heuristic can access problem.heuristicInfo[&#x27;wallCount&#x27;] &quot;&quot;&quot; position, foodGrid = state &quot;*** YOUR CODE HERE ***&quot; value = 0 foods = foodGrid.asList() for food in foods: value = max(value, mazeDistance(food, position, problem.startingGameState)) return value Answer (optimize) The approach for this solution was construct a fully-connected graph between all the food items were the weight between two items was the distance between them within the maze (i.e. the maze distance). The was computed using a breadth-first search for each pair of points and storing the result in an adjacency matrix. The heuristic was constructed by taking the maze distance to the closest food item plus the total weight across the minimum spanning tree of uneaten food items. Computing the adjacency matrix was an expensive operation, and therefore the result was cached and variants on the matrix were constructed by zeroing out the rows and columns corresponding to already eaten food pellets. The figure below shows the full and partial adjacency matrices for the medium search problem. This approach was graded 5/4 and expanded 255 nodes. Experiments with Manhattan distance rather than maze distance yielded a grade of 4/4 and expanded 7137 nodes. Furthermore, this program version took significantly longer to run, confirming that computing the expensive adjacency matrix before searching for the solution reduced the overall cost. However, the process of computing the initial adjacency matrix could be hugely optimized with more aggressive caching. The current solution independently computes the pairwise distances between food pellets, despite the computation for any given pair (that aren’t a distance=1 from each other) necessarily traversing over many intermediate food pellets. Given that BFS runs in O(V+E), where V is the number of legal positions in the maze and E is the number of valid transitions between positions. Therefore, the current computation of the matrix is O(F^2(V+E)) for F food pellets. As F &lt;= V and the grid structure of the graph restricts E = cV, 1 &lt; c &lt; 4, in the worst case this is becomes O(V^3). An improvement to this algorithm would be to use Prim’s algorithm to construct a minimum spanning from each food pellet and record cumulative distances as the tree is built. Prim’s algorithm has time complexity O(E ln V), therefore, this algorithm would be O(FE ln V) = O(V^2 ln V). The following is the core bits of code for the solution: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110@lru_cache(maxsize=None)def getFoodIndices(gameState): return &#123;f: i for i, f in enumerate(gameState.getFood().asList())&#125;@lru_cache(maxsize=None)def getFoodAdjacencyMatrix(gameState): foodList = gameState.getFood().asList() foodIndices = getFoodIndices(gameState) numFood = len(foodList) adjM = np.zeros((numFood, numFood)) for f1, f2 in combinations(foodList, 2): i, j = foodIndices[f1], foodIndices[f2] adjM[i, j] = adjM[j, i] = mazeDistance(gameState, f1, f2) return adjMclass FoodSearchProblem: &quot;&quot;&quot; A search problem associated with finding the a path that collects all of the food (dots) in a Pacman game. A search state in this problem is a tuple ( pacmanPosition, foodGrid ) where pacmanPosition: a tuple (x,y) of integers specifying Pacman&#x27;s position foodGrid: a Grid (see game.py) of either True or False, specifying remaining food &quot;&quot;&quot; def __init__(self, startingGameState: pacman.GameState): self.start = (startingGameState.getPacmanPosition(), startingGameState.getFood()) self.walls = startingGameState.getWalls() self.startingGameState = startingGameState self._expanded = 0 # DO NOT CHANGE self.heuristicInfo = &#123; &#x27;initialFood&#x27;: startingGameState.getFood().asList(), &#x27;foodIndices&#x27;: getFoodIndices(startingGameState), &#x27;foodAdjMatrix&#x27;: getFoodAdjacencyMatrix(startingGameState), &#x27;mazeDistFn&#x27;: partial(mazeDistance, startingGameState) &#125; # A dictionary for the heuristic to store information ...def minimumSpanningTreeTotalWeight(adjM): g = nx.from_numpy_matrix(adjM) mst = nx.minimum_spanning_tree(g) return sum(e[2][&#x27;weight&#x27;] for e in mst.edges(data=True))def foodAdjMatrixAfterEating(problem, foodLeft): foodList = problem.heuristicInfo[&#x27;initialFood&#x27;] foodIndices = problem.heuristicInfo[&#x27;foodIndices&#x27;] M = problem.heuristicInfo[&#x27;foodAdjMatrix&#x27;].copy() for f in set(foodList).difference(set(foodLeft)): i = foodIndices[f] M[i, :] = M[:, i] = 0 return M def foodHeuristic(state: Tuple[Tuple, List[List]], problem: FoodSearchProblem): &quot;&quot;&quot; Your heuristic for the FoodSearchProblem goes here. This heuristic must be consistent to ensure correctness. First, try to come up with an admissible heuristic; almost all admissible heuristics will be consistent as well. If using A* ever finds a solution that is worse uniform cost search finds, your heuristic is *not* consistent, and probably not admissible! On the other hand, inadmissible or inconsistent heuristics may find optimal solutions, so be careful. The state is a tuple ( pacmanPosition, foodGrid ) where foodGrid is a Grid (see game.py) of either True or False. You can call foodGrid.asList() to get a list of food coordinates instead. If you want access to info like walls, capsules, etc., you can query the problem. For example, problem.walls gives you a Grid of where the walls are. If you want to *store* information to be reused in other calls to the heuristic, there is a dictionary called problem.heuristicInfo that you can use. For example, if you only want to count the walls once and store that value, try: problem.heuristicInfo[&#x27;wallCount&#x27;] = problem.walls.count() Subsequent calls to this heuristic can access problem.heuristicInfo[&#x27;wallCount&#x27;] &quot;&quot;&quot; position, foodGrid = state &quot;*** YOUR CODE HERE ***&quot; foodLeft = foodGrid.asList() adjM = foodAdjMatrixAfterEating(problem, foodLeft) mstTotalW = minimumSpanningTreeTotalWeight(adjM) distToPacman = partial(problem.heuristicInfo[&#x27;mazeDistFn&#x27;], position) closestFood = min(map(distToPacman, foodLeft), default=0) return closestFood + mstTotalW... def mazeDistance(gameState: pacman.GameState, point1: Tuple[int, int], point2: Tuple[int, int]) -&gt; int: &quot;&quot;&quot; Returns the maze distance between any two points, using the search functions you have already built. The gameState can be any game state -- Pacman&#x27;s position in that state is ignored. Example usage: mazeDistance( (2,4), (5,6), gameState) This might be a useful helper function for your ApproximateSearchAgent. &quot;&quot;&quot; x1, y1 = point1 x2, y2 = point2 walls = gameState.getWalls() assert not walls[x1][y1], &#x27;point1 is a wall: &#x27; + str(point1) assert not walls[x2][y2], &#x27;point2 is a wall: &#x27; + str(point2) prob = PositionSearchProblem(gameState, start=point1, goal=point2, warn=False, visualize=False) return len(search.bfs(prob)) Q8 (3 pts): Suboptimal Search Sometimes, even with A* and a good heuristic, finding the optimal path through all the dots is hard. In these cases, we’d still like to find a reasonably good path, quickly. In this section, you’ll write an agent that always greedily eats the closest dot. ClosestDotSearchAgent is implemented for you in searchAgents.py, but it’s missing a key function that finds a path to the closest dot. Implement the function findPathToClosestDot in searchAgents.py. Our agent solves this maze (suboptimally!) in under a second with a path cost of 350: 1python pacman.py -l bigSearch -p ClosestDotSearchAgent -z .5 Hint: The quickest way to complete findPathToClosestDot is to fill in the AnyFoodSearchProblem, which is missing its goal test. Then, solve that problem with an appropriate search function. The solution should be very short! Your ClosestDotSearchAgent won’t always find the shortest possible path through the maze. Make sure you understand why and try to come up with a small example where repeatedly going to the closest dot does not result in finding the shortest path for eating all the dots. Grading: Please run the below command to see if your implementation passes all the autograder test cases. 1python autograder.py -q q8 Answer Run the BFS to find the path to the closest dot. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051def findPathToClosestDot(self, gameState: pacman.GameState): &quot;&quot;&quot; Returns a path (a list of actions) to the closest dot, starting from gameState. &quot;&quot;&quot; # Here are some useful elements of the startState startPosition = gameState.getPacmanPosition() food = gameState.getFood() walls = gameState.getWalls() problem = AnyFoodSearchProblem(gameState) &quot;*** YOUR CODE HERE ***&quot; # util.raiseNotDefined() return search.bfs(problem) class AnyFoodSearchProblem(PositionSearchProblem): &quot;&quot;&quot; A search problem for finding a path to any food. This search problem is just like the PositionSearchProblem, but has a different goal test, which you need to fill in below. The state space and successor function do not need to be changed. The class definition above, AnyFoodSearchProblem(PositionSearchProblem), inherits the methods of the PositionSearchProblem. You can use this search problem to help you fill in the findPathToClosestDot method. &quot;&quot;&quot; def __init__(self, gameState): &quot;Stores information from the gameState. You don&#x27;t need to change this.&quot; # Store the food for later reference self.food = gameState.getFood() # Store info for the PositionSearchProblem (no need to change this) self.walls = gameState.getWalls() self.startState = gameState.getPacmanPosition() self.costFn = lambda x: 1 self._visited, self._visitedlist, self._expanded = &#123;&#125;, [], 0 # DO NOT CHANGE def isGoalState(self, state: Tuple[int, int]): &quot;&quot;&quot; The state is Pacman&#x27;s position. Fill this in with a goal test that will complete the problem definition. &quot;&quot;&quot; x,y = state &quot;*** YOUR CODE HERE ***&quot; # util.raiseNotDefined() return self.food[x][y] Autograder Report 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243Starting on 12-16 at 20:28:47Question q1===========*** PASS: test_cases/q1/graph_backtrack.test*** solution: [&#x27;1:A-&gt;C&#x27;, &#x27;0:C-&gt;G&#x27;]*** expanded_states: [&#x27;A&#x27;, &#x27;D&#x27;, &#x27;C&#x27;]*** PASS: test_cases/q1/graph_bfs_vs_dfs.test*** solution: [&#x27;2:A-&gt;D&#x27;, &#x27;0:D-&gt;G&#x27;]*** expanded_states: [&#x27;A&#x27;, &#x27;D&#x27;]*** PASS: test_cases/q1/graph_infinite.test*** solution: [&#x27;0:A-&gt;B&#x27;, &#x27;1:B-&gt;C&#x27;, &#x27;1:C-&gt;G&#x27;]*** expanded_states: [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]*** PASS: test_cases/q1/graph_manypaths.test*** solution: [&#x27;2:A-&gt;B2&#x27;, &#x27;0:B2-&gt;C&#x27;, &#x27;0:C-&gt;D&#x27;, &#x27;2:D-&gt;E2&#x27;, &#x27;0:E2-&gt;F&#x27;, &#x27;0:F-&gt;G&#x27;]*** expanded_states: [&#x27;A&#x27;, &#x27;B2&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E2&#x27;, &#x27;F&#x27;]*** PASS: test_cases/q1/pacman_1.test*** pacman layout: mediumMaze*** solution length: 130*** nodes expanded: 146### Question q1: 3/3 ###Question q2===========*** PASS: test_cases/q2/graph_backtrack.test*** solution: [&#x27;1:A-&gt;C&#x27;, &#x27;0:C-&gt;G&#x27;]*** expanded_states: [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;]*** PASS: test_cases/q2/graph_bfs_vs_dfs.test*** solution: [&#x27;1:A-&gt;G&#x27;]*** expanded_states: [&#x27;A&#x27;, &#x27;B&#x27;]*** PASS: test_cases/q2/graph_infinite.test*** solution: [&#x27;0:A-&gt;B&#x27;, &#x27;1:B-&gt;C&#x27;, &#x27;1:C-&gt;G&#x27;]*** expanded_states: [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]*** PASS: test_cases/q2/graph_manypaths.test*** solution: [&#x27;1:A-&gt;C&#x27;, &#x27;0:C-&gt;D&#x27;, &#x27;1:D-&gt;F&#x27;, &#x27;0:F-&gt;G&#x27;]*** expanded_states: [&#x27;A&#x27;, &#x27;B1&#x27;, &#x27;C&#x27;, &#x27;B2&#x27;, &#x27;D&#x27;, &#x27;E1&#x27;, &#x27;F&#x27;, &#x27;E2&#x27;]*** PASS: test_cases/q2/pacman_1.test*** pacman layout: mediumMaze*** solution length: 68*** nodes expanded: 269### Question q2: 3/3 ###Question q3===========*** PASS: test_cases/q3/graph_backtrack.test*** solution: [&#x27;1:A-&gt;C&#x27;, &#x27;0:C-&gt;G&#x27;]*** expanded_states: [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;]*** PASS: test_cases/q3/graph_bfs_vs_dfs.test*** solution: [&#x27;1:A-&gt;G&#x27;]*** expanded_states: [&#x27;A&#x27;, &#x27;B&#x27;]*** PASS: test_cases/q3/graph_infinite.test*** solution: [&#x27;0:A-&gt;B&#x27;, &#x27;1:B-&gt;C&#x27;, &#x27;1:C-&gt;G&#x27;]*** expanded_states: [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]*** PASS: test_cases/q3/graph_manypaths.test*** solution: [&#x27;1:A-&gt;C&#x27;, &#x27;0:C-&gt;D&#x27;, &#x27;1:D-&gt;F&#x27;, &#x27;0:F-&gt;G&#x27;]*** expanded_states: [&#x27;A&#x27;, &#x27;B1&#x27;, &#x27;C&#x27;, &#x27;B2&#x27;, &#x27;D&#x27;, &#x27;E1&#x27;, &#x27;F&#x27;, &#x27;E2&#x27;]*** PASS: test_cases/q3/ucs_0_graph.test*** solution: [&#x27;Right&#x27;, &#x27;Down&#x27;, &#x27;Down&#x27;]*** expanded_states: [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;D&#x27;, &#x27;C&#x27;, &#x27;G&#x27;]*** PASS: test_cases/q3/ucs_1_problemC.test*** pacman layout: mediumMaze*** solution length: 68*** nodes expanded: 269*** PASS: test_cases/q3/ucs_2_problemE.test*** pacman layout: mediumMaze*** solution length: 74*** nodes expanded: 260*** PASS: test_cases/q3/ucs_3_problemW.test*** pacman layout: mediumMaze*** solution length: 152*** nodes expanded: 173*** PASS: test_cases/q3/ucs_4_testSearch.test*** pacman layout: testSearch*** solution length: 7*** nodes expanded: 14*** PASS: test_cases/q3/ucs_5_goalAtDequeue.test*** solution: [&#x27;1:A-&gt;B&#x27;, &#x27;0:B-&gt;C&#x27;, &#x27;0:C-&gt;G&#x27;]*** expanded_states: [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]### Question q3: 3/3 ###Question q4===========*** PASS: test_cases/q4/astar_0.test*** solution: [&#x27;Right&#x27;, &#x27;Down&#x27;, &#x27;Down&#x27;]*** expanded_states: [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;D&#x27;, &#x27;C&#x27;, &#x27;G&#x27;]*** PASS: test_cases/q4/astar_1_graph_heuristic.test*** solution: [&#x27;0&#x27;, &#x27;0&#x27;, &#x27;2&#x27;]*** expanded_states: [&#x27;S&#x27;, &#x27;A&#x27;, &#x27;D&#x27;, &#x27;C&#x27;]*** PASS: test_cases/q4/astar_2_manhattan.test*** pacman layout: mediumMaze*** solution length: 68*** nodes expanded: 221*** PASS: test_cases/q4/astar_3_goalAtDequeue.test*** solution: [&#x27;1:A-&gt;B&#x27;, &#x27;0:B-&gt;C&#x27;, &#x27;0:C-&gt;G&#x27;]*** expanded_states: [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]*** PASS: test_cases/q4/graph_backtrack.test*** solution: [&#x27;1:A-&gt;C&#x27;, &#x27;0:C-&gt;G&#x27;]*** expanded_states: [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;]*** PASS: test_cases/q4/graph_manypaths.test*** solution: [&#x27;1:A-&gt;C&#x27;, &#x27;0:C-&gt;D&#x27;, &#x27;1:D-&gt;F&#x27;, &#x27;0:F-&gt;G&#x27;]*** expanded_states: [&#x27;A&#x27;, &#x27;B1&#x27;, &#x27;C&#x27;, &#x27;B2&#x27;, &#x27;D&#x27;, &#x27;E1&#x27;, &#x27;F&#x27;, &#x27;E2&#x27;]### Question q4: 3/3 ###Question q5===========*** PASS: test_cases/q5/corner_tiny_corner.test*** pacman layout: tinyCorner*** solution length: 28### Question q5: 3/3 ###Question q6===========*** PASS: heuristic value less than true cost at start state*** PASS: heuristic value less than true cost at start state*** PASS: heuristic value less than true cost at start statepath: [&#x27;North&#x27;, &#x27;East&#x27;, &#x27;East&#x27;, &#x27;East&#x27;, &#x27;East&#x27;, &#x27;North&#x27;, &#x27;North&#x27;, &#x27;West&#x27;, &#x27;West&#x27;, &#x27;West&#x27;, &#x27;West&#x27;, &#x27;North&#x27;, &#x27;North&#x27;, &#x27;North&#x27;, &#x27;North&#x27;, &#x27;North&#x27;, &#x27;North&#x27;, &#x27;North&#x27;, &#x27;North&#x27;, &#x27;West&#x27;, &#x27;West&#x27;, &#x27;West&#x27;, &#x27;West&#x27;, &#x27;South&#x27;, &#x27;South&#x27;, &#x27;East&#x27;, &#x27;East&#x27;, &#x27;East&#x27;, &#x27;East&#x27;, &#x27;South&#x27;, &#x27;South&#x27;, &#x27;South&#x27;, &#x27;South&#x27;, &#x27;South&#x27;, &#x27;South&#x27;, &#x27;West&#x27;, &#x27;West&#x27;, &#x27;South&#x27;, &#x27;South&#x27;, &#x27;South&#x27;, &#x27;West&#x27;, &#x27;West&#x27;, &#x27;East&#x27;, &#x27;East&#x27;, &#x27;North&#x27;, &#x27;North&#x27;, &#x27;North&#x27;, &#x27;East&#x27;, &#x27;East&#x27;, &#x27;East&#x27;, &#x27;East&#x27;, &#x27;East&#x27;, &#x27;East&#x27;, &#x27;East&#x27;, &#x27;East&#x27;, &#x27;South&#x27;, &#x27;South&#x27;, &#x27;East&#x27;, &#x27;East&#x27;, &#x27;East&#x27;, &#x27;East&#x27;, &#x27;East&#x27;, &#x27;North&#x27;, &#x27;North&#x27;, &#x27;East&#x27;, &#x27;East&#x27;, &#x27;North&#x27;, &#x27;North&#x27;, &#x27;East&#x27;, &#x27;East&#x27;, &#x27;North&#x27;, &#x27;North&#x27;, &#x27;East&#x27;, &#x27;East&#x27;, &#x27;East&#x27;, &#x27;East&#x27;, &#x27;South&#x27;, &#x27;South&#x27;, &#x27;South&#x27;, &#x27;South&#x27;, &#x27;East&#x27;, &#x27;East&#x27;, &#x27;North&#x27;, &#x27;North&#x27;, &#x27;East&#x27;, &#x27;East&#x27;, &#x27;South&#x27;, &#x27;South&#x27;, &#x27;South&#x27;, &#x27;South&#x27;, &#x27;South&#x27;, &#x27;North&#x27;, &#x27;North&#x27;, &#x27;North&#x27;, &#x27;North&#x27;, &#x27;North&#x27;, &#x27;North&#x27;, &#x27;North&#x27;, &#x27;West&#x27;, &#x27;West&#x27;, &#x27;North&#x27;, &#x27;North&#x27;, &#x27;East&#x27;, &#x27;East&#x27;, &#x27;North&#x27;, &#x27;North&#x27;]path length: 106*** PASS: Heuristic resulted in expansion of 702 nodes### Question q6: 3/3 ###Question q7===========*** PASS: test_cases/q7/food_heuristic_1.test*** PASS: test_cases/q7/food_heuristic_10.test*** PASS: test_cases/q7/food_heuristic_11.test*** PASS: test_cases/q7/food_heuristic_12.test*** PASS: test_cases/q7/food_heuristic_13.test*** PASS: test_cases/q7/food_heuristic_14.test*** PASS: test_cases/q7/food_heuristic_15.test*** PASS: test_cases/q7/food_heuristic_16.test*** PASS: test_cases/q7/food_heuristic_17.test*** PASS: test_cases/q7/food_heuristic_2.test*** PASS: test_cases/q7/food_heuristic_3.test*** PASS: test_cases/q7/food_heuristic_4.test*** PASS: test_cases/q7/food_heuristic_5.test*** PASS: test_cases/q7/food_heuristic_6.test*** PASS: test_cases/q7/food_heuristic_7.test*** PASS: test_cases/q7/food_heuristic_8.test*** PASS: test_cases/q7/food_heuristic_9.test*** PASS: test_cases/q7/food_heuristic_grade_tricky.test*** expanded nodes: 255*** thresholds: [15000, 12000, 9000, 7000]### Question q7: 5/4 ###Question q8===========[SearchAgent] using function depthFirstSearch[SearchAgent] using problem type PositionSearchProblem*** PASS: test_cases/q8/closest_dot_1.test*** pacman layout: Test 1*** solution length: 1[SearchAgent] using function depthFirstSearch[SearchAgent] using problem type PositionSearchProblem*** PASS: test_cases/q8/closest_dot_10.test*** pacman layout: Test 10*** solution length: 1[SearchAgent] using function depthFirstSearch[SearchAgent] using problem type PositionSearchProblem*** PASS: test_cases/q8/closest_dot_11.test*** pacman layout: Test 11*** solution length: 2[SearchAgent] using function depthFirstSearch[SearchAgent] using problem type PositionSearchProblem*** PASS: test_cases/q8/closest_dot_12.test*** pacman layout: Test 12*** solution length: 3[SearchAgent] using function depthFirstSearch[SearchAgent] using problem type PositionSearchProblem*** PASS: test_cases/q8/closest_dot_13.test*** pacman layout: Test 13*** solution length: 1[SearchAgent] using function depthFirstSearch[SearchAgent] using problem type PositionSearchProblem*** PASS: test_cases/q8/closest_dot_2.test*** pacman layout: Test 2*** solution length: 1[SearchAgent] using function depthFirstSearch[SearchAgent] using problem type PositionSearchProblem*** PASS: test_cases/q8/closest_dot_3.test*** pacman layout: Test 3*** solution length: 1[SearchAgent] using function depthFirstSearch[SearchAgent] using problem type PositionSearchProblem*** PASS: test_cases/q8/closest_dot_4.test*** pacman layout: Test 4*** solution length: 3[SearchAgent] using function depthFirstSearch[SearchAgent] using problem type PositionSearchProblem*** PASS: test_cases/q8/closest_dot_5.test*** pacman layout: Test 5*** solution length: 1[SearchAgent] using function depthFirstSearch[SearchAgent] using problem type PositionSearchProblem*** PASS: test_cases/q8/closest_dot_6.test*** pacman layout: Test 6*** solution length: 2[SearchAgent] using function depthFirstSearch[SearchAgent] using problem type PositionSearchProblem*** PASS: test_cases/q8/closest_dot_7.test*** pacman layout: Test 7*** solution length: 1[SearchAgent] using function depthFirstSearch[SearchAgent] using problem type PositionSearchProblem*** PASS: test_cases/q8/closest_dot_8.test*** pacman layout: Test 8*** solution length: 1[SearchAgent] using function depthFirstSearch[SearchAgent] using problem type PositionSearchProblem*** PASS: test_cases/q8/closest_dot_9.test*** pacman layout: Test 9*** solution length: 1### Question q8: 3/3 ###Finished at 20:28:49Provisional grades==================Question q1: 3/3Question q2: 3/3Question q3: 3/3Question q4: 3/3Question q5: 3/3Question q6: 3/3Question q7: 5/4Question q8: 3/3------------------Total: 26/25","categories":[],"tags":[{"name":"CS188","slug":"CS188","permalink":"http://www.misaka-9982.com/tags/CS188/"},{"name":"AI","slug":"AI","permalink":"http://www.misaka-9982.com/tags/AI/"}]},{"title":"Configure Kubernetes based on cri-dockerd","slug":"基于cri-dockered-配置-kubernetes","date":"2022-12-14T06:19:02.000Z","updated":"2022-12-15T09:46:25.987Z","comments":true,"path":"2022/12/14/基于cri-dockered-配置-kubernetes/","link":"","permalink":"http://www.misaka-9982.com/2022/12/14/%E5%9F%BA%E4%BA%8Ecri-dockered-%E9%85%8D%E7%BD%AE-kubernetes/","excerpt":"","text":"1. Environment Computer MacOS Monterey Version 12.3.1 (21E258) MacBook Air (M1, 2020) Chip Apple M1 Memory 8 GB Virtual Machine Parallels Desktop 18 for Mac Business Edition Version 18.0.2 (53077) ISO file ubuntu-22.04.1-live-server-arm64.iso download URL: https://cdimage.ubuntu.com/releases/22.04/release/ubuntu-22.04.1-live-server-arm64.iso NetWork: Bridged Network Default Adapter Software Version docker: 20.10.21 cri-dockerd: 0.2.6.arm64 kubeadm : 1.25 kubectl : 1.25 kubelet : 1.25 2. Config the host 1234567sudo apt-get update &amp;&amp; sudo apt-get upgradesudo echo \\&#x27;172.20.10.5 k8s-master172.20.10.6 k8s-node1172.20.10.3 k8s-node2&#x27; &gt;&gt; /etc/hosts 3. Close selinux 1234sudo touch /etc/selinux/configsudo sed -i &#x27;s/SELINUX=enforcing/SELINUX=disabled/g&#x27; /etc/selinux/config# Restart the machine to take effectreboot 4. Close the Swap 12sudo swapoff -asudo sed -i &#x27;/swap/s/^/#/&#x27; /etc/fstab 5. Enabling IPv4 Forwarding 12345678910111213sudo cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/k8s.confoverlaybr_netfilterEOFsudo modprobe overlaysudo modprobe br_netfiltersudo cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.confnet.bridge.bridge-nf-call-iptables = 1net.bridge.bridge-nf-call-ip6tables = 1net.ipv4.ip_forward = 1EOFsudo sysctl --system 6. Install docker and configure the Cgroupdriver 12345678910111213141516171819202122sudo apt install apt-transport-https ca-certificates curl software-properties-common gnupg lsb-releasecurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpgecho &quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/nullsudo apt updatesudo apt install docker-ce docker-ce-cli containerd.io docker-compose-pluginsudo usermod -aG docker $USER## Modify the docker process managersudo cat &gt; /etc/docker/daemon.json &lt;&lt; EOF&#123;&quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;,&quot;https://hub-mirror.c.163.com&quot;,&quot;https://reg-mirror.qiniu.com&quot;,&quot;https://registry.docker-cn.com&quot;],&quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart dockersudo systemctl status docker 7. Install the cri-docker and start 1234wget https://github.com/Mirantis/cri-dockerd/releases/download/v0.2.6/cri-dockerd-0.2.6.arm64.tgztar -xf cri-dockerd-0.2.6.arm64.tgzcp cri-dockerd/cri-dockerd /usr/bin/chmod +x /usr/bin/cri-dockerd Configure the cri-dockerd 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950cat &lt;&lt;&quot;EOF&quot; &gt; /usr/lib/systemd/system/cri-docker.service[Unit]Description=CRI Interface for Docker Application Container EngineDocumentation=https://docs.mirantis.comAfter=network-online.target firewalld.service docker.serviceWants=network-online.targetRequires=cri-docker.socket[Service]Type=notifyExecStart=/usr/bin/cri-dockerd --network-plugin=cni --pod-infra-container-image=registry.aliyuncs.com/google_containers/pause:3.7ExecReload=/bin/kill -s HUP $MAINPIDTimeoutSec=0RestartSec=2Restart=alwaysStartLimitBurst=3StartLimitInterval=60sLimitNOFILE=infinityLimitNPROC=infinityLimitCORE=infinityTasksMax=infinityDelegate=yesKillMode=process[Install]WantedBy=multi-user.targetEOFcat &lt;&lt;&quot;EOF&quot; &gt; /usr/lib/systemd/system/cri-docker.socket[Unit]Description=CRI Docker Socket for the APIPartOf=cri-docker.service[Socket]ListenStream=%t/cri-dockerd.sockSocketMode=0660SocketUser=rootSocketGroup=docker[Install]WantedBy=sockets.targetEOF Start the cri-docker 1234systemctl daemon-reloadsystemctl start cri-dockersystemctl enable cri-dockersystemctl status cri-docker 8. Install kubeadm kubectl kubelet and enable it 12345sudo apt-get install -y apt-transport-httpscurl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add - echo &#x27;deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main&#x27; &gt;&gt; /etc/apt/sources.listsudo apt-get updatesudo apt-get install -y kubelet=1.25.0-00 kubeadm=1.25.0-00 kubectl=1.25.0-00 9. Configure Master 123456789101112131415161718192021222324252627282930313233343536373839404142434445# Master Nodeecho &#x27;apiVersion: kubeadm.k8s.io/v1beta3bootstrapTokens:- groups: - system:bootstrappers:kubeadm:default-node-token token: abcdef.0123456789abcdef ttl: 24h0m0s usages: - signing - authenticationkind: InitConfigurationlocalAPIEndpoint: advertiseAddress: [IP address of this machine] bindPort: 6443nodeRegistration: criSocket: unix:///var/run/cri-dockerd.sock imagePullPolicy: IfNotPresent name: [Host name of this machine] taints: null---apiServer: timeoutForControlPlane: 4m0sapiVersion: kubeadm.k8s.io/v1beta3certificatesDir: /etc/kubernetes/pkiclusterName: kubernetescontrollerManager: &#123;&#125;dns: &#123;&#125;etcd: local: dataDir: /var/lib/etcdimageRepository: registry.aliyuncs.com/google_containerskind: ClusterConfigurationkubernetesVersion: 1.25.0networking: dnsDomain: cluster.local serviceSubnet: 10.96.0.0/12 # Pod scheduler: &#123;&#125;---kind: KubeletConfigurationapiVersion: kubelet.config.k8s.io/v1beta1cgroupDriver: systemd # Set it to systemd&#x27; &gt; kubeadm-config.yamlsudo kubeadm init --config kubeadm-config.yaml To start using your cluster, you need to run the following as a regular user: 123mkdir -p $HOME/.kubesudo cp -i etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config 10. Configure Node 12345# Node kubeadm join &lt;control-plane-endpoint&gt;:6443 --token &lt;token&gt; \\--discovery-token-ca-cert-hash sha256:&lt;hash&gt; \\--cri-socket /run/containerd/containerd.sock \\--node-name &lt;nodename&gt; 11. Installing Network Plugin 1234## If the status of all nodes changes to ready after installation, it is a successwget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.ymlkubectl apply -f ./kube-flannel.ymlkubectl get nodes If the network segment of the Pod CIDR is not 10.244.0.0/16, change the network segment in the flannel configuration to be the same as that in the Pod CIDR. 12. reset deployment 1234567891011121314151617181920#!/usr/bin/env bashsudo kubeadm reset -f# Clear the data directorysudo rm -fr /var/lib/etcdsudo rm -fr /etc/kubernetessudo rm -fr ~/.kube/# delete flannelifconfig cni0 downip link delete cni0ifconfig flannel.1 downip link delete flannel.1sudo rm -rf /var/lib/cni/sudo rm -f /etc/cni/net.d/*kubectl delete -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml systemctl restart dockersystemctl restart kubelet Reference 使用kubeadm安装生产环境kubernetes Centos7.9 arm架构 搭建 k8s v1.24.0 (超新)","categories":[],"tags":[]},{"title":"CS61A Homework 8","slug":"CS61A-Homework-8","date":"2022-07-30T05:49:23.000Z","updated":"2022-07-30T05:55:42.017Z","comments":true,"path":"2022/07/30/CS61A-Homework-8/","link":"","permalink":"http://www.misaka-9982.com/2022/07/30/CS61A-Homework-8/","excerpt":"","text":"Homework 8 Solutions hw08.zip Solution Files You can find the solutions in the [hw08.py hw08.lark](https://cs61a.org/hw/sol-hw08/hw08.py hw08.lark) file. Questions RegEx Q1: CS Classes On reddit.com, there is an /r/berkeley subreddit for discussions about everything UC Berkeley. However, there is such a large amount of EE and CS-related posts that those posts are auto-tagged so that readers can choose to ignore them or read only them. Write a regular expression that finds strings that resemble a CS or EE class- starting with “CS” or “EE”, followed by a number, and then optionally followed by “A”, “B”, or “C”. Your search should be case insensitive, so both “CS61A” and “cs61a” would match. 1234567891011121314151617181920212223242526import redef cs_classes(post): &quot;&quot;&quot; Returns strings that look like a Berkeley CS or EE class, starting with &quot;CS&quot; or &quot;EE&quot;, followed by a number, optionally ending with A, B, or C and potentially with a space between &quot;CS&quot; or &quot;EE&quot; and the number. Case insensitive. &gt;&gt;&gt; cs_classes(&quot;Is it unreasonable to take CS61A, CS61B, CS70, and EE16A in the summer?&quot;) True &gt;&gt;&gt; cs_classes(&quot;how do I become a TA for cs61a? that job sounds so fun&quot;) True &gt;&gt;&gt; cs_classes(&quot;Can I take ECON101 as a CS major?&quot;) False &gt;&gt;&gt; cs_classes(&quot;Should I do the lab lites or regular labs in EE16A?&quot;) True &gt;&gt;&gt; cs_classes(&quot;thoughts on ee127?&quot;) True &gt;&gt;&gt; cs_classes(&quot;Is 70 considered an EECS class?&quot;) False &gt;&gt;&gt; cs_classes(&quot;What are some good CS upper division courses? I was thinking about CS 161 or CS 169a&quot;) True &quot;&quot;&quot; return bool(re.search(r&quot;(ee|EE|cs|CS)\\s?\\d+[a-cA-C]?&quot;, post)) Use Ok to test your code: 1python3 ok -q cs_classes✂️ Q2: Time for Times You’re given a body of text and told that within it are some times. Times can be written in two different ways: 12-hour AM/PM clock: 07:23AM, 05:24PM 24-hour clock: 23:59, 12:22, 00:00 Write a regular expression which, for a few examples, would match the following: 1[&#x27;07:23AM&#x27;, &#x27;05:24PM&#x27;, &#x27;23:59&#x27;, &#x27;12:22&#x27;, &#x27;00:00&#x27;] but would not match these invalid “times” 123456789101112131415161718192021222324[&#x27;05:64&#x27;, &#x27;70:23&#x27;]import redef match_time(text): &quot;&quot;&quot; &gt;&gt;&gt; match_time(&quot;At 07:23AM, I woke up and had some coffee.&quot;) True &gt;&gt;&gt; match_time(&quot;I looked at my phone at 12:22 to check the weather.&quot;) True &gt;&gt;&gt; match_time(&quot;At 05:24PM, I had sesame bagels with cream cheese.&quot;) True &gt;&gt;&gt; match_time(&quot;At 23:59 I was sound asleep.&quot;) True &gt;&gt;&gt; match_time(&quot;After, the clocked turned to 00:00.&quot;) True &gt;&gt;&gt; match_time(&quot;Mix water in a 1:2 ratio with chicken stock.&quot;) False &gt;&gt;&gt; match_time(&quot;At work, I pinged 127.0.0.1:80.&quot;) False &gt;&gt;&gt; match_time(&quot;The tennis score was 40:30.&quot;) False &quot;&quot;&quot; return bool(re.search(r&quot;\\b(([01]?\\d)|(2[0123])):[012345]\\d([AaPp][Mm])?\\b&quot;, text)) Use Ok to test your code: 1python3 ok -q match_time✂️ BNF Q3: Linked List BNF For the next two problems, you can test your code on code.cs61a.org by adding the following line at the beginning before the problem’s skeleton code: 12?start: link-- replace link with tree_node for the next question In this problem, we’re going to define a BNF that parses integer Linked Lists created in Python. We won’t be handling Link.empty. For reference, here are some examples of Linked Lists: Your implementation should be able to handle nested Linked Lists, such as the third example below. Link(2) Link(12, Link(2)) Link(5, Link(7, Link(Link(8, Link(9))))) 1234567link: &quot;Link(&quot; link_first link_rest? &quot;)&quot;?link_first: link|NUMBER?link_rest: &quot;, &quot; link%ignore /\\s+/%import common.NUMBER Use Ok to test your code: 1python3 ok -q linked_list✂️ Q4: Tree BNF Now, we will define a BNF to parse Trees with integer leaves created in Python. Here are some examples of Trees: Your implementation should be able to handle Trees with no branches and one or more branches. Tree(2) Tree(6, [Tree(1), Tree(3, [Tree(1), Tree(2)])]) 1234567tree_node: &quot;Tree(&quot; label branches? &quot;)&quot;?label: NUMBERbranches:&quot;, [&quot; (tree_node &quot;,&quot;)* tree_node &quot;]&quot;%ignore /\\s+/%import common.NUMBER Use Ok to test your code: 1python3 ok -q tree✂️ Regex Parser Previously in CS61A you studied regular expressions (regex), a grammar for pattern matching in strings. In this question you will create a BNF grammar for parsing through regular expression patterns, which we will denote as an rstring. Below, we’ve defined the following skeleton for rstring grammar: 1234567891011121314151617rstring: &quot;r\\&quot;&quot; regex* &quot;\\&quot;&quot;?regex: group | pipe | character | word | classgroup: &quot;(&quot; regex &quot;)&quot;pipe: regex &quot;|&quot; regexclass: &quot;[&quot;(range | character)+&quot;]&quot;range: (LETTER &quot;-&quot; LETTER) | (NUMBER &quot;-&quot; NUMBER)character: LETTER | NUMBERword: WORD%ignore /\\s+/%import common.LETTER%import common.NUMBER%import common.WORD The current implementation is very limited, and can only support alphanumeric patterns which directly match the input. In the following questions, you will implement support for a limited subset of regular expression features. NOTE: for the purposes of testing, we require that your syntax trees match the doctests’. Be sure to define all expressions as noted in the question, and prefix all extra expressions not mentioned in the question with a ? (such as ?rstring). Q5: Grouping and Pipes In this question, you will add support for grouping and piping. Recall that grouping allows for an entire regular expression to be treated as a single unit, and piping allows for a pattern to match an expression on either side. Combined, these will let us create patterns which match multiple strings! Define the group and pipe expressions in your grammar. A group consists of any regex expression surrounded by parentheses (()). A pipe operator consists of a regex expression, followed by a pipe (|) character, and lastly followed by another regex expression. For example, r&quot;apples&quot; would match exactly the phrase “apples” in an input. If we wanted our pattern from before to match “oranges” as well, we could expand our rstring to do so using groupings and pipes: r&quot;(apples)|(oranges)&quot;. Hint: note that groups and pipes are valid regex expressions on their own! You may need to update a previously defined expression. Use Ok to test your code: 1python3 ok -q regex_grouping✂️ Q6: Classes Now, we will add support for character classes. Recall that character classes allow for the pattern to match any singular character defined within the class. The class itself consists either of individual characters, or ranges of characters. Specifically, we define the following: A range consists of either NUMBERs or LETTERs separated by a hyphen (-). A class expression consists of any number of characters or character ranges surrounded by square brackets ([]). Note that for this question, a range may only consist of either NUMBERs or LETTERs; this means that while [0-9] and [A-Z] are valid ranges, [0-Z] would not be a valid range. In addition, the characters and ranges in a class may appear in any order and any number of times. For example, [ad-fc0-9], [ad-f0-9c], [a0-9d-fc], and [0-9ad-fc] are all valid classes. Use Ok to test your code: 1python3 ok -q regex_classes✂️ Submit Make sure to submit this assignment by running: 1python3 ok --submit","categories":[],"tags":[{"name":"CS61A","slug":"CS61A","permalink":"http://www.misaka-9982.com/tags/CS61A/"}]},{"title":"CS61A Homework 7","slug":"CS61A-Homework-7","date":"2022-07-30T05:49:19.000Z","updated":"2022-07-30T05:51:27.415Z","comments":true,"path":"2022/07/30/CS61A-Homework-7/","link":"","permalink":"http://www.misaka-9982.com/2022/07/30/CS61A-Homework-7/","excerpt":"","text":"Homework 7 Solutions hw07.zip Solution Files You can find the solutions in hw07.scm. Scheme is a famous functional programming language from the 1970s. It is a dialect of Lisp (which stands for LISt Processing). The first observation most people make is the unique syntax, which uses a prefix notation and (often many) nested parentheses (see http://xkcd.com/297/). Scheme features first-class functions and optimized tail-recursion, which were relatively new features at the time. You may find it useful to try code.cs61a.org/scheme when working through problems, as it can draw environment and box-and-pointer diagrams and it lets you walk your code step-by-step (similar to Python Tutor). Don’t forget to submit your code through Ok though! Scheme Editor As you’re writing your code, you can debug using the Scheme Editor. In your scheme folder you will find a new editor. To run this editor, run python3 editor. This should pop up a window in your browser; if it does not, please navigate to localhost:31415 and you should see it. Make sure to run python3 ok in a separate tab or window so that the editor keeps running. If you find that your code works in the online editor but not in your own interpreter, it’s possible you have a bug in code from an earlier part that you’ll have to track down. Every once in a while there’s a bug that our tests don’t catch, and if you find one you should let us know! Required Questions Keyword Lists In the following problems, you will explore creating two separate implementations for the same abstraction. A keyword list is the Scheme analogue of a dict in Python, with a few key differences: It allows for repeating keys It functions as a list as well, which allows for ordering. The kwlist abstraction keeps a mapping of keys and values. To create a kwlist, call the constructor (make-kwlist keys values) where keys is a Scheme list of symbols and values is a Scheme list of any type. This returns some abstracted item lst that we can call the following methods to either retrieve or add items: 12345678scm&gt; (define lst (make-kwlist &#x27;(x y z) &#x27;(7 8 9)) ; create the keyword listlstscm&gt; (get-first-from-kwlist lst &#x27;x) ; get an item7scm&gt; (define lst (add-to-kwlist lst &#x27;a 10)) ; add a new itemlstscm&gt; (get-first-from-kwlist lst &#x27;a) ; get the new item.10 Q1: Keyword List: Construct First, implement abstractions for kwlist in two ways, with the following example: (kwlist '(x y z) '(7 8 9)) kwlist1, which stores a keyword list in the following manner: ((key1 key2 key3 ...) (value1 value2 value3 ...). With the example above, this should look like ((x y z) (7 8 9)). kwlist2, which stores a keyword list in the following manner: ((key1 value1) (key2 value2) ...). With the example above, this should look like ((x 7) (y 8) (z 9)). Specifically, implement constructors and selectors for kwlist1 and kwlist2. The constructors, make-kwlist1 and make-kwlist2, should take in Scheme lists for both keys and values, and construct the abstraction as above. The selectors, get-keys-kwlist1, get-keys-kwlist2, get-values-kwlist1, and get-values-kwlist1, should take in a kwlist1 or kwlist2 and return their keys and values respectively. Note that because you are currently creating the implementation, you are “under the abstraction barrier;” feel free to refer to specific details of the structure of kwlist1 and kwlist2. Hint: The map function may prove to be useful, but is not required. You may also use the cadr function, which is defined for you in the file. 123456789101112131415161718192021222324252627282930313233343536scm&gt; (define ex-lst1 (make-kwlist1 &#x27;(a b c) &#x27;(1 2 3)))ex-listscm&gt; (get-keys-kwlist1 ex-lst1)(a b c)scm&gt; (get-values-kwlist1 ex-lst1)(1 2 3)scm&gt; (define ex-lst2 (make-kwlist2 &#x27;(a b c) &#x27;(1 2 3)))ex-listscm&gt; (get-keys-kwlist2 ex-lst)(a b c)scm&gt; (get-values-kwlist2 ex-lst)(1 2 3)(define (make-kwlist1 keys values) (list keys values))(define (get-keys-kwlist1 kwlist) (car kwlist))(define (get-values-kwlist1 kwlist) (cadr kwlist))(define (make-kwlist2 keys values) (if (null? keys) nil (cons (list (car keys) (car values)) (make-kwlist2 (cdr keys) (cdr values)))))(define (get-keys-kwlist2 kwlist) (map (lambda (x) (car x)) kwlist))(define (get-values-kwlist2 kwlist) (map (lambda (x) (cadr x)) kwlist)) Use Ok to test your code: 1python3 ok -q kwlist_construct✂️ Important: For the following questions, your implementations should be invariant with respect to the abstraction used; that is, it should work regardless of whether kwlist1 or kwlist2 is used. Specifically, in the tests, we will define the abstraction kwlist as either kwlist1 or kwlist2: 12345678scm&gt; (define make-kwlist make-kwlist1)scm&gt; (define get-keys-kwlist get-keys-kwlist1)scm&gt; (define get-values-kwlist get-values-kwlist1); tests here...scm&gt; (define make-kwlist make-kwlist2)scm&gt; (define get-keys-kwlist get-keys-kwlist2)scm&gt; (define get-values-kwlist get-values-kwlist2); tests here... You should refer to the above kwlist procedures, not kwlist1 or kwlist2’s procedures in your implementation. Q2: Keyword List: Add Now, implement add-to-kwlist, which implements support for adding a new (key, value) pair to any implementation of a kwlist. Specifically, add-to-kwlist takes in a kwlist, a key, and a value as input, and returns a new kwlist with updated keys and values. Note that kwlists are ordered; that is, a pair p1 that was added to a kwlist before a different pair p2 should appear earlier in the kwlist. Hint: The append method may be useful here. To make your implementation work with both abstractions, be sure to use methods ending in kwlist, not kwlist1 or kwlist2. 123456789101112131415scm&gt; (define ex-lst (make-kwlist &#x27;(a b c) &#x27;(1 2 3)))ex-lstscm&gt; (get-keys-kwlist ex-lst)(a b c)scm&gt; (get-values-kwlist ex-lst)(1 2 3)scm&gt; (define ex-lst (add-to-kwlist ex-lst &#x27;d &#x27;4))ex-lstscm&gt; (get-keys-kwlist ex-lst) ; note that new items are at the end of the list!(a b c d)scm&gt; (get-values-kwlist ex-lst) ; here too!(1 2 3 4)(define (add-to-kwlist kwlist key value) (make-kwlist (append (get-keys-kwlist kwlist) (list key)) (append (get-values-kwlist kwlist) (list value)))) Use Ok to test your code: 1python3 ok -q kwlist_add✂️ Q3: (Optional) Keyword List: Get Now, implement get-first-from-kwlist, which implements support for getting the first value bound to a key in kwlist. If key is not present in the list, the function should return nil to indicate that there were no valid keys found. Hint: Consider using let to temporarily bind names to values. To make your implementation work with both abstractions, be sure to use methods ending in kwlist, not kwlist1 or kwlist2. 123456789101112131415161718192021222324252627282930scm&gt; (define ex-lst (make-kwlist &#x27;(a b c) &#x27;(1 2 3)))ex-lstscm&gt; (get-first-from-kwlist ex-lst &#x27;b)2scm&gt; (get-first-from-kwlist ex-lst &#x27;d) ; if not found, return nil()scm&gt; (define ex-lst (add-to-kwlist ex-lst &#x27;d &#x27;4))ex-lstscm&gt; (get-first-from-kwlist ex-lst &#x27;b)2scm&gt; (get-first-from-kwlist ex-lst &#x27;d)4scm&gt; (define ex-lst (add-to-kwlist ex-lst &#x27;d &#x27;5))ex-lstscm&gt; (get-first-from-kwlist ex-lst &#x27;b)2scm&gt; (get-first-from-kwlist ex-lst &#x27;d) ; return the *first* occurrence4(define (get-first-from-kwlist kwlist key) (if (null? (get-keys-kwlist kwlist)) nil (let ((values (get-values-kwlist kwlist)) (keys (get-keys-kwlist kwlist))) (cond ((equal? (car keys) key) (car values)) (else (get-first-from-kwlist (make-kwlist (cdr keys) (cdr values)) key)) ) ) )) Use Ok to test your code: 1python3 ok -q kwlist_get✂️ Programs as Data Note that the following question is separate from the previous questions. Q4: Prune Implement prune-expr, a procedure that takes in an expression, which is represented as a list, and returns the same expression with every other argument included. The operator should not be modified. Hint: You may find it helpful to write a helper function that prunes a list. The behavior of prune-expr is specified by the following doctests: 123456789101112131415scm&gt; (prune-expr &#x27;(+ 10 20))(+ 10)scm&gt; (prune-expr &#x27;(+ 10 20 30))(+ 10 30)scm&gt; (eval (prune-expr &#x27;(+ 10 20 30)))40(define (prune-expr expr) (define (prune-helper lst) (if (or (null? lst) (null? (cdr lst))) lst (cons (car lst) (prune-helper (cdr (cdr lst)))) ) ) (cons (car expr) (prune-helper (cdr expr)))) Use Ok to test your code: 1python3 ok -q prune-expr✂️ Chef Curry Recall that currying transforms a multiple argument function into a series of higher-order, one argument functions. In the next set of questions, you will be creating functions that can automatically curry a function of any length using the notion that programs are data! Q5: Cooking Curry Implement the function curry-cook, which takes in a Scheme list formals and a quoted expression body. curry-cook should generate a program as a list which is a curried version of a lambda function. The outputted program should be a curried version of a lambda function with formal arguments equal to formals, and a function body equal to body. You may assume that all functions passed in will have more than 0 formals; otherwise, it would not be curry-able! For example, if you wanted to curry the function (lambda (x y) (+ x y)), you would set formals equal to '(x y), the body equal to '(+ x y), and make a call to curry-cook: (curry-cook '(x y) '(+ x y)). 12345678910scm&gt; (curry-cook &#x27;(a) &#x27;a)(lambda (a) a)scm&gt; (curry-cook &#x27;(x y) &#x27;(+ x y))(lambda (x) (lambda (y) (+ x y)))(define (curry-cook formals body) (if (null? formals) body `(lambda (,(car formals)) ,(curry-cook (cdr formals) body)) )) Use Ok to test your code: 1python3 ok -q curry_cook✂️ Q6: Consuming Curry Now that you have a function that creates lambda programs as lists, create a function which is able to evaluate lambda functions using a series of arguments. Specifically, implement the function curry-consume, which takes in a curried lambda function curries (not a list), and applys the function to a list of arguments args. Similarly to the previous question, you may make several assumptions: If curries is an n-curried function, then there will be at most n arguments in args. If there are 0 arguments, then you may assume that curries has been fully apply’d with relevant arguments; in this case, curries now contains a value representing the output of the lambda function. Return it. Note that there can be fewer args than formals for the corresponding lambda function curries! In the case that there are fewer arguments, curry-consume should return a curried lambda function, which is the result of partially applying curries up to the number of args provdied. 1234567891011121314151617181920scm&gt; (define three-curry (curry-cook &#x27;(x y z) &#x27;(+ x (* y z))))three-curryscm&gt; three-curry(lambda (x) (lambda (y) (lambda (z) (+ x (* y z)))))scm&gt; (define three-curry-fn (eval three-curry)) ; three-curry-fn is a lambda function derived from the programthree-curry-fnscm&gt; (define eat-two (curry-consume three-curry-fn &#x27;(1 2))) ; pass in only two arguments, return should be a one-arg lambda function!eat-twoscm&gt; eat-two(lambda (z) (+ x (* y z)))scm&gt; (eat-two 3) ; pass in the last argument; 1 + (2 * 3)7scm&gt; (curry-consume three-curry-fn &#x27;(1 2 3)) ; all three arguments at once7(define (curry-consume curries args) (if (null? args) curries (curry-consume (curries (car args)) (cdr args)) )) Use Ok to test your code: 1python3 ok -q curry_consume✂️ Optional Questions Homework assignments will also contain prior exam-level questions for you to take a look at. These questions have no submission component; feel free to attempt them if you’d like a challenge! Fall 2019 Final Q7c: *-to-mul Fall 2021 Final Q5a: Spice","categories":[],"tags":[{"name":"CS61A","slug":"CS61A","permalink":"http://www.misaka-9982.com/tags/CS61A/"}]},{"title":"CS61A Lab 14","slug":"CS61A-Lab-14","date":"2022-07-30T05:46:42.000Z","updated":"2022-07-30T05:53:53.225Z","comments":true,"path":"2022/07/30/CS61A-Lab-14/","link":"","permalink":"http://www.misaka-9982.com/2022/07/30/CS61A-Lab-14/","excerpt":"","text":"Lab 14 Solutions lab14.zip Solution Files This lab has many files. Remember to write in lab14.scm for the Scheme questions, lab14.lark for the BNF question, and lab14.py for all other questions. Required Questions Scheme Q1: Split Implement split-at, which takes a list lst and a non-negative number n as input and returns a pair new such that (car new) is the first n elements of lst and (cdr new) is the remaining elements of lst. If n is greater than the length of lst, (car new) should be lst and (cdr new) should be nil. 12345678910scm&gt; (car (split-at &#x27;(2 4 6 8 10) 3))(2 4 6)scm&gt; (cdr (split-at &#x27;(2 4 6 8 10) 3))(8 10)(define (split-at lst n) (cond ((= n 0) (cons nil lst)) ((null? lst) (cons lst nil)) (else (let ((rec (split-at (cdr lst) (- n 1)))) (cons (cons (car lst) (car rec)) (cdr rec)))))) Use Ok to test your code: 1python3 ok -q split-at✂️ Scheme Data Abstraction Q2: Filter Odd Tree Write a function filter-odd which takes a tree data abstraction and returns a new tree with all even labels replaced with nil. Consider using the map procedure to apply a one-argument function to a list. Below is a Scheme-ified data abstraction of the Tree class we’ve been working with this semester. 123456789101112131415; Constructs tree given label and list of branches(tree label branches); Returns the label of the tree(label t); Returns the list of branches of the given tree(branches t)(define (filter-odd t) (cond ((null? t) nil) ((odd? (label t)) (tree (label t) (map filter-odd (branches t)))) (else (tree nil (map filter-odd (branches t)))) )) Use Ok to test your code: 1python3 ok -q filter_odd✂️ Programs as Data Q3: Swap Implement swap which takes an expression expr representing a call to some procedure and returns the same expression with its first two operands swapped if the value of the second operand is greater than the value of the first. Otherwise, it should just return the original expression. For example, (swap '(- 1 (+ 3 5) 7)) should return the expression (- (+ 3 5) 1 7) since 1 evaluates to 1, (+ 3 5) evaluates to 8, and 8 &gt; 1. Any operands after the first two should not be evaluated during the execution of the procedure, and they should be left unchanged in the final expression. You may assume that every operand evaluates to a number and that there are always at least two operands in expr. You may want to consider using a let expression in addition to the provided procedures to help simplify your code. 12345678910111213141516171819202122(define (cddr s) (cdr (cdr s)))(define (cadr s) (car (cdr s)))(define (caddr s) (car (cddr s)))(define (swap expr) (let ((op (car expr)) (first (car (cdr expr))) (second (caddr expr)) (rest (cdr (cddr expr)))) (if (&gt; (eval second) (eval first)) (cons op (cons second (cons first rest))) expr) )) Use Ok to test your code: 1python3 ok -q swap✂️ Regex Q4: Address First Line Write a regular expression that parses strings and returns whether it contains the first line of a US mailing address. US mailing addresses typically contain a block number, which is a sequence of 3-5 digits, following by a street name. The street name can consist of multiple words but will always end with a street type abbreviation, which itself is a sequence of 2-5 English letters. The street name can also optionally start with a cardinal direction (“N”, “E”, “W”, “S”). Everything should be properly capitalized. Proper capitalization means that the first letter of each name is capitalized. It is fine to have things like “WeirdCApitalization” match. See the doctests for some examples. 123456789101112131415161718192021222324def address_oneline(text): &quot;&quot;&quot; Finds and returns if there are expressions in text that represent the first line of a US mailing address. &gt;&gt;&gt; address_oneline(&quot;110 Sproul Hall, Berkeley, CA 94720&quot;) True &gt;&gt;&gt; address_oneline(&quot;What&#x27;s at 39177 Farwell Dr? Is there a 39177 Nearwell Dr?&quot;) True &gt;&gt;&gt; address_oneline(&quot;I just landed at 780 N McDonnell Rd, and I need to get to 1880-ish University Avenue. Help!&quot;) True &gt;&gt;&gt; address_oneline(&quot;123 Le Roy Ave&quot;) True &gt;&gt;&gt; address_oneline(&quot;110 Unabbreviated Boulevard&quot;) False &gt;&gt;&gt; address_oneline(&quot;790 lowercase St&quot;) False &quot;&quot;&quot; block_number = r&quot;\\d&#123;3,5&#125;&quot; cardinal_dir = r&quot;(?:[NEWS] )?&quot; # whitespace is important! street = r&quot;(?:[A-Z][A-Za-z]+ )+&quot; type_abbr = r&quot;[A-Z][a-z]&#123;1,4&#125;\\b&quot; street_name = f&quot;&#123;cardinal_dir&#125;&#123;street&#125;&#123;type_abbr&#125;&quot; return bool(re.search(f&quot;&#123;block_number&#125; &#123;street_name&#125;&quot;, text)) Use Ok to test your code: 1python3 ok -q address_oneline✂️ BNF Q5: WWPD: PyCombinator Consider this attempt at a BNF grammar for Pycombinator, a grammar which supports a subset of Python’s functionality. Specifically, it is able to parse any expression with a Python arithmetic operator. The grammar is specified below: 123456789101112?start: pycomb_expressionpycomb_expression: func &quot;(&quot; arg (&quot;,&quot; arg)* &quot;)&quot;arg: pycomb_expression | NUMBERfunc: FUNCNAMEFUNCNAME: &quot;add&quot; | &quot;mul&quot; | &quot;sub&quot;%ignore &quot; &quot;%import common.NUMBER Let’s understand and modify the functionality of this BNF with a few questions. Use Ok to test your knowledge by choosing the best answer for each of the following “What Would PyCombinator Do” questions: 1python3 ok -q wwpd-bnf -u Submit Make sure to submit this assignment by running: 1python3 ok --submit Recommended Questions The following problems are not required for credit on this lab but may help you prepare for the final. Trees Q6: Prune Min Write a function that prunes a Tree t mutatively. t and its branches always have zero or two branches. For the trees with two branches, reduce the number of branches from two to one by keeping the branch that has the smaller label value. Do nothing with trees with zero branches. Prune the tree in a direction of your choosing (top down or bottom up). The result should be a linear tree. 123456789101112131415161718192021222324252627282930313233def prune_min(t): &quot;&quot;&quot;Prune the tree mutatively. &gt;&gt;&gt; t1 = Tree(6) &gt;&gt;&gt; prune_min(t1) &gt;&gt;&gt; t1 Tree(6) &gt;&gt;&gt; t2 = Tree(6, [Tree(3), Tree(4)]) &gt;&gt;&gt; prune_min(t2) &gt;&gt;&gt; t2 Tree(6, [Tree(3)]) &gt;&gt;&gt; t3 = Tree(6, [Tree(3, [Tree(1), Tree(2)]), Tree(5, [Tree(3), Tree(4)])]) &gt;&gt;&gt; prune_min(t3) &gt;&gt;&gt; t3 Tree(6, [Tree(3, [Tree(1)])]) &quot;&quot;&quot; if t.branches == []: return prune_min(t.branches[0]) prune_min(t.branches[1]) if (t.branches[0].label &gt; t.branches[1].label): t.branches.pop(0) else: t.branches.pop(1) return # return statement to block alternate from running# Alternate solution if t.is_leaf(): return remove_ind = int(t.branches[0].label &lt; t.branches[1].label) t.branches.pop(remove_ind) prune_min(t.branches[0]) Use Ok to test your code: 1python3 ok -q prune_min✂️ Q7: Add trees Define the function add_trees, which takes in two trees and returns a new tree where each corresponding node from the first tree is added with the node from the second tree. If a node at any particular position is present in one tree but not the other, it should be present in the new tree as well. Hint: You may want to use the built-in zip function to iterate over multiple sequences at once. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748def add_trees(t1, t2): &quot;&quot;&quot; &gt;&gt;&gt; numbers = Tree(1, ... [Tree(2, ... [Tree(3), ... Tree(4)]), ... Tree(5, ... [Tree(6, ... [Tree(7)]), ... Tree(8)])]) &gt;&gt;&gt; print(add_trees(numbers, numbers)) 2 4 6 8 10 12 14 16 &gt;&gt;&gt; print(add_trees(Tree(2), Tree(3, [Tree(4), Tree(5)]))) 5 4 5 &gt;&gt;&gt; print(add_trees(Tree(2, [Tree(3)]), Tree(2, [Tree(3), Tree(4)]))) 4 6 4 &gt;&gt;&gt; print(add_trees(Tree(2, [Tree(3, [Tree(4), Tree(5)])]), \\ Tree(2, [Tree(3, [Tree(4)]), Tree(5)]))) 4 6 8 5 5 &quot;&quot;&quot; if not t1: return t2 if not t2: return t1 new_label = t1.label + t2.label t1_branches, t2_branches = list(t1.branches), list(t2.branches) length_t1, length_t2 = len(t1_branches), len(t2_branches) if length_t1 &lt; length_t2: t1_branches += [None for _ in range(length_t1, length_t2)] elif length_t1 &gt; length_t2: t2_branches += [None for _ in range(length_t2, length_t1)] return Tree(new_label, [add_trees(branch1, branch2) for branch1, branch2 in zip(t1_branches, t2_branches)]) Use Ok to test your code: 1python3 ok -q add_trees✂️ Objects Let’s implement a game called Election. In this game, two players compete to try and earn the most votes. Both players start with 0 votes and 100 popularity. The two players alternate turns, and the first player starts. Each turn, the current player chooses an action. There are two types of actions: The player can debate, and either gain or lose 50 popularity. If the player has popularity p1 and the other player has popularity p2, then the probability that the player gains 50 popularity is max(0.1, p1 / (p1 + p2)) Note that the max causes the probability to never be lower than 0.1. The player can give a speech. If the player has popularity p1 and the other player has popularity p2, then the player gains p1 // 10 votes and popularity and the other player loses p2 // 10 popularity. The game ends when a player reaches 50 votes, or after a total of 10 turns have been played (each player has taken 5 turns). Whoever has more votes at the end of the game is the winner! Q8: Player First, let’s implement the Player class. Fill in the debate and speech methods, that take in another Player other, and implement the correct behavior as detailed above. Here are two additional things to keep in mind: In the debate method, you should call the provided random function, which returns a random float between 0 and 1. The player should gain 50 popularity if the random number is smaller than the probability described above, and lose 50 popularity otherwise. Neither players’ popularity should ever become negative. If this happens, set it equal to 0 instead. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263### Phase 1: The Player Classclass Player: &quot;&quot;&quot; &gt;&gt;&gt; random = make_test_random() &gt;&gt;&gt; p1 = Player(&#x27;Hill&#x27;) &gt;&gt;&gt; p2 = Player(&#x27;Don&#x27;) &gt;&gt;&gt; p1.popularity 100 &gt;&gt;&gt; p1.debate(p2) # random() should return 0.0 &gt;&gt;&gt; p1.popularity 150 &gt;&gt;&gt; p2.popularity 100 &gt;&gt;&gt; p2.votes 0 &gt;&gt;&gt; p2.speech(p1) &gt;&gt;&gt; p2.votes 10 &gt;&gt;&gt; p2.popularity 110 &gt;&gt;&gt; p1.popularity 135 &gt;&gt;&gt; # Additional correctness tests &gt;&gt;&gt; p1.speech(p2) &gt;&gt;&gt; p1.votes 13 &gt;&gt;&gt; p1.popularity 148 &gt;&gt;&gt; p2.votes 10 &gt;&gt;&gt; p2.popularity 99 &gt;&gt;&gt; for _ in range(4): # 0.1, 0.2, 0.3, 0.4 ... p1.debate(p2) &gt;&gt;&gt; p2.debate(p1) &gt;&gt;&gt; p2.popularity 49 &gt;&gt;&gt; p2.debate(p1) &gt;&gt;&gt; p2.popularity 0 &quot;&quot;&quot; def __init__(self, name): self.name = name self.votes = 0 self.popularity = 100 def debate(self, other): prob = max(0.1, self.popularity / (self.popularity + other.popularity)) if random() &lt; prob: self.popularity += 50 else: self.popularity = max(0, self.popularity - 50) def speech(self, other): self.votes += self.popularity // 10 self.popularity += self.popularity // 10 other.popularity -= other.popularity // 10 def choose(self, other): return self.speech Use Ok to test your code: 1python3 ok -q Player✂️ Q9: Game Now, implement the Game class. Fill in the play method, which should alternate between the two players, starting with p1, and have each player take one turn at a time. The choose method in the Player class returns the method, either debate or speech, that should be called to perform the action. In addition, fill in the winner method, which should return the player with more votes, or None if the players are tied. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546### Phase 2: The Game Classclass Game: &quot;&quot;&quot; &gt;&gt;&gt; p1, p2 = Player(&#x27;Hill&#x27;), Player(&#x27;Don&#x27;) &gt;&gt;&gt; g = Game(p1, p2) &gt;&gt;&gt; winner = g.play() &gt;&gt;&gt; p1 is winner True &gt;&gt;&gt; # Additional correctness tests &gt;&gt;&gt; winner is g.winner() True &gt;&gt;&gt; g.turn 10 &gt;&gt;&gt; p1.votes = p2.votes &gt;&gt;&gt; print(g.winner()) None &quot;&quot;&quot; def __init__(self, player1, player2): self.p1 = player1 self.p2 = player2 self.turn = 0 def play(self): while not self.game_over(): if self.turn % 2 == 0: curr, other = self.p1, self.p2 else: curr, other = self.p2, self.p1 curr.choose(other)(other) self.turn += 1 return self.winner() def game_over(self): return max(self.p1.votes, self.p2.votes) &gt;= 50 or self.turn &gt;= 10 def winner(self): if self.p1.votes &gt; self.p2.votes: return self.p1 elif self.p2.votes &gt; self.p1.votes: return self.p2 else: return None Use Ok to test your code: 1python3 ok -q Game✂️ Q10: New Players The choose method in the Player class is boring, because it always returns the speech method. Let’s implement two new classes that inherit from Player, but have more interesting choose methods. Implement the choose method in the AggressivePlayer class, which returns the debate method if the player’s popularity is less than or equal to other’s popularity, and speech otherwise. Also implement the choose method in the CautiousPlayer class, which returns the debate method if the player’s popularity is 0, and speech otherwise. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051### Phase 3: New Playersclass AggressivePlayer(Player): &quot;&quot;&quot; &gt;&gt;&gt; random = make_test_random() &gt;&gt;&gt; p1, p2 = AggressivePlayer(&#x27;Don&#x27;), Player(&#x27;Hill&#x27;) &gt;&gt;&gt; g = Game(p1, p2) &gt;&gt;&gt; winner = g.play() &gt;&gt;&gt; p1 is winner True &gt;&gt;&gt; # Additional correctness tests &gt;&gt;&gt; p1.popularity = p2.popularity &gt;&gt;&gt; p1.choose(p2) == p1.debate True &gt;&gt;&gt; p1.popularity += 1 &gt;&gt;&gt; p1.choose(p2) == p1.debate False &gt;&gt;&gt; p2.choose(p1) == p2.speech True &quot;&quot;&quot; def choose(self, other): if self.popularity &lt;= other.popularity: return self.debate else: return self.speechclass CautiousPlayer(Player): &quot;&quot;&quot; &gt;&gt;&gt; random = make_test_random() &gt;&gt;&gt; p1, p2 = CautiousPlayer(&#x27;Hill&#x27;), AggressivePlayer(&#x27;Don&#x27;) &gt;&gt;&gt; p1.popularity = 0 &gt;&gt;&gt; p1.choose(p2) == p1.debate True &gt;&gt;&gt; p1.popularity = 1 &gt;&gt;&gt; p1.choose(p2) == p1.debate False &gt;&gt;&gt; # Additional correctness tests &gt;&gt;&gt; p2.choose(p1) == p2.speech True &quot;&quot;&quot; def choose(self, other): if self.popularity == 0: return self.debate else: return self.speech Use Ok to test your code: 12python3 ok -q AggressivePlayerpython3 ok -q CautiousPlayer✂️ Lists Q11: Intersection - Summer 2015 MT1 Q4 Implement intersection(lst_of_lsts), which takes a list of lists and returns a list of distinct elements that appear in all the lists in lst_of_lsts. If no number appears in all of the lists, return the empty list. You may assume that lst_of_lsts contains at least one list. 1234567891011121314151617181920212223242526def intersection(lst_of_lsts): &quot;&quot;&quot;Returns a list of distinct elements that appear in every list in lst_of_lsts. &gt;&gt;&gt; lsts1 = [[1, 2, 3], [1, 3, 5]] &gt;&gt;&gt; intersection(lsts1) [1, 3] &gt;&gt;&gt; lsts2 = [[1, 4, 2, 6], [7, 2, 4], [4, 4]] &gt;&gt;&gt; intersection(lsts2) [4] &gt;&gt;&gt; lsts3 = [[1, 2, 3], [4, 5], [7, 8, 9, 10]] &gt;&gt;&gt; intersection(lsts3) # No number appears in all lists [] &gt;&gt;&gt; lsts4 = [[3, 3], [1, 2, 3, 3], [3, 4, 3, 5]] &gt;&gt;&gt; intersection(lsts4) # Return list of distinct elements [3] &quot;&quot;&quot; elements = [] for elem in lst_of_lsts[0]: condition = elem not in elements for lst in lst_of_lsts[1:]: if elem not in lst: condition = False if condition: elements = elements + [elem] return elements Use Ok to test your code: 1python3 ok -q intersection✂️ Q12: Deck of cards Write a list comprehension that will create a deck of cards, given a list of suits and a list of ranks. Each element in the list will be a card, which is represented by a 2-element list of the form [suit, rank]. 1234567891011121314151617def deck(suits, ranks): &quot;&quot;&quot;Creates a deck of cards (a list of 2-element lists) with the given suits and ranks. Each element in the returned list should be of the form [suit, rank]. &gt;&gt;&gt; deck([&#x27;S&#x27;, &#x27;C&#x27;], [1, 2, 3]) [[&#x27;S&#x27;, 1], [&#x27;S&#x27;, 2], [&#x27;S&#x27;, 3], [&#x27;C&#x27;, 1], [&#x27;C&#x27;, 2], [&#x27;C&#x27;, 3]] &gt;&gt;&gt; deck([&#x27;S&#x27;, &#x27;C&#x27;], [3, 2, 1]) [[&#x27;S&#x27;, 3], [&#x27;S&#x27;, 2], [&#x27;S&#x27;, 1], [&#x27;C&#x27;, 3], [&#x27;C&#x27;, 2], [&#x27;C&#x27;, 1]] &gt;&gt;&gt; deck([], [3, 2, 1]) [] &gt;&gt;&gt; deck([&#x27;S&#x27;, &#x27;C&#x27;], []) [] &quot;&quot;&quot; return [[suit, rank] for suit in suits for rank in ranks] Use Ok to test your code: 1python3 ok -q deck✂️ Linked Lists Q13: O!-Pascal - Fall 2017 Final Q4 Pasal’s Triangle is perhaps familiar to you from the diagram below, which shows the first five rows. Every square is the sum of the two squares above it (as illustrated by the arrows showing here the value 4 comes from), unless it doesn’t have two squares above it, in whih case its value is 1. Given a linked list that represents a row in Pasal’s triangle, return a linked list that will represent the row below it. 12345678910111213141516171819202122def pascal_row(s): &quot;&quot;&quot; &gt;&gt;&gt; a = Link.empty &gt;&gt;&gt; for _ in range(5): ... a = pascal_row(a) ... print(a) &lt;1&gt; &lt;1 1&gt; &lt;1 2 1&gt; &lt;1 3 3 1&gt; &lt;1 4 6 4 1&gt; &quot;&quot;&quot; if s is Link.empty: return Link(1) start = Link(1) last, current = start, s while current.rest is not Link.empty: last.rest = Link(current.first + current.rest.first) last, current = last.rest, current.rest last.rest = Link(1) return start Use Ok to test your code: 1python3 ok -q pascal_row✂️","categories":[],"tags":[{"name":"CS61A","slug":"CS61A","permalink":"http://www.misaka-9982.com/tags/CS61A/"}]},{"title":"CS61A Lab 13","slug":"CS61A-Lab-13","date":"2022-07-30T05:45:13.000Z","updated":"2022-07-30T05:52:43.694Z","comments":true,"path":"2022/07/30/CS61A-Lab-13/","link":"","permalink":"http://www.misaka-9982.com/2022/07/30/CS61A-Lab-13/","excerpt":"","text":"Lab 13 Solutions lab13.zip Solution Files Topics Consult this section if you need a refresher on the material for this lab. It’s okay to skip directly to the questions and refer back here should you get stuck. Questions Regular Expressions Q1: What Would RegEx Match? For each of the following regular expressions, suggest a string that would be fully matched. Use Ok to test your knowledge by choosing the best answer for each of the following questions: 1python3 ok -q wwrm -u A hexadecimal color code begins with # and is followed by exactly six hexadecimal numbers, which can be the digits 0-9 or letters a-f. 12345678910111213141516171819202122232425262728Q: #[a-f0-9]&#123;6&#125;Choose the number of the correct choice:0) A hexadecimal color code with 3 letters and 3 numbers1) A hexadecimal color code that starts with letters and ends with numbers, like #gg12342) Any 6-digit hexadecimal color code, like #fdb5153) Any hexadecimal color code with 0-6 digitsQ: (fizz(buzz|)|buzz)Choose the number of the correct choice:0) Only fizzbuzz or buzz1) Only fizzbuzzbuzz2) Only fizz3) Only fizzbuzz, fizz, and buzz4) Only fizzbuzzQ: [-+]?\\d*\\.?\\d+Choose the number of the correct choice:0) Only signed numbers like +1000, -1.51) Only signed or unsigned integers like +1000, -332) Signed or unsigned numbers like +1000, -1.5, .0513) Only unsigned numbers like 0.051Q: [1-9]+[05]+Choose the number of the correct choice:0) Any positive number1) Numbers that are both greater than 5 and divisible by 5 like 10, 25, 8002) Numbers that are divisible by 5 but do not have the digits 0 and 5 adjacent to each other as the last 2 digits3) Numbers that are divisible by 5 like 5, 20, 6325 Q2: Scientific Name Returns whether the input string name follows the correct format for a scientific name. A scientific name’s format is as follows: starts with a capital letter, followed by a period (.) or a series of lowercase letters, followed by a space, followed by a series of lowercase letters. Refer to the doctests for examples of valid and invalid strings. 12345678910111213141516171819202122232425262728import redef scientific_name(name): &quot;&quot;&quot; Returns True for strings that are in the correct notation for scientific names; i.e. contains a capital letter followed by a period or lowercase letters, followed by a space, followed by more lowercase letters. Returns False for invalid strings. &gt;&gt;&gt; scientific_name(&quot;T. rex&quot;) True &gt;&gt;&gt; scientific_name(&quot;t. rex&quot;) False &gt;&gt;&gt; scientific_name(&quot;tyrannosurus rex&quot;) False &gt;&gt;&gt; scientific_name(&quot;t rex&quot;) False &gt;&gt;&gt; scientific_name(&quot;Falco peregrinus&quot;) True &gt;&gt;&gt; scientific_name(&quot;F peregrinus&quot;) False &gt;&gt;&gt; scientific_name(&quot;Annie the F. peregrinus&quot;) False &gt;&gt;&gt; scientific_name(&quot;I want a pet T. rex right now&quot;) False &quot;&quot;&quot; return bool(re.search(r&quot;^[A-Z]([.]|[a-z]+)\\s[a-z]+$&quot;, name)) Use Ok to test your code: 1python3 ok -q scientific_name✂️ Q3: Calculator Ops Write a regular expression that parses strings written in the 61A Calculator language and returns True if any expression has exactly two numeric operands. Returns False otherwise. Note: the allowed operators are +, -, *, and /. Check these lecture slides for a refresher on what the 61A calculator language is. 1234567891011121314151617181920212223242526import redef calculator_ops(calc_str): &quot;&quot;&quot; Returns True if an expression from the Calculator language that has two numeric operands exists in calc_str, False otherwise. &gt;&gt;&gt; calculator_ops(&quot;(* 2 4)&quot;) True &gt;&gt;&gt; calculator_ops(&quot;(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))&quot;) True &gt;&gt;&gt; calculator_ops(&quot;(* 2)&quot;) False &gt;&gt;&gt; calculator_ops(&quot;(/ 8 4 2)&quot;) False &gt;&gt;&gt; calculator_ops(&quot;(- 8 3)&quot;) True &gt;&gt;&gt; calculator_ops(&quot;+ 3 23&quot;) False &quot;&quot;&quot; # Since hyphen is a special character inside [], it must be escaped return bool(re.search(r&quot;\\(([+\\-/*]\\s+\\d+\\s+\\d+)\\)&quot;, calc_str)) # Alternate solution: hyphen must be at either beginning or end inside [] return bool(re.search(r&quot;\\(([-+*/]\\s+\\d+\\s+\\d+)\\)&quot;, calc_str)) Use Ok to test your code: 1python3 ok -q calculator_ops✂️ Q4: Roman Numerals Return True if any string of letters that resemble a Roman numeral exists in text and aren’t part of another word. A Roman numeral is made up of the letters I, V, X, L, C, D, M and is at least one letter long. For the purposes of this problem, don’t worry about whether or not a Roman numeral is valid. For example, “VIIIII” is not a Roman numeral, but it is fine if your regex matches it. 12345678910111213141516171819202122import redef roman_numerals(text): &quot;&quot;&quot; Returns True if any string of letters that could be a Roman numeral (made up of the letters I, V, X, L, C, D, M) is found. Returns False otherwise. &gt;&gt;&gt; roman_numerals(&quot;Sir Richard IIV, can you tell Richard VI that Richard IV is on the phone?&quot;) True &gt;&gt;&gt; roman_numerals(&quot;My TODOs: I. Groceries II. Learn how to count in Roman IV. Profit&quot;) True &gt;&gt;&gt; roman_numerals(&quot;I. Act 1 II. Act 2 III. Act 3 IV. Act 4 V. Act 5&quot;) True &gt;&gt;&gt; roman_numerals(&quot;Let&#x27;s play Civ VII&quot;) True &gt;&gt;&gt; roman_numerals(&quot;i love vi so much more than emacs.&quot;) False &gt;&gt;&gt; roman_numerals(&quot;she loves ALL editors equally.&quot;) False &quot;&quot;&quot; return bool(re.search(r&quot;\\b([IVXLCDM]+)\\b&quot;, text)) Use Ok to test your code: 1python3 ok -q roman_numerals✂️ Submit Make sure to submit this assignment by running: 1python3 ok --submit","categories":[],"tags":[{"name":"CS61A","slug":"CS61A","permalink":"http://www.misaka-9982.com/tags/CS61A/"}]},{"title":"CS61A Lab 12","slug":"CS61A-Lab-12","date":"2022-07-30T05:36:53.000Z","updated":"2022-07-30T05:41:15.817Z","comments":true,"path":"2022/07/30/CS61A-Lab-12/","link":"","permalink":"http://www.misaka-9982.com/2022/07/30/CS61A-Lab-12/","excerpt":"","text":"Lab 12: Scheme Data Abstraction lab12.zip Due by 11:59pm on Wednesday, April 13. Starter Files Download lab12.zip. Inside the archive, you will find starter files for the questions in this lab, along with a copy of the Ok autograder. Topics Consult this section if you need a refresher on the material for this lab. It’s okay to skip directly to the questions and refer back here should you get stuck. Data Abstractions Data Abstractions Example Data Abstractions Rational Recall that a rational number is any number that can be expressed as p / q, where p and q are integers. 123456789101112131415; Creates the rational number n/d (Assume n, d are integers and d != 0); Note that the constructor simplifies the numerator and denominator.(rational n d); Gets the numerator of rational number r(numer r) ; Gets the denominator of rational number r(denom r); Adds two rational numbers x and y(add-rational x y); Multiplies two rational numbers x and y(mul-rational x y) Trees Below is a Scheme-ified data abstraction of the Tree class we’ve been working with this semester. 1234567891011; Constructs tree given label and list of branches(tree label branches); Returns the label of the tree(label t); Returns the list of branches of the given tree(branches t); Returns #t if t is a leaf, #f otherwise(is-leaf t) Questions What Would Scheme Do? Q1: WWSD: Data Abstractions Let’s familiarize ourselves with some Scheme data abstractions! If you need a refresher on the tree and rational abstractions, refer to this lab’s introduction or Monday 04/11’s lecture. Use Ok to test your knowledge with the following “What Would Python Display?” questions: 1python3 ok -q abstractions -u✂️ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748scm&gt; (load rational.scm)scm&gt; (define x (rational 2 5))scm&gt; (numer x)scm&gt; (denom x)scm&gt; (define y (rational 1 4))scm&gt; (define z1 (add-rational x y))scm&gt; (numer z1)scm&gt; (denom z1)scm&gt; (define z2 (mul-rational x y)) ; don&#x27;t forget to reduce the rational!scm&gt; (numer z2)scm&gt; (denom z2)scm&gt; (load tree.scm)scm&gt; (define t (tree 1 (list (tree 2 nil)) ))scm&gt; (label t)scm&gt; (length (branches t))scm&gt; (define child (car (branches t)))scm&gt; (label child)scm&gt; (is-leaf child)scm&gt; (branches child)scm&gt; (load tree.scm)scm&gt; (define b1 (tree 5 (list (tree 6 nil) (tree 7 nil)) )) scm&gt; (map is-leaf (branches b1)) ; draw the tree if you get stuck!scm&gt; (define b2 (tree 8 (list (tree 9 (list (tree 10 nil)) )) )) scm&gt; (map is-leaf (branches b2)) ; draw the tree if you get stuck!scm&gt; (define t (tree 11 (list b1 b2)))scm&gt; (label t)scm&gt; (map (lambda (b) (label b)) (branches t)) ; draw the tree if you get stuck! 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125$ python3 ok -q abstractions -u=====================================================================Assignment: Lab 12OK, version v1.18.1=====================================================================~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Unlocking testsAt each &quot;? &quot;, type what you would expect the output to be.Type exit() to quit---------------------------------------------------------------------What Would Scheme Display? &gt; Suite 1 &gt; Case 1(cases remaining: 3)scm&gt; (load &quot;./lab12.scm&quot;)scm&gt; (define x (rational 2 5))? x-- OK! --scm&gt; (numer x)? 2-- OK! --scm&gt; (denom x)? 5-- OK! --scm&gt; (define y (rational 1 4))? y-- OK! --scm&gt; (define z1 (add-rational x y))? z1-- OK! --scm&gt; (numer z1)? 13-- OK! --scm&gt; (denom z1)? 20-- OK! --scm&gt; (define z2 (mul-rational x y))? z2-- OK! --scm&gt; (numer z2)? 1-- OK! --scm&gt; (denom z2)? 10-- OK! -----------------------------------------------------------------------What Would Scheme Display? &gt; Suite 1 &gt; Case 2(cases remaining: 2)scm&gt; (load &quot;./lab12.scm&quot;)scm&gt; (define t (tree 1 (list (tree 2 nil))))? t-- OK! --scm&gt; (label t)? 1-- OK! --scm&gt; (length (branches t))? 1-- OK! --scm&gt; (define child (car (branches t)))? child-- OK! --scm&gt; (label child)? 2-- OK! --scm&gt; (is-leaf child)? #t-- OK! --scm&gt; (branches child)? ()-- OK! -----------------------------------------------------------------------What Would Scheme Display? &gt; Suite 1 &gt; Case 3(cases remaining: 1)scm&gt; (load &quot;./lab12.scm&quot;)scm&gt; (define b1 (tree 5 (list (tree 6 nil) (tree 7 nil)) )) ? b1-- OK! --scm&gt; (map is-leaf (branches b1)) ; draw the tree if you get stuck!? (#t #t)-- OK! --scm&gt; (define b2 (tree 8 (list (tree 9 (list (tree 10 nil)) )) )) ? b2-- OK! --scm&gt; (map is-leaf (branches b2)) ; draw the tree if you get stuck!? (#f)-- OK! --scm&gt; (define t (tree 11 (list b1 b2)))? t-- OK! --scm&gt; (label t)? 11-- OK! --scm&gt; (map (lambda (b) (label b)) (branches t))? (5 8)-- OK! -----------------------------------------------------------------------OK! All cases for What Would Scheme Display? unlocked. Code Writing Questions Remember that when working with data abstractions, you should not break the abstraction barrier if possible! Later questions will have abstraction checks, where the underlying representation of the abstraction will be changed; thus, attempting to refer to specifics of the implementation will break. Attempt to use the functions you are creating to interface with the classes whenever possible. Cities Say we have an abstract data type for cities. A city has a name, a latitude coordinate, and a longitude coordinate. Our data abstraction has one constructor: (make-city name lat lon): Creates a city object with the given name, latitude, and longitude. We also have the following selectors in order to get the information for each city: (get-name city): Returns the city’s name (get-lat city): Returns the city’s latitude (get-lon city): Returns the city’s longitude Here is how we would use the constructor and selectors to create cities and extract their information: 12345678910scm&gt; (define berkeley (make-city &#x27;Berkeley 122 37))berkeleyscm&gt; (get-name berkeley)Berkeleyscm&gt; (get-lat berkeley)122scm&gt; (define new-york (make-city &#x27;NYC 74 40))new-yorkscm&gt; (get-lon new-york)40 All of the selector and constructor functions can be found in the lab file, if you are curious to see how they are implemented. However, the point of data abstraction is that we do not need to know how an abstract data type is implemented, but rather just how we can interact with and use the data type. Q2: Distance We will now implement the function distance, which computes the Euclidean distance between two city objects; the Euclidean distance between two coordinate pairs (x1, y1) and (x2, y2) can be found by calculating the sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2). Use the latitude and longitude of a city as its coordinates; you’ll need to use the selectors to access this info! You may find the following methods useful: (expt base exp): calculate base ** exp (sqrt x) calculate sqrt(x) 123456789(define (distance city-a city-b) &#x27;YOUR-CODE-HERE (sqrt (+ (expt (- (get-lat city-a) (get-lat city-b)) 2) (expt (- (get-lon city-a) (get-lon city-b)) 2) ) )) Use Ok to test your code: 1python3 ok -q city_distance✂️ Q3: Closer city Next, implement closer-city, a function that takes a latitude, longitude, and two cities, and returns the name of the city that is relatively closer to the provided latitude and longitude. You may only use the selectors and constructors introduced above and the distance function you just defined for this question. Hint: How can you use your distance function to find the distance between the given location and each of the given cities? 123456789(define (closer-city lat lon city-a city-b) &#x27;YOUR-CODE-HERE (define x (make-city &#x27;x lat lon)) (if (&lt; (distance x city-a) (distance x city-b)) (get-name city-a) (get-name city-b) )) Use Ok to test your code: 1python3 ok -q city_closer✂️ Teachers and Students In the following questions, you’ll be implementing data abstractions for students and teachers: The teacher abstraction keeps track of the teacher’s name, the class they teach, and the students enrolled in their class. Specifically, a teacher’s name and class are atomic symbols, and their students is a list of student objects. The student abstraction keeps track of a student’s name and number of classes attended. Specifically, a student’s name is an atomic symbol, and their classes is a list of atomic symbols representing all classes attended. For example, if a student had attended cs61a and astronomy, their classes list would be (cs61a astronomy). You can find the constructors for these classes below: 12(define (student-create name classes) (cons name classes))(define (teacher-create name class students) (cons name (cons class students))) Q4: Teachers and Students: Selectors Implement student-get-name, student-get-classes, teacher-get-name, teacher-get-class, and teacher-get-students. These functions take in a student or teacher abstraction, and return the relevant attribute; for example, student-get-name takes a student as input, and returns the name. 1234567891011121314151617181920212223242526272829303132(define (student-create name classes) (cons name classes))(define (teacher-create name class students) (cons name (cons class students)))(define (student-get-name student) &#x27;YOUR-CODE-HERE (car student))(define (student-get-classes student) &#x27;YOUR-CODE-HERE (cdr student))(define (teacher-get-name teacher) &#x27;YOUR-CODE-HERE (car teacher))(define (teacher-get-class teacher) &#x27;YOUR-CODE-HERE (car (cdr teacher)))(define (teacher-get-students teacher) &#x27;YOUR-CODE-HERE (cdr (cdr teacher))) Use Ok to test your code: 1python3 ok -q teacher_student_selectors✂️ Q5: Students: Attend Class Implement student-attend-class. This method takes in a student and a class as input, and returns a new student abstraction with the class list updated to reflect the class attended. Be sure to keep the abstraction barrier in mind! 12345678910(define (student-attend-class student class) &#x27;YOUR-CODE-HERE ; (define new_class (cons class (student-get-classes student))) ; (define name (student-get-name student)) ; (student-create name new_class) (student-create (student-get-name student) (cons class (student-get-classes student)) )) Use Ok to test your code: 1python3 ok -q student_attend_class✂️ Q6: Teachers: Hold Discussion Implement teacher-hold-class. This method takes in a teacher as input, and emulates holding a class. Specifically, the function should return a new updated teacher, where all student objects in the teacher’s students list have updated class lists to reflect their attendance. Be sure to keep the abstraction barrier in mind! Feel free to use any of the functions implemented in previous parts of this lab. You may also find the map function useful. 12345678910111213141516(define (teacher-hold-class teacher) &#x27;YOUR-CODE-HERE (define name (teacher-get-name teacher)) (define class (teacher-get-class teacher)) (define students (teacher-get-students teacher)) (define new_students (map (lambda (student) (student-attend-class student class) ) students ) ) (teacher-create name class new_students)) Use Ok to test your code: 1python3 ok -q teacher_hold_class✂️ Submit Make sure to submit this assignment by running: 1python3 ok --submit","categories":[],"tags":[{"name":"CS61A","slug":"CS61A","permalink":"http://www.misaka-9982.com/tags/CS61A/"}]},{"title":"CS61A Lab 11","slug":"CS61A-Lab-11","date":"2022-07-30T05:33:10.000Z","updated":"2022-07-30T05:41:18.876Z","comments":true,"path":"2022/07/30/CS61A-Lab-11/","link":"","permalink":"http://www.misaka-9982.com/2022/07/30/CS61A-Lab-11/","excerpt":"","text":"Lab 11: Interpreters lab11.zip Due by 11:59pm on Wednesday, April 6. Starter Files Download lab11.zip. Inside the archive, you will find starter files for the questions in this lab, along with a copy of the Ok autograder. Introduction In the Scheme project, you’ll be implementing a Python interpreter for Scheme. Part of the process of interpreting Scheme expressions is being able to parse a string of Scheme code as our input into our interpreter’s internal Python representation of Scheme expressions. As all Scheme expressions are Scheme lists (and therefore linked lists), we represent all Scheme expressions using the Pair class, which behaves as a linked list. This class is defined in pair.py. When given an input such as (+ 1 2), there are two main steps we want to take. The first part of interpreting expressions is taking the input and breaking it down into each component. In our example, we want to treat each of (, +, 1, 2, and ) as a separate token that we can then figure out how to represent. This is called lexical analysis, and has been implemented for you in the tokenize_lines function in scheme_tokens.py. Now that we’ve broken down the input into its component parts, we want to turn these Scheme tokens into our interpreter’s internal representations of them. This is called syntactic analysis, which happens in scheme_reader.py in the scheme_read and read_tail functions. ( tells us we are starting a call expression. + will be the operator, as it’s the first element in the call expression. 1 is our first operand. 2 is our second operand. ) tells us that we are ending the call expression. The main idea is that we’d like to first recognize what the input represents, before we do any of the evaluating, or calling the operator on the operands, and so on. The goal of this lab is to work with the various parts that go into parsing; while in this lab and in the project, we’re focusing on the Scheme language, the general ideas of how we’re setting up the Scheme interpreter can be applicable to other languages – such as Python itself! Required Questions Check out the introduction for the context of this lab. Part 1 Context We store tokens ready to be parsed in Buffer instances. For example, a buffer containing the input (+ (2 3)) would have the tokens '(', '+', '(', 2, 3, ')', and ')'. In this part, we will implement the Buffer class. A Buffer provides a way of accessing a sequence of tokens across lines. Its constructor takes an iterator, called “the source”, that returns the next line of tokens as a list each time it is queried, until it runs out of lines. For example, source could be defined as follows: 12345line1 = [&#x27;(&#x27;, &#x27;+&#x27;, 6, 1, &#x27;)&#x27;] # (+ 6 1)line2 = [&#x27;(&#x27;, &#x27;quote&#x27;, &#x27;A&#x27;, &#x27;)&#x27;] # (quote A)line3 = [2, 1, 0] # 2 1 0input_lines = [line1, line2, line3]source = iter(input_lines) In effect, the Buffer combines the sequences returned from its source and then supplies the items from them one at a time through its pop_first method, calling the source for more sequences of items only when needed. In addition, Buffer provides a current instance attribute to look at the next item to be supplied, without moving past it. Problem 1 Important: Your code for this part should go in buffer.py. Your job in this part is to implement the create_generator, __init__, and pop_first methods of the Buffer class. Note: For this question, you may want to use the built-in function next with its default argument. Here’s an example: 1234567&gt;&gt;&gt; iterator = iter([1, 2])&gt;&gt;&gt; next(iterator) # Here, there is no default arg given.1&gt;&gt;&gt; next(iterator, 5) # Here, there is a default arg given, but not used.2&gt;&gt;&gt; next(iterator, 5) # The iterator is exhausted, so next returns default.5 For more about next, feel free to read through the next Python documentation. create_generator Implement create_generator, a generator function which takes in source, an iterator over line(s), each of which is a list that contains token(s). This function should yield a single token from a line of the source at a time. If there are no more tokens on a line, then it should yield EOL_TOKEN (an object that represents an end-of-line token). If there are no more tokens in the entire source, it should have no more yields. If you were to call next on a generator of this function in this case, a StopIteration would be raised, as there would be no more applicable yields. You can reference this function in your implementations for __init__ and pop_first. Remember that generator functions can be used as follows: 12345&gt;&gt;&gt; gen = some_generator_function()&gt;&gt;&gt; next(gen)# Returns the first yield from some_generator_function&gt;&gt;&gt; next(gen)# Returns the next yield from some_generator_function __init__ __init__ takes in the input source source. You should define the following instance attributes: An instance attribute that holds a generator created by create_generator based off of the source, and self.current to represent the current token of the generator that the Buffer instance is on. In __init__, the current token should be the very first token that the generator yields. If you wish, you may define more instance attributes as you see fit. pop_first Implement pop_first, which does the following: Saves the current token of the Buffer instance, to be returned later. Updates the current token of the Buffer instance to the next token from its generator instance. If there are no more tokens after the initial current token, then update the current token to be None. (Hint: see the note on the default argument to next at the beginning of this problem.) Returns the initial current token (not the updated current token!). Testing your code Use Ok to test your code: 1python3 ok -q buffer✂️ 1234567891011121314151617181920def __init__(self, source): &quot;&quot;&quot; Initialize a Buffer instance based on the given source. &quot;&quot;&quot; # BEGIN self.lines = [] self.curr_line = [] self.token = self.create_generator(source) self.current = next(self.token, None) # self.buffer = [] # token_buffer = self.create_generator(source) # for token in token_buffer: # self.buffer.append(token) # self.current = None # if self.buffer: # self.current = self.buffer[0] # END Part 2 Internal Representations The reader will parse Scheme code into Python values with the following representations: Input Example Scheme Expression Type Our Internal Representation scm&gt; 1 Numbers Python’s built-in int and float values scm&gt; x Symbols Python’s built-in string values scm&gt; #t Booleans (#t, #f) Python’s built-in True, False values scm&gt; (+ 2 3) Combinations Instances of the Pair class, defined in scheme_reader.py. This example is represented as: Pair('+', Pair(2, Pair(3, nil))). scm&gt; nil nil The nil object, defined in scheme_reader.py When we refer to combinations here, we are referring to both call expressions and special forms. Problem 2 Important: Your code for this part should go in scheme_reader.py. Important: While unlocking this problem, if the token yielded from the Buffer instance should be EOL_TOKEN, it will be displayed according to the __repr__ function of the EOL_TOKEN class. Specifically, you would get: 12&gt;&gt;&gt; EOL_TOKENThis is a token representing the end of a line. Your job in this part is to write the parsing functionality, which consists of two mutually recursive functions: scheme_read and read_tail. Each function takes in a single src parameter, which is a Buffer instance. scheme_read removes enough tokens from src to form a single expression and returns that expression in the correct internal representation. read_tail expects to read the rest of a list or Pair, assuming the open parenthesis of that list or Pair has already been removed by scheme_read. It will read expressions (and thus remove tokens) until the matching closing parenthesis ) is seen. This list of expressions is returned as a linked list of Pair instances. In short, scheme_read returns the next single complete expression in the buffer and read_tail returns the rest of a list or Pair in the buffer. Both functions mutate the buffer, removing the tokens that have already been processed. The behavior of both functions depends on the first token currently in src. They should be implemented as follows: scheme_read: If the current token is the string &quot;nil&quot;, return the nil object. If the current token is (, the expression is a pair or list. Call read_tail on the rest of src and return its result. If the current token is ', the rest of the buffer should be processed as a quote expression. You will implement this portion in the next problem. If the next token is not a delimiter, then it must be a primitive expression (i.e. a number, boolean). Return it. Provided If none of the above cases apply, raise an error. Provided read_tail: If there are no more tokens, then the list is missing a close parenthesis and we should raise an error. Provided If the token is ), then we’ve reached the end of the list or pair. Remove this token from the buffer and return the nil object. If none of the above cases apply, the next token is the operator in a combination. For example, src could contain + 2 3). To parse this: scheme_read the next complete expression in the buffer. Call read_tail to read the rest of the combination until the matching closing parenthesis. Return the results as a Pair instance, where the first element is the next complete expression from (1) and the second element is the rest of the combination from (2). Use Ok to unlock and test your code: 12python3 ok -q scheme_read -upython3 ok -q scheme_read✂️ Problem 3 Important: Your code for this part should go in scheme_reader.py. Your task in this problem is to complete the implementation of scheme_read by allowing the function to now be able to handle quoted expressions. In Scheme, quoted expressions such as '&lt;expr&gt; are equivalent to (quote &lt;expr&gt;). That means that we need to wrap the expression following ' (which you can get by recursively calling scheme_read) into the quote special form, which is a Scheme list (as with all special forms). In our representation, a Pair represents a Scheme list. You should therefore wrap the expression following ' in a Pair. For example, 'bagel, or [&quot;'&quot;, &quot;bagel&quot;] after being tokenized, should be represented as Pair('quote', Pair('bagel', nil)). '(1 2) (or [&quot;'&quot;, &quot;(&quot;, 1, 2, &quot;)&quot;]) should be represented as Pair('quote', Pair(Pair(1, Pair(2, nil)), nil)). Use Ok to unlock and test your code: 12python3 ok -q quote -upython3 ok -q quote✂️ Running your parser Now that your parser is complete, you can test the read-eval-print loop by running: 1python3 scheme_reader.py --repl Every time you type in a value into the prompt, both the str and repr values of the parsed expression are printed. You can try the following inputs: 123456789read&gt; 42str : 42repr: 42read&gt; nilstr : ()repr: nilread&gt; (1 (2 3) (4 (5)))str : (1 (2 3) (4 (5)))repr: Pair(1, Pair(Pair(2, Pair(3, nil)), Pair(Pair(4, Pair(Pair(5, nil), nil)), nil))) To exit the interpreter, you can type exit. Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142&quot;&quot;&quot;This module implements the built-in data types of the Scheme language, alongwith a parser for Scheme expressions.In addition to the types defined in this file, some data types in Scheme arerepresented by their corresponding type in Python: number: int or float symbol: string boolean: bool unspecified: NoneThe __repr__ method of a Scheme value will return a Python expression thatwould be evaluated to the value, where possible.The __str__ method of a Scheme value will return a Scheme expression thatwould be read to the value, where possible.&quot;&quot;&quot;import numbersimport builtinsfrom ucb import main, trace, interactfrom scheme_tokens import tokenize_lines, DELIMITERSfrom buffer import Buffer, InputReader, LineReaderfrom pair import Pair, nil# Scheme list parserdef scheme_read(src): &quot;&quot;&quot;Read the next expression from SRC, a Buffer of tokens. &gt;&gt;&gt; scheme_read(Buffer(tokenize_lines([&#x27;nil&#x27;]))) nil &gt;&gt;&gt; scheme_read(Buffer(tokenize_lines([&#x27;1&#x27;]))) 1 &gt;&gt;&gt; scheme_read(Buffer(tokenize_lines([&#x27;true&#x27;]))) True &gt;&gt;&gt; scheme_read(Buffer(tokenize_lines([&#x27;(+ 1 2)&#x27;]))) Pair(&#x27;+&#x27;, Pair(1, Pair(2, nil))) &quot;&quot;&quot; if src.current is None: raise EOFError val = src.pop_first() # Get and remove the first token if val == &#x27;nil&#x27;: # BEGIN PROBLEM 2 return nil # END PROBLEM 2 elif val == &#x27;(&#x27;: # BEGIN PROBLEM 2 return read_tail(src) # END PROBLEM 2 elif val == &quot;&#x27;&quot;: # BEGIN PROBLEM 3 return Pair(&#x27;quote&#x27;, Pair(scheme_read(src), nil)) # END PROBLEM 3 elif val not in DELIMITERS: return val else: raise SyntaxError(&#x27;unexpected token: &#123;0&#125;&#x27;.format(val))def read_tail(src): &quot;&quot;&quot;Return the remainder of a list in SRC, starting before an element or ). &gt;&gt;&gt; read_tail(Buffer(tokenize_lines([&#x27;)&#x27;]))) nil &gt;&gt;&gt; read_tail(Buffer(tokenize_lines([&#x27;2 3)&#x27;]))) Pair(2, Pair(3, nil)) &quot;&quot;&quot; try: while src.end_of_line(): src.pop_first() if src.current is None: raise SyntaxError(&#x27;unexpected end of file&#x27;) elif src.current == &#x27;)&#x27;: # BEGIN PROBLEM 2 src.pop_first() return nil # END PROBLEM 2 else: # BEGIN PROBLEM 2 return Pair(scheme_read(src), read_tail(src)) # END PROBLEM 2 except EOFError: raise SyntaxError(&#x27;unexpected end of file&#x27;)# Convenience methodsdef buffer_input(prompt=&#x27;scm&gt; &#x27;): &quot;&quot;&quot;Return a Buffer instance containing interactive input.&quot;&quot;&quot; return Buffer(tokenize_lines(InputReader(prompt)))def buffer_lines(lines, prompt=&#x27;scm&gt; &#x27;, show_prompt=False): &quot;&quot;&quot;Return a Buffer instance iterating through LINES.&quot;&quot;&quot; if show_prompt: input_lines = lines else: input_lines = LineReader(lines, prompt) return Buffer(tokenize_lines(input_lines))def read_line(line): &quot;&quot;&quot;Read a single string LINE as a Scheme expression.&quot;&quot;&quot; buf = Buffer(tokenize_lines([line])) while buf.end_of_line(): buf.pop_first() result = scheme_read(buf) if not buf.end_of_line(): raise SyntaxError(&quot;read_line&#x27;s argument can only be a single element, but received multiple&quot;) return result# Interactive loopdef read_print_loop(): &quot;&quot;&quot;Run a read-print loop for Scheme expressions.&quot;&quot;&quot; while True: try: src = buffer_input(&#x27;read&gt; &#x27;) while src.end_of_line(): src.pop_first() while not src.end_of_line(): expression = scheme_read(src) if expression == &#x27;exit&#x27;: print() return print(&#x27;str :&#x27;, expression) print(&#x27;repr:&#x27;, repr(expression)) except (SyntaxError, ValueError) as err: print(type(err).__name__ + &#x27;:&#x27;, err) except (KeyboardInterrupt, EOFError): # &lt;Control&gt;-D, etc. print() return@maindef main(*args): if len(args) and &#x27;--repl&#x27; in args: read_print_loop() Submit Make sure to submit this assignment by running: 1python3 ok --submit","categories":[],"tags":[{"name":"CS61A","slug":"CS61A","permalink":"http://www.misaka-9982.com/tags/CS61A/"}]},{"title":"CS61A Homework 6","slug":"CS61A-Homework-6","date":"2022-07-30T05:29:52.000Z","updated":"2022-07-30T05:32:07.932Z","comments":true,"path":"2022/07/30/CS61A-Homework-6/","link":"","permalink":"http://www.misaka-9982.com/2022/07/30/CS61A-Homework-6/","excerpt":"","text":"Homework 6: Scheme, Scheme Lists hw06.zip Due by 11:59pm on Thursday, April 7 Instructions Download hw06.zip. Inside the archive, you will find a file called hw06.scm, along with a copy of the ok autograder. Submission: When you are done, submit with python3 ok --submit. You may submit more than once before the deadline; only the final submission will be scored. Check that you have successfully submitted your code on okpy.org. See Lab 0 for more instructions on submitting assignments. Using Ok: If you have any questions about using Ok, please refer to this guide. Readings: You might find the following references useful: Scheme Specification Scheme Built-in Procedure Reference Grading: Homework is graded based on correctness. Each incorrect problem will decrease the total score by one point. There is a homework recovery policy as stated in the syllabus. This homework is out of 2 points. Required Questions Getting Started Videos Code Writing Questions Q1: Thane of Cadr Define the procedures cadr and caddr, which return the second and third elements of a list, respectively. If you would like a quick refresher on scheme syntax consider looking at Lab 10 Scheme Refresher. 12345678910111213(define (cddr s) (cdr (cdr s)))(define (cadr s) &#x27;YOUR-CODE-HERE (car (cdr s)))(define (caddr s) &#x27;YOUR-CODE-HERE (car (cdr (cdr s)))) Use Ok to unlock and test your code: 12python3 ok -q cadr-caddr -upython3 ok -q cadr-caddr✂️ Q2: Ascending Implement a procedure called ascending?, which takes a list of numbers lst and returns True if the numbers are in nondescending order, and False otherwise. Numbers are considered nondescending if each subsequent number is either larger or equal to the previous, that is: 11 2 3 3 4 Is nondescending, but: 11 2 3 3 2 Is not. Hint: The built-in null? function returns whether its argument is nil. 1234567891011121314151617(define (ascending? lst) &#x27;YOUR-CODE-HERE (if (null? lst) #t (if (null? (cdr lst)) #t (if (&lt;= (car lst) (car (cdr lst)) ) (ascending? (cdr lst)) #f ) ) )) Use Ok to unlock and test your code: 12python3 ok -q ascending -upython3 ok -q ascending✂️ Q3: Interleave Implement the function interleave, which takes a two lists lst1 and lst2 as arguments. interleave should return a new list that interleaves the elements of the two lists. (In other words, the resulting list should contain elements alternating between lst1 and lst2.) If one of the input lists to interleave is shorter than the other, then interleave should alternate elements from both lists until one list has no more elements, and then the remaining elements from the longer list should be added to the end of the new list. 123456789(define (interleave lst1 lst2) &#x27;YOUR-CODE-HERE (if (null? lst1) lst2 (cons (car lst1) (interleave lst2 (cdr lst1)) ) )) Use Ok to unlock and test your code: 12python3 ok -q interleave -upython3 ok -q interleave✂️ Q4: My Filter Write a procedure my-filter, which takes a predicate func and a list lst, and returns a new list containing only elements of the list that satisfy the predicate. The output should contain the elements in the same order that they appeared in the original list. Note: Make sure that you are not just calling the built-in filter function in Scheme - we are asking you to re-implement this! 123456789101112(define (my-filter func lst) &#x27;YOUR-CODE-HERE (if (null? lst) lst (if (func (car lst)) (cons (car lst) (my-filter func (cdr lst)) ) (my-filter func (cdr lst)) ) )) Use Ok to unlock and test your code: 12python3 ok -q filter -upython3 ok -q filter✂️ Q5: No Repeats Implement no-repeats, which takes a list of numbers lst as input and returns a list that has all of the unique elements of lst in the order that they first appear, but no repeats. For example, (no-repeats (list 5 4 5 4 2 2)) evaluates to (5 4 2). Hint: How can you make the first time you see an element in the input list be the first and only time you see the element in the resulting list you return? Hint: You may find it helpful to use the my-filter procedure with a helper lambda function to use as a filter. To test if two numbers are equal, use the = procedure. To test if two numbers are not equal, use the not procedure in combination with =. 1234567891011121314151617181920212223(define (no-repeats lst) &#x27;YOUR-CODE-HERE (define (member item items) (if (null? items) #f (if (equal? item (car items)) #t (member item (cdr items)) ) ) ) (if (null? lst) lst (if (member (car lst) (cdr lst)) (no-repeats (cdr lst)) (cons (car lst) (no-repeats (cdr lst)) ) ) )) Use Ok to unlock and test your code: 12python3 ok -q no_repeats -upython3 ok -q no_repeats✂️","categories":[],"tags":[{"name":"CS61A","slug":"CS61A","permalink":"http://www.misaka-9982.com/tags/CS61A/"}]},{"title":"CS61A Lab 10","slug":"CS61A-Lab-10","date":"2022-07-30T05:26:09.000Z","updated":"2022-07-30T05:29:18.284Z","comments":true,"path":"2022/07/30/CS61A-Lab-10/","link":"","permalink":"http://www.misaka-9982.com/2022/07/30/CS61A-Lab-10/","excerpt":"","text":"Lab 10: Scheme lab10.zip Due by 11:59pm on Wednesday, March 30. Starter Files Download lab10.zip. Inside the archive, you will find starter files for the questions in this lab, along with a copy of the Ok autograder. Topics Consult this section if you need a refresher on the material for this lab. It’s okay to skip directly to the questions and refer back here should you get stuck. Scheme Scheme is a famous functional programming language from the 1970s. It is a dialect of Lisp (which stands for LISt Processing). The first observation most people make is the unique syntax, which uses a prefix notation and (often many) nested parentheses (see http://xkcd.com/297/). Scheme features first-class functions and optimized tail-recursion, which were relatively new features at the time. Our course uses a custom version of Scheme (which you will build for Project 4) included in the starter ZIP archive. To start the interpreter, type python3 scheme. To run a Scheme program interactively, type python3 scheme -i &lt;file.scm&gt;. To exit the Scheme interpreter, type (exit). You may find it useful to try code.cs61a.org/scheme when working through problems, as it can draw environment and box-and-pointer diagrams and it lets you walk your code step-by-step (similar to Python Tutor). Don’t forget to submit your code through Ok though! Scheme Editor As you’re writing your code, you can debug using the Scheme Editor. In your scheme folder you will find a new editor. To run this editor, run python3 editor. This should pop up a window in your browser; if it does not, please navigate to localhost:31415 and you should see it. Make sure to run python3 ok in a separate tab or window so that the editor keeps running. If you find that your code works in the online editor but not in your own interpreter, it’s possible you have a bug in code from an earlier part that you’ll have to track down. Every once in a while there’s a bug that our tests don’t catch, and if you find one you should let us know! Expressions Primitive Expressions Call Expressions Special Forms Control Structures If Expressions Cond Expressions Defining Names Define Form Lambda Functions Lambda Functions Required Questions What Would Scheme Display? Q1: Combinations Let’s familiarize ourselves with some built-in Scheme procedures and special forms! Use Ok to unlock the following “What would Scheme print?” questions: 1python3 ok -q combinations -u 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124$ python3 ok -q combinations -u=====================================================================Assignment: Lab 10OK, version v1.18.1=====================================================================~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Unlocking testsAt each &quot;? &quot;, type what you would expect the output to be.Type exit() to quit---------------------------------------------------------------------What Would Scheme Display? &gt; Suite 1 &gt; Case 1(cases remaining: 4)scm&gt; (- 10 4)? 6-- OK! --scm&gt; (* 7 6)? 42-- OK! --scm&gt; (+ 1 2 3 4)? 10-- OK! --scm&gt; (/ 8 2 2)? 2-- OK! --scm&gt; (quotient 29 5)? 5-- OK! --scm&gt; (modulo 29 5)? 4-- OK! -----------------------------------------------------------------------What Would Scheme Display? &gt; Suite 1 &gt; Case 2(cases remaining: 3)scm&gt; (= 1 3) ; Scheme uses &#x27;=&#x27; instead of &#x27;==&#x27; for comparison? #f-- OK! --scm&gt; (&lt; 1 3)? #t-- OK! --scm&gt; (or 1 #t) ; or special form short circuits? 1-- OK! --scm&gt; (and #t #f (/ 1 0))? #f-- OK! --scm&gt; (not #t)? #f-- OK! -----------------------------------------------------------------------What Would Scheme Display? &gt; Suite 1 &gt; Case 3(cases remaining: 2)scm&gt; (define x 3)? x-- OK! --scm&gt; x? 3-- OK! --scm&gt; (define y (+ x 4))? y-- OK! --scm&gt; y? 7-- OK! --scm&gt; (define x (lambda (y) (* y 2)))? x-- OK! --scm&gt; (x y)? 14-- OK! -----------------------------------------------------------------------What Would Scheme Display? &gt; Suite 1 &gt; Case 4(cases remaining: 1)scm&gt; (if (not (print 1)) (print 2) (print 3))(line 1)? 1(line 2)? 3-- OK! --scm&gt; (* (if (&gt; 3 2) 1 2) (+ 4 5))? 9-- OK! --scm&gt; (define foo (lambda (x y z) (if x y z)))? foo-- OK! --scm&gt; (foo 1 2 (print &#x27;hi))(line 1)? hi(line 2)? 2-- OK! --scm&gt; ((lambda (a) (print &#x27;a)) 100)? a-- OK! -----------------------------------------------------------------------OK! All cases for What Would Scheme Display? unlocked. Coding Questions Q2: Over or Under Define a procedure over-or-under which takes in a number num1 and a number num2 and returns the following: -1 if num1 is less than num2 0 if num1 is equal to num2 1 if num1 is greater than num2 Challenge: Implement this in 2 different ways using if and cond! 123456(define (over-or-under num1 num2) &#x27;YOUR-CODE-HERE (cond ((&lt; num1 num2) -1) ((&gt; num1 num2) 1) ((= num1 num2) 0))) Use Ok to test your code: 1python3 ok -q over_or_under✂️ Q3: Make Adder Write the procedure make-adder which takes in an initial number, num, and then returns a procedure. This returned procedure takes in a number inc and returns the result of num + inc. Hint: To return a procedure, you can either return a lambda expression or define another nested procedure. Remember that Scheme will automatically return the last clause in your procedure. You can find documentation on the syntax of lambda expressions in the 61A scheme specification! 12345(define (make-adder num) &#x27;YOUR-CODE-HERE (lambda (x) (+ x num))) Use Ok to test your code: 1python3 ok -q make_adder✂️ Q4: Compose Write the procedure composed, which takes in procedures f and g and outputs a new procedure. This new procedure takes in a number x and outputs the result of calling f on g of x. 1234(define (composed f g) &#x27;YOUR-CODE-HERE (lambda (x) (f (g x))) ) Use Ok to test your code: 1python3 ok -q composed✂️ Q5: Pow Implement a procedure pow for raising the number base to the power of a nonnegative integer exp for which the number of operations grows logarithmically, rather than linearly (the number of recursive calls should be much smaller than the input exp). For example, for (pow 2 32) should take 5 recursive calls rather than 32 recursive calls. Similarly, (pow 2 64) should take 6 recursive calls. Hint: Consider the following observations: x2y = (xy)2 x2y+1 = x(xy)2 For example we see that 232 is (216)2, 216 is (28)2, etc. You may use the built-in predicates even? and odd?. Scheme doesn’t support iteration in the same manner as Python, so consider another way to solve this problem. 123456789101112131415161718192021222324(define (pow base exp) &#x27;YOUR-CODE-HERE (cond ((= exp 0) 1) ((= exp 1) base) ((= exp 2) (square base)) ((= base 1) 1) (else (cond ((even? exp) (square (pow base (/ exp 2))) ) (else (* (square (pow base (/ (- exp 1) 2)) ) base ) ) ) ) )) Use Ok to unlock and test your code: 12python3 ok -q pow -upython3 ok -q pow✂️ Submit Make sure to submit this assignment by running: 1python3 ok --submit","categories":[],"tags":[{"name":"CS61A","slug":"CS61A","permalink":"http://www.misaka-9982.com/tags/CS61A/"}]},{"title":"CS61A","slug":"CS61A","date":"2022-07-30T03:45:00.000Z","updated":"2022-07-30T05:49:09.301Z","comments":true,"path":"2022/07/30/CS61A/","link":"","permalink":"http://www.misaka-9982.com/2022/07/30/CS61A/","excerpt":"","text":"近期比较忙，CS61A的Lab和Homework都已经写完了，Project除了Scheme的挑战版和Ant写了一半其他几个也写完了，往后再找时间复盘一下CS61A吧 Info CS61A 年份版本 : 2022 Spring 我的GitHub仓库：https://github.com/Misaka-9982-coder/CS61A 官网地址: https://inst.eecs.berkeley.edu/~cs61a/sp22/ 可供参考的Github仓库： fobiddengame：https://github.com/fobiddengame/CS61A-2022 caiscoding：https://caiscoding.github.io/CS61A-Spring2022/ Homeworks Homework 1: Variables &amp; Functions, Control Homework 2: Higher Order Functions Homework 3: Recursion, Tree Recursion Homework 4: Python Lists, Object-Oriented Programming Homework 5: Trees, Linked Lists Homework 6: Scheme, Scheme Lists Homework 7: Scheme Data Abstractions, Programs as Data Homework 8: Regular Expressions, BNF Homework 9: Finale Labs Lab 0: Getting Started Lab 1: Variables &amp; Functions, Control Lab 2: Higher-Order Functions, Lambda Expressions Lab 4: Recursion, Tree Recursion Lab 5: Python Lists, Mutability Lab 6: Object-Oriented Programming Lab 7: Linked Lists, Trees / Tree Mutation Lab 8: Midterm Review Lab 10: Scheme Lab 11: Interpreters Lab 12: Scheme Data Abstraction Lab 13: Regular Expressions Lab 14: Final Review Projects Project 0: (Extra Credit) Magic: the Lambda-ing Project 1: The Game of Hog Project 2: CS 61A Autocorrected Typing Software Project 3: Ants Vs. SomeBees Project 4: Scheme Interpreter Project 4: Scheme Interpreter (Challenge Version) Optional Contest: Scheme Art Scheme Art Gallery","categories":[],"tags":[{"name":"CS61A","slug":"CS61A","permalink":"http://www.misaka-9982.com/tags/CS61A/"}]},{"title":"CS61A Proj 0","slug":"CS61A-Proj-0","date":"2022-07-23T05:35:16.000Z","updated":"2022-07-30T04:10:27.979Z","comments":true,"path":"2022/07/23/CS61A-Proj-0/","link":"","permalink":"http://www.misaka-9982.com/2022/07/23/CS61A-Proj-0/","excerpt":"","text":"Project 0: (Extra Credit) Magic: the Lambda-ing lambdaing.zip My Professor’s deck doesn’t have pathetic cards. But it does have this! Introduction Note: This project is an optional extra credit opportunity. The goals of this are to practice object oriented programming as well as to try implementing a shorter game than some of the other projects in the course. You can get 2 bonus points by submitting the entire project by Friday, April 1. Download starter files To get started, download all of the project code as a zip archive. About the Game In this project, we will be implementing a card game! This game is inspired by the similarly named Magic: The Gathering. Rules of the Game This game is a little involved, though not nearly as much as its namesake. Here’s how it goes: There are two players. Each player has a hand of cards and a deck, and at the start of each round, each player draws a random card from their deck. If a player’s deck is empty when they try to draw, they will automatically lose the game. Cards have a name, an attack value, and a defense value. Each round, each player chooses one card to play from their own hands. Once both players have chosen a card, the cards’ power stats are then calculated and compared. The card with the higher power wins the round. Each played card’s power value is calculated as follows: 1(player card&#x27;s attack) - (opponent card&#x27;s defense) For example, let’s say Player 1 plays a card with 2000 attack and 1000 defense and Player 2 plays a card with 1500 attack and 3000 defense. Their cards’ powers are calculated as: 12P1: 2000 - 3000 = 2000 - 3000 = -1000P2: 1500 - 1000 = 1500 - 1000 = 500 So Player 2 would win this round. The first player to win 8 rounds wins the match! Special Effects To make the game more interesting, we will add special effects to our cards. A card can be of type AI, Tutor, TA, or Instructor, and each type has a different effect when they are played. All effects are applied before power is calculated during that round: An AI card will allow you to add the top two cards of your deck to your hand via drawing. A Tutor card will add a copy of the first card in your hand to your hand, at the cost of losing the current round. A TA card discards the card with the highest power in your hand, and add the discarded card’s attack and defense to its own respective stats. An Instructor card can survive multiple rounds, as long as it has a non-negative power. However, at the beginning of the round, its attack and defense are reduced by 1000 each. This game uses several different files. Code for all questions can be found in classes.py. The game loop can be found in cardgame.py, and is responsible for running the game. You won’t need to open or read this file to receive full credit. If you want to modify your game later to add your own custom cards and decks, you can look in cards.py to see all the standard cards and the default deck; here, you can add more cards and change what decks you and your opponent use. If you’re familiar with the original game, you may notice the cards were not created with balance in mind, so feel free to modify the stats and add or remove cards as desired. Once you’ve implemented the game, you can start it by typing: 1python3 cardgame.py While playing the game, you can exit it and return to the command line with Ctrl-C or Ctrl-D. Feel free to refer back to these series of rules later on, and let’s start making the game! Logistics The project is worth 2 extra credit points based on correctness. You will turn in the following files: classes.py You do not need to modify or turn in any other files to complete the project. To submit the project, run the following command: 1python3 ok --submit You will be able to view your submissions on the Ok dashboard. For the functions that we ask you to complete, there may be some initial code that we provide. If you would rather not use that code, feel free to delete it and start from scratch. You may also add new function definitions as you see fit. However, please do not modify any other functions or edit any files not listed above. Doing so may result in your code failing our autograder tests. Also, please do not change any function signatures (names, argument order, or number of arguments). Throughout this project, you should be testing the correctness of your code. It is good practice to test often, so that it is easy to isolate any problems. However, you should not be testing too often, to allow yourself time to think through problems. We have provided an autograder called ok to help you with testing your code and tracking your progress. The first time you run the autograder, you will be asked to log in with your Ok account using your web browser. Please do so. Each time you run ok, it will back up your work and progress on our servers. The primary purpose of ok is to test your implementations. We recommend that you submit after you finish each problem. Only your last submission will be graded. It is also useful for us to have more backups of your code in case you run into a submission issue. If you forget to submit, your last backup will be automatically converted to a submission. If you do not want us to record a backup of your work or information about your progress, you can run 1python3 ok --local With this option, no information will be sent to our course servers. If you want to test your code interactively, you can run 1python3 ok -q [question number] -i with the appropriate question number (e.g. 01) inserted. This will run the tests for that question until the first one you failed, then give you a chance to test the functions you wrote interactively. You can also use the debugging print feature in OK by writing 1print(&quot;DEBUG:&quot;, x) which will produce an output in your terminal without causing OK tests to fail with extra output. Part 1: Basic Game Before attempting any of the following questions, be sure to look at the Deck class included at the bottom of classes.py. A central mechanic of the game is manipulating the player’s deck of available cards; many methods of the Deck class will prove to be useful throughout the project. Q1: Making Cards To play a card game, we’re going to need to have cards, so let’s make some! We’re gonna implement the basics of the Card class first. First, implement the Card class constructor in classes.py. This constructor takes three arguments: a string as the name of the card an integer as the attack value of the card an integer as the defense value of the card Each Card instance should keep track of these values using instance attributes called name, attack, and defense. You should also implement the power method in Card, which takes in another card as an input and calculates the current card’s power. Refer to the Rules of the Game if you’d like a refresher on how power is calculated. Use Ok to test your code: 12python3 ok -q Card.__init__python3 ok -q Card.power✂️ For this mini-project, we provide doctests to incrementally test your code; note that the Part 1’s questions will be considered together under a different ok test, which is included at the end of the section. Q2: Making a Player Now that we have cards, we can make a deck, but we still need players to actually use them. We’ll now fill in the implementation of the Player class. A Player instance has three instance attributes: name is the player’s name. When you play the game, you can enter your name, which will be converted into a string to be passed to the constructor. deck is an instance of the Deck class. You can draw from it using its .draw() method. hand is a list of Card instances. Each player should start with 5 cards in their hand, drawn from their deck. Each card in the hand can be selected by its index in the list during the game. When a player draws a new card from the deck, it is added to the end of this list. Complete the implementation of the constructor for Player so that self.hand is set to a list of 5 cards drawn from the player’s deck. Next, implement the draw and play methods in the Player class. The draw method draws a card from the deck and adds it to the player’s hand. The play method removes and returns a card from the player’s hand at the given index. Hint: use class methods wherever possible when attempting to draw from the deck when implementing Player.__init__ and Player.draw. Use Ok to test your code: 123python3 ok -q Player.__init__python3 ok -q Player.drawpython3 ok -q Player.play✂️ For this mini-project, we provide doctests to incrementally test your code; note that the Part 1’s questions will be considered together under a different ok test, which is included at the end of the section. After you complete this problem, you have finished Part 1, and you’ll be able to play a working version of the game! Use Ok to test your code: 1python3 ok -q 01✂️ Additionally, type: 1python3 cardgame.py to start a game of Magic: The Lambda-ing! This version doesn’t have the effects for different cards yet. In the next part, we’ll be implementing effects for the various cards. Part 2: Card Effects To make the card game more interesting, let’s add effects to our cards! We can do this by implementing an effect function for each card class, which takes in the opponent card, the current player, and the opponent player. You can find the following questions in classes.py. Important: For the following sections, do not overwrite any lines denoted under You should add your implementation above this. In addition, there are pre-designated variables in certain effect methods which are used to determine when to print text. Be sure to set the variables to the correct values in your implementation, such that the text is printed when the effect occurs. Q3: AIs: Resourceful Resources In the AICard class, implement the effect method for AIs. An AICard will allow you to add the top two cards of your deck to your hand via drawing from your deck. Use Ok to test your code: 1python3 ok -q AICard.effect✂️ For this mini-project, we provide doctests to incrementally test your code; note that the Part 2’s questions will be considered together under a different ok test, which is included at the end of the section. Q4: Tutors: Sneaky Search In the TutorCard class, implement the effect method for Tutors. A TutorCard will add a copy of the first card in your hand to your hand, at the cost of losing the current round. Note that if there are no cards in hand, a TutorCard will not add any cards to the hand, but must still lose the round. To implement the “losing” functionality, it is sufficient to override TutorCard’s power method to return -float('inf'). In addition, be sure to add copies of cards, instead of the chosen card itself! Class methods may come in handy. Use Ok to test your code: 1python3 ok -q TutorCard.effect✂️ For this mini-project, we provide doctests to incrementally test your code; note that the Part 2’s questions will be considered together under a different ok test, which is included at the end of the section. Q5: TAs: Power Transfer In the TACard class, implement the effect method for TAs. A TACard discards the card with the highest power in your hand, and add the discarded card’s attack and defense to its own respective stats. Discarding a card removes the card from your hand. If there are no cards in hand, the TACard should not do anything for its effect. Use Ok to test your code: 1python3 ok -q TACard.effect✂️ For this mini-project, we provide doctests to incrementally test your code; note that the Part 2’s questions will be considered together under a different ok test, which is included at the end of the section. Q6: Instructors: Immovable In the InstructorCard class, implement the effect method for Instructors. An InstructorCard can survive multiple rounds, as long as it has a non-negative attack or defense at the end of a round. However, at the beginning of the round, its attack and defense are permanently reduced by 1000 each. To implement the “survive” functionality, the InstructorCard should re-add itself to the player’s hand. Use Ok to test your code: 1python3 ok -q InstructorCard.effect✂️ For this mini-project, we provide doctests to incrementally test your code; note that the Part 2’s questions will be considered together under a different ok test, which is included at the end of the section. After you complete this problem, you’ll have a fully functional game of Magic: The Lambda-ing! Use Ok to test your code: 1python3 ok -q 02✂️ Additionally, type: 1python3 cardgame.py to start a game. This doesn’t have to be the end, though; we encourage you to get creative with more card types, effects, and even adding more custom cards to your deck! Submit Make sure to submit this assignment by running: 1python3 ok --submit Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409# Magic the Lambda-ing!import randomclass Card: cardtype = &#x27;Staff&#x27; def __init__(self, name, attack, defense): &quot;&quot;&quot; Create a Card object with a name, attack, and defense. &gt;&gt;&gt; staff_member = Card(&#x27;staff&#x27;, 400, 300) &gt;&gt;&gt; staff_member.name &#x27;staff&#x27; &gt;&gt;&gt; staff_member.attack 400 &gt;&gt;&gt; staff_member.defense 300 &gt;&gt;&gt; other_staff = Card(&#x27;other&#x27;, 300, 500) &gt;&gt;&gt; other_staff.attack 300 &gt;&gt;&gt; other_staff.defense 500 &quot;&quot;&quot; # BEGIN Problem 1 self.name = name self.attack = attack self.defense = defense # END Problem 1 def power(self, opponent_card): &quot;&quot;&quot; Calculate power as: (player card&#x27;s attack) - (opponent card&#x27;s defense) &gt;&gt;&gt; staff_member = Card(&#x27;staff&#x27;, 400, 300) &gt;&gt;&gt; other_staff = Card(&#x27;other&#x27;, 300, 500) &gt;&gt;&gt; staff_member.power(other_staff) -100 &gt;&gt;&gt; other_staff.power(staff_member) 0 &gt;&gt;&gt; third_card = Card(&#x27;third&#x27;, 200, 400) &gt;&gt;&gt; staff_member.power(third_card) 0 &gt;&gt;&gt; third_card.power(staff_member) -100 &quot;&quot;&quot; # BEGIN Problem 1 return self.attack - opponent_card.defense # END Problem 1 def effect(self, opponent_card, player, opponent): &quot;&quot;&quot; Cards have no default effect. &quot;&quot;&quot; return def __repr__(self): &quot;&quot;&quot; Returns a string which is a readable version of a card, in the form: &lt;cardname&gt;: &lt;cardtype&gt;, [&lt;attack&gt;, &lt;defense&gt;] &quot;&quot;&quot; return &#x27;&#123;&#125;: &#123;&#125;, [&#123;&#125;, &#123;&#125;]&#x27;.format(self.name, self.cardtype, self.attack, self.defense) def copy(self): &quot;&quot;&quot; Returns a copy of this card. &quot;&quot;&quot; return Card(self.name, self.attack, self.defense)class Player: def __init__(self, deck, name): &quot;&quot;&quot;Initialize a Player object. A Player starts the game by drawing 5 cards from their deck. Each turn, a Player draws another card from the deck and chooses one to play. &gt;&gt;&gt; test_card = Card(&#x27;test&#x27;, 100, 100) &gt;&gt;&gt; test_deck = Deck([test_card.copy() for _ in range(6)]) &gt;&gt;&gt; test_player = Player(test_deck, &#x27;tester&#x27;) &gt;&gt;&gt; len(test_deck.cards) 1 &gt;&gt;&gt; len(test_player.hand) 5 &quot;&quot;&quot; self.deck = deck self.name = name self.hand = [] # BEGIN Problem 2 for _ in range(5): self.hand.append(self.deck.draw()) # END Problem 2 def draw(self): &quot;&quot;&quot;Draw a card from the player&#x27;s deck and add it to their hand. &gt;&gt;&gt; test_card = Card(&#x27;test&#x27;, 100, 100) &gt;&gt;&gt; test_deck = Deck([test_card.copy() for _ in range(6)]) &gt;&gt;&gt; test_player = Player(test_deck, &#x27;tester&#x27;) &gt;&gt;&gt; test_player.draw() &gt;&gt;&gt; len(test_deck.cards) 0 &gt;&gt;&gt; len(test_player.hand) 6 &quot;&quot;&quot; assert not self.deck.is_empty(), &#x27;Deck is empty!&#x27; # BEGIN Problem 2 self.hand.append(self.deck.draw()) # END Problem 2 def play(self, index): &quot;&quot;&quot;Remove and return a card from the player&#x27;s hand at the given INDEX. &gt;&gt;&gt; from cards import * &gt;&gt;&gt; test_player = Player(standard_deck, &#x27;tester&#x27;) &gt;&gt;&gt; ta1, ta2 = TACard(&quot;ta_1&quot;, 300, 400), TACard(&quot;ta_2&quot;, 500, 600) &gt;&gt;&gt; tutor1, tutor2 = TutorCard(&quot;t1&quot;, 200, 500), TutorCard(&quot;t2&quot;, 600, 400) &gt;&gt;&gt; test_player.hand = [ta1, ta2, tutor1, tutor2] &gt;&gt;&gt; test_player.play(0) is ta1 True &gt;&gt;&gt; test_player.play(2) is tutor2 True &gt;&gt;&gt; len(test_player.hand) 2 &quot;&quot;&quot; # BEGIN Problem 2 tmp = self.hand[index] self.hand.remove(self.hand[index]) return tmp # END Problem 2 def display_hand(self): &quot;&quot;&quot; Display the player&#x27;s current hand to the user. &quot;&quot;&quot; print(&#x27;Your hand:&#x27;) for card_index, displayed_card in zip(range(len(self.hand)), [str(card) for card in self.hand]): indent = &#x27; &#x27; * (5 - len(str(card_index))) print(card_index, indent + displayed_card) def play_random(self): &quot;&quot;&quot; Play a random card from hand. &quot;&quot;&quot; return self.play(random.randrange(len(self.hand)))class AICard(Card): cardtype = &#x27;AI&#x27; def effect(self, opponent_card, player, opponent): &quot;&quot;&quot; Add the top two cards of your deck to your hand via drawing. &gt;&gt;&gt; from cards import * &gt;&gt;&gt; player1, player2 = Player(player_deck, &#x27;p1&#x27;), Player(opponent_deck, &#x27;p2&#x27;) &gt;&gt;&gt; opponent_card = Card(&quot;other&quot;, 500, 500) &gt;&gt;&gt; test_card = AICard(&quot;AI Card&quot;, 500, 500) &gt;&gt;&gt; initial_deck_length = len(player1.deck.cards) &gt;&gt;&gt; initial_hand_size = len(player1.hand) &gt;&gt;&gt; test_card.effect(opponent_card, player1, player2) AI Card allows me to draw two cards! &gt;&gt;&gt; initial_hand_size == len(player1.hand) - 2 True &gt;&gt;&gt; initial_deck_length == len(player1.deck.cards) + 2 True &quot;&quot;&quot; # BEGIN Problem 3 player.draw() player.draw() # END Problem 3 # You should add your implementation above this. print(f&quot;&#123;self.name&#125; allows me to draw two cards!&quot;) def copy(self): &quot;&quot;&quot; Create a copy of this card. &quot;&quot;&quot; return AICard(self.name, self.attack, self.defense)class TutorCard(Card): cardtype = &#x27;Tutor&#x27; def power(self, opponent_card): &quot;&quot;&quot; Power is the same as original card. &quot;&quot;&quot; return -float(&#x27;inf&#x27;) def effect(self, opponent_card, player, opponent): &quot;&quot;&quot; Add a copy of the first card in your hand to your hand, at the cost of losing the current round. If there are no cards in hand, this card does not add any cards, but still loses the round. To implement the second part of this effect, a Tutor card&#x27;s power should be less than all non-Tutor cards. &gt;&gt;&gt; from cards import * &gt;&gt;&gt; player1, player2 = Player(player_deck, &#x27;p1&#x27;), Player(opponent_deck, &#x27;p2&#x27;) &gt;&gt;&gt; opponent_card = Card(&quot;other&quot;, 500, 500) &gt;&gt;&gt; test_card = TutorCard(&quot;Tutor Card&quot;, 10000, 10000) &gt;&gt;&gt; player1.hand = [Card(&quot;card1&quot;, 0, 100), Card(&quot;card2&quot;, 100, 0)] &gt;&gt;&gt; test_card.effect(opponent_card, player1, player2) Tutor Card allows me to add a copy of a card to my hand! &gt;&gt;&gt; print(player1.hand) [card1: Staff, [0, 100], card2: Staff, [100, 0], card1: Staff, [0, 100]] &gt;&gt;&gt; player1.hand[0] is player1.hand[2] # must add a copy! False &gt;&gt;&gt; player1.hand = [] &gt;&gt;&gt; test_card.effect(opponent_card, player1, player2) &gt;&gt;&gt; print(player1.hand) # must not add a card if not available [] &gt;&gt;&gt; test_card.power(opponent_card) &lt; opponent_card.power(test_card) True &quot;&quot;&quot; # BEGIN Problem 4 added = player.hand[0] if len(player.hand) &gt; 0 else None if added: player.hand.append(added.copy()) # END Problem 4 # You should add your implementation above this. if added: print(f&quot;&#123;self.name&#125; allows me to add a copy of a card to my hand!&quot;) def copy(self): &quot;&quot;&quot; Create a copy of this card. &quot;&quot;&quot; return TutorCard(self.name, self.attack, self.defense)class TACard(Card): cardtype = &#x27;TA&#x27; def effect(self, opponent_card, player, opponent, arg=None): &quot;&quot;&quot; Discard the card with the highest `power` in your hand, and add the discarded card&#x27;s attack and defense to this card&#x27;s own respective stats. &gt;&gt;&gt; from cards import * &gt;&gt;&gt; player1, player2 = Player(player_deck, &#x27;p1&#x27;), Player(opponent_deck, &#x27;p2&#x27;) &gt;&gt;&gt; opponent_card = Card(&quot;other&quot;, 500, 500) &gt;&gt;&gt; test_card = TACard(&quot;TA Card&quot;, 500, 500) &gt;&gt;&gt; player1.hand = [] &gt;&gt;&gt; test_card.effect(opponent_card, player1, player2) # if no cards in hand, no effect. &gt;&gt;&gt; print(test_card.attack, test_card.defense) 500 500 &gt;&gt;&gt; player1.hand = [Card(&quot;card1&quot;, 0, 100), TutorCard(&quot;tutor&quot;, 10000, 10000), Card(&quot;card3&quot;, 100, 0)] &gt;&gt;&gt; test_card.effect(opponent_card, player1, player2) # must use card&#x27;s power method. TA Card discards card3 from my hand to increase its own power! &gt;&gt;&gt; print(player1.hand) [card1: Staff, [0, 100], tutor: Tutor, [10000, 10000]] &gt;&gt;&gt; print(test_card.attack, test_card.defense) 600 500 &quot;&quot;&quot; # BEGIN Problem 5 best_card = None for card in player.hand: if best_card is None or card.power(opponent_card) &gt; best_card.power(opponent_card): best_card = card if best_card: player.hand.remove(best_card) self.attack += best_card.attack # END Problem 5 if best_card: print(f&quot;&#123;self.name&#125; discards &#123;best_card.name&#125; from my hand to increase its own power!&quot;) def copy(self): &quot;&quot;&quot; Create a copy of this card. &quot;&quot;&quot; return TACard(self.name, self.attack, self.defense)class InstructorCard(Card): cardtype = &#x27;Instructor&#x27; def effect(self, opponent_card, player, opponent, arg=None): &quot;&quot;&quot; Survives multiple rounds, as long as it has a non-negative attack or defense at the end of a round. At the beginning of the round, its attack and defense are permanently reduced by 1000 each. If this card would survive, it is added back to the hand. &gt;&gt;&gt; from cards import * &gt;&gt;&gt; player1, player2 = Player(player_deck, &#x27;p1&#x27;), Player(opponent_deck, &#x27;p2&#x27;) &gt;&gt;&gt; opponent_card = Card(&quot;other&quot;, 500, 500) &gt;&gt;&gt; test_card = InstructorCard(&quot;Instructor Card&quot;, 1000, 1000) &gt;&gt;&gt; player1.hand = [Card(&quot;card1&quot;, 0, 100)] &gt;&gt;&gt; test_card.effect(opponent_card, player1, player2) Instructor Card returns to my hand! &gt;&gt;&gt; print(player1.hand) # survives with non-negative attack [card1: Staff, [0, 100], Instructor Card: Instructor, [0, 0]] &gt;&gt;&gt; player1.hand = [Card(&quot;card1&quot;, 0, 100)] &gt;&gt;&gt; test_card.effect(opponent_card, player1, player2) &gt;&gt;&gt; print(player1.hand) [card1: Staff, [0, 100]] &gt;&gt;&gt; print(test_card.attack, test_card.defense) -1000 -1000 &quot;&quot;&quot; # BEGIN Problem 6 readd = None self.attack -= 1000 self.defense -= 1000 if self.attack &gt;= 0 and self.defense &gt;= 0: readd = self.copy() if readd: player.hand.append(readd) # END Problem 6 # You should add your implementation above this. if readd: print(f&quot;&#123;self.name&#125; returns to my hand!&quot;) def copy(self): return InstructorCard(self.name, self.attack, self.defense)######################################### Do not edit anything below this line #########################################class Deck: def __init__(self, cards): &quot;&quot;&quot; With a list of cards as input, create a deck. This deck should keep track of the cards it contains, and we should be able to draw from the deck, taking a random card out of it. &quot;&quot;&quot; self.cards = cards def draw(self): &quot;&quot;&quot; Draw a random card and remove it from the deck. &quot;&quot;&quot; assert self.cards, &#x27;The deck is empty!&#x27; rand_index = random.randrange(len(self.cards)) return self.cards.pop(rand_index) def is_empty(self): return len(self.cards) == 0 def copy(self): &quot;&quot;&quot; Create a copy of this deck. &quot;&quot;&quot; return Deck([card.copy() for card in self.cards])class Game: win_score = 8 def __init__(self, player1, player2): &quot;&quot;&quot; Initialize a game of &lt;REPLACE NAME&gt;. &quot;&quot;&quot; self.player1, self.player2 = player1, player2 self.p1_score = 0 self.p2_score = 0 def play_round(self, p1_card, p2_card): &quot;&quot;&quot; After each player picks a card, play them against each other. &quot;&quot;&quot; p1_card.effect(p2_card, self.player1, self.player2) p2_card.effect(p1_card, self.player2, self.player1) p1_power = p1_card.power(p2_card) p2_power = p2_card.power(p1_card) if p1_power &gt; p2_power: # Player 1 wins the round. self.p1_score += 1 result = &#x27;won&#x27; elif p2_power &gt; p1_power: # Player 2 wins the round. self.p2_score += 1 result = &#x27;lost&#x27; else: # This round is a draw. result = &#x27;tied&#x27; # Display results to user. print(&#x27;You &#123;&#125; this round!&#x27;.format(result)) print(&#x27;&#123;&#125;\\&#x27;s card: &#123;&#125;; Power: &#123;&#125;&#x27;.format(self.player1.name, p1_card, p1_power)) print(&#x27;Opponent\\&#x27;s card: &#123;&#125;; Power: &#123;&#125;&#x27;.format(p2_card, p2_power)) def game_won(self): &quot;&quot;&quot; Check if the game is won and, if so, which player won. &quot;&quot;&quot; if self.p1_score &lt; self.win_score and self.p2_score &lt; self.win_score: return 0 return 1 if self.p1_score &gt; self.p2_score else 2 def display_scores(self): &quot;&quot;&quot; Display players&#x27; scores to the user. &quot;&quot;&quot; print(&#x27;&#123;&#125;\\&#x27;s score: &#123;&#125;&#x27;.format(self.player1.name, self.p1_score)) print(&#x27;Opponent\\&#x27;s score: &#123;&#125;&#x27;.format(self.p2_score))","categories":[],"tags":[{"name":"CS61A","slug":"CS61A","permalink":"http://www.misaka-9982.com/tags/CS61A/"}]},{"title":"CS61BL","slug":"CS61BL","date":"2022-07-02T14:39:43.000Z","updated":"2022-07-11T12:22:07.876Z","comments":true,"path":"2022/07/02/CS61BL/","link":"","permalink":"http://www.misaka-9982.com/2022/07/02/CS61BL/","excerpt":"","text":"Lab01: Java and Git Exercise: Leap Year 1234public static boolean isLeapYear(int year) &#123; // TODO: Fill in this method. return year % 400 == 0 || (year % 4 == 0 &amp;&amp; year % 100 != 0);&#125; Proj0: 2048 This constructor should create a board of size size and set the instance variables for the start of the game. This constructor creates a new instance of the game with a Board state that reflects the given rawValues array. 1234567891011121314151617/** A new 2048 game on a board of size SIZE with no pieces * and score 0. */public Model(int size) &#123; // TODO: Fill in this constructor. this._board = new Board(size);&#125;/** A new 2048 game where RAWVALUES contain the values of the tiles * (0 if null). VALUES is indexed by (row, col) with (0, 0) corresponding * to the bottom-left corner. Used for testing purposes. */public Model(int[][] rawValues, int score, int maxScore, boolean gameOver) &#123; // TODO: Fill in this constructor. this._board = new Board(rawValues, score); this._score = score; this._maxScore = maxScore; this._gameOver = gameOver;&#125; Now, let’s look at the first three methods, which we can use to check certain properties of the board. public static boolean emptySpaceExists(Board b) Use double loop to find out whether exist a tile’s value is empty or not 123456789101112public static boolean emptySpaceExists(Board b) &#123; // TODO: Fill in this function. int size = b.size(); for(int i = 0; i &lt; size; i ++ ) &#123; for(int j = 0; j &lt; size; j ++ ) &#123; if(b.tile(i, j) == null) &#123; return true; &#125; &#125; &#125; return false;&#125; public static boolean maxTileExists(Board b) Use double loop to find out whether exist a tile has the max_piece value or not 1234567891011public static boolean maxTileExists(Board b) &#123; // TODO: Fill in this function. for(int i = 0; i &lt; b.size(); i ++ ) &#123; for(int j = 0; j &lt; b.size(); j ++ ) &#123; if(b.tile(i, j) != null &amp;&amp; b.tile(i, j).value() == MAX_PIECE) &#123; return true; &#125; &#125; &#125; return false;&#125; public static boolean atLeastOneMoveExists(Board b) There is at least one empty space on the board. There are two adjacent tiles with the same value. 1234567891011121314public static boolean atLeastOneMoveExists(Board b) &#123; // TODO: Fill in this function. if(emptySpaceExists(b)) return true; for(int i = 0; i &lt; b.size(); i ++ ) &#123; for(int j = 0; j &lt; b.size(); j ++ ) &#123; boolean leftOrRight = j + 1 &lt; b.size() &amp;&amp; b.tile(i, j).value() == b.tile(i, j + 1).value(); boolean upOrDown = i + 1 &lt; b.size() &amp;&amp; b.tile(i, j).value() == b.tile(i + 1, j).value(); if(leftOrRight || upOrDown) &#123; return true; &#125; &#125; &#125; return false;&#125; tilt Implementation convert the perspective of the view when we begin to move the tile, this step can help us from considering four directions’ movements to only consider how to move the tilt up 1_board.setViewingPerspective(side); At the end of the movement, we can recover the perspective of the board 1_board.setViewingPerspective(Side.NORTH); Move all the tiles to make them adjacent 1234567891011121314151617for (int row = size - 1; row &gt;= 0; row -- ) &#123; Tile t = _board.tile(col, row); if (t != null) &#123; // find nextPos which is null int nextPos = 3; while (nextPos &gt;= row) &#123; if (_board.tile(col, nextPos) == null) &#123; break; &#125; nextPos -- ; &#125; // check if nextPos is a legal position if (nextPos &gt;= row) &#123; _board.move(col, nextPos, t); changed = true; &#125; &#125; merge the tiles if they have the same value between one and the one next to it 123456789101112131415161718192021222324252627282930for (int row = 3; row &gt;= 0; row -- ) &#123; Tile curTile = _board.tile(col, row); // find out the next row&#x27;s tile int nextLine = row - 1; if (nextLine &lt; 0) &#123; break; &#125; Tile nextTile = _board.tile(col, nextLine); // if one of the two tile is null we break this loop if (curTile == null || nextTile == null) &#123; break; &#125; int nextValue = nextTile.value(); if (nextValue == curTile.value()) &#123; // merge the two tiles whose value are equaled _board.move(col, row, nextTile); _score += curTile.value() * 2; // move the tiles behind the two merged tiles to the place where the second tiles was for (int p = nextLine - 1; p &gt;= 0; p -- ) &#123; Tile tile = _board.tile(col, p); if (tile == null) &#123; break; &#125; if (p &lt; size) &#123; _board.move(col, p + 1, tile); &#125; &#125; changed = true; &#125;&#125; The full Complication 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public boolean tilt(Side side) &#123; boolean changed; changed = false; // TODO: Fill in this function. // set the viewing perspective to make the operations more convenient _board.setViewingPerspective(side); int size = _board.size(); for (int col = 0; col &lt; size; col ++ ) &#123; // move all the tiles to make them adjacent for (int row = size - 1; row &gt;= 0; row -- ) &#123; Tile t = _board.tile(col, row); if (t != null) &#123; // find nextPos which is null int nextPos = 3; while (nextPos &gt;= row) &#123; if (_board.tile(col, nextPos) == null) &#123; break; &#125; nextPos -- ; &#125; // check if nextPos is a legal position if (nextPos &gt;= row) &#123; _board.move(col, nextPos, t); changed = true; &#125; &#125; &#125; // Step2. try to merge // [2, 2, x, x] -&gt; [4, x, x, x] for (int row = 3; row &gt;= 0; row -- ) &#123; Tile curTile = _board.tile(col, row); // find out the next row&#x27;s tile int nextLine = row - 1; if (nextLine &lt; 0) &#123; break; &#125; Tile nextTile = _board.tile(col, nextLine); // if one of the two tile is null we break this loop if (curTile == null || nextTile == null) &#123; break; &#125; int nextValue = nextTile.value(); if (nextValue == curTile.value()) &#123; // merge the two tiles whose value are equaled _board.move(col, row, nextTile); _score += curTile.value() * 2; // move the tiles behind the two merged tiles to the place where the second tiles was for (int p = nextLine - 1; p &gt;= 0; p -- ) &#123; Tile tile = _board.tile(col, p); if (tile == null) &#123; break; &#125; if (p &lt; size) &#123; _board.move(col, p + 1, tile); &#125; &#125; changed = true; &#125; &#125; &#125; _board.setViewingPerspective(Side.NORTH); checkGameOver(); if (changed) &#123; setChanged(); &#125; return changed;&#125; Lab02: Account: add a private value to the Account class 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * This class represents a bank account whose current balance is a nonnegative * amount in US dollars. */public class Account &#123; private int balance; private Account parent; /** Initialize an account with the given balance. */ public Account(int balance) &#123; this.balance = balance; &#125; public Account(int balance, Account parent) &#123; this.balance = balance; this.parent = parent; &#125; /** Returns the balance for the current account. */ public int getBalance() &#123; return balance; &#125; /** Deposits amount into the current account. */ public void deposit(int amount) &#123; if (amount &lt; 0) &#123; System.out.println(&quot;Cannot deposit negative amount.&quot;); &#125; else &#123; balance += amount; &#125; &#125; /** * Subtract amount from the account if possible. If subtracting amount * would leave a negative balance, print an error message and leave the * balance unchanged. */ public boolean withdraw(int amount) &#123; // TODO if (amount &lt; 0) &#123; System.out.println(&quot;Cannot withdraw negative amount.&quot;); return false; &#125; else if (amount &lt; balance) &#123; balance -= amount; &#125; else if (parent != null &amp;&amp; balance + parent.balance &gt;= amount) &#123; amount -= balance; balance = 0; parent.balance -= amount; &#125; else &#123; System.out.println(&quot;Insufficient Funds.&quot;); return false; &#125; return true; &#125; /** * Merge account other into this account by removing all money from other * and depositing it into this account. */ public void merge(Account other) &#123; // TODO if (other == null) &#123; System.out.println(&quot;Cannot merge null account.&quot;); &#125; else &#123; balance += other.balance; other.balance = 0; &#125; &#125;&#125; Path: 1234567891011121314151617181920212223242526272829303132/** A class that represents a path via pursuit curves. */public class Path &#123; // TODO private Point curr, next; public Path(double x, double y) &#123; curr = new Point(); next = new Point(x, y); &#125; public double getCurrX() &#123; return curr.getX(); &#125; public double getCurrY() &#123; return curr.getY(); &#125; public double getNextX() &#123; return next.getX(); &#125; public double getNextY() &#123; return next.getY(); &#125; public void setCurrentPoint(Point point) &#123; curr = point; &#125; public void iterate(double x, double y) &#123; curr = next; next = new Point(curr.getX() + x, curr.getY() + y); &#125; public Point getCurrentPoint() &#123; return curr; &#125;&#125; Lab03: Date Converter 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.io.*;public class DateConverter &#123; /** * Given a day number in 2021, an integer between 1 and 365, as a * command-line argument, prints the date in month/day format. * * java DateConverter 365 * * should print 12/31 */ public static void main(String[] args) &#123; int dayOfYear = 0; try &#123; dayOfYear = Integer.parseInt(args[0]); &#125; catch (NumberFormatException e) &#123; e.printStackTrace(); &#125; int month, dateInMonth, daysInMonth; month = 1; daysInMonth = 31; while (dayOfYear &gt; daysInMonth) &#123; // TODO: Here is one place to put assignment statements. if (month == 2) &#123; daysInMonth = 28; &#125; else if (month == 4 || month == 6 || month == 9 || month == 11) &#123; daysInMonth = 30; &#125; else &#123; daysInMonth = 31; &#125; // TODO: Here is another possible place to put assignment statements.// System.out.println(month + &quot;/&quot; + daysInMonth + &quot;/&quot; + dayOfYear); if(dayOfYear &gt; daysInMonth) &#123; dayOfYear -= daysInMonth; month ++ ; &#125; &#125; dateInMonth = dayOfYear; System.out.println(month + &quot;/&quot; + dateInMonth); &#125;&#125; TriangleDrawer: 123456789101112131415public class TriangleDrawer &#123; public static void main(String[] args) &#123; int row = 0; int SIZE = 10; while(row &lt; SIZE) &#123; int col = 0; while(col &lt; row) &#123; System.out.print(&#x27;*&#x27;); col = col + 1; &#125; System.out.println(&#x27;*&#x27;); row = row + 1; &#125; &#125;&#125; ArrayOperations 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class ArrayOperations &#123; /** * Delete the value at the given position in the argument array, shifting * all the subsequent elements down, and storing a 0 as the last element of * the array. */ public static void delete(int[] values, int pos) &#123; if (pos &lt; 0 || pos &gt;= values.length) &#123; return; &#125; // TODO: YOUR CODE HERE for (int i = pos; i &lt; values.length - 1; i ++ ) &#123; values[i] = values[i + 1]; &#125; values[values.length - 1] = 0; &#125; /** * Insert newInt at the given position in the argument array, shifting all * the subsequent elements up to make room for it. The last element in the * argument array is lost. */ public static void insert(int[] values, int pos, int newInt) &#123; if (pos &lt; 0 || pos &gt;= values.length) &#123; return; &#125; // TODO: YOUR CODE HERE for (int i = values.length - 1; i &gt; pos; i -- ) &#123; values[i] = values[i - 1]; &#125; values[pos] = newInt; &#125; /** * Returns a new array consisting of the elements of A followed by the * the elements of B. */ public static int[] catenate(int[] A, int[] B) &#123; // TODO: YOUR CODE HERE int[] C = new int[A.length + B.length]; int index = 0, indexA = 0, indexB = 0; while(indexA &lt; A.length) &#123; C[index ++ ] = A[indexA ++]; &#125; while(indexB &lt; B.length) &#123; C[index ++ ] = B[indexB ++]; &#125; return C; &#125;&#125;","categories":[],"tags":[{"name":"CS61BL","slug":"CS61BL","permalink":"http://www.misaka-9982.com/tags/CS61BL/"},{"name":"Java","slug":"Java","permalink":"http://www.misaka-9982.com/tags/Java/"}]},{"title":"CS61A Proj 3","slug":"CS61A-Proj-3","date":"2022-05-23T09:05:24.000Z","updated":"2022-05-23T12:44:28.644Z","comments":true,"path":"2022/05/23/CS61A-Proj-3/","link":"","permalink":"http://www.misaka-9982.com/2022/05/23/CS61A-Proj-3/","excerpt":"","text":"Project 3: Ants Vs. SomeBees ants.zip The bees are coming! Create a better soldier With inherit-ants. Introduction Important submission note: For full credit, Submit with Phase 1 complete by Thursday, March 3 (worth 1 pt). Submit with Phase 2 complete by Tuesday, March 8 (worth 1 pt). Submit with all phases complete by Thursday, March 10. Try to attempt the problems in order, as some later problems will depend on earlier problems in their implementation and therefore also when running ok tests. The entire project can be completed with a partner. You can get 1 bonus point by submitting the entire project by Wednesday, March 9. In this project, you will create a tower defense game called Ants Vs. SomeBees. As the ant queen, you populate your colony with the bravest ants you can muster. Your ants must protect their queen from the evil bees that invade your territory. Irritate the bees enough by throwing leaves at them, and they will be vanquished. Fail to pester the airborne intruders adequately, and your queen will succumb to the bees’ wrath. This game is inspired by PopCap Games’ Plants Vs. Zombies. This project uses an object-oriented programming paradigm, focusing on material from Chapter 2.5 of Composing Programs. The project also involves understanding, extending, and testing a large program. When students in the past have tried to implement the functions without thoroughly reading the problem description, they’ve often run into issues. 😱 Read each description thoroughly before starting to code. Download starter files The ants.zip archive contains several files, but all of your changes will be made to ants.py. ants.py: The game logic of Ants Vs. SomeBees ants_gui.py: The original GUI for Ants Vs. SomeBees gui.py: A new GUI for Ants Vs. SomeBees. graphics.py: Utilities for displaying simple two-dimensional animations utils.py: Some functions to facilitate the game interface ucb.py: Utility functions for CS 61A state.py: Abstraction for gamestate for gui.py assets: A directory of images and files used by gui.py img: A directory of images used by ants_gui.py ok: The autograder proj3.ok: The ok configuration file tests: A directory of tests used by ok Logistics The project is worth 24 points. 22 points are for correctness, 1 point is for submitting Phase 1 by the first checkpoint date, and 1 point is for submitting Phase 2 by the second checkpoint date. Additionally, there are some extra credit point opportunities. You can get 1 EC point for submitting the entire project by Wednesday, March 9, and 2 EC points for submitting the extra credit problem. Important: In order to receive all of the possible extra credit points for Ants, your implementation of the entire project, including the EC problem, must be submitted by the early submission deadline. You will turn in the following files: ants.py You do not need to modify or turn in any other files to complete the project. To submit the project, run the following command: 1python3 ok --submit You will be able to view your submissions on the Ok dashboard. For the functions that we ask you to complete, there may be some initial code that we provide. If you would rather not use that code, feel free to delete it and start from scratch. You may also add new function definitions as you see fit. However, please do not modify any other functions or edit any files not listed above. Doing so may result in your code failing our autograder tests. Also, please do not change any function signatures (names, argument order, or number of arguments). Throughout this project, you should be testing the correctness of your code. It is good practice to test often, so that it is easy to isolate any problems. However, you should not be testing too often, to allow yourself time to think through problems. We have provided an autograder called ok to help you with testing your code and tracking your progress. The first time you run the autograder, you will be asked to log in with your Ok account using your web browser. Please do so. Each time you run ok, it will back up your work and progress on our servers. The primary purpose of ok is to test your implementations. We recommend that you submit after you finish each problem. Only your last submission will be graded. It is also useful for us to have more backups of your code in case you run into a submission issue. If you forget to submit, your last backup will be automatically converted to a submission. If you do not want us to record a backup of your work or information about your progress, you can run 1python3 ok --local With this option, no information will be sent to our course servers. If you want to test your code interactively, you can run 1python3 ok -q [question number] -i with the appropriate question number (e.g. 01) inserted. This will run the tests for that question until the first one you failed, then give you a chance to test the functions you wrote interactively. You can also use the debugging print feature in OK by writing 1print(&quot;DEBUG:&quot;, x) which will produce an output in your terminal without causing OK tests to fail with extra output. The Game A game of Ants Vs. SomeBees consists of a series of turns. In each turn, new bees may enter the ant colony. Then, new ants are placed to defend their colony. Finally, all insects (ants, then bees) take individual actions. Bees either try to move toward the end of the tunnel or sting ants in their way. Ants perform a different action depending on their type, such as collecting more food or throwing leaves at the bees. The game ends either when a bee reaches the end of the tunnel (you lose), the bees destroy the QueenAnt if it exists (you lose), or the entire bee fleet has been vanquished (you win). Core concepts The Colony. This is where the game takes place. The colony consists of several Places that are chained together to form a tunnel where bees can travel through. The colony also has some quantity of food which can be expended in order to place an ant in a tunnel. Places. A place links to another place to form a tunnel. The player can put a single ant into each place. However, there can be many bees in a single place. The Hive. This is the place where bees originate. Bees exit the beehive to enter the ant colony. Ants. Players place an ant into the colony by selecting from the available ant types at the top of the screen. Each type of ant takes a different action and requires a different amount of colony food to place. The two most basic ant types are the HarvesterAnt, which adds one food to the colony during each turn, and the ThrowerAnt, which throws a leaf at a bee each turn. You will be implementing many more! Bees. In this game, bees are the antagonistic forces that the player must defend the ant colony from. Each turn, a bee either advances to the next place in the tunnel if no ant is in its way, or it stings the ant in its way. Bees win when at least one bee reaches the end of a tunnel. Core classes The concepts described above each have a corresponding class that encapsulates the logic for that concept. Here is a summary of the main classes involved in this game: GameState: Represents the colony and some state information about the game, including how much food is available, how much time has elapsed, where the AntHomeBase is, and all the Places in the game. Place: Represents a single place that holds insects. At most one Ant can be in a single place, but there can be many Bees in a single place. Place objects have an exit to the left and an entrance to the right, which are also places. Bees travel through a tunnel by moving to a Place’s exit. Hive: Represents the place where Bees start out (on the right of the tunnel). AntHomeBase: Represents the place Ants are defending (on the left of the tunnel). If Bees get here, they win :( Insect: A superclass for Ant and Bee. All insects have health attribute, representing their remaining health, and a place attribute, representing the Place where they are currently located. Each turn, every active Insect in the game performs its action. Ant: Represents ants. Each Ant subclass has special attributes or a special action that distinguish it from other Ant types. For example, a HarvesterAnt gets food for the colony and a ThrowerAnt attacks Bees. Each ant type also has a food_cost attribute that indicates how much it costs to deploy one unit of that type of ant. Bee: Represents bees. Each turn, a bee either moves to the exit of its current Place if the Place is not blocked by an ant, or stings the ant occupying its same Place. Game Layout Below is a visualization of a GameState. As you work through the unlocking tests and problems, we recommend drawing out similar diagrams to help your understanding. Object map To help visualize how all the classes fit together, we’ve also created an object map for you to reference as you work, which you can find here: Playing the game The game can be run in two modes: as a text-based game or using a graphical user interface (GUI). The game logic is the same in either case, but the GUI enforces a turn time limit that makes playing the game more exciting. The text-based interface is provided for debugging and development. The files are separated according to these two modes. ants.py knows nothing of graphics or turn time limits. To start a text-based game, run 1python3 ants_text.py To start a graphical game, run 1python3 gui.py When you start the graphical version, a new browser window should appear. In the starter implementation, you have unlimited food and your ants can only throw leaves at bees in their current Place. Before you complete Problem 2, the GUI may crash since it doesn’t have a full conception of what a Place is yet! Try playing the game anyway! You’ll need to place a lot of ThrowerAnts (the second type) in order to keep the bees from reaching your queen. The game has several options that you will use throughout the project, which you can view with python3 ants_text.py --help. 123456789usage: ants_text.py [-h] [-d DIFFICULTY] [-w] [--food FOOD]Play Ants vs. SomeBeesoptional arguments: -h, --help show this help message and exit -d DIFFICULTY sets difficulty of game (test/easy/normal/hard/extra-hard) -w, --water loads a full layout with water --food FOOD number of food to start with when testing Getting Started Videos These videos may provide some helpful direction for tackling the coding problems on the project. To see these videos, you should be logged into your berkeley.edu email. YouTube link Phase 1: Basic gameplay Important submission note: For full credit, submit with Phase 1 complete by Thursday, March 3 (worth 1 pt). In the first phase you will complete the implementation that will allow for basic gameplay with the two basic Ants: the HarvesterAnt and the ThrowerAnt. Problem 0 (0 pt) Answer the following questions after you have read the entire ants.py file. To submit your answers, run: 1python3 ok -q 00 -u✂️ If you get stuck while answering these questions, you can try reading through ants.py again, consult the core concepts/classes sections above, or ask a question in the Question 0 thread on Piazza. What is the significance of an Insect’s health attribute? Does this value change? If so, how? Which of the following is a class attribute of the Insect class? Is the health attribute of the Ant class an instance attribute or a class attribute? Why? Is the damage attribute of an Ant subclass (such as ThrowerAnt) an instance attribute or class attribute? Why? Which class do both Ant and Bee inherit from? What do instances of Ant and instances of Bee have in common? How many insects can be in a single Place at any given time (before Problem 8)? What does a Bee do during one of its turns? When is the game lost? Remember to run: 1python3 ok -q 00 -u✂️ A note on unlocking tests: If you’d like to review the unlocking questions after you have completed the unlocking test, you can navigate to (within the ants folder), the tests folder. For example, after unlocking Problem 0, you can review the unlocking test at tests/00.py. Problem 1 (1 pt) Part A: Currently, there is no cost for placing any type of Ant, and so there is no challenge to the game. The base class Ant has a food_cost of zero. Override this class attribute for HarvesterAnt and ThrowerAnt according to the “Food Cost” column in the table below. Class Food Cost Initial Health HarvesterAnt 2 1 ThrowerAnt 3 1 Part B: Now that placing an Ant costs food, we need to be able to gather more food! To fix this issue, implement the HarvesterAnt class. A HarvesterAnt is a type of Ant that adds one food to the gamestate.food total as its action. Before writing any code, unlock the tests to verify your understanding of the question: 1python3 ok -q 01 -u✂️ Once you are done unlocking, begin implementing your solution. You can check your correctness with: 1python3 ok -q 01✂️ Try playing the game by running python3 gui.py. Once you have placed a HarvesterAnt, you should accumulate food each turn. You can also place ThrowerAnts, but you’ll see that they can only attack bees that are in their Place, making it a little difficult to win. Problem 2 (1 pt) In this problem, you’ll complete Place.__init__ by adding code that tracks entrances. Right now, a Place keeps track only of its exit. We would like a Place to keep track of its entrance as well. A Place needs to track only one entrance. Tracking entrances will be useful when an Ant needs to see what Bees are in front of it in the tunnel. However, simply passing an entrance to a Place constructor will be problematic; we would need to have both the exit and the entrance before creating a Place! (It’s a chicken or the egg problem.) To get around this problem, we will keep track of entrances in the following way instead. Place.__init__ should use this logic: A newly created Place always starts with its entrance as None. If the Place has an exit, then the exit’s entrance is set to that Place. Hint: Remember that when the __init__ method is called, the first parameter, self, is bound to the newly created object Hint: Try drawing out two Places next to each other if things get confusing. In the GUI, a place’s entrance is to its right while the exit is to its left. Hint: Remember that Places are not stored in a list, so you can’t index into anything to access them. This means that you can’t do something like colony[index + 1] to access an adjacent Place. How can you move from one place to another? Before writing any code, unlock the tests to verify your understanding of the question: 1python3 ok -q 02 -u✂️ Once you are done unlocking, begin implementing your solution. You can check your correctness with: 1python3 ok -q 02✂️ Problem 3 (2 pt) In order for a ThrowerAnt to throw a leaf, it must know which bee to hit. The provided implementation of the nearest_bee method in the ThrowerAnt class only allows them to hit bees in the same Place. Your job is to fix it so that a ThrowerAnt will throw_at the nearest bee in front of it that is not still in the Hive. This includes bees that are in the same Place as a ThrowerAnt Hint: All Places have an is_hive attribute which is True when that place is the Hive. Change nearest_bee so that it returns a random Bee from the nearest place that contains bees. Your implementation should follow this logic: Start from the current Place of the ThrowerAnt. For each place, return a random bee if there is any, and if not, inspect the place in front of it (stored as the current place’s entrance). If there is no bee to attack, return None. Hint: The random_bee function provided in ants.py returns a random bee from a list of bees or None if the list is empty. Hint: As a reminder, if there are no bees present at a Place, then the bees attribute of that Place instance will be an empty list. Hint: Having trouble visualizing the test cases? Try drawing them out on paper! The sample diagram provided in Game Layout shows the first test case for this problem. Before writing any code, unlock the tests to verify your understanding of the question: 1python3 ok -q 03 -u✂️ Once you are done unlocking, begin implementing your solution. You can check your correctness with: 1python3 ok -q 03✂️ After implementing nearest_bee, a ThrowerAnt should be able to throw_at a Bee in front of it that is not still in the Hive. Make sure that your ants do the right thing! To start a game with ten food (for easy testing): 1python3 gui.py --food 10 Make sure to submit by the checkpoint deadline using the following command: 1python3 ok --submit You can check to ensure that you have completed Phase 1’s problems by running: 1python3 ok --score Congratulations! You have finished Phase 1 of this project! Phase 2: Ants! Important submission note: For full credit, Submit with Phase 2 complete by Tuesday, March 8 (worth 1 pt). Now that you’ve implemented basic gameplay with two types of Ants, let’s add some flavor to the ways ants can attack bees. In this phase, you’ll be implementing several different Ants with different attack strategies. After you implement each Ant subclass in this section, you’ll need to set its implemented class attribute to True so that that type of ant will show up in the GUI. Feel free to try out the game with each new ant to test the functionality! With your Phase 2 ants, try python3 gui.py -d easy to play against a full swarm of bees in a multi-tunnel layout and try -d normal, -d hard, or -d extra-hard if you want a real challenge! If the bees are too numerous to vanquish, you might need to create some new ants. Problem 4 (2 pt) A ThrowerAnt is a powerful threat to the bees, but it has a high food cost. In this problem, you’ll implement two subclasses of ThrowerAnt that are less costly but have constraints on the distance they can throw: The LongThrower can only throw_at a Bee that is found after following at least 5 entrance transitions. It cannot hit Bees that are in the same Place as it or the first 4 Places in front of it. If there are two Bees, one too close to the LongThrower and the other within its range, the LongThrower should only throw at the farther Bee, which is within its range, instead of trying to hit the closer Bee. The ShortThrower can only throw_at a Bee that is found after following at most 3 entrance transitions. It cannot throw at any bees further than 3 Places in front of it. Neither of these specialized throwers can throw_at a Bee that is exactly 4 Places away. Class Food Cost Initial Health ShortThrower 2 1 LongThrower 2 1 To implement these new throwing ants, your ShortThrower and LongThrower classes should inherit the nearest_bee method from the base ThrowerAnt class. The logic of choosing which bee a thrower ant will attack is the same, except the ShortThrower and LongThrower ants have a maximum and minimum range, respectively. To do this, modify the nearest_bee method to reference min_range and max_range attributes, and only return a bee if it is within range. Make sure to give these min_range and max_range attributes appropriate values in the ThrowerAnt class so that the behavior of ThrowerAnt is unchanged. Then, implement the subclasses LongThrower and ShortThrower with appropriately constrained ranges. You should not need to repeat any code between ThrowerAnt, ShortThrower, and LongThrower. Hint: float('inf') returns an infinite positive value represented as a float that can be compared with other numbers. Hint: You can chain inequalities in Python: e.g. 2 &lt; x &lt; 6 will check if x is between 2 and 6. Also, min_range and max_range should mark an inclusive range. Important: Make sure your class attributes are called max_range and min_range The tests directly reference these attribute names, and will error if you use another name for these attributes. Don’t forget to set the implemented class attribute of LongThrower and ShortThrower to True. Before writing any code, unlock the tests to verify your understanding of the question: 1python3 ok -q 04 -u✂️ After writing code, test your implementation (rerun the tests for 03 to make sure they still work): 1python3 ok -q 03✂️ 1python3 ok -q 04✂️ 👩🏽‍💻👨🏿‍💻 Pair programming? Remember to alternate between driver and navigator roles. The driver controls the keyboard; the navigator watches, asks questions, and suggests ideas. Problem 5 (3 pt) Implement the FireAnt, which does damage when it receives damage. Specifically, if it is damaged by amount health units, it does a damage of amount to all bees in its place (this is called reflected damage). If it dies, it does an additional amount of damage, as specified by its damage attribute, which has a default value of 3 as defined in the FireAnt class. To implement this, override Ant’s reduce_health method. Your overriden method should call the reduce_health method inherited from the superclass (Ant) to reduce the current FireAnt instance’s health. Calling the inherited reduce_health method on a FireAnt instance reduces the insect’s health by the given amount and removes the insect from its place if its health reaches zero or lower. Hint: Do not call self.reduce_health, or you’ll end up stuck in a recursive loop. (Can you see why?) However, your method needs to also include the reflective damage logic: Determine the reflective damage amount: start with the amount inflicted on the ant, and then add damage if the ant’s health has dropped to 0. For each bee in the place, damage them with the total amount by calling the appropriate reduce_health method for each bee. Important: Remember that when any Ant loses all its health, it is removed from its place, so pay careful attention to the order of your logic in reduce_health. Class Food Cost Initial Health FireAnt 5 3 Hint: Damaging a bee may cause it to be removed from its place. If you iterate over a list, but change the contents of that list at the same time, you may not visit all the elements. This can be prevented by making a &gt; copy of the list. You can either use a list slice, or use the built-in list function. 1234567&gt;&gt;&gt; lst = [1,2,3,4]&gt;&gt;&gt; lst[:][1, 2, 3, 4]&gt;&gt;&gt; list(lst)[1, 2, 3, 4]&gt;&gt;&gt; lst[:] is not lst and list(lst) is not lstTrue Once you’ve finished implementing the FireAnt, give it a class attribute implemented with the value True. Note: Even though you are overriding the superclass’s reduce_health function (Ant.reduce_health), you can still use this method in your implementation by calling it. Note this is not recursion. (Why not?) Before writing any code, unlock the tests to verify your understanding of the question: 1python3 ok -q 05 -u✂️ Once you are done unlocking, begin implementing your solution. You can check your correctness with: 1python3 ok -q 05✂️ You can also test your program by playing a game or two! A FireAnt should destroy all co-located Bees when it is stung. To start a game with ten food (for easy testing): 1python3 gui.py --food 10 Problem 6 (1 pt) We are going to add some protection to our glorious home base by implementing the WallAnt, an ant that does nothing each turn. A WallAnt is useful because it has a large health value. Class Food Cost Initial Health WallAnt 4 4 Unlike with previous ants, we have not provided you with a class header. Implement the WallAnt class from scratch. Give it a class attribute name with the value 'Wall' (so that the graphics work) and a class attribute implemented with the value True (so that you can use it in a game). Hint: To start, take a look at how the previous problems’ ants were implemented! Before writing any code, unlock the tests to verify your understanding of the question: 1python3 ok -q 06 -u✂️ Once you are done unlocking, begin implementing your solution. You can check your correctness with: 1python3 ok -q 06✂️ Problem 7 (3 pt) Implement the HungryAnt, which will select a random Bee from its place and deal damage to the bee by eating it whole. After eating a Bee, a HungryAnt must spend 3 turns chewing before being able to eat again. While the HungryAnt is chewing, it is not able to eat (deal damage to) any Bee’s. After 3 turns, if there is no bee available to eat, the HungryAnt will do nothing. We have not provided you with a class header. Implement the HungryAnt class from scratch. Give it a class attribute name with the value 'Hungry' (so that the graphics work) and a class attribute implemented with the value True (so that you can use it in a game). Hint: When a Bee is eaten, it should lose all its health. Is there an existing function we can call on a Bee that can reduce its health to 0? Class Food Cost Initial Health HungryAnt 4 1 Give HungryAnt a time_to_chew class attribute that stores the number of turns that it will take a HungryAnt to chew (set to 3). Also, give each HungryAnt an instance attribute chew_timer that counts the number of turns it has left to chew (initialized to 0, since it hasn’t eaten anything at the beginning. You can also think of chew_timer as the number of turns until a HungryAnt can eat another Bee). Implement the action method of the HungryAnt: First, check if it is chewing; if so, decrement its chew_timer. Otherwise, eat a random Bee in its place by reducing the Bee’s health to 0. Make sure to set the chew_timer when a Bee is eaten! Hint: Other than the action method, make sure you implement the __init__ method too so the HungryAnt starts off with the appropriate amount of health! Before writing any code, unlock the tests to verify your understanding of the question: 1python3 ok -q 07 -u✂️ Once you are done unlocking, begin implementing your solution. You can check your correctness with: 1python3 ok -q 07✂️ We now have some great offensive troops to help vanquish the bees, but let’s make sure we’re also keeping our defensive efforts up. In this phase you will implement ants that have special defensive capabilities such as increased health and the ability to protect other ants. 👩🏽‍💻👨🏿‍💻 Pair programming? This would be a good time to switch roles. Switching roles makes sure that you both benefit from the learning experience of being in each role. Problem 8 (3 pt) Right now, our ants are quite frail. We’d like to provide a way to help them last longer against the onslaught of the bees. Enter the BodyguardAnt. Class Food Cost Initial Health BodyguardAnt 4 2 A BodyguardAnt differs from a normal ant because it is a ContainerAnt; it can contain another ant and protect it, all in one Place. When a Bee stings the ant in a Place where one ant contains another, only the container is damaged. The ant inside the container can still perform its original action. If the container perishes, the contained ant still remains in the place (and can then be damaged). Each ContainerAnt has an instance attribute ant_contained that stores the ant it contains. This ant, ant_contained, initially starts off as None to indicate that there is no ant being stored yet. Implement the store_ant method so that it sets the ContainerAnt’s ant_contained instance attribute to the passed in ant argument. Also implement the ContainerAnt’s action method to perform its ant_contained’s action if it is currently containing an ant. In addition, you will need to make the following modifications throughout your program so that a container and its contained ant can both occupy a place at the same time (a maximum of two ants per place), but only if exactly one is a container: There is an Ant.can_contain method, but it always returns False. Override the method ContainerAnt.can_contain so that it takes an ant other as an argument and returns True if: This ContainerAnt does not already contain another ant. The other ant is not a container. Modify Ant.add_to to allow a container and a non-container ant to occupy the same place according to the following rules: If the ant originally occupying a place can contain the ant being added, then both ants occupy the place and original ant contains the ant being added. If the ant being added can contain the ant originally in the space, then both ants occupy the place and the (container) ant being added contains the original ant. If neither Ant can contain the other, raise the same AssertionError as before (the one already present in the starter code). Important: If there are two ants in a specific Place, the ant attribute of the Place instance should refer to the container ant, and the container ant should contain the non-container ant. Add a BodyguardAnt.__init__ that sets the initial amount of health for the ant. Hint: You may find the is_container attribute that each Ant has useful for checking if a specific Ant is a container. You should also take advantage of the can_contain method you wrote and avoid repeating code. The constructor of ContainerAnt.__init__ is implemented as follows: 123def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.ant_contained = None As we saw in Hog, args is bound to all positional arguments (which are all arguments passed without keywords), and kwargs is bound to all the keyword arguments. This ensures that both sets of arguments are passed to the Ant constructor. Effectively, this means the constructor is exactly the same as its parent class’s constructor (Ant.__init__) but here we also set self.ant_contained = None. Once you’ve finished implementing the BodyguardAnt, give it a class attribute implemented with the value True. Note: If you’re getting an “unreachable code” warning for Ant.add_to via the VSCode Pylance extension, it’s fine to ignore this specific warning, as the code is actually run (the warning in this case is inaccurate). Before writing any code, unlock the tests to verify your understanding of the question: 1python3 ok -q 08 -u✂️ Once you are done unlocking, begin implementing your solution. You can check your correctness with: 1python3 ok -q 08✂️ Problem 9 (1 pt) The BodyguardAnt provides great defense, but they say the best defense is a good offense. The TankAnt is a container that protects an ant in its place and also deals 1 damage to all bees in its place each turn. Class Food Cost Initial Health TankAnt 6 2 We have not provided you with a class header. Implement the TankAnt class from scratch. Give it a class attribute name with the value 'Tank' (so that the graphics work) and a class attribute implemented with the value True (so that you can use it in a game). You should not need to modify any code outside of the TankAnt class. If you find yourself needing to make changes elsewhere, look for a way to write your code for the previous question such that it applies not just to BodyguardAnt and TankAnt objects, but to container ants in general. Hint: The only methods you need to override from TankAnt’s parent class are __init__ and action. Hint: Like with FireAnt, it is possible that damaging a bee will cause it to be removed from its place. Before writing any code, unlock the tests to verify your understanding of the question: 1python3 ok -q 09 -u✂️ Once you are done unlocking, begin implementing your solution. You can check your correctness with: 1python3 ok -q 09✂️ Phase 3: Water and Might Important submission note: For full credit, Submit with all phases complete by Thursday, March 10. You will get an extra credit point for submitting the entire project by Wednesday, March 9. In the final phase, you’re going to add one last kick to the game by introducing a new type of place and new ants that are able to occupy this place. One of these ants is the most important ant of them all: the queen of the colony! Problem 10 (1 pt) Let’s add water to the colony! Currently there are only two types of places, the Hive and a basic Place. To make things more interesting, we’re going to create a new type of Place called Water. Only an insect that is waterproof can be placed in Water. In order to determine whether an Insect is waterproof, add a new class attribute to the Insect class named is_waterproof that is set to False. Since bees can fly, set their is_waterproof attribute to True, overriding the inherited value. Now, implement the add_insect method for Water. First, add the insect to the place regardless of whether it is waterproof. Then, if the insect is not waterproof, reduce the insect’s health to 0. Do not repeat code from elsewhere in the program. Instead, use methods that have already been defined. Before writing any code, unlock the tests to verify your understanding of the question: 1python3 ok -q 10 -u✂️ Once you are done unlocking, begin implementing your solution. You can check your correctness with: 1python3 ok -q 10✂️ Once you’ve finished this problem, play a game that includes water. To access the wet_layout, which includes water, add the --water option (or -w for short) when you start the game. 1python3 gui.py --water 👩🏽‍💻👨🏿‍💻 Pair programming? Remember to alternate between driver and navigator roles. The driver controls the keyboard; the navigator watches, asks questions, and suggests ideas. Problem 11 (1 pt) Currently there are no ants that can be placed on Water. Implement the ScubaThrower, which is a subclass of ThrowerAnt that is more costly and waterproof, but otherwise identical to its base class. A ScubaThrower should not lose its health when placed in Water. Class Food Cost Initial Health ScubaThrower 6 1 We have not provided you with a class header. Implement the ScubaThrower class from scratch. Give it a class attribute name with the value 'Scuba' (so that the graphics work) and remember to set the class attribute implemented with the value True (so that you can use it in a game). Before writing any code, unlock the tests to verify your understanding of the question: 1python3 ok -q 11 -u✂️ Once you are done unlocking, begin implementing your solution. You can check your correctness with: 1python3 ok -q 11✂️ Problem 12 (3 pt) Finally, implement the QueenAnt. The queen is a waterproof ScubaThrower that inspires her fellow ants through her bravery. In addition to the standard ScubaThrower action, the QueenAnt doubles the damage of all the ants behind her each time she performs an action. Once an ant’s damage has been doubled, it is not doubled again for subsequent turns. Note: The reflected damage of a FireAnt should not be doubled, only the extra damage it deals when its health is reduced to 0. Class Food Cost Initial Health QueenAnt 7 1 However, with great power comes great responsibility. The QueenAnt is governed by three special rules: If the queen ever has its health reduced to 0, the ants lose. You will need to override Ant.reduce_health in QueenAnt and call ants_lose() in that case in order to signal to the simulator that the game is over. (The ants also still lose if any bee reaches the end of a tunnel.) There can be only one queen. A second queen cannot be constructed. To check if an Ant can be constructed, we use the Ant.construct() class method to either construct an Ant if possible, or return None if not. You will need to override Ant.construct as a class method of QueenAnt in order to add this check. To keep track of whether a queen has already been created, you can use an instance variable added to the current GameState. The queen cannot be removed. Attempts to remove the queen should have no effect (but should not cause an error). You will need to override Ant.remove_from in QueenAnt to enforce this condition. Hint: Think about how you can call the construct method of the superclass of QueenAnt. Remember that you ultimately want to construct a QueenAnt, not a regular Ant or a ScubaThrower. Hint: You can find each Place in a tunnel behind the QueenAnt by starting at the ant’s place.exit and then repeatedly following its exit. The exit of a Place at the end of a tunnel is None. Hint: To avoid doubling an ant’s damage twice, mark the ants that have been double damaged in a way that persists across calls to QueenAnt.action. Hint: When doubling the ants’ damage, keep in mind that there can be more than one ant in a Place, such as if one ant is guarding another. Before writing any code, unlock the tests to verify your understanding of the question: 1python3 ok -q 12 -u✂️ Once you are done unlocking, begin implementing your solution. You can check your correctness with: 1python3 ok -q 12✂️ Extra Credit (2 pt) During Office Hours and Project Parties, the staff will prioritize helping students with required questions. We will not be offering help with this question unless the queue is empty. Implement two final thrower ants that do zero damage, but instead apply a temporary “status” on the action method of a Bee instance that they throw_at. This “status” lasts for a certain number of turns, after which it ceases to take effect. We will be implementing two new ants that inherit from ThrowerAnt. SlowThrower throws sticky syrup at a bee, slowing it for 3 turns. When a bee is slowed, it can only move on turns when gamestate.time is even, and can do nothing otherwise. If a bee is hit by syrup while it is already slowed, it is slowed for an additional 3 turns. ScaryThrower intimidates a nearby bee, causing it to back away instead of advancing. (If the bee is already right next to the Hive and cannot go back further, it should not move. To check if a bee is next to the Hive, you might find the is_hive instance attribute of Places useful). Bees remain scared until they have tried to back away twice. Bees cannot try to back away if they are slowed and gamestate.time is odd. Once a bee has been scared once, it can’t be scared ever again. Important update (3/7): Previously, the spec mentioned that “Bees will not back up when scared if they are slowed.” However, the actual behavior of this should be, “Bees will not back up when scared if they are slowed *and gamestate.time is odd.*” as described and seen in the behavior of the doctests (which have not changed). The spec description has now been updated to reflect this behavior. A clarification on the doctest comments: # after this, no longer scared, but still slowed for 8 turns and # it's an even turn, so it can be scared and move backwards are referring to that since gamestate.time is even, the bee can now make its second attempt to back away due to being scared (which occurred at gamestate.time=0). The bee is not being scared a second time, it’s just showing the effects of being scared from gamestate.time=0. After the bee has made this second attempt to back away according to the doctest comments, it can no longer be inflicted by the scared status another time. Note: This change only affects the spec on this page, and not* the tests for the question itself.* Since the tests are still correct, there is nothing to redownload for this change. Class Food Cost Initial Health SlowThrower 4 1 ScaryThrower 6 1 In order to complete the implementations of these two ants, you will need to set their class attributes appropriately and implement the slow and scare methods on Bee, which apply their respective statuses on a particular bee. You may also have to edit some other methods of Bee. Before writing any code, unlock the tests to verify your understanding of the question: 1python3 ok -q EC -u✂️ You can run some provided tests, but they are not exhaustive: 1python3 ok -q EC✂️ Make sure to test your code! Your code should be able to apply multiple statuses on a target; each new status applies to the current (possibly previously affected) action method of the bee. Optional Problems Optional Problem 1 During Office Hours and Project Parties, the staff will prioritize helping students with required questions. We will not be offering help with this question unless the queue is empty. Implement the NinjaAnt, which damages all Bees that pass by, but can never be stung. Class Food Cost Initial Health NinjaAnt 5 1 A NinjaAnt does not block the path of a Bee that flies by. To implement this behavior, first modify the Ant class to include a new class attribute blocks_path that is set to True, then override the value of blocks_path to False in the NinjaAnt class. Second, modify the Bee’s method blocked to return False if either there is no Ant in the Bee’s place or if there is an Ant, but its blocks_path attribute is False. Now Bees will just fly past NinjaAnts. Finally, we want to make the NinjaAnt damage all Bees that fly past. Implement the action method in NinjaAnt to reduce the health of all Bees in the same place as the NinjaAnt by its damage attribute. Similar to the FireAnt, you must iterate over a potentially changing list of bees. Hint: Having trouble visualizing the test cases? Try drawing them out on paper! See the example in Game Layout for help. Before writing any code, unlock the tests to verify your understanding of the question: 1python3 ok -q optional1 -u✂️ Once you are done unlocking, begin implementing your solution. You can check your correctness with: 1python3 ok -q optional1✂️ For a challenge, try to win a game using only HarvesterAnt and NinjaAnt. Optional Problem 2 During Office Hours and Project Parties, the staff will prioritize helping students with required questions. We will not be offering help with this question unless the queue is empty. We’ve been developing this ant for a long time in secret. It’s so dangerous that we had to lock it in the super hidden CS61A underground vault, but we finally think it is ready to go out on the field. In this problem, you’ll be implementing the final ant – LaserAnt, a ThrowerAnt with a twist. Class Food Cost Initial Health LaserAnt 10 1 The LaserAnt shoots out a powerful laser, damaging all that dare to stand in its path. Both Bees and Ants, of all types, are at risk of being damaged by LaserAnt. When a LaserAnt takes its action, it will damage all Insects in its place (excluding itself, but including its container if it has one) and the Places in front of it, excluding the Hive. If that were it, LaserAnt would be too powerful for us to contain. The LaserAnt has a base damage of 2. But, LaserAnt’s laser comes with some quirks. The laser is weakened by 0.25 each place it travels away from LaserAnt’s place. Additionally, LaserAnt has limited battery. Each time LaserAnt actually damages an Insect its laser’s total damage goes down by 0.0625 (1/16). If LaserAnt’s damage becomes negative due to these restrictions, it simply does 0 damage instead. The exact order in which things are damaged within a turn is unspecified. In order to complete the implementation of this ultimate ant, read through the LaserAnt class, set the class attributes appropriately, and implement the following two functions: insects_in_front is an instance method, called by the action method, that returns a dictionary where each key is an Insect and each corresponding value is the distance (in places) that that Insect is away from LaserAnt. The dictionary should include all Insects on the same place or in front of the LaserAnt, excluding LaserAnt itself. calculate_damage is an instance method that takes in distance, the distance that an insect is away from the LaserAnt instance. It returns the damage that the LaserAnt instance should afflict based on: The distance away from the LaserAnt instance that an Insect is. The number of Insects that this LaserAnt has damaged, stored in the insects_shot instance attribute. In addition to implementing the methods above, you may need to modify, add, or use class or instance attributes in the LaserAnt class as needed. Note: There are no unlocking tests for this question. You can run the provided test, but it is not exhaustive: 1python3 ok -q optional2✂️ Make sure to test your code! Project submission At this point, run the entire autograder to see if there are any tests that don’t pass: 1python3 ok You can also check your score on each part of the project, including the extra credit problem: 1python3 ok --score Once you are satisfied, submit to complete the project. 1python3 ok --submit If you have a partner, make sure to add them to the project submission on okpy. You are now done with the project! If you haven’t yet, you should try playing the game! 1python3 gui.py [-h] [-d DIFFICULTY] [-w] [--food FOOD] Acknowledgments: Tom Magrino and Eric Tzeng developed this project with John DeNero. Jessica Wan contributed the original artwork. Joy Jeng and Mark Miyashita invented the queen ant. Many others have contributed to the project as well! The new concept artwork was drawn by Alana Tran, Andrew Huang, Emilee Chen, Jessie Salas, Jingyi Li, Katherine Xu, Meena Vempaty, Michelle Chang, and Ryan Davis.","categories":[],"tags":[{"name":"CS61A","slug":"CS61A","permalink":"http://www.misaka-9982.com/tags/CS61A/"}]},{"title":"CS61A Proj 2","slug":"CS61A-Proj-2","date":"2022-05-23T09:05:22.000Z","updated":"2022-07-23T05:24:47.058Z","comments":true,"path":"2022/05/23/CS61A-Proj-2/","link":"","permalink":"http://www.misaka-9982.com/2022/05/23/CS61A-Proj-2/","excerpt":"","text":"Project 2: CS 61A Autocorrected Typing Software cats.zip Programmers dream of Abstraction, recursion, and Typing really fast. Introduction Important submission note: For full credit: Submit with Phase 1 complete by Thursday, February 17, worth 1 pt. Submit with all phases complete by Thursday, February 24. Try to attempt the problems in order, as some later problems will depend on earlier problems in their implementation and therefore also when running ok tests. The entire project can be completed with a partner. You can get 1 bonus point by submitting the entire project by Wednesday, February 23. In this project, you will write a program that measures typing speed. Additionally, you will implement typing autocorrect, which is a feature that attempts to correct the spelling of a word after a user types it. This project is inspired by typeracer. When students in the past have tried to implement the functions without thoroughly reading the problem description, they’ve often run into issues. 😱 Read each description thoroughly before starting to code. Final Product Our staff solution to the project can be interacted with at cats.cs61a.org. If you’d like, feel free to try it out now. When you finish the project, you’ll have implemented a significant part of this match yourself! Download starter files You can download all of the project code as a zip archive. This project includes several files, but your changes will be made only to cats.py. Here are the files included in the archive: cats.py: The typing test logic. utils.py: Utility functions for interacting with files and strings. ucb.py: Utility functions for CS 61A projects. data/sample_paragraphs.txt: A file containing text samples to be typed. These are scraped Wikipedia articles about various topics. data/common_words.txt: A file containing common English words in order of frequency. data/words.txt: A file containing many more English words in order of frequency. cats_gui.py: A web server for the web-based graphical user interface (GUI). gui_files: A directory of files needed for the graphical user interface (GUI). multiplayer: A directory of files needed to support multiplayer mode. favicons: A directory of icons. images: A directory of images. ok, proj02.ok, tests: Testing files. Logistics The project is worth 20 points. 19 points are for correctness and 1 point is for submitting Phase 1 by the checkpoint date. You will turn in the following files: cats.py You do not need to modify or turn in any other files to complete the project. To submit the project, run the following command: 1python3 ok --submit You will be able to view your submissions on the Ok dashboard. For the functions that we ask you to complete, there may be some initial code that we provide. If you would rather not use that code, feel free to delete it and start from scratch. You may also add new function definitions as you see fit. However, please do not modify any other functions or edit any files not listed above. Doing so may result in your code failing our autograder tests. Also, please do not change any function signatures (names, argument order, or number of arguments). Throughout this project, you should be testing the correctness of your code. It is good practice to test often, so that it is easy to isolate any problems. However, you should not be testing too often, to allow yourself time to think through problems. We have provided an autograder called ok to help you with testing your code and tracking your progress. The first time you run the autograder, you will be asked to log in with your Ok account using your web browser. Please do so. Each time you run ok, it will back up your work and progress on our servers. The primary purpose of ok is to test your implementations. We recommend that you submit after you finish each problem. Only your last submission will be graded. It is also useful for us to have more backups of your code in case you run into a submission issue. If you forget to submit, your last backup will be automatically converted to a submission. If you do not want us to record a backup of your work or information about your progress, you can run 1python3 ok --local With this option, no information will be sent to our course servers. If you want to test your code interactively, you can run 1python3 ok -q [question number] -i with the appropriate question number (e.g. 01) inserted. This will run the tests for that question until the first one you failed, then give you a chance to test the functions you wrote interactively. You can also use the debugging print feature in OK by writing 1print(&quot;DEBUG:&quot;, x) which will produce an output in your terminal without causing OK tests to fail with extra output. Getting Started Videos To see these videos, you should be logged into your berkeley.edu email. Getting Started Videos Phase 1: Typing When students in the past have tried to implement the functions without thoroughly reading the problem description, they’ve often run into issues. 😱 Read each description thoroughly before starting to code. Problem 1 (1 pt) Throughout the project, we will be making changes to functions in cats.py. Implement choose. This function selects which paragraph the user will type. It takes three parameters: a list of paragraphs (strings) a select function, which returns True for paragraphs that can be selected a non-negative index k The choose function returns the kth paragraph for which select returns True. If no such paragraph exists (because k is too large), then choose returns the empty string. Before writing any code, unlock the tests to verify your understanding of the question: 1python3 ok -q 01 -u✂️ Once you are done unlocking, begin implementing your solution. You can check your correctness with: 1python3 ok -q 01✂️ Problem 2 (1 pt) Implement about, which takes a list of topic words. It returns a function which takes a paragraph and returns a boolean indicating whether that paragraph contains any of the words in topic. Once we’ve implemented about, we’ll be able to pass the returned function to choose as the select argument, which will be useful as we continue to implement our typing test. To be able to make this comparison accurately, you will need to ignore case (that is, assume that uppercase and lowercase letters don’t change what word it is) and punctuation in the paragraph. Additionally, only check for exact matches of the words in topic in the paragraph, not substrings. For example, “dogs” is not a match for the word “dog”. Hint: You may use the string utility functions in utils.py. You can reference the docstrings of the utility functions to see how they are being used. Before writing any code, unlock the tests to verify your understanding of the question: 1python3 ok -q 02 -u✂️ Once you are done unlocking, begin implementing your solution. You can check your correctness with: 1python3 ok -q 02✂️ Problem 3 (2 pts) Implement accuracy, which takes a typed paragraph and a reference paragraph. It returns the percentage of words in typed that exactly match the corresponding words in reference. Case and punctuation must match as well. “Corresponding” here means that two words must occur at the same indices in typed and reference—the first words of both must match, the second words of both must match, and so on. A word in this context is any sequence of characters separated from other words by whitespace, so treat “dog;” as a single word. If typed is longer than reference, then the extra words in typed that have no corresponding word in reference are all incorrect. If both typed and reference are empty, then the accuracy is 100.0. If typed is empty but reference is not empty, then the accuracy is zero. If typed is not empty but reference is empty, then the accuracy is zero. Before writing any code, unlock the tests to verify your understanding of the question: 1python3 ok -q 03 -u✂️ Once you are done unlocking, begin implementing your solution. You can check your correctness with: 1python3 ok -q 03✂️ 👩🏽‍💻👨🏿‍💻 Pair programming? Remember to alternate between driver and navigator roles. The driver controls the keyboard; the navigator watches, asks questions, and suggests ideas. Problem 4 (1 pt) Implement wpm, which computes the words per minute, a measure of typing speed, given a string typed and the amount of elapsed time in seconds. Despite its name, words per minute is not based on the number of words typed, but instead the number of groups of 5 characters, so that a typing test is not biased by the length of words. The formula for words per minute is the ratio of the number of characters (including spaces) typed divided by 5 (a typical word length) to the elapsed time in minutes. For example, the string &quot;I am glad!&quot; contains three words and ten characters (not including the quotation marks). The words per minute calculation uses 2 as the number of words typed (because 10 / 5 = 2). If someone typed this string in 30 seconds (half a minute), their speed would be 4 words per minute. Before writing any code, unlock the tests to verify your understanding of the question: 1python3 ok -q 04 -u✂️ Once you are done unlocking, begin implementing your solution. You can check your correctness with: 1python3 ok -q 04✂️ Time to test your typing speed! You can use the command line to test your typing speed on paragraphs about a particular topic. For example, the command below will load paragraphs about cats or kittens. See the run_typing_test function for the implementation if you’re curious (but it is defined for you). 1python3 cats.py -t cats kittens You can try out the web-based graphical user interface (GUI) using the following command. (You may have to use Ctrl+C or Cmd+C on your terminal to quit the GUI after you close the tab in your browser). 1python3 cats_gui.py To submit your Phase 1 checkpoint type: 1python3 ok --submit You can submit again once you’ve finished the whole project, and we will score only your latest submission, but please submit at least once before the checkpoint deadline (after finishing at least the Phase 1 questions) to receive credit for the checkpoint. 👩🏽‍💻👨🏿‍💻 Pair programming? This would be a good time to switch roles. Switching roles makes sure that you both benefit from the learning experience of being in each role. Phase 2: Autocorrect When students in the past have tried to implement the functions without thoroughly reading the problem description, they’ve often run into issues. 😱 Read each description thoroughly before starting to code. In the web-based GUI, there is an autocorrect button, but right now it doesn’t do anything. Let’s implement automatic correction of typos. Whenever the user presses the space bar, if the last word they typed doesn’t match a word in the dictionary but is close to one, then that similar word will be substituted for what they typed. Problem 5 (2 pts) Implement autocorrect, which takes a typed_word, a word_list, a diff_function, and a limit. If the typed_word is contained inside the word_list, autocorrect returns that word. Otherwise, autocorrect returns the word from word_list that has the lowest difference from the provided typed_word based on the diff_function. However, if the lowest difference between typed_word and any of the words in word_list is greater than limit, then typed_word is returned instead. Important: If typed_word is not contained inside word_list, and multiple strings have the same lowest difference from typed_word according to the diff_function, autocorrect should return the string that appears first in word_list. A diff function takes in three arguments. The first two arguments are the two strings to be compared (the typed_word and a word from word_list), and the third argument is the limit. The output of the diff function, which is a number, represents the amount of difference between the two strings. Here is an example of a diff function that computes the minimum of 1 + limit and the difference in length between the two input strings: 123456&gt;&gt;&gt; def length_diff(w1, w2, limit):... return min(limit + 1, abs(len(w2) - len(w1)))&gt;&gt;&gt; length_diff(&#x27;mellow&#x27;, &#x27;cello&#x27;, 10)1&gt;&gt;&gt; length_diff(&#x27;hippo&#x27;, &#x27;hippopotamus&#x27;, 5)6 Assume that typed_word and all elements of word_list are lowercase and have no punctuation. Hint: Try using max or min with the optional key argument. For some examples of using this argument, check out the lecture slides from Wednesday, February 16. Before writing any code, unlock the tests to verify your understanding of the question: 1python3 ok -q 05 -u✂️ Once you are done unlocking, begin implementing your solution. You can check your correctness with: 1python3 ok -q 05✂️ Problem 6 (3 pts) Implement sphinx_swaps, which is a diff function that takes two strings. It returns the minimum number of characters that must be changed in the start word in order to transform it into the goal word. If the strings are not of equal length, the difference in lengths is added to the total. Important: You may not use while, for, or list comprehensions in your implementation. Use recursion. Here are some examples: 1234567891011&gt;&gt;&gt; big_limit = 10&gt;&gt;&gt; sphinx_swaps(&quot;nice&quot;, &quot;rice&quot;, big_limit) # Substitute: n -&gt; r1&gt;&gt;&gt; sphinx_swaps(&quot;range&quot;, &quot;rungs&quot;, big_limit) # Substitute: a -&gt; u, e -&gt; s2&gt;&gt;&gt; sphinx_swaps(&quot;pill&quot;, &quot;pillage&quot;, big_limit) # Don&#x27;t substitute anything, length difference of 3.3&gt;&gt;&gt; sphinx_swaps(&quot;roses&quot;, &quot;arose&quot;, big_limit) # Substitute: r -&gt; a, o -&gt; r, s -&gt; o, e -&gt; s, s -&gt; e5&gt;&gt;&gt; sphinx_swaps(&quot;rose&quot;, &quot;hello&quot;, big_limit) # Substitute: r-&gt;h, o-&gt;e, s-&gt;l, e-&gt;l, length difference of 1.5 Important: If the number of characters that must change is greater than limit, then sphinx_swaps should return any number larger than limit and should minimize the amount of computation needed to do so. These two calls to sphinx_swaps should take about the same amount of time to evaluate: 12345&gt;&gt;&gt; limit = 4&gt;&gt;&gt; sphinx_swaps(&quot;roses&quot;, &quot;arose&quot;, limit) &gt; limitTrue&gt;&gt;&gt; sphinx_swaps(&quot;rosesabcdefghijklm&quot;, &quot;arosenopqrstuvwxyz&quot;, limit) &gt; limitTrue Before writing any code, unlock the tests to verify your understanding of the question: 1python3 ok -q 06 -u✂️ Once you are done unlocking, begin implementing your solution. You can check your correctness with: 1python3 ok -q 06✂️ Try turning on autocorrect in the GUI. Does it help you type faster? Are the corrections accurate? You should notice that inserting a letter or leaving one out near the beginning of a word is not handled well by this diff function. Let’s fix that! Problem 7 (3 pts) Implement minimum_mewtations, which is a diff function that returns the minimum number of edit operations needed to transform the start word into the goal word. There are three kinds of edit operations, with some examples: Add a letter to start. Adding &quot;k&quot; to &quot;itten&quot; gives us &quot;kitten&quot;. Remove a letter from start. Removing &quot;s&quot; from &quot;scat&quot; givs us &quot;cat&quot;. Substitute a letter in start for another. Substituting &quot;z&quot; with &quot;j&quot; in &quot;zaguar&quot; gives us &quot;jaguar&quot;. Each edit operation contributes 1 to the difference between two words. 1234567&gt;&gt;&gt; big_limit = 10&gt;&gt;&gt; minimum_mewtations(&quot;cats&quot;, &quot;scat&quot;, big_limit) # cats -&gt; scats -&gt; scat2&gt;&gt;&gt; minimum_mewtations(&quot;purng&quot;, &quot;purring&quot;, big_limit) # purng -&gt; purrng -&gt; purring2&gt;&gt;&gt; minimum_mewtations(&quot;ckiteus&quot;, &quot;kittens&quot;, big_limit) # ckiteus -&gt; kiteus -&gt; kitteus -&gt; kittens3 We have provided a template of an implementation in cats.py. Hint: This is a recursive function with three recursive calls. One of these recursive calls will be similar to the recursive call in sphinx_swaps. You may modify the template however you want or delete it entirely. Important: If the number of edits required is greater than limit, then minimum_mewtations should return any number larger than limit and should minimize the amount of computation needed to do so. These two calls to minimum_mewtations should take about the same amount of time to evaluate: 12345&gt;&gt;&gt; limit = 2&gt;&gt;&gt; minimum_mewtations(&quot;ckiteus&quot;, &quot;kittens&quot;, limit) &gt; limitTrue&gt;&gt;&gt; minimum_mewtations(&quot;ckiteusabcdefghijklm&quot;, &quot;kittensnopqrstuvwxyz&quot;, limit) &gt; limitTrue Before writing any code, unlock the tests to verify your understanding of the question: 1python3 ok -q 07 -u✂️ Once you are done unlocking, begin implementing your solution. You can check your correctness with: 1python3 ok -q 07✂️ Try typing again. Are the corrections more accurate? 1python3 cats_gui.py 👩🏽‍💻👨🏿‍💻 Pair programming? Celebrate, take a break, and switch roles! (Optional) Extension: final diff (0pt) You may optionally design your own diff function called final_diff. Here are some ideas for making even more accurate corrections: Take into account which additions and deletions are more likely than others. For example, it’s much more likely that you’ll accidentally leave out a letter if it appears twice in a row. Treat two adjacent letters that have swapped positions as one change, not two. Try to incorporate common misspellings. You can also set the limit you’d like your diff function to use by changing the value of the variable FINAL_DIFF_LIMIT in cats.py. You can check your final_diff’s success rate by running: 1python3 score.py If you don’t know where to start, try copy-pasting your code for sphinx_swaps and minimum_mewtations into final_diff and scoring them. Looking at the typos they accidentally fixed might give you some ideas! Phase 3: Multiplayer When students in the past have tried to implement the functions without thoroughly reading the problem description, they’ve often run into issues. 😱 Read each description thoroughly before starting to code. Typing is more fun with friends! You’ll now implement multiplayer functionality, so that when you run cats_gui.py on your computer, it connects to the course server at cats.cs61a.org and looks for someone else to race against. To race against a friend, 5 different programs will be running: Your GUI, which is a program that handles all the text coloring and display in your web browser. Your cats_gui.py, which is a web server that communicates with your GUI using the code you wrote in cats.py. Your opponent’s cats_gui.py. Your opponent’s GUI. The CS 61A multiplayer server, which matches players together and passes messages around. When you type, your GUI uploads what you have typed to your cats_gui.py server, which computes how much progress you have made and returns a progress update. It also uploads a progress update to the multiplayer server, so that your opponent’s GUI can display it. Meanwhile, your GUI display is always trying to keep current by asking for progress updates from cats_gui.py, which in turn requests that info from the multiplayer server. Each player has an id number that is used by the server to track typing progress. Problem 8 (2 pts) Implement report_progress, which is called every time the user finishes typing a word. It takes a list of the words sofar, a list of the words in the prompt, the user’s user_id, and a upload function that is used to upload a progress report to the multiplayer server. There will never be more words in sofar than in prompt. Your progress is a ratio of the words in the prompt that you have typed correctly, up to the first incorrect word, divided by the number of prompt words. For example, this example has a progress of 0.25: 1report_progress([&quot;Hello&quot;, &quot;ths&quot;, &quot;is&quot;], [&quot;Hello&quot;, &quot;this&quot;, &quot;is&quot;, &quot;wrong&quot;], ...) Your report_progress function should do two things: upload a message to the multiplayer server and return the progress of the player with user_id. You can upload a message to the multiplayer server by calling the upload function on a two-element dictionary containing the keys 'id' and 'progress'. You should then return the player’s progress, which is the ratio of words you computed. Hint: See the dictionary below for an example of a potential input into the upload function. This dictionary represents a player with user_id 1 and progress 0.6. 1&#123;&#x27;id&#x27;: 1, &#x27;progress&#x27;: 0.6&#125; Before writing any code, unlock the tests to verify your understanding of the question: 1python3 ok -q 08 -u✂️ Once you are done unlocking, begin implementing your solution. You can check your correctness with: 1python3 ok -q 08✂️ Problem 9 (2 pts) Implement time_per_word, which takes in a list words and times_per_player, a list of lists for each player with timestamps indicating when each player finished typing every individual word in words. It returns a match with the given information. A match is a dictionary that stores words and times. The times are stored as a list of lists of how long it took each player to type every word in words. Specifically, times[i][j] indicates how long it took player i to type words[j]. For example, say words = ['Hello', 'world'] and times = [[5, 1], [4, 2]], then [5, 1] corresponds to the list of times for player 0, and [4, 2] corresponds to the list of times for player 1. Thus, player 0 took 5 units of time to write the word 'Hello'. Important: Be sure to use the match constructor when returning a match. The tests will check that you are using the match dictionary rather than assuming a particular data format. Read the definitions for the match constructor in cats.py to learn more about how the dictionary is implemented. Timestamps are cumulative and always increasing, while the values in times are differences between consecutive timestamps for each player. Here’s an example: If times_per_player = [[1, 3, 5], [2, 5, 6]], the corresponding times attribute of the match would be [[2,2], [3, 1]]. This is because the differences in timestamps are (3-1), (5-3) for the first player and (5-2), (6-5) for the second player. The first value of each list within times_per_player represents the initial starting time for each player. Before writing any code, unlock the tests to verify your understanding of the question: 1python3 ok -q 09 -u✂️ Once you are done unlocking, begin implementing your solution. You can check your correctness with: 1python3 ok -q 09✂️ 👩🏽‍💻👨🏿‍💻 Pair programming? We suggest switching roles now, if you haven’t recently. Almost done! Problem 10 (2 pts) Implement fastest_words, which returns which words each player typed fastest. This function is called once both players have finished typing. It takes in a match. Specifically, the fastest_words function returns a list of lists of words, one list for each player, and within each list the words they typed the fastest (against all the other players). In the case of a tie, consider the earliest player in the list (the smallest player index) to be the one who typed it the fastest. For example consider the following match with the words ‘Just’, ‘have’, and ‘fun’. Player 0 typed ‘fun’ the fastest (3 seconds), Player 1 typed ‘Just’ the fastest (4 seconds), and they tied on the word ‘have’ (both took 1 second) so we consider to Player 0 to be the fastest, because they are the earliest player in the list. 1234&gt;&gt;&gt; player_0 = [5, 1, 3]&gt;&gt;&gt; player_1 = [4, 1, 6]&gt;&gt;&gt; fastest_words(match([&#x27;Just&#x27;, &#x27;have&#x27;, &#x27;fun&#x27;], [player_0, player_1]))[[&#x27;have&#x27;, &#x27;fun&#x27;], [&#x27;Just&#x27;]] The match argument is a match dictionary, like the one returned in Problem 9. You can access words in the match with the selector word_at, which takes in a match and the word_index (an integer). With word_at you can access the time it took any player to type any word using time. Important: Be sure to use the match constructor when returning a match. The tests will check that you are using the match dictionary rather than assuming a particular data format. Make sure your implementation does not mutate the given player input lists. For the example above, calling fastest_words on [player_0, player_1] should not mutate player_0 or player_1. Before writing any code, unlock the tests to verify your understanding of the question: 1python3 ok -q 10 -u✂️ Once you are done unlocking, begin implementing your solution. You can check your correctness with: 1python3 ok -q 10✂️ Congratulations! Now you can play against other students in the course. Set enable_multiplayer to True near the bottom of cats.py and type swiftly! 1python3 cats_gui.py At this point, run the entire autograder to see if there are any tests that don’t pass. 1python3 ok Once you are satisfied, submit to Ok to complete the project. 1python3 ok --submit If you have a partner, make sure to add them to the submission on okpy. Check to make sure that you did all the problems by running: 1python3 ok --score Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458&quot;&quot;&quot;Typing test implementation&quot;&quot;&quot;from utils import lower, split, remove_punctuation, lines_from_filefrom ucb import main, interact, tracefrom datetime import datetime############ Phase 1 ############def choose(paragraphs, select, k): &quot;&quot;&quot;Return the Kth paragraph from PARAGRAPHS for which SELECT called on the paragraph returns True. If there are fewer than K such paragraphs, return the empty string. Arguments: paragraphs: a list of strings select: a function that returns True for paragraphs that can be selected k: an integer &gt;&gt;&gt; ps = [&#x27;hi&#x27;, &#x27;how are you&#x27;, &#x27;fine&#x27;] &gt;&gt;&gt; s = lambda p: len(p) &lt;= 4 &gt;&gt;&gt; choose(ps, s, 0) &#x27;hi&#x27; &gt;&gt;&gt; choose(ps, s, 1) &#x27;fine&#x27; &gt;&gt;&gt; choose(ps, s, 2) &#x27;&#x27; &quot;&quot;&quot; # BEGIN PROBLEM 1 idx = 0 cnt = -1 while idx &lt; len(paragraphs): if select(paragraphs[idx]): cnt += 1 if cnt == k: return paragraphs[idx] idx += 1 return &#x27;&#x27; # END PROBLEM 1def about(topic): &quot;&quot;&quot;Return a select function that returns whether a paragraph contains one of the words in TOPIC. Arguments: topic: a list of words related to a subject &gt;&gt;&gt; about_dogs = about([&#x27;dog&#x27;, &#x27;dogs&#x27;, &#x27;pup&#x27;, &#x27;puppy&#x27;]) &gt;&gt;&gt; choose([&#x27;Cute Dog!&#x27;, &#x27;That is a cat.&#x27;, &#x27;Nice pup!&#x27;], about_dogs, 0) &#x27;Cute Dog!&#x27; &gt;&gt;&gt; choose([&#x27;Cute Dog!&#x27;, &#x27;That is a cat.&#x27;, &#x27;Nice pup.&#x27;], about_dogs, 1) &#x27;Nice pup.&#x27; &quot;&quot;&quot; assert all([lower(x) == x for x in topic]), &#x27;topics should be lowercase.&#x27; # BEGIN PROBLEM 2 def helper(paragraphs): for item in split(lower(remove_punctuation(paragraphs))): if item in topic: return True return False return helper # END PROBLEM 2def accuracy(typed, reference): &quot;&quot;&quot;Return the accuracy (percentage of words typed correctly) of TYPED when compared to the prefix of REFERENCE that was typed. Arguments: typed: a string that may contain typos reference: a string without errors &gt;&gt;&gt; accuracy(&#x27;Cute Dog!&#x27;, &#x27;Cute Dog.&#x27;) 50.0 &gt;&gt;&gt; accuracy(&#x27;A Cute Dog!&#x27;, &#x27;Cute Dog.&#x27;) 0.0 &gt;&gt;&gt; accuracy(&#x27;cute Dog.&#x27;, &#x27;Cute Dog.&#x27;) 50.0 &gt;&gt;&gt; accuracy(&#x27;Cute Dog. I say!&#x27;, &#x27;Cute Dog.&#x27;) 50.0 &gt;&gt;&gt; accuracy(&#x27;Cute&#x27;, &#x27;Cute Dog.&#x27;) 100.0 &gt;&gt;&gt; accuracy(&#x27;&#x27;, &#x27;Cute Dog.&#x27;) 0.0 &gt;&gt;&gt; accuracy(&#x27;&#x27;, &#x27;&#x27;) 100.0 &quot;&quot;&quot; typed_words = split(typed) reference_words = split(reference) # BEGIN PROBLEM 3 if len(typed_words) == len(reference_words) == 0: return 100.0 elif len(typed_words) == 0: return 0.0 correct = 0 for x, y in zip(typed_words, reference_words): if x == y: correct += 1 return correct / len(typed_words) * 100.0 # END PROBLEM 3def wpm(typed, elapsed): &quot;&quot;&quot;Return the words-per-minute (WPM) of the TYPED string. Arguments: typed: an entered string elapsed: an amount of time in seconds &gt;&gt;&gt; wpm(&#x27;hello friend hello buddy hello&#x27;, 15) 24.0 &gt;&gt;&gt; wpm(&#x27;0123456789&#x27;,60) 2.0 &quot;&quot;&quot; assert elapsed &gt; 0, &#x27;Elapsed time must be positive&#x27; # BEGIN PROBLEM 4 if len(typed) == 0: return 0.0 cnt = len(typed) / 5.0 res = cnt / elapsed * 60 return res # END PROBLEM 4############ Phase 2 ############def autocorrect(typed_word, word_list, diff_function, limit): &quot;&quot;&quot;Returns the element of WORD_LIST that has the smallest difference from TYPED_WORD. Instead returns TYPED_WORD if that difference is greater than LIMIT. Arguments: typed_word: a string representing a word that may contain typos word_list: a list of strings representing reference words diff_function: a function quantifying the difference between two words limit: a number &gt;&gt;&gt; ten_diff = lambda w1, w2, limit: 10 # Always returns 10 &gt;&gt;&gt; autocorrect(&quot;hwllo&quot;, [&quot;butter&quot;, &quot;hello&quot;, &quot;potato&quot;], ten_diff, 20) &#x27;butter&#x27; &gt;&gt;&gt; first_diff = lambda w1, w2, limit: (1 if w1[0] != w2[0] else 0) # Checks for matching first char &gt;&gt;&gt; autocorrect(&quot;tosting&quot;, [&quot;testing&quot;, &quot;asking&quot;, &quot;fasting&quot;], first_diff, 10) &#x27;testing&#x27; &quot;&quot;&quot; # BEGIN PROBLEM 5 if typed_word in word_list: return typed_word diff_list = [diff_function(typed_word, word, limit) for word in word_list] if min(diff_list) &gt; limit: return typed_word return word_list[diff_list.index(min(diff_list))] # END PROBLEM 5def sphinx_swaps(start, goal, limit): &quot;&quot;&quot;A diff function for autocorrect that determines how many letters in START need to be substituted to create GOAL, then adds the difference in their lengths and returns the result. Arguments: start: a starting word goal: a string representing a desired goal word limit: a number representing an upper bound on the number of chars that must change &gt;&gt;&gt; big_limit = 10 &gt;&gt;&gt; sphinx_swaps(&quot;nice&quot;, &quot;rice&quot;, big_limit) # Substitute: n -&gt; r 1 &gt;&gt;&gt; sphinx_swaps(&quot;range&quot;, &quot;rungs&quot;, big_limit) # Substitute: a -&gt; u, e -&gt; s 2 &gt;&gt;&gt; sphinx_swaps(&quot;pill&quot;, &quot;pillage&quot;, big_limit) # Don&#x27;t substitute anything, length difference of 3. 3 &gt;&gt;&gt; sphinx_swaps(&quot;roses&quot;, &quot;arose&quot;, big_limit) # Substitute: r -&gt; a, o -&gt; r, s -&gt; o, e -&gt; s, s -&gt; e 5 &gt;&gt;&gt; sphinx_swaps(&quot;rose&quot;, &quot;hello&quot;, big_limit) # Substitute: r-&gt;h, o-&gt;e, s-&gt;l, e-&gt;l, length difference of 1. 5 &quot;&quot;&quot; # BEGIN PROBLEM 6 def counts(curr_start, curr_goal, cnt): if cnt &gt; limit: return limit + 1 if not curr_start and not curr_goal: return cnt elif not curr_start or not curr_goal: return counts(curr_start[1:], curr_goal[1:], cnt + 1) elif curr_start[0] == curr_goal[0]: return counts(curr_start[1:], curr_goal[1:], cnt) else: return counts(curr_start[1:], curr_goal[1:], cnt + 1) return counts(start, goal, 0) # END PROBLEM 6def minimum_mewtations(start, goal, limit): &quot;&quot;&quot;A diff function that computes the edit distance from START to GOAL. This function takes in a string START, a string GOAL, and a number LIMIT. Arguments: start: a starting word goal: a goal word limit: a number representing an upper bound on the number of edits &gt;&gt;&gt; big_limit = 10 &gt;&gt;&gt; minimum_mewtations(&quot;cats&quot;, &quot;scat&quot;, big_limit) # cats -&gt; scats -&gt; scat 2 &gt;&gt;&gt; minimum_mewtations(&quot;purng&quot;, &quot;purring&quot;, big_limit) # purng -&gt; purrng -&gt; purring 2 &gt;&gt;&gt; minimum_mewtations(&quot;ckiteus&quot;, &quot;kittens&quot;, big_limit) # ckiteus -&gt; kiteus -&gt; kitteus -&gt; kittens 3 &quot;&quot;&quot; # assert False, &#x27;Remove this line&#x27; if limit &lt; 0: return 0 if not start and not goal: # Fill in the condition # BEGIN return 0 # END elif not start or not goal: # Feel free to remove or add additional cases # BEGIN return abs(len(start) - len(goal)) # END elif start[0] == goal[0]: # Feel free to remove or add additional cases # BEGIN return minimum_mewtations(start[1:], goal[1:], limit) # END else: add = minimum_mewtations(start, goal[1:], limit - 1) # Fill in these lines remove = minimum_mewtations(start[1:], goal, limit - 1) substitute = minimum_mewtations(start[1:], goal[1:], limit - 1) # BEGIN return min(add, remove, substitute) + 1 # ENDdef final_diff(start, goal, limit): &quot;&quot;&quot;A diff function that takes in a string START, a string GOAL, and a number LIMIT. If you implement this function, it will be used.&quot;&quot;&quot; # assert False, &#x27;Remove this line to use your final_diff function.&#x27; return minimum_mewtations(start, goal, limit)FINAL_DIFF_LIMIT = 6 # REPLACE THIS WITH YOUR LIMIT############ Phase 3 ############def report_progress(sofar, prompt, user_id, upload): &quot;&quot;&quot;Upload a report of your id and progress so far to the multiplayer server. Returns the progress so far. Arguments: sofar: a list of the words input so far prompt: a list of the words in the typing prompt user_id: a number representing the id of the current user upload: a function used to upload progress to the multiplayer server &gt;&gt;&gt; print_progress = lambda d: print(&#x27;ID:&#x27;, d[&#x27;id&#x27;], &#x27;Progress:&#x27;, d[&#x27;progress&#x27;]) &gt;&gt;&gt; # The above function displays progress in the format ID: __, Progress: __ &gt;&gt;&gt; print_progress(&#123;&#x27;id&#x27;: 1, &#x27;progress&#x27;: 0.6&#125;) ID: 1 Progress: 0.6 &gt;&gt;&gt; sofar = [&#x27;how&#x27;, &#x27;are&#x27;, &#x27;you&#x27;] &gt;&gt;&gt; prompt = [&#x27;how&#x27;, &#x27;are&#x27;, &#x27;you&#x27;, &#x27;doing&#x27;, &#x27;today&#x27;] &gt;&gt;&gt; report_progress(sofar, prompt, 2, print_progress) ID: 2 Progress: 0.6 0.6 &gt;&gt;&gt; report_progress([&#x27;how&#x27;, &#x27;aree&#x27;], prompt, 3, print_progress) ID: 3 Progress: 0.2 0.2 &quot;&quot;&quot; # BEGIN PROBLEM 8 count = 0 for i in range(len(sofar)): if sofar[i] != prompt[i]: break count += 1 progress = count / len(prompt) upload(&#123;&#x27;id&#x27;: user_id, &#x27;progress&#x27;: progress&#125;) return progress # END PROBLEM 8def time_per_word(words, times_per_player): &quot;&quot;&quot;Given timing data, return a match dictionary, which contains a list of words and the amount of time each player took to type each word. Arguments: words: a list of words, in the order they are typed. times_per_player: A list of lists of timestamps including the time the player started typing, followed by the time the player finished typing each word. &gt;&gt;&gt; p = [[75, 81, 84, 90, 92], [19, 29, 35, 36, 38]] &gt;&gt;&gt; match = time_per_word([&#x27;collar&#x27;, &#x27;plush&#x27;, &#x27;blush&#x27;, &#x27;repute&#x27;], p) &gt;&gt;&gt; match[&quot;words&quot;] [&#x27;collar&#x27;, &#x27;plush&#x27;, &#x27;blush&#x27;, &#x27;repute&#x27;] &gt;&gt;&gt; match[&quot;times&quot;] [[6, 3, 6, 2], [10, 6, 1, 2]] &quot;&quot;&quot; # BEGIN PROBLEM 9 match = &#123;&#125; match[&quot;words&quot;] = words times = [] for i in range(len(times_per_player)): times.append([]) for j in range(len(times_per_player[i]) - 1): times[i].append(times_per_player[i][j + 1] - times_per_player[i][j]) match[&quot;times&quot;] = times return match # END PROBLEM 9def fastest_words(match): &quot;&quot;&quot;Return a list of lists of which words each player typed fastest. Arguments: match: a match dictionary as returned by time_per_word. &gt;&gt;&gt; p0 = [5, 1, 3] &gt;&gt;&gt; p1 = [4, 1, 6] &gt;&gt;&gt; fastest_words(match([&#x27;Just&#x27;, &#x27;have&#x27;, &#x27;fun&#x27;], [p0, p1])) [[&#x27;have&#x27;, &#x27;fun&#x27;], [&#x27;Just&#x27;]] &gt;&gt;&gt; p0 # input lists should not be mutated [5, 1, 3] &gt;&gt;&gt; p1 [4, 1, 6] &quot;&quot;&quot; player_indices = range(len(match[&quot;times&quot;])) # contains an *index* for each player word_indices = range(len(match[&quot;words&quot;])) # contains an *index* for each word # BEGIN PROBLEM 10 res = [] for _ in range(len(player_indices)): res.append([]) for idx in range(len(word_indices)): min_time = match[&quot;times&quot;][0][idx] min_idx = 0 for i in range(len(player_indices)): if match[&quot;times&quot;][i][idx] &lt; min_time: min_time = match[&quot;times&quot;][i][idx] min_idx = i res[min_idx].append(match[&quot;words&quot;][idx]) return res # END PROBLEM 10def match(words, times): &quot;&quot;&quot;A dictionary containing all words typed and their times. Arguments: words: A list of strings, each string representing a word typed. times: A list of lists for how long it took for each player to type each word. times[i][j] = time it took for player i to type words[j]. Example input: words: [&#x27;Hello&#x27;, &#x27;world&#x27;] times: [[5, 1], [4, 2]] &quot;&quot;&quot; assert all([type(w) == str for w in words]), &#x27;words should be a list of strings&#x27; assert all([type(t) == list for t in times]), &#x27;times should be a list of lists&#x27; assert all([isinstance(i, (int, float)) for t in times for i in t]), &#x27;times lists should contain numbers&#x27; assert all([len(t) == len(words) for t in times]), &#x27;There should be one word per time.&#x27; return &#123;&quot;words&quot;: words, &quot;times&quot;: times&#125;def word_at(match, word_index): &quot;&quot;&quot;A utility function that gets the word with index word_index&quot;&quot;&quot; assert 0 &lt;= word_index &lt; len(match[&quot;words&quot;]), &quot;word_index out of range of words&quot; return match[&quot;words&quot;][word_index]def time(match, player_num, word_index): &quot;&quot;&quot;A utility function for the time it took player_num to type the word at word_index&quot;&quot;&quot; assert word_index &lt; len(match[&quot;words&quot;]), &quot;word_index out of range of words&quot; assert player_num &lt; len(match[&quot;times&quot;]), &quot;player_num out of range of players&quot; return match[&quot;times&quot;][player_num][word_index]def match_string(match): &quot;&quot;&quot;A helper function that takes in a match dictionary and returns a string representation of it&quot;&quot;&quot; return f&quot;match(&#123;match[&#x27;words&#x27;]&#125;, &#123;match[&#x27;times&#x27;]&#125;)&quot;enable_multiplayer = False # Change to True when you&#x27;re ready to race.########################### Command Line Interface ###########################def run_typing_test(topics): &quot;&quot;&quot;Measure typing speed and accuracy on the command line.&quot;&quot;&quot; paragraphs = lines_from_file(&#x27;data/sample_paragraphs.txt&#x27;) select = lambda p: True if topics: select = about(topics) i = 0 while True: reference = choose(paragraphs, select, i) if not reference: print(&#x27;No more paragraphs about&#x27;, topics, &#x27;are available.&#x27;) return print(&#x27;Type the following paragraph and then press enter/return.&#x27;) print(&#x27;If you only type part of it, you will be scored only on that part.\\n&#x27;) print(reference) print() start = datetime.now() typed = input() if not typed: print(&#x27;Goodbye.&#x27;) return print() elapsed = (datetime.now() - start).total_seconds() print(&quot;Nice work!&quot;) print(&#x27;Words per minute:&#x27;, wpm(typed, elapsed)) print(&#x27;Accuracy: &#x27;, accuracy(typed, reference)) print(&#x27;\\nPress enter/return for the next paragraph or type q to quit.&#x27;) if input().strip() == &#x27;q&#x27;: return i += 1@maindef run(*args): &quot;&quot;&quot;Read in the command-line argument and calls corresponding functions.&quot;&quot;&quot; import argparse parser = argparse.ArgumentParser(description=&quot;Typing Test&quot;) parser.add_argument(&#x27;topic&#x27;, help=&quot;Topic word&quot;, nargs=&#x27;*&#x27;) parser.add_argument(&#x27;-t&#x27;, help=&quot;Run typing test&quot;, action=&#x27;store_true&#x27;) args = parser.parse_args() if args.t: run_typing_test(args.topic)","categories":[],"tags":[{"name":"CS61A","slug":"CS61A","permalink":"http://www.misaka-9982.com/tags/CS61A/"}]},{"title":"CS61A Lab 8","slug":"CS61A-Lab-8","date":"2022-05-23T09:02:28.000Z","updated":"2022-05-24T11:27:39.749Z","comments":true,"path":"2022/05/23/CS61A-Lab-8/","link":"","permalink":"http://www.misaka-9982.com/2022/05/23/CS61A-Lab-8/","excerpt":"","text":"Lab 8: Midterm Review lab08.zip Due by 11:59pm on Wednesday, March 16. Starter Files Download lab08.zip. Inside the archive, you will find starter files for the questions in this lab, along with a copy of the Ok autograder. Topics Consult this section if you need a refresher on the material for this lab. It’s okay to skip directly to the questions and refer back here should you get stuck. Iterators Generators Required Questions Iterators &amp; Generators Q1: Repeated Implement repeated, which takes in an iterator t and returns the first value in t that appears k times in a row. Note: You can assume that the iterator t will have a value that appears at least k times in a row. If you are receiving a StopIteration, your repeated function is likely not identifying the correct value. Your implementation should iterate through the items in a way such that if the same iterator is passed into repeated twice, it should continue in the second call at the point it left off in the first. An example of this behavior is in the doctests. 1234567891011121314151617181920212223242526272829303132def repeated(t, k): &quot;&quot;&quot;Return the first value in iterator T that appears K times in a row. Iterate through the items such that if the same iterator is passed into the function twice, it continues in the second call at the point it left off in the first. &gt;&gt;&gt; s = iter([10, 9, 10, 9, 9, 10, 8, 8, 8, 7]) &gt;&gt;&gt; repeated(s, 2) 9 &gt;&gt;&gt; s2 = iter([10, 9, 10, 9, 9, 10, 8, 8, 8, 7]) &gt;&gt;&gt; repeated(s2, 3) 8 &gt;&gt;&gt; s = iter([3, 2, 2, 2, 1, 2, 1, 4, 4, 5, 5, 5]) &gt;&gt;&gt; repeated(s, 3) 2 &gt;&gt;&gt; repeated(s, 3) 5 &gt;&gt;&gt; s2 = iter([4, 1, 6, 6, 7, 7, 8, 8, 2, 2, 2, 5]) &gt;&gt;&gt; repeated(s2, 3) 2 &quot;&quot;&quot; assert k &gt; 1 &quot;*** YOUR CODE HERE ***&quot; cnt, prev = 1, next(t) for item in t: if item == prev: cnt += 1 if cnt == k: return item else: cnt = 1 prev = item Use Ok to test your code: 1python3 ok -q repeated✂️ Q2: Merge Implement merge(incr_a, incr_b), which takes two iterables incr_a and incr_b whose elements are ordered. merge yields elements from incr_a and incr_b in sorted order, eliminating repetition. You may assume incr_a and incr_b themselves do not contain repeats, and that none of the elements of either are None. You may not assume that the iterables are finite; either may produce an infinite stream of results. You will probably find it helpful to use the two-argument version of the built-in next function: next(incr, v) is the same as next(incr), except that instead of raising StopIteration when incr runs out of elements, it returns v. See the doctest for examples of behavior. 12345678910111213141516171819202122232425262728293031323334353637383940def merge(incr_a, incr_b): &quot;&quot;&quot;Yield the elements of strictly increasing iterables incr_a and incr_b, removing repeats. Assume that incr_a and incr_b have no repeats. incr_a or incr_b may or may not be infinite sequences. &gt;&gt;&gt; m = merge([0, 2, 4, 6, 8, 10, 12, 14], [0, 3, 6, 9, 12, 15]) &gt;&gt;&gt; type(m) &lt;class &#x27;generator&#x27;&gt; &gt;&gt;&gt; list(m) [0, 2, 3, 4, 6, 8, 9, 10, 12, 14, 15] &gt;&gt;&gt; def big(n): ... k = 0 ... while True: yield k; k += n &gt;&gt;&gt; m = merge(big(2), big(3)) &gt;&gt;&gt; [next(m) for _ in range(11)] [0, 2, 3, 4, 6, 8, 9, 10, 12, 14, 15] &quot;&quot;&quot; iter_a, iter_b = iter(incr_a), iter(incr_b) next_a, next_b = next(iter_a, None), next(iter_b, None) &quot;*** YOUR CODE HERE ***&quot; while next_a is not None and next_b is not None: val_a, val_b = next_a, next_b if val_a == val_b: yield next_a next_a, next_b = next(iter_a, None), next(iter_b, None) elif val_a &lt; val_b: yield next_a next_a = next(iter_a, None) else: yield next_b next_b = next(iter_b, None) # incr_a is not empty while next_a: yield next_a next_a = next(iter_a, None) # incr_b is not empty while next_b: yield next_b next_b = next(iter_b, None) Use Ok to test your code: 1python3 ok -q merge✂️ Linked Lists &amp; Trees Q3: Deep Linked List Length A linked list that contains one or more linked lists as elements is called a deep linked list. Write a function deep_len that takes in a (possibly deep) linked list and returns the deep length of that linked list. The deep length of a linked list is the total number of non-link elements in the list, as well as the total number of elements contained in all contained lists. See the function’s doctests for examples of the deep length of linked lists. Hint: Use isinstance to check if something is an instance of an object. 1234567891011121314151617181920def deep_len(lnk): &quot;&quot;&quot; Returns the deep length of a possibly deep linked list. &gt;&gt;&gt; deep_len(Link(1, Link(2, Link(3)))) 3 &gt;&gt;&gt; deep_len(Link(Link(1, Link(2)), Link(3, Link(4)))) 4 &gt;&gt;&gt; levels = Link(Link(Link(1, Link(2)), \\ Link(3)), Link(Link(4), Link(5))) &gt;&gt;&gt; print(levels) &lt;&lt;&lt;1 2&gt; 3&gt; &lt;4&gt; 5&gt; &gt;&gt;&gt; deep_len(levels) 5 &quot;&quot;&quot; if lnk == Link.empty: return 0 elif not isinstance(lnk, Link): return 1 else: return deep_len(lnk.first) + deep_len(lnk.rest) Use Ok to test your code: 1python3 ok -q deep_len✂️ Q4: Add Leaves Implement add_d_leaves, a function that takes in a Tree instance t and a number v. We define the depth of a node in t to be the number of edges from the root to that node. The depth of root is therefore 0. For each node in the tree, you should add d leaves to it, where d is the depth of the node. Every added leaf should have a label of v. If the node at this depth has existing branches, you should add these leaves to the end of that list of branches. For example, you should be adding 1 leaf with label v to each node at depth 1, 2 leaves to each node at depth 2, and so on. Here is an example of a tree t(shown on the left) and the result after add_d_leaves is applied with v as 5. Try drawing out the second doctest to visualize how the function is mutating t3. Hint: Use a helper function to keep track of the depth! 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172def add_d_leaves(t, v): &quot;&quot;&quot;Add d leaves containing v to each node at every depth d. &gt;&gt;&gt; t_one_to_four = Tree(1, [Tree(2), Tree(3, [Tree(4)])]) &gt;&gt;&gt; print(t_one_to_four) 1 2 3 4 &gt;&gt;&gt; add_d_leaves(t_one_to_four, 5) &gt;&gt;&gt; print(t_one_to_four) 1 2 5 3 4 5 5 5 &gt;&gt;&gt; t1 = Tree(1, [Tree(3)]) &gt;&gt;&gt; add_d_leaves(t1, 4) &gt;&gt;&gt; t1 Tree(1, [Tree(3, [Tree(4)])]) &gt;&gt;&gt; t2 = Tree(2, [Tree(5), Tree(6)]) &gt;&gt;&gt; t3 = Tree(3, [t1, Tree(0), t2]) &gt;&gt;&gt; print(t3) 3 1 3 4 0 2 5 6 &gt;&gt;&gt; add_d_leaves(t3, 10) &gt;&gt;&gt; print(t3) 3 1 3 4 10 10 10 10 10 10 0 10 2 5 10 10 6 10 10 10 &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; def dfs(root, depth, v): if root.is_leaf(): for _ in range(depth): root.branches.append(Tree(v)) return for b in root.branches: dfs(b, depth + 1, v) for _ in range(depth): root.branches.append(Tree(v)) dfs(t, 0, v) Use Ok to test your code: 1python3 ok -q add_d_leaves✂️ Efficiency Q5: Efficiency Practice Choose the term that fills in the blank for the functions defined below: &lt;function&gt; runs in ____ time in the length of its input. Constant Logarithmic Linear Quadratic Exponential None of these Assume that len runs in constant time and all runs in linear time in the length of its input. Selecting an element of a list by its index requires constant time. Constructing a range requires constant time. 1234567891011121314151617181920212223242526272829303132def count_partitions(n, m): &quot;&quot;&quot;Counts the number of partitions of a positive integer n, using parts up to size m.&quot;&quot;&quot; if n == 0: return 1 elif n &lt; 0: return 0 elif m == 0: return 0 else: with_m = count_partitions(n-m, m) without_m = count_partitions(n, m-1) return with_m + without_mdef is_palindrome(s): &quot;&quot;&quot;Return whether a list of numbers s is a palindrome.&quot;&quot;&quot; return all([s[i] == s[len(s) - i - 1] for i in range(len(s))])def binary_search(lst, n): &quot;&quot;&quot;Takes in a sorted list lst and returns the index where integer n is contained in lst. Returns -1 if n does not exist in lst.&quot;&quot;&quot; low = 0 high = len(lst) while low &lt;= high: middle = (low + high) // 2 if lst[middle] == n: return middle elif n &lt; lst[middle]: high = middle - 1 else: low = middle + 1 return -1 The is_palindrome question was reformatted from question 6(d) on fall 2019’s final. Use Ok to test your understanding: 123456789101112131415161718192021222324252627282930313233343536373839404142434445python3 ok -q efficiency_practice -uQ: The count_partitions function runs in ____ time in the length of its input.Choose the number of the correct choice:0) Quadratic1) None of these2) Constant3) Logarithmic4) Linear5) Exponential? 5-- OK! -----------------------------------------------------------------------efficiency_practice &gt; Suite 1 &gt; Case 2(cases remaining: 2)Q: The is_palindrome function runs in ____ time in the length of its input.Choose the number of the correct choice:0) Linear1) Quadratic2) None of these3) Exponential4) Constant5) Logarithmic? 0-- OK! -----------------------------------------------------------------------efficiency_practice &gt; Suite 1 &gt; Case 3(cases remaining: 1)Q: The binary_search function runs in ____ time in the length of its input.Choose the number of the correct choice:0) Linear1) Logarithmic2) Constant3) None of these4) Exponential5) Quadratic? 1-- OK! -----------------------------------------------------------------------OK! All cases for efficiency_practice unlocked. Submit Make sure to submit this assignment by running: 1python3 ok --submit Extra Practice Recursion and Tree Recursion Q6: Subsequences A subsequence of a sequence S is a subset of elements from S, in the same order they appear in S. Consider the list [1, 2, 3]. Here are a few of it’s subsequences [], [1, 3], [2], and [1, 2, 3]. Write a function that takes in a list and returns all possible subsequences of that list. The subsequences should be returned as a list of lists, where each nested list is a subsequence of the original input. In order to accomplish this, you might first want to write a function insert_into_all that takes an item and a list of lists, adds the item to the beginning of each nested list, and returns the resulting list. 1234567891011121314151617181920212223242526def insert_into_all(item, nested_list): &quot;&quot;&quot;Return a new list consisting of all the lists in nested_list, but with item added to the front of each. You can assume that nested_list is a list of lists. &gt;&gt;&gt; nl = [[], [1, 2], [3]] &gt;&gt;&gt; insert_into_all(0, nl) [[0], [0, 1, 2], [0, 3]] &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot;def subseqs(s): &quot;&quot;&quot;Return a nested list (a list of lists) of all subsequences of S. The subsequences can appear in any order. You can assume S is a list. &gt;&gt;&gt; seqs = subseqs([1, 2, 3]) &gt;&gt;&gt; sorted(seqs) [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]] &gt;&gt;&gt; subseqs([]) [[]] &quot;&quot;&quot; if len(s) &lt;= 1: return [[], s] if s != [] else [[]] else: tmp = subseqs(s[1:]) return insert_into_all(s[0], tmp) + tmp Use Ok to test your code: 1python3 ok -q subseqs✂️ Q7: Non-Decreasing Subsequences Just like the last question, we want to write a function that takes a list and returns a list of lists, where each individual list is a subsequence of the original input. This time we have another condition: we only want the subsequences for which consecutive elements are nondecreasing. For example, [1, 3, 2] is a subsequence of [1, 3, 2, 4], but since 2 &lt; 3, this subsequence would not be included in our result. Fill in the blanks to complete the implementation of the non_decrease_subseqs function. You may assume that the input list contains no negative elements. You may use the provided helper function insert_into_all, which takes in an item and a list of lists and inserts the item to the front of each list. 123456789101112131415161718192021222324def non_decrease_subseqs(s): &quot;&quot;&quot;Assuming that S is a list, return a nested list of all subsequences of S (a list of lists) for which the elements of the subsequence are strictly nondecreasing. The subsequences can appear in any order. &gt;&gt;&gt; seqs = non_decrease_subseqs([1, 3, 2]) &gt;&gt;&gt; sorted(seqs) [[], [1], [1, 2], [1, 3], [2], [3]] &gt;&gt;&gt; non_decrease_subseqs([]) [[]] &gt;&gt;&gt; seqs2 = non_decrease_subseqs([1, 1, 2]) &gt;&gt;&gt; sorted(seqs2) [[], [1], [1], [1, 1], [1, 1, 2], [1, 2], [1, 2], [2]] &quot;&quot;&quot; def subseq_helper(s, prev): if not s: return ____________________ elif s[0] &lt; prev: return ____________________ else: a = ______________________ b = ______________________ return insert_into_all(________, ______________) + ________________ return subseq_helper(____, ____) Use Ok to test your code: 1python3 ok -q non_decrease_subseqs✂️ Mutable Lists Q8: Shuffle Define a function shuffle that takes a sequence with an even number of elements (cards) and creates a new list that interleaves the elements of the first half with the elements of the second half. To interleave two sequences s0 and s1 is to create a new sequence such that the new sequence contains (in this order) the first element of s0, the first element of s1, the second element of s0, the second element of s1, and so on. If the two lists are not the same length, then the leftover elements of the longer list should still appear at the end. Note: If you’re running into an issue where the special heart / diamond / spades / clubs symbols are erroring in the doctests, feel free to copy paste the below doctests into your file as these don’t use the special characters and should not give an “illegal multibyte sequence” error. 12345678910111213141516171819202122232425262728293031def card(n): &quot;&quot;&quot;Return the playing card numeral as a string for a positive n &lt;= 13.&quot;&quot;&quot; assert type(n) == int and n &gt; 0 and n &lt;= 13, &quot;Bad card n&quot; specials = &#123;1: &#x27;A&#x27;, 11: &#x27;J&#x27;, 12: &#x27;Q&#x27;, 13: &#x27;K&#x27;&#125; return specials.get(n, str(n))def shuffle(cards): &quot;&quot;&quot;Return a shuffled list that interleaves the two halves of cards. &gt;&gt;&gt; shuffle(range(6)) [0, 3, 1, 4, 2, 5] &gt;&gt;&gt; suits = [&#x27;H&#x27;, &#x27;D&#x27;, &#x27;S&#x27;, &#x27;C&#x27;] &gt;&gt;&gt; cards = [card(n) + suit for n in range(1,14) for suit in suits] &gt;&gt;&gt; cards[:12] [&#x27;AH&#x27;, &#x27;AD&#x27;, &#x27;AS&#x27;, &#x27;AC&#x27;, &#x27;2H&#x27;, &#x27;2D&#x27;, &#x27;2S&#x27;, &#x27;2C&#x27;, &#x27;3H&#x27;, &#x27;3D&#x27;, &#x27;3S&#x27;, &#x27;3C&#x27;] &gt;&gt;&gt; cards[26:30] [&#x27;7S&#x27;, &#x27;7C&#x27;, &#x27;8H&#x27;, &#x27;8D&#x27;] &gt;&gt;&gt; shuffle(cards)[:12] [&#x27;AH&#x27;, &#x27;7S&#x27;, &#x27;AD&#x27;, &#x27;7C&#x27;, &#x27;AS&#x27;, &#x27;8H&#x27;, &#x27;AC&#x27;, &#x27;8D&#x27;, &#x27;2H&#x27;, &#x27;8S&#x27;, &#x27;2D&#x27;, &#x27;8C&#x27;] &gt;&gt;&gt; shuffle(shuffle(cards))[:12] [&#x27;AH&#x27;, &#x27;4D&#x27;, &#x27;7S&#x27;, &#x27;10C&#x27;, &#x27;AD&#x27;, &#x27;4S&#x27;, &#x27;7C&#x27;, &#x27;JH&#x27;, &#x27;AS&#x27;, &#x27;4C&#x27;, &#x27;8H&#x27;, &#x27;JD&#x27;] &gt;&gt;&gt; cards[:12] # Should not be changed [&#x27;AH&#x27;, &#x27;AD&#x27;, &#x27;AS&#x27;, &#x27;AC&#x27;, &#x27;2H&#x27;, &#x27;2D&#x27;, &#x27;2S&#x27;, &#x27;2C&#x27;, &#x27;3H&#x27;, &#x27;3D&#x27;, &#x27;3S&#x27;, &#x27;3C&#x27;] &quot;&quot;&quot; assert len(cards) % 2 == 0, &#x27;len(cards) must be even&#x27; half = _______________ shuffled = [] for i in _____________: _________________ _________________ return shuffled Use Ok to test your code: 1python3 ok -q shuffle✂️ Generators &amp; Iterators Q9: Pairs (generator) Write a generator function pairs that takes a list and yields all the possible pairs of elements from that list. 123456789101112131415161718192021def pairs(lst): &quot;&quot;&quot; &gt;&gt;&gt; type(pairs([3, 4, 5])) &lt;class &#x27;generator&#x27;&gt; &gt;&gt;&gt; for x, y in pairs([3, 4, 5]): ... print(x, y) ... 3 3 3 4 3 5 4 3 4 4 4 5 5 3 5 4 5 5 &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; for x in lst: for y in lst: yield x, y Use Ok to test your code: 1python3 ok -q pairs✂️ Q10: Pairs (iterator) Important note (March 14): This question is not in scope for this semester (Spring 2022), as it involves __iter__ and __next__. Now write an iterator that does the same thing. You are only allowed to use a linear amount of space - so computing a list of all of the possible pairs is not a valid answer. Notice how much harder it is - this is why generators are useful. 1234567891011121314151617181920212223class PairsIterator: &quot;&quot;&quot; &gt;&gt;&gt; for x, y in PairsIterator([3, 4, 5]): ... print(x, y) ... 3 3 3 4 3 5 4 3 4 4 4 5 5 3 5 4 5 5 &quot;&quot;&quot; def __init__(self, lst): &quot;*** YOUR CODE HERE ***&quot; def __next__(self): &quot;*** YOUR CODE HERE ***&quot; def __iter__(self): &quot;*** YOUR CODE HERE ***&quot; Use Ok to test your code: 1python3 ok -q PairsIterator✂️ Trees Q11: Long Paths Implement long_paths, which returns a list of all paths in a tree with length at least n. A path in a tree is a linked list of node values that starts with the root and ends at a leaf. Each subsequent element must be from a child of the previous value’s node. The length of a path is the number of edges in the path (i.e. one less than the number of nodes in the path). Paths are listed in order from left to right. See the doctests for some examples. 123456789101112131415161718192021222324252627282930def long_paths(tree, n): &quot;&quot;&quot;Return a list of all paths in tree with length at least n. &gt;&gt;&gt; t = Tree(3, [Tree(4), Tree(4), Tree(5)]) &gt;&gt;&gt; left = Tree(1, [Tree(2), t]) &gt;&gt;&gt; mid = Tree(6, [Tree(7, [Tree(8)]), Tree(9)]) &gt;&gt;&gt; right = Tree(11, [Tree(12, [Tree(13, [Tree(14)])])]) &gt;&gt;&gt; whole = Tree(0, [left, Tree(13), mid, right]) &gt;&gt;&gt; for path in long_paths(whole, 2): ... print(path) ... &lt;0 1 2&gt; &lt;0 1 3 4&gt; &lt;0 1 3 4&gt; &lt;0 1 3 5&gt; &lt;0 6 7 8&gt; &lt;0 6 9&gt; &lt;0 11 12 13 14&gt; &gt;&gt;&gt; for path in long_paths(whole, 3): ... print(path) ... &lt;0 1 3 4&gt; &lt;0 1 3 4&gt; &lt;0 1 3 5&gt; &lt;0 6 7 8&gt; &lt;0 11 12 13 14&gt; &gt;&gt;&gt; long_paths(whole, 4) [Link(0, Link(11, Link(12, Link(13, Link(14)))))] &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; Use Ok to test your code: 1python3 ok -q long_paths✂️ Linked Lists Q12: Flip Two Write a recursive function flip_two that takes as input a linked list s and mutates s so that every pair of values in the linked list is flipped. 123456789101112131415def flip_two(s): &quot;&quot;&quot; &gt;&gt;&gt; one_lnk = Link(1) &gt;&gt;&gt; flip_two(one_lnk) &gt;&gt;&gt; one_lnk Link(1) &gt;&gt;&gt; lnk = Link(1, Link(2, Link(3, Link(4, Link(5))))) &gt;&gt;&gt; flip_two(lnk) &gt;&gt;&gt; lnk Link(2, Link(1, Link(4, Link(3, Link(5))))) &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; # For an extra challenge, try writing out an iterative approach as well below! &quot;*** YOUR CODE HERE ***&quot; Use Ok to test your code: 1python3 ok -q flip_two✂️","categories":[],"tags":[{"name":"CS61A","slug":"CS61A","permalink":"http://www.misaka-9982.com/tags/CS61A/"}]},{"title":"CS61A Lab 7","slug":"CS61A-Lab-7","date":"2022-05-23T08:53:19.000Z","updated":"2022-07-20T09:14:00.751Z","comments":true,"path":"2022/05/23/CS61A-Lab-7/","link":"","permalink":"http://www.misaka-9982.com/2022/05/23/CS61A-Lab-7/","excerpt":"","text":"Lab 7: Linked Lists, Trees / Tree Mutation lab07.zip What Would Python Display? Q1: WWPD: Linked Lists Read over the Link class in lab07.py. Make sure you understand the doctests. Use Ok to test your knowledge with the following “What Would Python Display?” questions: 1python3 ok -q link -u Enter Function if you believe the answer is &lt;function ...&gt;, Error if it errors, and Nothing if nothing is displayed. If you get stuck, try drawing out the box-and-pointer diagram for the linked list on a piece of paper or loading the Link class into the interpreter with python3 -i lab07.py. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&gt;&gt;&gt; from lab07 import *&gt;&gt;&gt; link = Link(1000)&gt;&gt;&gt; link.first______&gt;&gt;&gt; link.rest is Link.empty______&gt;&gt;&gt; link = Link(1000, 2000)______&gt;&gt;&gt; link = Link(1000, Link())______&gt;&gt;&gt; from lab07 import *&gt;&gt;&gt; link = Link(1, Link(2, Link(3)))&gt;&gt;&gt; link.first______&gt;&gt;&gt; link.rest.first______&gt;&gt;&gt; link.rest.rest.rest is Link.empty______&gt;&gt;&gt; link.first = 9001&gt;&gt;&gt; link.first______&gt;&gt;&gt; link.rest = link.rest.rest&gt;&gt;&gt; link.rest.first______&gt;&gt;&gt; link = Link(1)&gt;&gt;&gt; link.rest = link&gt;&gt;&gt; link.rest.rest.rest.rest.first______&gt;&gt;&gt; link = Link(2, Link(3, Link(4)))&gt;&gt;&gt; link2 = Link(1, link)&gt;&gt;&gt; link2.first______&gt;&gt;&gt; link2.rest.first______&gt;&gt;&gt; from lab07 import *&gt;&gt;&gt; link = Link(5, Link(6, Link(7)))&gt;&gt;&gt; link # Look at the __repr__ method of Link______&gt;&gt;&gt; print(link) # Look at the __str__ method of Link______ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&gt;&gt;&gt; from lab07 import *&gt;&gt;&gt; link = Link(1000)&gt;&gt;&gt; link.first? 1000-- OK! --&gt;&gt;&gt; link.rest is Link.empty? true-- Not quite. Try again! --? Treu-- Not quite. Try again! --? True-- OK! --&gt;&gt;&gt; link = Link(1000, 2000)? Error-- OK! --&gt;&gt;&gt; link = Link(1000, Link())? Error-- OK! -----------------------------------------------------------------------Link &gt; Suite 1 &gt; Case 2(cases remaining: 2)What would Python display? If you get stuck, try it out in the Pythoninterpreter!&gt;&gt;&gt; from lab07 import *&gt;&gt;&gt; link = Link(1, Link(2, Link(3)))&gt;&gt;&gt; link.first? 1-- OK! --&gt;&gt;&gt; link.rest.first? 2-- OK! --&gt;&gt;&gt; link.rest.rest.rest is Link.empty? True-- OK! --&gt;&gt;&gt; link.first = 9001&gt;&gt;&gt; link.first? 9001-- OK! --&gt;&gt;&gt; link.rest = link.rest.rest&gt;&gt;&gt; link.rest.first? 3-- OK! --&gt;&gt;&gt; link = Link(1)&gt;&gt;&gt; link.rest = link&gt;&gt;&gt; link.rest.rest.rest.rest.first? 1-- OK! --&gt;&gt;&gt; link = Link(2, Link(3, Link(4)))&gt;&gt;&gt; link2 = Link(1, link)&gt;&gt;&gt; link2.first? 1-- OK! --&gt;&gt;&gt; link2.rest.first? 2-- OK! -----------------------------------------------------------------------Link &gt; Suite 1 &gt; Case 3(cases remaining: 1)What would Python display? If you get stuck, try it out in the Pythoninterpreter!&gt;&gt;&gt; from lab07 import *&gt;&gt;&gt; link = Link(5, Link(6, Link(7)))&gt;&gt;&gt; link # Look at the __repr__ method of Link? Link(5, Link(6, Link(7)))-- OK! --&gt;&gt;&gt; print(link) # Look at the __str__ method of Link? &lt;5 6 7&gt;-- OK! -----------------------------------------------------------------------OK! All cases for Link unlocked. Parsons Problems To work on these problems, open the Parsons editor: 1python3 parsons Q2: Reverse Link Write a function that takes in a linked list and returns a reversed version of that linked list (with elements in the opposite order). It should not mutate the original list. 12345678910&gt;&gt;&gt; s = Link(1, Link(2, Link(3, Link.empty)))&gt;&gt;&gt; reverse_link(s)Link(3, Link(2, Link(1)))&gt;&gt;&gt; sLink(1, Link(2, Link(3)))&gt;&gt;&gt; k = Link(3, Link(5, Link(7, Link(9))))&gt;&gt;&gt; reverse_link(k)Link(9, Link(7, Link(5, Link(3))))&gt;&gt;&gt; kLink(3, Link(5, Link(7, Link(9)))) Hint: you should iterate over the linked list. If you’re having trouble starting, attempt to replicate the following diagram. 12345678910111213141516171819202122def reverse_link(lnk): &quot;&quot;&quot; Given a linked list lnk, return a new linked list which has all the elements of lnk but in reverse order. &gt;&gt;&gt; s = Link(1, Link(2, Link(3, Link.empty))) &gt;&gt;&gt; reverse_link(s) Link(3, Link(2, Link(1))) &gt;&gt;&gt; s Link(1, Link(2, Link(3))) &gt;&gt;&gt; k = Link(3, Link(5, Link(7, Link(9)))) &gt;&gt;&gt; reverse_link(k) Link(9, Link(7, Link(5, Link(3)))) &gt;&gt;&gt; k Link(3, Link(5, Link(7, Link(9)))) &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; result = Link.empty while lnk: result = Link(lnk.first, result) lnk = lnk.rest return result Q3: Label Multiplier Write a function label_multiplier that takes in a Tree and an integer val. label_multiplier should mutate the tree’s labels by multiplying their original value by val. 1234567891011121314151617181920212223242526&gt;&gt;&gt; t1 = Tree(2, [Tree(4, [Tree(6)]), Tree(8)])&gt;&gt;&gt; label_multiplier(t1, 10)&gt;&gt;&gt; t1Tree(20, [Tree(40, [Tree(60)]), Tree(80)])&gt;&gt;&gt; t2 = Tree(10, [Tree(9), Tree(8, [Tree(7), Tree(6)]), Tree(5, [Tree(4), Tree(3), Tree(2)])])&gt;&gt;&gt; label_multiplier(t2, 3)&gt;&gt;&gt; t2Tree(30, [Tree(27), Tree(24, [Tree(21), Tree(18)]), Tree(15, [Tree(12), Tree(9), Tree(6)])])def label_multiplier(t, val): &quot;&quot;&quot; Given a tree t, mutate t so that all of the tree&#x27;s labels are multiplied by the argument val. &gt;&gt;&gt; t1 = Tree(2, [Tree(4, [Tree(6)]), Tree(8)]) &gt;&gt;&gt; label_multiplier(t1, 10) &gt;&gt;&gt; t1 Tree(20, [Tree(40, [Tree(60)]), Tree(80)]) &gt;&gt;&gt; t2 = Tree(10, [Tree(9), Tree(8, [Tree(7), Tree(6)]), Tree(5, [Tree(4), Tree(3), Tree(2)])]) &gt;&gt;&gt; label_multiplier(t2, 3) &gt;&gt;&gt; t2 Tree(30, [Tree(27), Tree(24, [Tree(21), Tree(18)]), Tree(15, [Tree(12), Tree(9), Tree(6)])]) &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; t.label = t.label * val for b in t.branches: label_multiplier(b, val) Coding Practice Q4: Store Digits Write a function store_digits that takes in an integer n and returns a linked list where each element of the list is a digit of n. Important: Do not use any string manipulation functions like str and reversed. 12345678910111213141516171819202122def store_digits(n): &quot;&quot;&quot;Stores the digits of a positive number n in a linked list. &gt;&gt;&gt; s = store_digits(1) &gt;&gt;&gt; s Link(1) &gt;&gt;&gt; store_digits(2345) Link(2, Link(3, Link(4, Link(5)))) &gt;&gt;&gt; store_digits(876) Link(8, Link(7, Link(6))) &gt;&gt;&gt; # a check for restricted functions &gt;&gt;&gt; import inspect, re &gt;&gt;&gt; cleaned = re.sub(r&quot;#.*\\\\n&quot;, &#x27;&#x27;, re.sub(r&#x27;&quot;&#123;3&#125;[\\s\\S]*?&quot;&#123;3&#125;&#x27;, &#x27;&#x27;, inspect.getsource(store_digits))) &gt;&gt;&gt; print(&quot;Do not use str or reversed!&quot;) if any([r in cleaned for r in [&quot;str&quot;, &quot;reversed&quot;]]) else None &gt;&gt;&gt; link1 = Link(3, Link(Link(4), Link(5, Link(6)))) &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; lnk = Link.empty while n: lnk = Link(n % 10, lnk) n = n // 10 return lnk Use Ok to test your code: 1python3 ok -q store_digits✂️ Q5: Cumulative Mul Write a function cumulative_mul that mutates the Tree t so that each node’s label becomes the product of its label and all labels in the subtrees rooted at the node. Hint: Consider carefully when to do the mutation of the tree and whether that mutation should happen before or after processing the subtrees. 123456789101112131415161718192021def cumulative_mul(t): &quot;&quot;&quot;Mutates t so that each node&#x27;s label becomes the product of all labels in the corresponding subtree rooted at t. &gt;&gt;&gt; t = Tree(1, [Tree(3, [Tree(5)]), Tree(7)]) &gt;&gt;&gt; cumulative_mul(t) &gt;&gt;&gt; t Tree(105, [Tree(15, [Tree(5)]), Tree(7)]) &gt;&gt;&gt; otherTree = Tree(2, [Tree(1, [Tree(3), Tree(4), Tree(5)]), Tree(6, [Tree(7)])]) &gt;&gt;&gt; cumulative_mul(otherTree) &gt;&gt;&gt; otherTree Tree(5040, [Tree(60, [Tree(3), Tree(4), Tree(5)]), Tree(42, [Tree(7)])]) &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; if t.is_leaf(): return for b in t.branches: cumulative_mul(b) if isinstance(b, Tree): t.label *= b.label Use Ok to test your code: 1python3 ok -q cumulative_mul✂️ Submit Make sure to submit this assignment by running: 1python3 ok --submit Optional Questions Q6: Cycles The Link class can represent lists with cycles. That is, a list may contain itself as a sublist. 1234&gt;&gt;&gt; s = Link(1, Link(2, Link(3)))&gt;&gt;&gt; s.rest.rest.rest = s&gt;&gt;&gt; s.rest.rest.rest.rest.rest.first3 Implement has_cycle,that returns whether its argument, a Link instance, contains a cycle. Hint: Iterate through the linked list and try keeping track of which Link objects you’ve already seen. 12345678910111213141516171819202122def has_cycle(link): &quot;&quot;&quot;Return whether link contains a cycle. &gt;&gt;&gt; s = Link(1, Link(2, Link(3))) &gt;&gt;&gt; s.rest.rest.rest = s &gt;&gt;&gt; has_cycle(s) True &gt;&gt;&gt; t = Link(1, Link(2, Link(3))) &gt;&gt;&gt; has_cycle(t) False &gt;&gt;&gt; u = Link(2, Link(2, Link(2))) &gt;&gt;&gt; has_cycle(u) False &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; links = [] while link is not Link.empty: if link in links: return True links.append(link) link = link.rest return False Use Ok to test your code: 1python3 ok -q has_cycle✂️ Extra challenge (Optional): Implement has_cycle without keeping track of all Link objects you’ve already seen. The solution is short (less than 20 lines of code), but requires a clever idea. Try to discover the solution yourself before asking around. 12345678910111213141516171819202122def has_cycle_constant(link): &quot;&quot;&quot;Return whether link contains a cycle. &gt;&gt;&gt; s = Link(1, Link(2, Link(3))) &gt;&gt;&gt; s.rest.rest.rest = s &gt;&gt;&gt; has_cycle_constant(s) True &gt;&gt;&gt; t = Link(1, Link(2, Link(3))) &gt;&gt;&gt; has_cycle_constant(t) False &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; slow = link fast = link while fast is not Link.empty: if fast.rest is Link.empty: return False slow = slow.rest fast = fast.rest.rest if slow is fast: return True return False Use Ok to test your code: 1python3 ok -q has_cycle_constant","categories":[],"tags":[{"name":"CS61A","slug":"CS61A","permalink":"http://www.misaka-9982.com/tags/CS61A/"}]},{"title":"CS61A Homework 5","slug":"CS61A-Homework-5","date":"2022-05-23T02:15:08.000Z","updated":"2022-05-23T05:30:22.787Z","comments":true,"path":"2022/05/23/CS61A-Homework-5/","link":"","permalink":"http://www.misaka-9982.com/2022/05/23/CS61A-Homework-5/","excerpt":"","text":"Homework 5: Trees, Linked Lists hw05.zip Mid-Semester Feedback Q1: Mid-Semester Feedback As part of this week’s homework, please fill out the Mid-Semester Feedback form. This survey is designed to help us make short term adjustments to the course so that it works better for you. We appreciate your feedback. We may not be able to make every change that you request, but we will read all the feedback and consider it. Confidentiality: Your responses to the survey are confidential, and only the instructor (Pamela) and head TA (Vanshaj) will be able to see this data unanonymized. More specifics on confidentiality can be found on the survey itself. Once you finish the survey, you will be presented with a passphrase (if you miss it, it should also be at the bottom of the confirmation email you receive). Put this passphrase, as a string, on the line that says passphrase = '*** PASSPHRASE HERE ***' in the Python file for this assignment. Use Ok to test your code: 1python3 ok -q midsem_survey✂️ Parsons Problems Q2: Chain For this question, we will define a chain as a path from the root of a tree t to any leaf such that all nodes on the path share the same label. Implement the function chain, which, given a tree t, returns True if there exists any chain in the tree, and False otherwise. 123456789101112131415161718192021def chain(t): &quot;&quot;&quot; Returns whether there exists a path in t where all nodes share the same label. &gt;&gt;&gt; all_fives = Tree(5, [Tree(5), Tree(5, [Tree(5)])]) &gt;&gt;&gt; chain(all_fives) True &gt;&gt;&gt; t1 = Tree(1, [Tree(3, [Tree(4)]), Tree(1)]) &gt;&gt;&gt; chain(t1) True &gt;&gt;&gt; t2 = Tree(1, [Tree(3, [Tree(4)]), Tree(5)]) &gt;&gt;&gt; chain(t2) False &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; if t.is_leaf(): return True for b in t.branches: if t.label == b.label and chain(b): return True return False Q3: Flatten Link Write a function flatten_link that takes in a linked list lnk and returns the sequence as a Python list. If lnk has nested linked lists, flatten_link should flatten lnk. 123456789101112131415161718def flatten_link(lnk): &quot;&quot;&quot;Takes a linked list and returns a flattened Python list with the same elements. &gt;&gt;&gt; link = Link(1, Link(2, Link(3, Link(4)))) &gt;&gt;&gt; flatten_link(link) [1, 2, 3, 4] &gt;&gt;&gt; flatten_link(Link.empty) [] &gt;&gt;&gt; deep_link = Link(Link(1, Link(2, Link(3, Link(4)))), Link(Link(5), Link(6))) &gt;&gt;&gt; flatten_link(deep_link) [1, 2, 3, 4, 5, 6] &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; if lnk is Link.empty: return [] if isinstance(lnk.first, Link): return flatten_link(lnk.first) + flatten_link(lnk.rest) return [lnk.first] + flatten_link(lnk.rest) Code Writing Questions Q4: Has Path Write a function has_path that takes in a Tree t and a string term. It returns True if there is a path that starts from the root where the entries along the path spell out the term, and False otherwise. You may assume that every node’s label is exactly one character. This data structure is called a trie, and it has a lot of cool applications, such as autocomplete. 123456789101112131415161718192021222324252627282930313233343536373839404142def has_path(t, term): &quot;&quot;&quot;Return whether there is a path in a Tree where the entries along the path spell out a particular term. &gt;&gt;&gt; greetings = Tree(&#x27;h&#x27;, [Tree(&#x27;i&#x27;), ... Tree(&#x27;e&#x27;, [Tree(&#x27;l&#x27;, [Tree(&#x27;l&#x27;, [Tree(&#x27;o&#x27;)])]), ... Tree(&#x27;y&#x27;)])]) &gt;&gt;&gt; print(greetings) h i e l l o y &gt;&gt;&gt; has_path(greetings, &#x27;h&#x27;) True &gt;&gt;&gt; has_path(greetings, &#x27;i&#x27;) False &gt;&gt;&gt; has_path(greetings, &#x27;hi&#x27;) True &gt;&gt;&gt; has_path(greetings, &#x27;hello&#x27;) True &gt;&gt;&gt; has_path(greetings, &#x27;hey&#x27;) True &gt;&gt;&gt; has_path(greetings, &#x27;bye&#x27;) False &gt;&gt;&gt; has_path(greetings, &#x27;hint&#x27;) False &quot;&quot;&quot; assert len(term) &gt; 0, &#x27;no path for empty term.&#x27; &quot;*** YOUR CODE HERE ***&quot; if len(term) == 1: return str(t.label) == term[0] flag = False if str(t.label) == term[0]: for b in t.branches: if str(b.label) == term[1]: flag = has_path(b, term[1:]) return flag Use Ok to test your code: 1python3 ok -q has_path✂️ Q5: Duplicate Link Write a function duplicate_link that takes in a linked list lnk and a value. duplicate_link will mutate lnk such that if there is a linked list node that has a first equal to value, that node will be duplicated. Note that you should be mutating the original link list lnk; you will need to create new Links, but you should not be returning a new linked list. Note: in order to insert a link into a linked list, you need to modify the .rest of certain links. We encourage you to draw out a doctest to visualize! 123456789101112131415161718192021222324def duplicate_link(lnk, val): &quot;&quot;&quot;Mutates `lnk` such that if there is a linked list node that has a first equal to value, that node will be duplicated. Note that you should be mutating the original link list. &gt;&gt;&gt; x = Link(5, Link(4, Link(3))) &gt;&gt;&gt; duplicate_link(x, 5) &gt;&gt;&gt; x Link(5, Link(5, Link(4, Link(3)))) &gt;&gt;&gt; y = Link(2, Link(4, Link(6, Link(8)))) &gt;&gt;&gt; duplicate_link(y, 10) &gt;&gt;&gt; y Link(2, Link(4, Link(6, Link(8)))) &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; def duplicate(lnk, val): new_lnk = Link(val, lnk) return new_lnk if int(lnk.first) == val: new_lnk = duplicate(lnk.rest, val) lnk.rest = new_lnk Use Ok to test your code: 1python3 ok -q duplicate_link✂️ Q6: Mutable Mapping Implement deep_map_mut(fn, link), which applies a function fn onto all elements in the given linked list lnk. If an element is itself a linked list, apply fn to each of its elements, and so on. Your implementation should mutate the original linked list. Do not create any new linked lists. Hint: The built-in isinstance function may be useful. 12345&gt;&gt;&gt; s = Link(1, Link(2, Link(3, Link(4))))&gt;&gt;&gt; isinstance(s, Link)True&gt;&gt;&gt; isinstance(s, int)False Construct Check: The last doctest of this question ensures that you do not create new linked lists. If you are failing this doctest, ensure that you are not creating link lists by calling the constructor, i.e. 1s = Link(1) 123456789101112131415161718192021222324def deep_map_mut(fn, lnk): &quot;&quot;&quot;Mutates a deep link lnk by replacing each item found with the result of calling fn on the item. Does NOT create new Links (so no use of Link&#x27;s constructor). Does not return the modified Link object. &gt;&gt;&gt; link1 = Link(3, Link(Link(4), Link(5, Link(6)))) &gt;&gt;&gt; # Disallow the use of making new Links before calling deep_map_mut &gt;&gt;&gt; Link.__init__, hold = lambda *args: print(&quot;Do not create any new Links.&quot;), Link.__init__ &gt;&gt;&gt; try: ... deep_map_mut(lambda x: x * x, link1) ... finally: ... Link.__init__ = hold &gt;&gt;&gt; print(link1) &lt;9 &lt;16&gt; 25 36&gt; &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; while lnk: if isinstance(lnk.first, Link): deep_map_mut(fn, lnk.first) else: lnk.first = fn(lnk.first) lnk = lnk.rest Use Ok to test your code: 1python3 ok -q deep_map_mut✂️ Submit Make sure to submit this assignment by running: 1python3 ok --submit Optional Questions Homework assignments will also contain prior exam-level questions for you to take a look at. These questions have no submission component; feel free to attempt them if you’d like a challenge! Spring 2018 MT2 Q5ab: Trees Spring 2019 MT2 Q6a: Trie this Fall 2017 Final Q4a: O! Pascal","categories":[],"tags":[{"name":"CS61A","slug":"CS61A","permalink":"http://www.misaka-9982.com/tags/CS61A/"}]},{"title":"CS61A Lab 6","slug":"CS61A-Lab-6","date":"2022-05-22T11:44:18.000Z","updated":"2022-05-22T13:21:14.122Z","comments":true,"path":"2022/05/22/CS61A-Lab-6/","link":"","permalink":"http://www.misaka-9982.com/2022/05/22/CS61A-Lab-6/","excerpt":"","text":"Lab 6: Object-Oriented Programming lab06.zip What Would Python Do? These questions use inheritance. For an overview of inheritance, see the inheritance portion of Composing Programs. Q1: WWPD: Classy Cars Below is the definition of a Car class that we will be using in the following WWPD questions. Note: The Car class definition can also be found in car.py. 123456789101112131415161718192021222324252627282930class Car: num_wheels = 4 gas = 30 headlights = 2 size = &#x27;Tiny&#x27; def __init__(self, make, model): self.make = make self.model = model self.color = &#x27;No color yet. You need to paint me.&#x27; self.wheels = Car.num_wheels self.gas = Car.gas def paint(self, color): self.color = color return self.make + &#x27; &#x27; + self.model + &#x27; is now &#x27; + color def drive(self): if self.wheels &lt; Car.num_wheels or self.gas &lt;= 0: return &#x27;Cannot drive!&#x27; self.gas -= 10 return self.make + &#x27; &#x27; + self.model + &#x27; goes vroom!&#x27; def pop_tire(self): if self.wheels &gt; 0: self.wheels -= 1 def fill_gas(self): self.gas += 20 return &#x27;Gas level: &#x27; + str(self.gas) For the later unlocking questions, we will be referencing the MonsterTruck class below. Note: The MonsterTruck class definition can also be found in car.py. 123456789class MonsterTruck(Car): size = &#x27;Monster&#x27; def rev(self): print(&#x27;Vroom! This Monster Truck is huge!&#x27;) def drive(self): self.rev() return super().drive() You can find the unlocking questions below. Use Ok to test your knowledge with the following “What Would Python Display?” questions: 1python3 ok -q wwpd-car -u✂️ Important: For all WWPD questions, type Function if you believe the answer is &lt;function...&gt;, Error if it errors, and Nothing if nothing is displayed. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&gt;&gt;&gt; deneros_car = Car(&#x27;Tesla&#x27;, &#x27;Model S&#x27;)&gt;&gt;&gt; deneros_car.model______&gt;&gt;&gt; deneros_car.gas = 10&gt;&gt;&gt; deneros_car.drive()______&gt;&gt;&gt; deneros_car.drive()______&gt;&gt;&gt; deneros_car.fill_gas()______&gt;&gt;&gt; deneros_car.gas______&gt;&gt;&gt; Car.gas______&gt;&gt;&gt; deneros_car = Car(&#x27;Tesla&#x27;, &#x27;Model S&#x27;)&gt;&gt;&gt; deneros_car.wheels = 2&gt;&gt;&gt; deneros_car.wheels______&gt;&gt;&gt; Car.num_wheels______&gt;&gt;&gt; deneros_car.drive()______&gt;&gt;&gt; Car.drive()______&gt;&gt;&gt; Car.drive(deneros_car)______&gt;&gt;&gt; deneros_car = MonsterTruck(&#x27;Monster&#x27;, &#x27;Batmobile&#x27;)&gt;&gt;&gt; deneros_car.drive()______&gt;&gt;&gt; Car.drive(deneros_car)______&gt;&gt;&gt; MonsterTruck.drive(deneros_car)______&gt;&gt;&gt; Car.rev(deneros_car)______ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108What would Python display? If you get stuck, try it out in the Pythoninterpreter!&gt;&gt;&gt; from car import *&gt;&gt;&gt; deneros_car = Car(&#x27;Tesla&#x27;, &#x27;Model S&#x27;)&gt;&gt;&gt; deneros_car.model? Model S-- Not quite. Try again! --? &#x27;Model S&#x27;-- OK! --&gt;&gt;&gt; deneros_car.gas = 10&gt;&gt;&gt; deneros_car.drive()? Tesla Model S goes vroom!-- Not quite. Try again! --? &#x27;Tesla Model S goes vroom!&#x27;-- OK! --&gt;&gt;&gt; deneros_car.drive()? &#x27;Cannot drive&#x27;-- Not quite. Try again! --? &#x27;Cannot drive!&#x27;-- OK! --&gt;&gt;&gt; deneros_car.fill_gas()? &#x27;Gas level: 20&#x27;-- OK! --&gt;&gt;&gt; deneros_car.gas? 20-- OK! --&gt;&gt;&gt; Car.gas? 30-- OK! -----------------------------------------------------------------------Car &gt; Suite 1 &gt; Case 2(cases remaining: 2)What would Python display? If you get stuck, try it out in the Pythoninterpreter!&gt;&gt;&gt; from car import *&gt;&gt;&gt; deneros_car = Car(&#x27;Tesla&#x27;, &#x27;Model S&#x27;)&gt;&gt;&gt; deneros_car.wheels = 2&gt;&gt;&gt; deneros_car.wheels? 2-- OK! --&gt;&gt;&gt; Car.num_wheels? 4-- OK! --&gt;&gt;&gt; deneros_car.drive() # Type Error if an error occurs and Nothing if nothing is displayed? &#x27;Cannot drive&#x27;-- Not quite. Try again! --? &#x27;Cannot drive!&#x27;-- OK! --&gt;&gt;&gt; Car.drive() # Type Error if an error occurs and Nothing if nothing is displayed? Nothing-- Not quite. Try again! --? Error-- OK! --&gt;&gt;&gt; Car.drive(deneros_car) # Type Error if an error occurs and Nothing if nothing is displayed? &#x27;Cannot drive!&#x27;-- OK! -----------------------------------------------------------------------Car &gt; Suite 1 &gt; Case 3(cases remaining: 1)What would Python display? If you get stuck, try it out in the Pythoninterpreter!&gt;&gt;&gt; from car import *&gt;&gt;&gt; deneros_car = MonsterTruck(&#x27;Monster&#x27;, &#x27;Batmobile&#x27;)&gt;&gt;&gt; deneros_car.drive() # Type Error if an error occurs and Nothing if nothing is displayed(line 1)? Vroom! This Monster Truck is huge!(line 2)? &#x27;Monster Batmobile goes vroom!&#x27;-- OK! --&gt;&gt;&gt; Car.drive(deneros_car) # Type Error if an error occurs and Nothing if nothing is displayed? &#x27;Monster Batmobile goes vroom!&#x27;-- OK! --&gt;&gt;&gt; MonsterTruck.drive(deneros_car) # Type Error if an error occurs and Nothing if nothing is displayed(line 1)? Vroom! This Monster Truck is huge!(line 2)? &#x27;Monster Batmobile goes vroom!&#x27;-- OK! --&gt;&gt;&gt; Car.rev(deneros_car) # Type Error if an error occurs and Nothing if nothing is displayed? Vroom! This Monster Truck is huge!-- Not quite. Try again! --? Error-- OK! -----------------------------------------------------------------------OK! All cases for Car unlocked. Parsons Problems To work on these problems, open the Parsons editor: 1python3 parsons Q2: Cool Cats The Cat class models a cat: you can find the implementation below. Now, you will implement NoisyCat; NoisyCats are very similar to Cats, but talks twice as much. However, in exchange for such great powers, it gives up one of its initial lives. Use superclass methods wherever possible. 1234567891011121314151617181920212223242526272829303132333435class Cat: def __init__(self, name, owner, lives=9): self.is_alive = True self.name = name self.owner = owner self.lives = lives def talk(self): return self.name + &#x27; says meow!&#x27;class NoisyCat(Cat): &quot;&quot;&quot; &gt;&gt;&gt; my_cat = NoisyCat(&quot;Furball&quot;, &quot;James&quot;) &gt;&gt;&gt; my_cat.name &#x27;Furball&#x27; &gt;&gt;&gt; my_cat.is_alive True &gt;&gt;&gt; my_cat.lives 8 &gt;&gt;&gt; my_cat.talk() &#x27;Furball says meow! Furball says meow!&#x27; &gt;&gt;&gt; friend_cat = NoisyCat(&quot;Tabby&quot;, &quot;James&quot;, 2) &gt;&gt;&gt; friend_cat.talk() &#x27;Tabby says meow! Tabby says meow!&#x27; &gt;&gt;&gt; friend_cat.lives 1 &quot;&quot;&quot; def __init__(self, name, owner, lives=9): Cat.__init__(self, name, owner, lives) self.lives -= 1 def talk(self): words = Cat.talk(self) words = words + &#x27; &#x27; + words return words Coding Practice Q3: Cat Adoption So far, you’ve implemented the NoisyCat based off of the Cat class. However, you now want to be able to create lots of different Cats! Build on the Cat class from the earlier problem by adding a class method called adopt_a_cat. This class method allows you to create Cats that can then be adopted. Specifically, adopt_a_cat should return a new instance of a Cat whose owner is owner. This Cat instance’s name and number of lives depends on the owner. Its name should be chosen from cat_names (provided in the skeleton code), and should correspond to the name at the index len(owner) % (modulo) the number of possible cat names. Its number of lives should be equal to len(owner) + the length of the chosen name. 1234567891011121314151617181920212223242526272829303132333435363738394041class Cat: def __init__(self, name, owner, lives=9): self.is_alive = True self.name = name self.owner = owner self.lives = lives def talk(self): return self.name + &#x27; says meow!&#x27; @classmethod def adopt_a_cat(cls, owner): &quot;&quot;&quot; Returns a new instance of a Cat. This instance&#x27;s owner is the given owner. Its name and its number of lives is chosen programatically based on the spec&#x27;s noted behavior. &gt;&gt;&gt; cat1 = Cat.adopt_a_cat(&quot;Ifeoma&quot;) &gt;&gt;&gt; isinstance(cat1, Cat) True &gt;&gt;&gt; cat1.owner &#x27;Ifeoma&#x27; &gt;&gt;&gt; cat1.name &#x27;Felix&#x27; &gt;&gt;&gt; cat1.lives 11 &gt;&gt;&gt; cat2 = Cat.adopt_a_cat(&quot;Ay&quot;) &gt;&gt;&gt; cat2.owner &#x27;Ay&#x27; &gt;&gt;&gt; cat2.name &#x27;Grumpy&#x27; &gt;&gt;&gt; cat2.lives 8 &quot;&quot;&quot; cat_names = [&quot;Felix&quot;, &quot;Bugs&quot;, &quot;Grumpy&quot;] &quot;*** YOUR CODE HERE ***&quot; cat_name = cat_names[len(owner) % 3] lives = len(owner) + len(cat_name) return cls(cat_name, owner, lives) Use Ok to test your code: 1python3 ok -q Cat.adopt_a_cat✂️ Accounts Let’s say we’d like to model a bank account that can handle interactions such as depositing funds or gaining interest on current funds. In the following questions, we will be building off of the Account class. Here’s our current definition of the class: 123456789101112131415161718192021222324252627282930313233343536class Account: &quot;&quot;&quot;An account has a balance and a holder. &gt;&gt;&gt; a = Account(&#x27;John&#x27;) &gt;&gt;&gt; a.deposit(10) 10 &gt;&gt;&gt; a.balance 10 &gt;&gt;&gt; a.interest 0.02 &gt;&gt;&gt; a.time_to_retire(10.25) # 10 -&gt; 10.2 -&gt; 10.404 2 &gt;&gt;&gt; a.balance # balance should not change 10 &gt;&gt;&gt; a.time_to_retire(11) # 10 -&gt; 10.2 -&gt; ... -&gt; 11.040808032 5 &gt;&gt;&gt; a.time_to_retire(100) 117 &quot;&quot;&quot; max_withdrawal = 10 interest = 0.02 def __init__(self, account_holder): self.balance = 0 self.holder = account_holder def deposit(self, amount): self.balance = self.balance + amount return self.balance def withdraw(self, amount): if amount &gt; self.balance: return &quot;Insufficient funds&quot; if amount &gt; self.max_withdrawal: return &quot;Can&#x27;t withdraw that amount&quot; self.balance = self.balance - amount return self.balance Q4: Retirement Add a time_to_retire method to the Account class. This method takes in an amount and returns how many years the holder would need to wait in order for the current balance to grow to at least amount, assuming that the bank adds balance times the interest rate to the total balance at the end of every year. 12345678910def time_to_retire(self, amount): &quot;&quot;&quot;Return the number of years until balance would grow to amount.&quot;&quot;&quot; assert self.balance &gt; 0 and amount &gt; 0 and self.interest &gt; 0 &quot;*** YOUR CODE HERE ***&quot; cnt = 0 deposit = self.balance * ((1 + self.interest) ** cnt) while deposit &lt; amount: cnt = cnt + 1 deposit = self.balance * ((1 + self.interest) ** cnt) return cnt Use Ok to test your code: 1python3 ok -q Account✂️ Q5: FreeChecking Implement the FreeChecking class, which is like the Account class from lecture except that it charges a withdraw fee after 2 withdrawals. If a withdrawal is unsuccessful, it still counts towards the number of free withdrawals remaining, but no fee for the withdrawal will be charged. Hint: Don’t forget that FreeChecking inherits from Account! Check the Inheritance section in Topics for a refresher. 123456789101112131415161718192021222324252627282930313233343536373839404142434445class FreeChecking(Account): &quot;&quot;&quot;A bank account that charges for withdrawals, but the first two are free! &gt;&gt;&gt; ch = FreeChecking(&#x27;Jack&#x27;) &gt;&gt;&gt; ch.balance = 20 &gt;&gt;&gt; ch.withdraw(100) # First one&#x27;s free &#x27;Insufficient funds&#x27; &gt;&gt;&gt; ch.withdraw(3) # And the second 17 &gt;&gt;&gt; ch.balance 17 &gt;&gt;&gt; ch.withdraw(3) # Ok, two free withdrawals is enough 13 &gt;&gt;&gt; ch.withdraw(3) 9 &gt;&gt;&gt; ch2 = FreeChecking(&#x27;John&#x27;) &gt;&gt;&gt; ch2.balance = 10 &gt;&gt;&gt; ch2.withdraw(3) # No fee 7 &gt;&gt;&gt; ch.withdraw(3) # ch still charges a fee 5 &gt;&gt;&gt; ch.withdraw(5) # Not enough to cover fee + withdraw &#x27;Insufficient funds&#x27; &quot;&quot;&quot; withdraw_fee = 1 free_withdrawals = 2 &quot;*** YOUR CODE HERE ***&quot; def __init__(self, Account): Account.__init__(self) def withdraw(self, amount): if amount + self.withdraw_fee &gt; self.balance: return &quot;Insufficient funds&quot; if amount &gt; self.max_withdrawal: return &quot;Can&#x27;t withdraw that amount&quot; if self.free_withdrawals &gt; 0: self.free_withdrawals -= 1 self.balance = self.balance - amount if self.free_withdrawals &lt;= 0: self.balance = self.balance - self.withdraw_fee return self.balance Use Ok to test your code: 1python3 ok -q FreeChecking✂️ Submit Make sure to submit this assignment by running: 1python3 ok --submit","categories":[],"tags":[{"name":"CS61A","slug":"CS61A","permalink":"http://www.misaka-9982.com/tags/CS61A/"}]},{"title":"CS61A Homework 4","slug":"CS61A-Homework-4","date":"2022-05-21T05:54:01.000Z","updated":"2022-05-22T11:01:57.785Z","comments":true,"path":"2022/05/21/CS61A-Homework-4/","link":"","permalink":"http://www.misaka-9982.com/2022/05/21/CS61A-Homework-4/","excerpt":"","text":"Homework 4: Python Lists, Object-Oriented Programming hw04.zip Parsons Problems To work on these problems, open the Parsons editor: 1python3 parsons Q1: Remove Odd Indices Complete the function remove_odd_indices, which takes in a list lst and a boolean odd, and returns a new list with elements removed at certain indices. If odd is True, then the function should remove elements at odd indices; otherwise if odd is False, then the function should remove even indexed items. Note that lists are zero-indexed; thus, the first element is at index 0, the second element is at index 1, etc. 12345678910111213141516171819def remove_odd_indices(lst, odd): &quot;&quot;&quot; Remove elements of lst that have odd indices. &gt;&gt;&gt; s = [1, 2, 3, 4] &gt;&gt;&gt; t = remove_odd_indices(s, True) &gt;&gt;&gt; s [1, 2, 3, 4] &gt;&gt;&gt; t [1, 3] &gt;&gt;&gt; l = [5, 6, 7, 8] &gt;&gt;&gt; m = remove_odd_indices(l, False) &gt;&gt;&gt; m [6, 8] &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; if odd: return [lst[x] for x in range(len(lst)) if x % 2 == 0] else: return [lst[x] for x in range(len(lst)) if x % 2 == 1] Q2: Smart Fridge The SmartFridge class is used by smart refrigerators to track which items are in the fridge and let owners know when an item has run out. The class internally uses a dictionary to store items, where each key is the item name and the value is the current quantity. The add_item method should add the given quantity of the given item and report the current quantity. You can assume that the use_item method will only be called on items that are already in the fridge, and it should use up the given quantity of the given item. If the quantity would fall to or below zero, it should only use up to the remaining quantity, and remind the owner to buy more of that item. Finish implementing the SmartFridge class definition so that its add_item and use_item methods work as expected. 123456789101112131415161718192021222324252627class SmartFridge: &quot;&quot;&quot;&quot; &gt;&gt;&gt; fridgey = SmartFridge() &gt;&gt;&gt; fridgey.add_item(&#x27;Mayo&#x27;, 1) &#x27;I now have 1 Mayo&#x27; &gt;&gt;&gt; fridgey.add_item(&#x27;Mayo&#x27;, 2) &#x27;I now have 3 Mayo&#x27; &gt;&gt;&gt; fridgey.use_item(&#x27;Mayo&#x27;, 2.5) &#x27;I have 0.5 Mayo left&#x27; &gt;&gt;&gt; fridgey.use_item(&#x27;Mayo&#x27;, 0.5) &#x27;Uh oh, buy more Mayo!&#x27; &quot;&quot;&quot; def __init__(self): self.items = &#123;&#125; def add_item(self, item, quantity): &quot;*** YOUR CODE HERE ***&quot; if item in self.items: self.items[item] += quantity else: self.items[item] = quantity return f&#x27;I now have &#123;self.items[item]&#125;&#123;item&#125;&#x27; def use_item(self, item, quantity): &quot;*** YOUR CODE HERE ***&quot; self.items[item] -= min(quantity, self.items[item]) if self.items[item] == 0: return f&#x27;Uh oh, buy more &#123;item&#125;!&#x27; return f&#x27;I have &#123;self.items[item]&#125;&#123;item&#125; left&#x27; Code Writing Questions Q3: Merge Write a function merge that takes 2 sorted lists lst1 and lst2, and returns a new list that contains all the elements in the two lists in sorted order. Note: Try to solve this question using recursion instead of iteration. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748def merge(lst1, lst2): &quot;&quot;&quot;Merges two sorted lists. &gt;&gt;&gt; merge([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] &gt;&gt;&gt; merge([], [2, 4, 6]) [2, 4, 6] &gt;&gt;&gt; merge([1, 2, 3], []) [1, 2, 3] &gt;&gt;&gt; merge([5, 7], [2, 4, 6]) [2, 4, 5, 6, 7] &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; def helper(lst1, n, lst2, m): if n == 0: return lst2 if m == 0: return lst1 res = [] if lst1[0] &lt; lst2[0]: res.append(lst1[0]) res.extend(helper(lst1[1:], n - 1, lst2, m)) else: res.append(lst2[0]) res.extend(helper(lst2[1:], m - 1, lst1, n)) return res return helper(lst1, len(lst1), lst2, len(lst2)) &quot;&quot;&quot;Iteration res = [] i, j = 0, 0 while i &lt; len(lst1) and j &lt; len(lst2): if lst1[i] &lt; lst2[j]: res.append(lst1[i]) i += 1 else: res.append(lst2[j]) j += 1 while i &lt; len(lst1): res.append(lst1[i]) i += 1 while j &lt; len(lst2): res.append(lst2[j]) j += 1 return res &quot;&quot;&quot; Use Ok to test your code: 1python3 ok -q merge✂️ Q4: Mint A mint is a place where coins are made. In this question, you’ll implement a Mint class that can output a Coin with the correct year and worth. Each Mint instance has a year stamp. The update method sets the year stamp to the present_year class attribute of the Mint class. The create method takes a subclass of Coin and returns an instance of that class stamped with the mint’s year (which may be different from Mint.present_year if it has not been updated.) A Coin’s worth method returns the cents value of the coin plus one extra cent for each year of age beyond 50. A coin’s age can be determined by subtracting the coin’s year from the present_year class attribute of the Mint class. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Mint: &quot;&quot;&quot;A mint creates coins by stamping on years. The update method sets the mint&#x27;s stamp to Mint.present_year. &gt;&gt;&gt; mint = Mint() &gt;&gt;&gt; mint.year 2021 &gt;&gt;&gt; dime = mint.create(Dime) &gt;&gt;&gt; dime.year 2021 &gt;&gt;&gt; Mint.present_year = 2101 # Time passes &gt;&gt;&gt; nickel = mint.create(Nickel) &gt;&gt;&gt; nickel.year # The mint has not updated its stamp yet 2021 &gt;&gt;&gt; nickel.worth() # 5 cents + (80 - 50 years) 35 &gt;&gt;&gt; mint.update() # The mint&#x27;s year is updated to 2101 &gt;&gt;&gt; Mint.present_year = 2176 # More time passes &gt;&gt;&gt; mint.create(Dime).worth() # 10 cents + (75 - 50 years) 35 &gt;&gt;&gt; Mint().create(Dime).worth() # A new mint has the current year 10 &gt;&gt;&gt; dime.worth() # 10 cents + (155 - 50 years) 115 &gt;&gt;&gt; Dime.cents = 20 # Upgrade all dimes! &gt;&gt;&gt; dime.worth() # 20 cents + (155 - 50 years) 125 &quot;&quot;&quot; present_year = 2021 def __init__(self): self.update() def create(self, coin): &quot;*** YOUR CODE HERE ***&quot; return coin(self.year) def update(self): &quot;*** YOUR CODE HERE ***&quot; self.year = Mint.present_yearclass Coin: cents = None # will be provided by subclasses, but not by Coin itself def __init__(self, year): self.year = year def worth(self): &quot;*** YOUR CODE HERE ***&quot; return self.cents + max(0, Mint.present_year - self.year - 50)class Nickel(Coin): cents = 5class Dime(Coin): cents = 10 Use Ok to test your code: 1python3 ok -q Mint✂️ Q5: Vending Machine In this question you’ll create a vending machine that only outputs a single product and provides change when needed. Create a class called VendingMachine that represents a vending machine for some product. A VendingMachine object returns strings describing its interactions. Remember to match exactly the strings in the doctests – including punctuation and spacing! Fill in the VendingMachine class, adding attributes and methods as appropriate, such that its behavior matches the following doctests: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class VendingMachine: &quot;&quot;&quot;A vending machine that vends some product for some price. &gt;&gt;&gt; v = VendingMachine(&#x27;candy&#x27;, 10) &gt;&gt;&gt; v.vend() &#x27;Nothing left to vend. Please restock.&#x27; &gt;&gt;&gt; v.add_funds(15) &#x27;Nothing left to vend. Please restock. Here is your $15.&#x27; &gt;&gt;&gt; v.restock(2) &#x27;Current candy stock: 2&#x27; &gt;&gt;&gt; v.vend() &#x27;You must add $10 more funds.&#x27; &gt;&gt;&gt; v.add_funds(7) &#x27;Current balance: $7&#x27; &gt;&gt;&gt; v.vend() &#x27;You must add $3 more funds.&#x27; &gt;&gt;&gt; v.add_funds(5) &#x27;Current balance: $12&#x27; &gt;&gt;&gt; v.vend() &#x27;Here is your candy and $2 change.&#x27; &gt;&gt;&gt; v.add_funds(10) &#x27;Current balance: $10&#x27; &gt;&gt;&gt; v.vend() &#x27;Here is your candy.&#x27; &gt;&gt;&gt; v.add_funds(15) &#x27;Nothing left to vend. Please restock. Here is your $15.&#x27; &gt;&gt;&gt; w = VendingMachine(&#x27;soda&#x27;, 2) &gt;&gt;&gt; w.restock(3) &#x27;Current soda stock: 3&#x27; &gt;&gt;&gt; w.restock(3) &#x27;Current soda stock: 6&#x27; &gt;&gt;&gt; w.add_funds(2) &#x27;Current balance: $2&#x27; &gt;&gt;&gt; w.vend() &#x27;Here is your soda.&#x27; &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; def __init__(self, name, price): self.name = name self.price = price self.num = 0 self.balance = 0 def restock(self, num): self.num += num return f&quot;Current &#123;self.name&#125; stock: &#123;self.num&#125;&quot; def add_funds(self, amount): if self.num &gt; 0: self.balance += amount return f&quot;Current balance: $&#123;self.balance&#125;&quot; else: return f&#x27;Nothing left to vend. Please restock. Here is your $&#123;amount&#125;.&#x27; def vend(self): if self.num == 0: return f&#x27;Nothing left to vend. Please restock.&#x27; if self.balance &lt; self.price: return f&quot;You must add $&#123;self.price - self.balance&#125; more funds.&quot; else: self.balance = self.balance - self.price self.num -= 1 if self.balance &gt; 0: ret = f&quot;Here is your &#123;self.name&#125; and $&#123;self.balance&#125; change.&quot; self.balance = 0 return ret elif self.balance == 0: return f&quot;Here is your &#123;self.name&#125;.&quot; You may find Python’s formatted string literals, or f-strings useful. A quick example: 1234&gt;&gt;&gt; feeling = &#x27;love&#x27;&gt;&gt;&gt; course = &#x27;61A!&#x27;&gt;&gt;&gt; f&#x27;I &#123;feeling&#125; &#123;course&#125;&#x27;&#x27;I love 61A!&#x27; Use Ok to test your code: 1python3 ok -q VendingMachine✂️ If you’re curious about alternate methods of string formatting, you can also check out an older method of Python string formatting. A quick example: 123&gt;&gt;&gt; ten, twenty, thirty = 10, &#x27;twenty&#x27;, [30]&gt;&gt;&gt; &#x27;&#123;0&#125; plus &#123;1&#125; is &#123;2&#125;&#x27;.format(ten, twenty, thirty)&#x27;10 plus twenty is [30]&#x27; Submit Make sure to submit this assignment by running: 1python3 ok --submit","categories":[],"tags":[{"name":"CS61A","slug":"CS61A","permalink":"http://www.misaka-9982.com/tags/CS61A/"}]},{"title":"CS61A Lab 5","slug":"CS61A-Lab-5","date":"2022-05-20T16:43:41.000Z","updated":"2022-05-21T05:50:35.486Z","comments":true,"path":"2022/05/21/CS61A-Lab-5/","link":"","permalink":"http://www.misaka-9982.com/2022/05/21/CS61A-Lab-5/","excerpt":"","text":"What Would Python Do? Q1: WWPD: List-Mutation Use Ok to test your knowledge with the following “What Would Python Display?” questions: 1python3 ok -q list-mutation -u✂️ Important: For all WWPD questions, type Function if you believe the answer is &lt;function...&gt;, Error if it errors, and Nothing if nothing is displayed. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&gt;&gt;&gt; lst = [5, 6, 7, 8]&gt;&gt;&gt; lst.append(6)? Nothing-- OK! --&gt;&gt;&gt; lst? [5, 6, 7, 8, 6]-- OK! --&gt;&gt;&gt; lst.insert(0, 9)&gt;&gt;&gt; lst? [9, 5, 6, 7, 8, 6]-- OK! --&gt;&gt;&gt; x = lst.pop(2)&gt;&gt;&gt; lst? [9, 5, 7, 8, 6]-- OK! --&gt;&gt;&gt; lst.remove(x)&gt;&gt;&gt; lst? [9, 5, 7, 8]-- OK! --&gt;&gt;&gt; a, b = lst, lst[:]&gt;&gt;&gt; a is lst? False-- Not quite. Try again! --? True-- OK! --&gt;&gt;&gt; b == lst? True-- OK! --&gt;&gt;&gt; b is lst? False-- OK! --&gt;&gt;&gt; lst = [1, 2, 3]&gt;&gt;&gt; lst.extend([4,5])&gt;&gt;&gt; lst? [1, 2, 3, 4, 5]-- OK! --&gt;&gt;&gt; lst.extend([lst.append(9), lst.append(10)])&gt;&gt;&gt; lst? [1, 2, 3, 4, 5, 9, 10, None, None]-- OK! -- Parsons Problems To work on these problems, open the Parsons editor: 1python3 parsons Q2: Replace Elements Complete the function replace_elements, a function which takes in source_list and dest_list and mutates the elements of dest_list to be the elements at the corresponding index in source_list. dest_list always has a length greater than or equal to the length of source_list. 1234567891011121314151617181920212223def replace_elements(source_list, dest_list): &quot;&quot;&quot; Complete the function replace_elements, a function which takes in source_list and dest_list and mutates the elements of dest_list to be the elements at the corresponding index in source_list. dest_list always has a length greater than or equal to the length of source_list. &gt;&gt;&gt; s1 = [1, 2, 3] &gt;&gt;&gt; s2 = [5, 4] &gt;&gt;&gt; replace_elements(s2, s1) &gt;&gt;&gt; s1 [5, 4, 3] &gt;&gt;&gt; s3 = [0, 0, 0, 0, 0] &gt;&gt;&gt; replace_elements(s1, s3) &gt;&gt;&gt; s3 [5, 4, 3, 0, 0] &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; for i in range(len(source_list)): dest_list[i] = source_list[i] Code Writing Questions Q3: Flatten Write a function flatten that takes a list and “flattens” it. The list could be a deep list, meaning that there could be a multiple layers of nesting within the list. For example, one use case of flatten could be the following: 123&gt;&gt;&gt; lst = [1, [[2], 3], 4, [5, 6]]&gt;&gt;&gt; flatten(lst)[1, 2, 3, 4, 5, 6] Make sure your solution does not mutate the input list. Hint: you can check if something is a list by using the built-in type function. For example: 1234&gt;&gt;&gt; type(3) == listFalse&gt;&gt;&gt; type([1, 2, 3]) == listTrue 123456789101112131415161718192021222324def flatten(s): &quot;&quot;&quot;Returns a flattened version of list s. &gt;&gt;&gt; flatten([1, 2, 3]) # normal list [1, 2, 3] &gt;&gt;&gt; x = [1, [2, 3], 4] # deep list &gt;&gt;&gt; flatten(x) [1, 2, 3, 4] &gt;&gt;&gt; x # Ensure x is not mutated [1, [2, 3], 4] &gt;&gt;&gt; x = [[1, [1, 1]], 1, [1, 1]] # deep list &gt;&gt;&gt; flatten(x) [1, 1, 1, 1, 1, 1] &gt;&gt;&gt; x [[1, [1, 1]], 1, [1, 1]] &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; res = [] for item in s: if type(item) == list: res.extend(flatten(item)) else: res.append(item) return res Use Ok to test your code: 1python3 ok -q flatten✂️ Q4: Couple Implement the function couple, which takes in two lists and returns a list that contains lists with i-th elements of two sequences coupled together. You can assume the lengths of two sequences are the same. Try using a list comprehension. Hint: You may find the built in range function helpful. 12345678910111213141516171819202122def couple(s, t): &quot;&quot;&quot;Return a list of two-element lists in which the i-th element is [s[i], t[i]]. &gt;&gt;&gt; a = [1, 2, 3] &gt;&gt;&gt; b = [4, 5, 6] &gt;&gt;&gt; couple(a, b) [[1, 4], [2, 5], [3, 6]] &gt;&gt;&gt; c = [&#x27;c&#x27;, 6] &gt;&gt;&gt; d = [&#x27;s&#x27;, &#x27;1&#x27;] &gt;&gt;&gt; couple(c, d) [[&#x27;c&#x27;, &#x27;s&#x27;], [6, &#x27;1&#x27;]] &quot;&quot;&quot; assert len(s) == len(t) &quot;*** YOUR CODE HERE ***&quot; def make_pair(a, b): return [a, b] res = [] for index in range(len(s)): pair = make_pair(s[index], t[index]) res.append(pair) return res Use Ok to test your code: 1python3 ok -q couple✂️ Q5: Insert Items Write a function which takes in a list lst, an argument entry, and another argument elem. This function will check through each item in lst to see if it is equal to entry. Upon finding an item equal to entry, the function should modify the list by placing elem into lst right after the item. At the end of the function, the modified list should be returned. See the doctests for examples on how this function is utilized. Important: Use list mutation to modify the original list. No new lists should be created or returned. Note: If the values passed into entry and elem are equivalent, make sure you’re not creating an infinitely long list while iterating through it. If you find that your code is taking more than a few seconds to run, the function may be in a loop of inserting new values. 1234567891011121314151617181920212223242526272829303132333435def insert_items(lst, entry, elem): &quot;&quot;&quot;Inserts elem into lst after each occurence of entry and then returns lst. &gt;&gt;&gt; test_lst = [1, 5, 8, 5, 2, 3] &gt;&gt;&gt; new_lst = insert_items(test_lst, 5, 7) &gt;&gt;&gt; new_lst [1, 5, 7, 8, 5, 7, 2, 3] &gt;&gt;&gt; double_lst = [1, 2, 1, 2, 3, 3] &gt;&gt;&gt; double_lst = insert_items(double_lst, 3, 4) &gt;&gt;&gt; double_lst [1, 2, 1, 2, 3, 4, 3, 4] &gt;&gt;&gt; large_lst = [1, 4, 8] &gt;&gt;&gt; large_lst2 = insert_items(large_lst, 4, 4) &gt;&gt;&gt; large_lst2 [1, 4, 4, 8] &gt;&gt;&gt; large_lst3 = insert_items(large_lst2, 4, 6) &gt;&gt;&gt; large_lst3 [1, 4, 6, 4, 6, 8] &gt;&gt;&gt; large_lst3 is large_lst True &gt;&gt;&gt; # Ban creating new lists &gt;&gt;&gt; from construct_check import check &gt;&gt;&gt; check(HW_SOURCE_FILE, &#x27;insert_items&#x27;, ... [&#x27;List&#x27;, &#x27;ListComp&#x27;, &#x27;Slice&#x27;]) True &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; idx = 0 while idx &lt; len(lst): if lst[idx] == entry: lst.insert(idx + 1, elem) idx += 2 else: idx += 1 return lst Use Ok to test your code: 1python3 ok -q insert_items","categories":[],"tags":[{"name":"CS61A","slug":"CS61A","permalink":"http://www.misaka-9982.com/tags/CS61A/"}]},{"title":"CS61A Lab 4","slug":"CS61A-Lab-4","date":"2022-05-20T15:27:05.000Z","updated":"2022-05-20T16:32:48.608Z","comments":true,"path":"2022/05/20/CS61A-Lab-4/","link":"","permalink":"http://www.misaka-9982.com/2022/05/20/CS61A-Lab-4/","excerpt":"","text":"Lab 4: Recursion, Tree Recursion lab04.zip What Would Python Do? Q1: Squared Virahanka Fibonacci Use Ok to test your knowledge with the following “What Would Python Display?” questions: 1python3 ok -q squared-virfib-wwpd -u✂️ Hint: If you are stuck, try drawing out the recursive call tree. See 02/11’s Lecture (Tree Recursion) for more information. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&gt;&gt;&gt; def virfib_sq(n):... print(n)... if n &lt;= 1:... return n... return (virfib_sq(n - 1) + virfib_sq(n - 2)) ** 2&gt;&gt;&gt; r0 = virfib_sq(0)? 0-- OK! --&gt;&gt;&gt; r1 = virfib_sq(1)? 1-- OK! --&gt;&gt;&gt; r2 = virfib_sq(2)(line 1)? 2(line 2)? 1(line 3)? 0-- OK! --&gt;&gt;&gt; r3 = virfib_sq(3)(line 1)? 3(line 2)? 2(line 3)? 1(line 4)? 0(line 5)? 1-- OK! --&gt;&gt;&gt; r3? 4-- OK! --&gt;&gt;&gt; (r1 + r2) ** 2? 4-- OK! --&gt;&gt;&gt; r4 = virfib_sq(4)(line 1)? 4(line 2)? 3(line 3)? 2(line 4)? 1(line 5)? 0(line 6)? 1(line 7)? 2(line 8)? 1(line 9)? 0-- OK! --&gt;&gt;&gt; r4? 25-- OK! -- Parsons Problems To work on these problems, open the Parsons editor: 1python3 parsons Q2: Line Stepper Complete the function line_stepper, which returns the number of ways there are to go from start to 0 on the number line by taking exactly k steps along the number line. Note that at each step, you must travel either left or right; you may not stay in place! For example, here is a visualization of all possible paths if we start at 3 on the number line with 5 steps. At every step, we move either one step to the left of right, and we ultimately end each path at 0. 123456789101112131415161718192021222324def line_stepper(start, k): &quot;&quot;&quot; Complete the function line_stepper, which returns the number of ways there are to go from start to 0 on the number line by taking exactly k steps along the number line. &gt;&gt;&gt; line_stepper(1, 1) 1 &gt;&gt;&gt; line_stepper(0, 2) 2 &gt;&gt;&gt; line_stepper(-3, 3) 1 &gt;&gt;&gt; line_stepper(3, 5) 5 &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; def line_stepper(start, k): if start == 0 and k == 0: return 1 elif k == 0: return 0 else: left = line_stepper(start - 1, k - 1) right = line_stepper(start + 1, k - 1) return left + right Code Writing Questions Q3: Summation Write a recursive implementation of summation, which takes a positive integer n and a function term. It applies term to every number from 1 to n including n and returns the sum. Important: Use recursion; the tests will fail if you use any loops (for, while). 1234567891011121314151617181920212223def summation(n, term): &quot;&quot;&quot;Return the sum of numbers 1 through n (including n) wíth term applied to each number. Implement using recursion! &gt;&gt;&gt; summation(5, lambda x: x * x * x) # 1^3 + 2^3 + 3^3 + 4^3 + 5^3 225 &gt;&gt;&gt; summation(9, lambda x: x + 1) # 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 54 &gt;&gt;&gt; summation(5, lambda x: 2**x) # 2^1 + 2^2 + 2^3 + 2^4 + 2^5 62 &gt;&gt;&gt; # Do not use while/for loops! &gt;&gt;&gt; from construct_check import check &gt;&gt;&gt; # ban iteration &gt;&gt;&gt; check(HW_SOURCE_FILE, &#x27;summation&#x27;, ... [&#x27;While&#x27;, &#x27;For&#x27;]) True &quot;&quot;&quot; assert n &gt;= 1 &quot;*** YOUR CODE HERE ***&quot; if n == 1: return term(n) else: return term(n) + summation(n - 1, term) Use Ok to test your code: 1python3 ok -q summation✂️ Q4: Insect Combinatorics Consider an insect in an M by N grid. The insect starts at the bottom left corner, (1, 1), and wants to end up at the top right corner, (M, N). The insect is only capable of moving right or up. Write a function paths that takes a grid length and width and returns the number of different paths the insect can take from the start to the goal. (There is a closed-form solution to this problem, but try to answer it procedurally using recursion.) For example, the 2 by 2 grid has a total of two ways for the insect to move from the start to the goal. For the 3 by 3 grid, the insect has 6 diferent paths (only 3 are shown above). Hint: What happens if we hit the top or rightmost edge? 12345678910111213141516171819202122def paths(m, n): &quot;&quot;&quot;Return the number of paths from one corner of an M by N grid to the opposite corner. &gt;&gt;&gt; paths(2, 2) 2 &gt;&gt;&gt; paths(5, 7) 210 &gt;&gt;&gt; paths(117, 1) 1 &gt;&gt;&gt; paths(1, 157) 1 &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; if m == 1 and n == 1: return 1 elif m == 0 or n == 0: return 0 else: up = paths(m - 1, n) right = paths(m, n - 1) return up + right Use Ok to test your code: 1python3 ok -q paths✂️ Q5: Pascal’s Triangle Pascal’s triangle gives the coefficients of a binomial expansion; if you expand the expression (a + b) ** n, all coefficients will be found on the nth row of the triangle, and the coefficient of the ith term will be at the ith column. Here’s a part of the Pascal’s trangle: 1234511 11 2 11 3 3 11 4 6 4 1 Every number in Pascal’s triangle is defined as the sum of the item above it and the item above and to the left of it. Rows and columns are zero-indexed; that is, the first row is row 0 instead of 1 and the first column is column 0 instead of column 1. For example, the item at row 2, column 1 in Pascal’s triangle is 2. Now, define the procedure pascal(row, column) which takes a row and a column, and finds the value of the item at that position in Pascal’s triangle. Note that Pascal’s triangle is only defined at certain areas; use 0 if the item does not exist. For the purposes of this question, you may also assume that row &gt;= 0 and column &gt;= 0. 12345678910111213141516171819202122def pascal(row, column): &quot;&quot;&quot;Returns the value of the item in Pascal&#x27;s Triangle whose position is specified by row and column. &gt;&gt;&gt; pascal(0, 0) 1 &gt;&gt;&gt; pascal(0, 5) # Empty entry; outside of Pascal&#x27;s Triangle 0 &gt;&gt;&gt; pascal(3, 2) # Row 3 (1 3 3 1), Column 2 3 &gt;&gt;&gt; pascal(4, 2) # Row 4 (1 4 6 4 1), Column 2 6 &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; if row == 0 and column == 0: return 1 elif column == 0 or column == row: return 1 elif column &gt; row: return 0 else: return pascal(row - 1, column - 1) + pascal(row - 1, column) Use Ok to test your code: 1python3 ok -q pascal✂️","categories":[],"tags":[{"name":"CS61A","slug":"CS61A","permalink":"http://www.misaka-9982.com/tags/CS61A/"}]},{"title":"CS61A Proj 1","slug":"CS61A-Proj-1","date":"2022-05-19T11:24:49.000Z","updated":"2022-07-23T05:20:14.308Z","comments":true,"path":"2022/05/19/CS61A-Proj-1/","link":"","permalink":"http://www.misaka-9982.com/2022/05/19/CS61A-Proj-1/","excerpt":"","text":"Rules In Hog, two players alternate turns trying to be the first to end a turn with at least 100 total points. On each turn, the current player chooses some number of dice to roll, up to 10. That player’s score for the turn is the sum of the dice outcomes. However, a player who rolls too many dice risks: Sow Sad. If any of the dice outcomes is a 1, the current player’s score for the turn is 1. Examples Example 1: The current player rolls 7 dice, 5 of which are 1’s. They score 1 point for the turn. Example 2: The current player rolls 4 dice, all of which are 3’s. Since Sow Sad did not occur, they score 12 points for the turn. In a normal game of Hog, those are all the rules. To spice up the game, we’ll include some special rules: Hefty Hogs. If the opponent’s score is 0 and the player chooses to roll zero dice, the player will get 1 point. However, if the opponent’s score is not 0, a player who chooses to roll zero dice will gain points according to the following: The opponent’s score will be mapped to a series of functions to be applied to the player’s score, starting from the rightmost digit (the one’s place) and ending on the leftmost digit. Each digit from 0 to 9 corresponds to a pre-defined function, f0 through f9. The result of this series of calls modulo 30 is the amount of points the player receives for the turn. Examples Example 1: The current player has 10 points. The opponent player has 32 points. The functions are applied in this order: The rightmost digit of the opponent’s score is 2. The corresponding function, f2, is applied to 10. The next digit of the opponent’s score is 3. The corresponding function, f3, is applied to the result of f2(10). The points the current player gains is the result of that call, modulo 30: f3(f2(10)) % 30. Example 2: The current player has 33 points. The opponent player has 5439 points. The functions are applied in this order: The rightmost digit of the opponent’s score is 9. The corresponding function,f9, is applied to 33. And so on: Function f3 is applied to the result of f9(33). Function f4 is applied to the result of f3(f9(33)). Function f5 is applied to the result of f4(f3(f9(33))). The points the current player gains is the result of that call, modulo 30: f5(f4(f3(f9(33)))) % 30. Hog Pile. After points for the turn are added to the current player’s score, if the one’s digit (ones_digit) of the current player’s score is the same as the one’s digit of the opponent player’s score, the current player gains an additional ones_digit points. Examples Example: Both players start out at 0. (0, 0) Player 0 rolls 2 dice and gets 5 points. (5, 0) Player 1 rolls 1 dice and gets 5 points. (5, 5) Player 1 gets 5 more points. (5, 10) Player 0 rolls 2 dice and gets 6 points. (11, 10) Player 1 rolls 8 dice and gets 1 point. (11, 11) Player 1 gets 1 more point. (11, 12) 游戏规则 在 Hog 游戏中，两个玩家轮流尝试成为第一个以至少100分的总分结束一回合的人。在每个回合中，当前的玩家会选择一定数量的骰子来掷出，最多为10。该玩家在该回合的得分是骰子结果的总和。然而，一个玩家如果掷出太多的骰子，就会有风险。 Sow Sad. 如果任何一个骰子的结果是1，那么当前玩家在这一回合的得分就是1。 例1：当前玩家掷出7个骰子，其中5个是1。他们在这一回合的得分是1分。 例2：当前玩家掷出4颗骰子，全部是3。由于 Sow Sad 没有发生，他们这一局得12分。 在一个正常的霍格游戏中，这些就是所有的规则。为了增加游戏的趣味性，我们会加入一些特殊的规则。 Hefty Hogs. 如果对手的分数是0，而玩家选择掷出0个骰子，玩家将得到1分。然而，如果对手的分数不是0，选择掷零骰子的玩家将按照以下方式获得分数: 对手的分数将被映射成一系列的函数，应用于玩家的分数，从最右边的数字（一的位置）开始，到最左边的数字结束。 从0到9的每个数字都对应着一个预定义的函数，f0到f9。 这一系列调用modulo 30的结果就是玩家在这一回合获得的分数。 例1：当前玩家有10分。对方棋手有32分。这些函数是按照这个顺序来应用的。 对方分数的最右边的数字是2。 相应的函数，$f2$ ，被应用于10。 对手得分的下一个数字是3。 相应的函数 $f3$ 被应用于 $f2(10)$ 的结果。 当前玩家获得的分数是该调用的结果，模数为30：$f3(f2(10)) % 30$ 例2：当前棋手有33分。对方棋手有5439分。这些函数是按照这个顺序来应用的 对方分数的最右边的数字是9。 相应的函数 $f9$ 被应用于33。 以此类推。 函数 $f3$ 被应用于 $f9(33)$ 的结果。 函数 $f4$ 被应用于 $f3(f9(33))$ 的结果。 函数 $f5$ 被应用于 $f4(f3(f9(33)))$ 的结果。 当前玩家获得的点数是该调用的结果，模数为30：$f5(f4(f3(f9(33)))) % 30$ 。 Hog Pile.在本回合的分数加到当前棋手的分数之后，如果当前棋手的分数的一位数 $(ones_digit)$ 与对手棋手的分数的一位数相同，当前棋手就会获得额外的一位数的分数。 例子 双方玩家的起点都是0。 玩家0掷出2个骰子，得到5分。$(5, 0)$ 玩家1掷1个骰子，得到5分。$(5, 5)$ 玩家1又得到5分。$(5, 10)$ 玩家0掷出2个骰子，得到6分。$(11, 10)$ 玩家1掷出8个骰子，得到1分。$(11, 11)$ 玩家1又得到1分。$(11, 12)$ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423&quot;&quot;&quot;CS 61A Presents The Game of Hog.&quot;&quot;&quot;from dice import six_sided, four_sided, make_test_dicefrom ucb import main, trace, interactGOAL_SCORE = 100 # The goal of Hog is to score 100 points.####################### Phase 1: Simulator #######################def roll_dice(num_rolls, dice=six_sided): &quot;&quot;&quot;Simulate rolling the DICE exactly NUM_ROLLS &gt; 0 times. Return the sum of the outcomes unless any of the outcomes is 1. In that case, return 1. num_rolls: The number of dice rolls that will be made. dice: A function that simulates a single dice roll outcome. &quot;&quot;&quot; # These assert statements ensure that num_rolls is a positive integer. assert type(num_rolls) == int, &#x27;num_rolls must be an integer.&#x27; assert num_rolls &gt; 0, &#x27;Must roll at least once.&#x27; # BEGIN PROBLEM 1 occur_1 = False cnt = 0 for _ in range(num_rolls): cur = dice() cnt += cur if cur == 1: occur_1 = True if occur_1: cnt = 1 return cnt # END PROBLEM 1def digit_fn(digit): &quot;&quot;&quot;Return the corresponding function for the given DIGIT. value: The value which this function starts at. &quot;&quot;&quot; # Error if DIGIT is not one of: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 assert isinstance(digit, int) and 0 &lt;= digit &lt; 10 # List of pre-defined functions f0 = lambda value: value + 1 f1 = lambda value: value ** 2 f2 = lambda value: value * 3 f3 = lambda value: value // 4 f4 = lambda value: value - 5 f5 = lambda value: value % 6 f6 = lambda value: int((value % 7) * 8) f7 = lambda value: int(value * 8.8) f8 = lambda value: int(value / 99 * 15) + 10 f9 = lambda value: value # Mapping from digit to function if digit == 0: return f0 elif digit == 1: return f1 elif digit == 2: return f2 elif digit == 3: return f3 elif digit == 4: return f4 elif digit == 5: return f5 elif digit == 6: return f6 elif digit == 7: return f7 elif digit == 8: return f8 elif digit == 9: return f9def hefty_hogs(player_score, opponent_score): &quot;&quot;&quot;Return the points scored by player due to Hefty Hogs. player_score: The total score of the current player. opponent_score: The total score of the other player. &quot;&quot;&quot; # BEGIN PROBLEM 2 res = player_score cur = opponent_score while cur: res = digit_fn(cur % 10)(res) cur = cur // 10 res = res % 30 return res # END PROBLEM 2def take_turn(num_rolls, player_score, opponent_score, dice=six_sided, goal=GOAL_SCORE): &quot;&quot;&quot;Simulate a turn rolling NUM_ROLLS dice, which may be 0 in the case of a player using Hefty Hogs. Return the points scored for the turn by the current player. num_rolls: The number of dice rolls that will be made. player_score: The total score of the current player. opponent_score: The total score of the opponent. dice: A function that simulates a single dice roll outcome. goal: The goal score of the game. &quot;&quot;&quot; # Leave these assert statements here; they help check for errors. assert type(num_rolls) == int, &#x27;num_rolls must be an integer.&#x27; assert num_rolls &gt;= 0, &#x27;Cannot roll a negative number of dice in take_turn.&#x27; assert num_rolls &lt;= 10, &#x27;Cannot roll more than 10 dice.&#x27; assert max(player_score, opponent_score) &lt; goal, &#x27;The game should be over.&#x27; # BEGIN PROBLEM 3 if num_rolls == 0: if opponent_score == 0: return 1 return hefty_hogs(player_score, opponent_score) return roll_dice(num_rolls, dice) # END PROBLEM 3def hog_pile(player_score, opponent_score): &quot;&quot;&quot;Return the points scored by player due to Hog Pile. player_score: The total score of the current player. opponent_score: The total score of the other player. &quot;&quot;&quot; # BEGIN PROBLEM 4 if player_score % 10 == opponent_score % 10: return player_score % 10 return 0 # END PROBLEM 4def next_player(who): &quot;&quot;&quot;Return the other player, for a player WHO numbered 0 or 1. &gt;&gt;&gt; next_player(0) 1 &gt;&gt;&gt; next_player(1) 0 &quot;&quot;&quot; return 1 - whodef silence(score0, score1, leader=None): &quot;&quot;&quot;Announce nothing (see Phase 2).&quot;&quot;&quot; return leader, Nonedef play(strategy0, strategy1, score0=0, score1=0, dice=six_sided, goal=GOAL_SCORE, say=silence): &quot;&quot;&quot;Simulate a game and return the final scores of both players, with Player 0&#x27;s score first, and Player 1&#x27;s score second. A strategy is a function that takes two total scores as arguments (the current player&#x27;s score, and the opponent&#x27;s score), and returns a number of dice that the current player will roll this turn. strategy0: The strategy function for Player 0, who plays first. strategy1: The strategy function for Player 1, who plays second. score0: Starting score for Player 0 score1: Starting score for Player 1 dice: A function of zero arguments that simulates a dice roll. goal: The game ends and someone wins when this score is reached. say: The commentary function to call every turn. &quot;&quot;&quot; who = 0 # Who is about to take a turn, 0 (first) or 1 (second) leader = None # To be used in problem 7 msg = None # BEGIN PROBLEM 5 while score0 &lt; goal and score1 &lt; goal: if who == 0: roll0 = strategy0(score0, score1) add0 = take_turn(roll0, score0, score1, dice, goal) score0 += add0 pile0 = hog_pile(score0, score1) score0 += pile0 else: roll1 = strategy1(score1, score0) add1 = take_turn(roll1, score1, score0, dice, goal) score1 += add1 pile1 = hog_pile(score1, score0) score1 += pile1 leader, msg = say(score0, score1, leader) if msg: print(msg) who = next_player(who) # END PROBLEM 5 # (note that the indentation for the problem 7 prompt (***YOUR CODE HERE***) might be misleading) # BEGIN PROBLEM 7 &quot;*** YOUR CODE HERE ***&quot; # END PROBLEM 7 return score0, score1######################## Phase 2: Commentary ########################def say_scores(score0, score1, player=None): &quot;&quot;&quot;A commentary function that announces the score for each player.&quot;&quot;&quot; message = f&quot;Player 0 now has &#123;score0&#125; and now Player 1 has &#123;score1&#125;&quot; return player, messagedef announce_lead_changes(score0, score1, last_leader=None): &quot;&quot;&quot;A commentary function that announces when the leader has changed. &gt;&gt;&gt; leader, message = announce_lead_changes(5, 0) &gt;&gt;&gt; print(message) Player 0 takes the lead by 5 &gt;&gt;&gt; leader, message = announce_lead_changes(5, 12, leader) &gt;&gt;&gt; print(message) Player 1 takes the lead by 7 &gt;&gt;&gt; leader, message = announce_lead_changes(8, 12, leader) &gt;&gt;&gt; print(leader, message) 1 None &gt;&gt;&gt; leader, message = announce_lead_changes(8, 13, leader) &gt;&gt;&gt; leader, message = announce_lead_changes(15, 13, leader) &gt;&gt;&gt; print(message) Player 0 takes the lead by 2 &quot;&quot;&quot; # BEGIN PROBLEM 6 if last_leader is None: if score0 &gt; score1: return 0, f&quot;Player 0 takes the lead by &#123;score0 - score1&#125;&quot; elif score0 &lt; score1: return 1, f&quot;Player 1 takes the lead by &#123;score1 - score0&#125;&quot; else: return None, None elif last_leader == 0: if score0 &lt; score1: return 1, f&quot;Player 1 takes the lead by &#123;score1 - score0&#125;&quot; elif score0 &gt; score1: return 0, None else: return None, None elif last_leader == 1: if score0 &gt; score1: return 0, f&quot;Player 0 takes the lead by &#123;score0 - score1&#125;&quot; elif score0 &lt; score1: return 1, None else: return None, None # END PROBLEM 6def both(f, g): &quot;&quot;&quot;A commentary function that says what f says, then what g says. &gt;&gt;&gt; say_both = both(say_scores, announce_lead_changes) &gt;&gt;&gt; player, message = say_both(10, 0) &gt;&gt;&gt; print(message) Player 0 now has 10 and now Player 1 has 0 Player 0 takes the lead by 10 &gt;&gt;&gt; player, message = say_both(10, 8, player) &gt;&gt;&gt; print(message) Player 0 now has 10 and now Player 1 has 8 &gt;&gt;&gt; player, message = say_both(10, 17, player) &gt;&gt;&gt; print(message) Player 0 now has 10 and now Player 1 has 17 Player 1 takes the lead by 7 &quot;&quot;&quot; def say(score0, score1, player=None): f_player, f_message = f(score0, score1, player) g_player, g_message = g(score0, score1, player) if f_message and g_message: return g_player, f_message + &quot;\\n&quot; + g_message else: return g_player, f_message or g_message return say######################## Phase 3: Strategies ########################def always_roll(n): &quot;&quot;&quot;Return a strategy that always rolls N dice. A strategy is a function that takes two total scores as arguments (the current player&#x27;s score, and the opponent&#x27;s score), and returns a number of dice that the current player will roll this turn. &gt;&gt;&gt; strategy = always_roll(5) &gt;&gt;&gt; strategy(0, 0) 5 &gt;&gt;&gt; strategy(99, 99) 5 &quot;&quot;&quot; def strategy(score, opponent_score): return n return strategydef make_averaged(original_function, total_samples=1000): &quot;&quot;&quot;Return a function that returns the average value of ORIGINAL_FUNCTION called TOTAL_SAMPLES times. To implement this function, you will have to use *args syntax, a new Python feature introduced in this project. See the project description. &gt;&gt;&gt; dice = make_test_dice(4, 2, 5, 1) &gt;&gt;&gt; averaged_dice = make_averaged(roll_dice, 1000) &gt;&gt;&gt; averaged_dice(1, dice) 3.0 &quot;&quot;&quot; # BEGIN PROBLEM 8 return lambda *args: sum(original_function(*args) for _ in range(total_samples)) / total_samples # END PROBLEM 8def max_scoring_num_rolls(dice=six_sided, total_samples=1000): &quot;&quot;&quot;Return the number of dice (1 to 10) that gives the highest average turn score by calling roll_dice with the provided DICE a total of TOTAL_SAMPLES times. Assume that the dice always return positive outcomes. &gt;&gt;&gt; dice = make_test_dice(1, 6) &gt;&gt;&gt; max_scoring_num_rolls(dice) 1 &quot;&quot;&quot; # BEGIN PROBLEM 9 ma = make_averaged(roll_dice, total_samples) trials = [ma(i, dice) for i in range(1, 11)] return trials.index(max(trials)) + 1 # END PROBLEM 9def winner(strategy0, strategy1): &quot;&quot;&quot;Return 0 if strategy0 wins against strategy1, and 1 otherwise.&quot;&quot;&quot; score0, score1 = play(strategy0, strategy1) if score0 &gt; score1: return 0 else: return 1def average_win_rate(strategy, baseline=always_roll(6)): &quot;&quot;&quot;Return the average win rate of STRATEGY against BASELINE. Averages the winrate when starting the game as player 0 and as player 1. &quot;&quot;&quot; win_rate_as_player_0 = 1 - make_averaged(winner)(strategy, baseline) win_rate_as_player_1 = make_averaged(winner)(baseline, strategy) return (win_rate_as_player_0 + win_rate_as_player_1) / 2def run_experiments(): &quot;&quot;&quot;Run a series of strategy experiments and report results.&quot;&quot;&quot; six_sided_max = max_scoring_num_rolls(six_sided) print(&#x27;Max scoring num rolls for six-sided dice:&#x27;, six_sided_max) print(&#x27;always_roll(6) win rate:&#x27;, average_win_rate(always_roll(6))) #print(&#x27;always_roll(8) win rate:&#x27;, average_win_rate(always_roll(8))) #print(&#x27;hefty_hogs_strategy win rate:&#x27;, average_win_rate(hefty_hogs_strategy)) print(&#x27;hog_pile_strategy win rate:&#x27;, average_win_rate(hog_pile_strategy)) #print(&#x27;final_strategy win rate:&#x27;, average_win_rate(final_strategy)) &quot;*** You may add additional experiments as you wish ***&quot;def hefty_hogs_strategy(score, opponent_score, threshold=8, num_rolls=6): &quot;&quot;&quot;This strategy returns 0 dice if that gives at least THRESHOLD points, and returns NUM_ROLLS otherwise. &quot;&quot;&quot; # BEGIN PROBLEM 10 return 0 if hefty_hogs(score, opponent_score) &gt;= threshold else num_rolls # END PROBLEM 10 # return 6 # Remove this line once implemented. # END PROBLEM 10def hog_pile_strategy(score, opponent_score, threshold=8, num_rolls=6): &quot;&quot;&quot;This strategy returns 0 dice when this would result in Hog Pile taking effect. It also returns 0 dice if it gives at least THRESHOLD points. Otherwise, it returns NUM_ROLLS. &quot;&quot;&quot; # BEGIN PROBLEM 11 tmp = hefty_hogs(score, opponent_score) if hog_pile(score + tmp, opponent_score) &gt; 0: return 0 return hefty_hogs_strategy(score, opponent_score, threshold, num_rolls) # return 6 # Remove this line once implemented. # END PROBLEM 11def final_strategy(score, opponent_score): &quot;&quot;&quot;Write a brief description of your final strategy. *** YOUR DESCRIPTION HERE *** &quot;&quot;&quot; # BEGIN PROBLEM 12 return hog_pile_strategy(score, opponent_score) # return 6 # Remove this line once implemented. # END PROBLEM 12########################### Command Line Interface ############################ NOTE: Functions in this section do not need to be changed. They use features# of Python not yet covered in the course.@maindef run(*args): &quot;&quot;&quot;Read in the command-line argument and calls corresponding functions.&quot;&quot;&quot; import argparse parser = argparse.ArgumentParser(description=&quot;Play Hog&quot;) parser.add_argument(&#x27;--run_experiments&#x27;, &#x27;-r&#x27;, action=&#x27;store_true&#x27;, help=&#x27;Runs strategy experiments&#x27;) args = parser.parse_args() if args.run_experiments: run_experiments()","categories":[],"tags":[{"name":"CS61A","slug":"CS61A","permalink":"http://www.misaka-9982.com/tags/CS61A/"}]},{"title":"CS61A Lab 2","slug":"CS61A-Lab-2","date":"2022-05-19T11:07:23.000Z","updated":"2022-05-19T11:16:42.192Z","comments":true,"path":"2022/05/19/CS61A-Lab-2/","link":"","permalink":"http://www.misaka-9982.com/2022/05/19/CS61A-Lab-2/","excerpt":"","text":"Currying We can transform multiple-argument functions into a chain of single-argument, higher order functions. For example, we can write a function f(x, y) as a different function g(x)(y). This is known as currying. For example, to convert the function add(x, y) into its curried form: 1234def curry_add(x): def add2(y): return x + y return add2 Calling curry_add(1) returns a new function which only performs the addition once the returned function is called with the second addend. 12345&gt;&gt;&gt; add_one = curry_add(1)&gt;&gt;&gt; add_one(2)3&gt;&gt;&gt; add_one(4)5 Refer to the textbook for more details about currying. What Would Python Display? Important: For all WWPD questions, type Function if you believe the answer is &lt;function...&gt;, Error if it errors, and Nothing if nothing is displayed. Q1: WWPD: Lambda the Free Use Ok to test your knowledge with the following “What Would Python Display?” questions: 1python3 ok -q lambda -u✂️ As a reminder, the following two lines of code will not display anything in the Python interpreter when executed: 12&gt;&gt;&gt; x = None&gt;&gt;&gt; x 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&gt;&gt;&gt; lambda x: x # A lambda expression with one parameter x______&gt;&gt;&gt; a = lambda x: x # Assigning the lambda function to the name a&gt;&gt;&gt; a(5)______&gt;&gt;&gt; (lambda: 3)() # Using a lambda expression as an operator in a call exp.______&gt;&gt;&gt; b = lambda x: lambda: x # Lambdas can return other lambdas!&gt;&gt;&gt; c = b(88)&gt;&gt;&gt; c______&gt;&gt;&gt; c()______&gt;&gt;&gt; d = lambda f: f(4) # They can have functions as arguments as well.&gt;&gt;&gt; def square(x):... return x * x&gt;&gt;&gt; d(square)______&gt;&gt;&gt; x = None # remember to review the rules of WWPD given above!&gt;&gt;&gt; x&gt;&gt;&gt; lambda x: x______&gt;&gt;&gt; z = 3&gt;&gt;&gt; e = lambda x: lambda y: lambda: x + y + z&gt;&gt;&gt; e(0)(1)()______&gt;&gt;&gt; f = lambda z: x + z&gt;&gt;&gt; f(3)______&gt;&gt;&gt; higher_order_lambda = lambda f: lambda x: f(x)&gt;&gt;&gt; g = lambda x: x * x&gt;&gt;&gt; higher_order_lambda(2)(g) # Which argument belongs to which function call?______&gt;&gt;&gt; higher_order_lambda(g)(2)______&gt;&gt;&gt; call_thrice = lambda f: lambda x: f(f(f(x)))&gt;&gt;&gt; call_thrice(lambda y: y + 1)(0)______&gt;&gt;&gt; print_lambda = lambda z: print(z) # When is the return expression of a lambda expression executed?&gt;&gt;&gt; print_lambda______&gt;&gt;&gt; one_thousand = print_lambda(1000)______&gt;&gt;&gt; one_thousand______ Q2: WWPD: Higher Order Functions Use Ok to test your knowledge with the following “What Would Python Display?” questions: 1python3 ok -q hof-wwpd -u✂️ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&gt;&gt;&gt; def even(f):... def odd(x):... if x &lt; 0:... return f(-x)... return f(x)... return odd&gt;&gt;&gt; steven = lambda x: x&gt;&gt;&gt; stewart = even(steven)&gt;&gt;&gt; stewart______&gt;&gt;&gt; stewart(61)______&gt;&gt;&gt; stewart(-4)______&gt;&gt;&gt; def cake():... print(&#x27;beets&#x27;)... def pie():... print(&#x27;sweets&#x27;)... return &#x27;cake&#x27;... return pie&gt;&gt;&gt; chocolate = cake()______&gt;&gt;&gt; chocolate______&gt;&gt;&gt; chocolate()______&gt;&gt;&gt; more_chocolate, more_cake = chocolate(), cake______&gt;&gt;&gt; more_chocolate______&gt;&gt;&gt; def snake(x, y):... if cake == more_cake:... return chocolate... else:... return x + y&gt;&gt;&gt; snake(10, 20)______&gt;&gt;&gt; snake(10, 20)()______&gt;&gt;&gt; cake = &#x27;cake&#x27;&gt;&gt;&gt; snake(10, 20)______ Parsons Problems To work on these problems, open the Parsons editor: 1python3 parsons Q3: A Hop, a Skip, and a Jump Complete hop, which implements a curried version of the function f(x, y) = y. 12345678910111213def hop(): &quot;&quot;&quot; Calling hop returns a curried version of the function f(x, y) = y. &gt;&gt;&gt; hop()(3)(2) # .Case 1 2 &gt;&gt;&gt; hop()(3)(7) # .Case 2 7 &gt;&gt;&gt; hop()(4)(7) # .Case 3 7 &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; return lambda x: lambda y: y Q4: Digit Index Factory Complete the function digit_index_factory, which takes in two integers k and num as input and returns a function. The returned function takes no arguments, and outputs the offset between k and the rightmost digit of num. The offset between two numbers is defined to be the number of steps between the two numbers. For example, in 25, there is an offset of 1 between 2 and 5. Note that 0 is considered to have no digits (not even 0). 12345678910111213141516171819202122232425def digit_index_factory(num, k): &quot;&quot;&quot; Returns a function that takes no arguments, and outputs the offset between k and the rightmost digit of num. If k is not in num, then the returned function returns -1. Note that 0 is considered to contain no digits (not even 0). &gt;&gt;&gt; digit_index_factory(34567, 4)() # .Case 1 3 &gt;&gt;&gt; digit_index_factory(30001, 0)() # .Case 2 1 &gt;&gt;&gt; digit_index_factory(999, 1)() # .Case 3 -1 &gt;&gt;&gt; digit_index_factory(1234, 0)() # .Case 4 -1 &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; def digit_index_factory(num, k):1 index = 0 while num: if num % 10 == k: return lambda: index index += 1 num //= 107 return lambda: -1 Coding Practice Q5: Lambdas and Currying Write a function lambda_curry2 that will curry any two argument function using lambdas. Your solution to this problem should fit entirely on the return line. You can try first writing a solution without the restriction, and then rewriting it into one line after. If the syntax check isn’t passing: Make sure you’ve removed the line containing &quot;***YOUR CODE HERE***&quot; so that it doesn’t get treated as part of the function for the syntax check. 1234567891011121314151617def lambda_curry2(func): &quot;&quot;&quot; Returns a Curried version of a two-argument function FUNC. &gt;&gt;&gt; from operator import add, mul, mod &gt;&gt;&gt; curried_add = lambda_curry2(add) &gt;&gt;&gt; add_three = curried_add(3) &gt;&gt;&gt; add_three(5) 8 &gt;&gt;&gt; curried_mul = lambda_curry2(mul) &gt;&gt;&gt; mul_5 = curried_mul(5) &gt;&gt;&gt; mul_5(42) 210 &gt;&gt;&gt; lambda_curry2(mod)(123)(10) 3 &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; return lambda x: lambda y: func(x, y) Use Ok to test your code: 1python3 ok -q lambda_curry2✂️ Q6: Count van Count Consider the following implementations of count_factors and count_primes: 1234567891011121314151617181920212223242526272829303132def count_factors(n): &quot;&quot;&quot;Return the number of positive factors that n has. &gt;&gt;&gt; count_factors(6) 4 # 1, 2, 3, 6 &gt;&gt;&gt; count_factors(4) 3 # 1, 2, 4 &quot;&quot;&quot; i = 1 count = 0 while i &lt;= n: if n % i == 0: count += 1 i += 1 return countdef count_primes(n): &quot;&quot;&quot;Return the number of prime numbers up to and including n. &gt;&gt;&gt; count_primes(6) 3 # 2, 3, 5 &gt;&gt;&gt; count_primes(13) 6 # 2, 3, 5, 7, 11, 13 &quot;&quot;&quot; i = 1 count = 0 while i &lt;= n: if is_prime(i): count += 1 i += 1 return countdef is_prime(n): return count_factors(n) == 2 # only factors are 1 and n The implementations look quite similar! Generalize this logic by writing a function count_cond, which takes in a two-argument predicate function condition(n, i). count_cond returns a one-argument function that takes in n, which counts all the numbers from 1 to n that satisfy condition when called. 12345678910111213141516171819202122232425262728293031323334353637def count_cond(condition): &quot;&quot;&quot;Returns a function with one parameter N that counts all the numbers from 1 to N that satisfy the two-argument predicate function Condition, where the first argument for Condition is N and the second argument is the number from 1 to N. &gt;&gt;&gt; count_factors = count_cond(lambda n, i: n % i == 0) &gt;&gt;&gt; count_factors(2) # 1, 2 2 &gt;&gt;&gt; count_factors(4) # 1, 2, 4 3 &gt;&gt;&gt; count_factors(12) # 1, 2, 3, 4, 6, 12 6 &gt;&gt;&gt; is_prime = lambda n, i: count_factors(i) == 2 &gt;&gt;&gt; count_primes = count_cond(is_prime) &gt;&gt;&gt; count_primes(2) # 2 1 &gt;&gt;&gt; count_primes(3) # 2, 3 2 &gt;&gt;&gt; count_primes(4) # 2, 3 2 &gt;&gt;&gt; count_primes(5) # 2, 3, 5 3 &gt;&gt;&gt; count_primes(20) # 2, 3, 5, 7, 11, 13, 17, 19 8 &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; def counter(n): i = 1 cnt = 0 while i &lt;= n: if condition(n, i): cnt = cnt + 1 i = i + 1 return cnt return counter Use Ok to test your code: 1python3 ok -q count_cond✂️ Submit Make sure to submit this assignment by running: 1python3 ok --submit Optional Questions Q7: Composite Identity Function Write a function that takes in two single-argument functions, f and g, and returns another function that has a single parameter x. The returned function should return True if f(g(x)) is equal to g(f(x)). You can assume the output of g(x) is a valid input for f and vice versa. Try to use the composer function defined below for more HOF practice. 1234567891011121314151617181920212223242526272829303132333435def composer(f, g): &quot;&quot;&quot;Return the composition function which given x, computes f(g(x)). &gt;&gt;&gt; add_one = lambda x: x + 1 # adds one to x &gt;&gt;&gt; square = lambda x: x**2 &gt;&gt;&gt; a1 = composer(square, add_one) # (x + 1)^2 &gt;&gt;&gt; a1(4) 25 &gt;&gt;&gt; mul_three = lambda x: x * 3 # multiplies 3 to x &gt;&gt;&gt; a2 = composer(mul_three, a1) # ((x + 1)^2) * 3 &gt;&gt;&gt; a2(4) 75 &gt;&gt;&gt; a2(5) 108 &quot;&quot;&quot; return lambda x: f(g(x))def composite_identity(f, g): &quot;&quot;&quot; Return a function with one parameter x that returns True if f(g(x)) is equal to g(f(x)). You can assume the result of g(x) is a valid input for f and vice versa. &gt;&gt;&gt; add_one = lambda x: x + 1 # adds one to x &gt;&gt;&gt; square = lambda x: x**2 &gt;&gt;&gt; b1 = composite_identity(square, add_one) &gt;&gt;&gt; b1(0) # (0 + 1)^2 == 0^2 + 1 True &gt;&gt;&gt; b1(4) # (4 + 1)^2 != 4^2 + 1 False &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; def identity(x): return composer(f, g)(x) == composer(g, f)(x) return identity Use Ok to test your code: 1python3 ok -q composite_identity✂️ Q8: I Heard You Liked Functions… Define a function cycle that takes in three functions f1, f2, f3, as arguments. cycle will return another function that should take in an integer argument n and return another function. That final function should take in an argument x and cycle through applying f1, f2, and f3 to x, depending on what n was. Here’s what the final function should do to x for a few values of n: n = 0, return x n = 1, apply f1 to x, or return f1(x) n = 2, apply f1 to x and then f2 to the result of that, or return f2(f1(x)) n = 3, apply f1 to x, f2 to the result of applying f1, and then f3 to the result of applying f2, or f3(f2(f1(x))) n = 4, start the cycle again applying f1, then f2, then f3, then f1 again, or f1(f3(f2(f1(x)))) And so forth. Hint: most of the work goes inside the most nested function. 12345678910111213141516171819202122232425262728293031323334def cycle(f1, f2, f3): &quot;&quot;&quot;Returns a function that is itself a higher-order function. &gt;&gt;&gt; def add1(x): ... return x + 1 &gt;&gt;&gt; def times2(x): ... return x * 2 &gt;&gt;&gt; def add3(x): ... return x + 3 &gt;&gt;&gt; my_cycle = cycle(add1, times2, add3) &gt;&gt;&gt; identity = my_cycle(0) &gt;&gt;&gt; identity(5) 5 &gt;&gt;&gt; add_one_then_double = my_cycle(2) &gt;&gt;&gt; add_one_then_double(1) 4 &gt;&gt;&gt; do_all_functions = my_cycle(3) &gt;&gt;&gt; do_all_functions(2) 9 &gt;&gt;&gt; do_more_than_a_cycle = my_cycle(4) &gt;&gt;&gt; do_more_than_a_cycle(2) 10 &gt;&gt;&gt; do_two_cycles = my_cycle(6) &gt;&gt;&gt; do_two_cycles(1) 19 &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; def ref_fn(n): def ret(x): if n == 0: return x return cycle(f2, f3, f1)(n - 1)(f1(x)) return ret return ref_fn Use Ok to test your code: 1python3 ok -q cycle","categories":[],"tags":[{"name":"CS61A","slug":"CS61A","permalink":"http://www.misaka-9982.com/tags/CS61A/"}]},{"title":"CS61A Lab 1","slug":"CS61A-Lab-1","date":"2022-05-19T10:38:02.000Z","updated":"2022-05-19T11:03:04.706Z","comments":true,"path":"2022/05/19/CS61A-Lab-1/","link":"","permalink":"http://www.misaka-9982.com/2022/05/19/CS61A-Lab-1/","excerpt":"","text":"Lab 1: Variables &amp; Functions, Control lab01.zip What Would Python Display? (WWPD) Q1: WWPD: Control Use Ok to test your knowledge with the following “What Would Python Display?” questions: 1python3 ok -q control -u Hint: Make sure your while loop conditions eventually evaluate to a false value, or they’ll never stop! Typing Ctrl-C will stop infinite loops in the interpreter. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&gt;&gt;&gt; def xk(c, d):... if c == 4:... return 6... elif d &gt;= 4:... return 6 + 7 + c... else:... return 25&gt;&gt;&gt; xk(10, 10)______&gt;&gt;&gt; xk(10, 6)______&gt;&gt;&gt; xk(4, 6)______&gt;&gt;&gt; xk(0, 0)______&gt;&gt;&gt; def how_big(x):... if x &gt; 10:... print(&#x27;huge&#x27;)... elif x &gt; 5:... return &#x27;big&#x27;... elif x &gt; 0:... print(&#x27;small&#x27;)... else:... print(&quot;nothing&quot;)&gt;&gt;&gt; how_big(7)______&gt;&gt;&gt; how_big(12)______&gt;&gt;&gt; how_big(1)______&gt;&gt;&gt; how_big(-1)______&gt;&gt;&gt; n = 3&gt;&gt;&gt; while n &gt;= 0:... n -= 1... print(n)______ Hint: Make sure your while loop conditions eventually evaluate to a false value, or they’ll never stop! Typing Ctrl-C will stop infinite loops in the interpreter. 123456789101112131415&gt;&gt;&gt; positive = 28&gt;&gt;&gt; while positive:... print(&quot;positive?&quot;)... positive -= 3______&gt;&gt;&gt; positive = -9&gt;&gt;&gt; negative = -12&gt;&gt;&gt; while negative:... if positive:... print(negative)... positive += 3... negative += 3______ Q2: WWPD: Veritasiness Use Ok to test your knowledge with the following “What Would Python Display?” questions: 1python3 ok -q short-circuit -u✂️ 123456789101112131415161718192021222324252627282930313233343536373839404142434445&gt;&gt;&gt; True and 13______&gt;&gt;&gt; False or 0______&gt;&gt;&gt; not 10______&gt;&gt;&gt; not None______&gt;&gt;&gt; True and 1 / 0 and False______&gt;&gt;&gt; True or 1 / 0 or False______&gt;&gt;&gt; True and 0______&gt;&gt;&gt; False or 1______&gt;&gt;&gt; 1 and 3 and 6 and 10 and 15______&gt;&gt;&gt; -1 and 1 &gt; 0______&gt;&gt;&gt; 0 or False or 2 or 1 / 0______&gt;&gt;&gt; not 0______&gt;&gt;&gt; (1 + 1) and 1______&gt;&gt;&gt; 1/0 or True______&gt;&gt;&gt; (True or False) and False______ Q3: Debugging Quiz The following is a quick quiz on different debugging techniques that will be helpful for you to use in this class. You can refer to the debugging article to answer the questions. Use Ok to test your understanding: 1python3 ok -q debugging-quiz -u✂️ Parsons Problems To work on these problems, open the Parsons editor: 1python3 parsons Q4: Add in Range Complete add_in_range, which returns the sum of all integers between start and stop (inclusive). 12345678910111213def add_in_range(start, stop): &quot;&quot;&quot; &gt;&gt;&gt; add_in_range(3, 5) # .Case 1 12 &gt;&gt;&gt; add_in_range(1, 10) # .Case 2 55 &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; total = 0 while start &lt;= stop: total += start start += 1 return total Q5: Digit Position Match A number has a digit-position match if the ith-to-last digit is i. For example, 980 has the 0th-to-last digit as 0. Or 98276 has the 2nd-to-last digit as a 2. Write a function that determine if a number n has a digit-position match at a kth-to-last digit k. 1234567891011121314151617def digit_pos_match(n, k): &quot;&quot;&quot; &gt;&gt;&gt; digit_pos_match(980, 0) # .Case 1 True &gt;&gt;&gt; digit_pos_match(980, 2) # .Case 2 False &gt;&gt;&gt; digit_pos_match(98276, 2) # .Case 3 True &gt;&gt;&gt; digit_pos_match(98276, 3) # .Case 4 False &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; index = 0 while index &lt; k: index = index + 1 n = n // 105 return n % 10 == k Code Writing Questions Q6: Falling Factorial Let’s write a function falling, which is a “falling” factorial that takes two arguments, n and k, and returns the product of k consecutive numbers, starting from n and working downwards. When k is 0, the function should return 1. 12345678910111213141516171819def falling(n, k): &quot;&quot;&quot;Compute the falling factorial of n to depth k. &gt;&gt;&gt; falling(6, 3) # 6 * 5 * 4 120 &gt;&gt;&gt; falling(4, 3) # 4 * 3 * 2 24 &gt;&gt;&gt; falling(4, 1) # 4 4 &gt;&gt;&gt; falling(4, 0) 1 &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; res = 1 while k: res = res * n n = n - 1 k = k - 1 return res Use Ok to test your code: 1python3 ok -q falling✂️ Q7: Sum Digits Write a function that takes in a nonnegative integer and sums its digits. (Using floor division and modulo might be helpful here!) 1234567891011121314151617181920def sum_digits(y): &quot;&quot;&quot;Sum all the digits of y. &gt;&gt;&gt; sum_digits(10) # 1 + 0 = 1 1 &gt;&gt;&gt; sum_digits(4224) # 4 + 2 + 2 + 4 = 12 12 &gt;&gt;&gt; sum_digits(1234567890) 45 &gt;&gt;&gt; a = sum_digits(123) # make sure that you are using return rather than print &gt;&gt;&gt; a 6 &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; res = 0 while y: tmp = y % 10 y = y // 10 res = res + tmp return res Use Ok to test your code: 1python3 ok -q sum_digits✂️ Submit Make sure to submit this assignment by running: 1python3 ok --submit Extra Practice These questions are optional and will not affect your score on this assignment. However, they are great practice for future assignments, projects, and exams. Attempting these questions can be valuable in helping cement your knowledge of course concepts. Q8: WWPD: What If? Use Ok to test your knowledge with the following “What Would Python Display?” questions: 1python3 ok -q if-statements -u✂️ Hint: print (unlike return) does not cause the function to exit. 123456789101112131415161718192021222324&gt;&gt;&gt; def ab(c, d):... if c &gt; 5:... print(c)... elif c &gt; 7:... print(d)... print(&#x27;foo&#x27;)&gt;&gt;&gt; ab(10, 20)______&gt;&gt;&gt; def bake(cake, make):... if cake == 0:... cake = cake + 1... print(cake)... if cake == 1:... print(make)... else:... return cake... return make&gt;&gt;&gt; bake(0, 29)______&gt;&gt;&gt; bake(1, &quot;mashed potatoes&quot;)______ Q9: K-Occurrence Complete k_occurrence, a function which returns the number of times the digit k appears in num. 0 is considered to have no digits. 123456789101112131415161718def k_occurrence(k, num): &quot;&quot;&quot; &gt;&gt;&gt; k_occurrence(5, 10) # .Case 1 0 &gt;&gt;&gt; k_occurrence(5, 5115) # .Case 2 2 &gt;&gt;&gt; k_occurrence(0, 100) # .Case 3 2 &gt;&gt;&gt; k_occurrence(0, 0) # .Case 4 0 &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; occurrences = 0 while num: if num % 10 == k: occurrences += 1 num = num // 10 return occurrences To work on this problem, open the Parsons editor: 1python3 parsons Q10: Double Eights Write a function that takes in a number and determines if the digits contain two adjacent 8s. 12345678910111213141516171819202122232425262728def double_eights(n): &quot;&quot;&quot;Return true if n has two eights in a row. &gt;&gt;&gt; double_eights(8) False &gt;&gt;&gt; double_eights(88) True &gt;&gt;&gt; double_eights(2882) True &gt;&gt;&gt; double_eights(880088) True &gt;&gt;&gt; double_eights(12345) False &gt;&gt;&gt; double_eights(80808080) False &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; cnt = 0 while n: if n % 100 == 88: n = n // 100 cnt = cnt + 2 else: n = n // 10 if cnt % 2 == 0 and cnt != 0: return True else: return False Use Ok to test your code: 1python3 ok -q double_eights","categories":[],"tags":[{"name":"CS61A","slug":"CS61A","permalink":"http://www.misaka-9982.com/tags/CS61A/"}]},{"title":"CS61A Homework 2","slug":"CS61A-Homework-2","date":"2022-05-19T10:15:38.000Z","updated":"2022-05-19T10:32:14.229Z","comments":true,"path":"2022/05/19/CS61A-Homework-2/","link":"","permalink":"http://www.misaka-9982.com/2022/05/19/CS61A-Homework-2/","excerpt":"","text":"Homework 2: Higher Order Functions hw02.zip Several doctests refer to these functions: 12345from operator import add, mulsquare = lambda x: x * xidentity = lambda x: xtriple = lambda x: 3 * xincrement = lambda x: x + 1 Getting Started Videos Parsons Problems Q1: Count Until Larger Implement the function count_until_larger. count_until_larger takes in a positive integer num. count_until_larger counts the distance between the rightmost digit of num and the nearest greater digit; to do so, the function counts digits from right to left. Once it encounters a digit larger than the rightmost digit, it returns that count. If no such digit exists, then the function returns -1. For example, 8117 has a rightmost digit of 7 and returns a count of 3. 9118117 also returns a count of 3: for both, the count stops at 8. 0 should be treated as having no digits and returns a count of -1. Consult the following doctests for specific behaviors of count_until_larger. 12345678910111213141516171819202122232425262728293031def count_until_larger(num): &quot;&quot;&quot; Complete the function count_until_larger that takes in a positive integer num. count_until_larger examines the rightmost digit and counts digits from right to left until it encounters a digit larger than the rightmost digit, then returns that count. &gt;&gt;&gt; count_until_larger(117) # .Case 1 -1 &gt;&gt;&gt; count_until_larger(8117) # .Case 2 3 &gt;&gt;&gt; count_until_larger(9118117) # .Case 3 3 &gt;&gt;&gt; count_until_larger(8777) # .Case 4 3 &gt;&gt;&gt; count_until_larger(22) # .Case 5 -1 &gt;&gt;&gt; count_until_larger(0) # .Case 6 -1 &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; def count_until_larger(num): res = 0 rightest_num = num % 10 while num: if num % 10 &gt; rightest_num: return res res += 1 num //= 10 return -1 Q2: Filter Sequence Write a function filter_sequence which takes in two integers, start and stop, as well as a function cond, which takes in a single argument and outputs a boolean value. filter_sequence returns the sum of all digits from start to stop (inclusive) for which cond returns True. 1234567891011121314151617181920def filter_sequence(cond, start, stop): &quot;&quot;&quot; Returns the sum of numbers from start (inclusive) to stop (inclusive) that satisfy the one-argument function cond. &gt;&gt;&gt; filter_sequence(lambda x: x % 2 == 0, 0, 10) # .Case 1 30 &gt;&gt;&gt; filter_sequence(lambda x: x % 2 == 1, 0, 10) # .Case 2 25 &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; Construct your solution here, including indents def filter_sequence(cond, start, stop): sum = 0 while start &lt;= stop: if cond(start): sum += start start += 1 return sum Code Writing Questions Q3: Hailstone Douglas Hofstadter’s Pulitzer-prize-winning book, Gödel, Escher, Bach, poses the following mathematical puzzle. Pick a positive integer n as the start. If n is even, divide it by 2. If n is odd, multiply it by 3 and add 1. Continue this process until n is 1. The number n will travel up and down but eventually end at 1 (at least for all numbers that have ever been tried – nobody has ever proved that the sequence will terminate). Analogously, a hailstone travels up and down in the atmosphere before eventually landing on earth. This sequence of values of n is often called a Hailstone sequence. Write a function that takes a single argument with formal parameter name n, prints out the hailstone sequence starting at n, and returns the number of steps in the sequence: 12345678910111213141516171819202122232425262728293031def hailstone(n): &quot;&quot;&quot;Print the hailstone sequence starting at n and return its length. &gt;&gt;&gt; a = hailstone(10) 10 5 16 8 4 2 1 &gt;&gt;&gt; a 7 &gt;&gt;&gt; b = hailstone(1) 1 &gt;&gt;&gt; b 1 &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; cnt = 1 while n != 1: cnt = cnt + 1 print(int(n)) if n % 2 == 0: n = n / 2 else: n = triple(n) n = increment(n) print(int(n)) return cnt Hailstone sequences can get quite long! Try 27. What’s the longest you can find? Note that if n == 1 initially, then the sequence is one step long. Use Ok to test your code: 1python3 ok -q hailstone✂️ Curious about hailstones or hailstone sequences? Take a look at these articles: Check out this article to learn more about how hailstones work! In 2019, there was a major development in understanding how the hailstone conjecture works for most numbers! Q4: Product The summation(n, term) function from the higher-order functions lecture adds up term(1) + ... + term(n). Write a similar function called product that returns term(1) * ... * term(n). 123456789101112131415161718192021222324def product(n, term): &quot;&quot;&quot;Return the product of the first n terms in a sequence. n: a positive integer term: a function that takes one argument to produce the term &gt;&gt;&gt; product(3, identity) # 1 * 2 * 3 6 &gt;&gt;&gt; product(5, identity) # 1 * 2 * 3 * 4 * 5 120 &gt;&gt;&gt; product(3, square) # 1^2 * 2^2 * 3^2 36 &gt;&gt;&gt; product(5, square) # 1^2 * 2^2 * 3^2 * 4^2 * 5^2 14400 &gt;&gt;&gt; product(3, increment) # (1+1) * (2+1) * (3+1) 24 &gt;&gt;&gt; product(3, triple) # 1*3 * 2*3 * 3*3 162 &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; res = 1 for i in range(1, n + 1): res = res * term(i) return res Use Ok to test your code: 1python3 ok -q product✂️ Q5: Accumulate Let’s take a look at how summation and product are instances of a more general function called accumulate, which we would like to implement: 1234567891011121314151617181920212223242526272829def accumulate(merger, start, n, term): &quot;&quot;&quot;Return the result of merging the first n terms in a sequence and start. The terms to be merged are term(1), term(2), ..., term(n). merger is a two-argument commutative function. &gt;&gt;&gt; accumulate(add, 0, 5, identity) # 0 + 1 + 2 + 3 + 4 + 5 15 &gt;&gt;&gt; accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5 26 &gt;&gt;&gt; accumulate(add, 11, 0, identity) # 11 11 &gt;&gt;&gt; accumulate(add, 11, 3, square) # 11 + 1^2 + 2^2 + 3^2 25 &gt;&gt;&gt; accumulate(mul, 2, 3, square) # 2 * 1^2 * 2^2 * 3^2 72 &gt;&gt;&gt; # 2 + (1^2 + 1) + (2^2 + 1) + (3^2 + 1) &gt;&gt;&gt; accumulate(lambda x, y: x + y + 1, 2, 3, square) 19 &gt;&gt;&gt; # ((2 * 1^2 * 2) * 2^2 * 2) * 3^2 * 2 &gt;&gt;&gt; accumulate(lambda x, y: 2 * x * y, 2, 3, square) 576 &gt;&gt;&gt; accumulate(lambda x, y: (x + y) % 17, 19, 20, square) 16 &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; res = start for i in range(1, n + 1): res = merger(res, term(i)) return res accumulate has the following parameters: term and n: the same parameters as in summation and product merger: a two-argument function that specifies how the current term is merged with the previously accumulated terms. start: value at which to start the accumulation. For example, the result of accumulate(add, 11, 3, square) is 111 + square(1) + square(2) + square(3) = 25 Note: You may assume that merger is commutative. That is, merger(a, b) == merger(b, a) for all a, b, and c. However, you may not assume merger is chosen from a fixed function set and hard-code the solution. After implementing accumulate, show how summation and product can both be defined as function calls to accumulate. Important: You should have a single line of code (which should be a return statement) in each of your implementations for summation_using_accumulate and product_using_accumulate, which the syntax check will check for. Use Ok to test your code: 123python3 ok -q accumulatepython3 ok -q summation_using_accumulatepython3 ok -q product_using_accumulate 1234567891011121314151617181920212223242526272829303132def summation_using_accumulate(n, term): &quot;&quot;&quot;Returns the sum: term(1) + ... + term(n), using accumulate. &gt;&gt;&gt; summation_using_accumulate(5, square) 55 &gt;&gt;&gt; summation_using_accumulate(5, triple) 45 &gt;&gt;&gt; # You aren&#x27;t expected to understand the code of this test. &gt;&gt;&gt; # Check that the bodies of the functions are just return statements. &gt;&gt;&gt; # If this errors, make sure you have removed the &quot;***YOUR CODE HERE***&quot;. &gt;&gt;&gt; import inspect, ast &gt;&gt;&gt; [type(x).__name__ for x in ast.parse(inspect.getsource(summation_using_accumulate)).body[0].body] [&#x27;Expr&#x27;, &#x27;Return&#x27;] &quot;&quot;&quot; return accumulate(add, 0, n, term)def product_using_accumulate(n, term): &quot;&quot;&quot;Returns the product: term(1) * ... * term(n), using accumulate. &gt;&gt;&gt; product_using_accumulate(4, square) 576 &gt;&gt;&gt; product_using_accumulate(6, triple) 524880 &gt;&gt;&gt; # You aren&#x27;t expected to understand the code of this test. &gt;&gt;&gt; # Check that the bodies of the functions are just return statements. &gt;&gt;&gt; # If this errors, make sure you have removed the &quot;***YOUR CODE HERE***&quot;. &gt;&gt;&gt; import inspect, ast &gt;&gt;&gt; [type(x).__name__ for x in ast.parse(inspect.getsource(product_using_accumulate)).body[0].body] [&#x27;Expr&#x27;, &#x27;Return&#x27;] &quot;&quot;&quot; return accumulate(mul, 1, n, term) Bonus Questions Homework assignments will also contain prior exam-level questions for you to take a look at. These questions have no submission component; feel free to attempt them if you’d like a challenge! Note that exams from Spring 2020, Fall 2020, and Spring 2021 gave students access to an interpreter, so the question format may be different than other years. Regardless, the questions included remain good exam-level problems doable without access to an interpreter. Fall 2019 MT1 Q3: You Again [Higher Order Functions] Spring 2021 MT1 Q4: Domain on the Range [Higher Order Functions] Fall 2021 MT1 Q1b: tik [Functions and Expressions]","categories":[],"tags":[{"name":"CS61A","slug":"CS61A","permalink":"http://www.misaka-9982.com/tags/CS61A/"}]},{"title":"CS61A Homework 1","slug":"CS61A-Homework-1","date":"2022-05-19T10:15:35.000Z","updated":"2022-05-19T10:22:09.031Z","comments":true,"path":"2022/05/19/CS61A-Homework-1/","link":"","permalink":"http://www.misaka-9982.com/2022/05/19/CS61A-Homework-1/","excerpt":"","text":"Homework 1: Variables &amp; Functions, Control hw01.zip Parsons Problems Q2: k in Num Write a function k_in_num which takes in two integers, k and num. k_in_num returns True if num has the digit k and returns False if num does not have the digit k. 0 is considered to have no digits. 123456789101112131415161718192021222324def k_in_num(k, num): &quot;&quot;&quot; Complete k_in_num, a function which returns True if num has the digit k and returns False if num does not have the digit k. 0 is considered to have no digits. &gt;&gt;&gt; k_in_num(3, 123) # .Case 1 True &gt;&gt;&gt; k_in_num(2, 123) # .Case 2 True &gt;&gt;&gt; k_in_num(5, 123) # .Case 3 False &gt;&gt;&gt; k_in_num(0, 0) # .Case 4 False &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; Construct your solution here, including indentsdef k_in_num(k, num): while num: if k == num % 10: return True num = num // 10 return False Code Writing Problems Q3: A Plus Abs B Python’s operator module defines binary functions for Python’s intrinsic arithmetic operators. For example, calling operator.add(2,3) is equivalent to calling the expression 2 + 3; both will return 5. Fill in the blanks in the following function for adding a to the absolute value of b, without calling abs. You may not modify any of the provided code other than the two blanks. 1234567891011121314151617181920212223def a_plus_abs_b(a, b): &quot;&quot;&quot;Return a+abs(b), but without calling abs. &gt;&gt;&gt; a_plus_abs_b(2, 3) 5 &gt;&gt;&gt; a_plus_abs_b(2, -3) 5 &gt;&gt;&gt; a_plus_abs_b(-1, 4) 3 &gt;&gt;&gt; a_plus_abs_b(-1, -4) 3 &quot;&quot;&quot; if b &lt; 0: f = _____ else: f = _____ return f(a, b) if b &lt; 0: f = sub else: f = add return f(a, b) Q4: Two of Three Write a function that takes three positive numbers as arguments and returns the sum of the squares of the two smallest numbers. Use only a single line for the body of the function. 123456789101112131415def two_of_three(i, j, k): &quot;&quot;&quot;Return m*m + n*n, where m and n are the two smallest members of the positive numbers i, j, and k. &gt;&gt;&gt; two_of_three(1, 2, 3) 5 &gt;&gt;&gt; two_of_three(5, 3, 1) 10 &gt;&gt;&gt; two_of_three(10, 2, 8) 68 &gt;&gt;&gt; two_of_three(5, 5, 5) 50 &quot;&quot;&quot; return _____ return i * i + j * j + k * k - max(i, j, k) * max(i, j, k) Hint: Consider using the max or min function: 1234&gt;&gt;&gt; max(1, 2, 3)3&gt;&gt;&gt; min(-1, -2, -3)-3 Q5: Largest Factor Write a function that takes an integer n that is greater than 1 and returns the largest integer that is smaller than n and evenly divides n. 1234567891011121314151617def largest_factor(n): &quot;&quot;&quot;Return the largest factor of n that is smaller than n. &gt;&gt;&gt; largest_factor(15) # factors are 1, 3, 5 5 &gt;&gt;&gt; largest_factor(80) # factors are 1, 2, 4, 5, 8, 10, 16, 20, 40 40 &gt;&gt;&gt; largest_factor(13) # factor is 1 since 13 is prime 1 &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; res = 1 for i in range(2, n): if n % i == 0: res = n // i break return res Hint: To check if b evenly divides a, you can use the expression a % b == 0, which can be read as, “the remainder of dividing a by b is 0.”","categories":[],"tags":[{"name":"CS61A","slug":"CS61A","permalink":"http://www.misaka-9982.com/tags/CS61A/"}]},{"title":"CS61A Homework 3","slug":"CS61A-Homework-3","date":"2022-05-19T09:06:41.000Z","updated":"2022-05-19T10:06:51.125Z","comments":true,"path":"2022/05/19/CS61A-Homework-3/","link":"","permalink":"http://www.misaka-9982.com/2022/05/19/CS61A-Homework-3/","excerpt":"","text":"Homework 3: Recursion, Tree Recursion hw03.zip Parsons Problems Q1: Neighbor Digits Problem Statement Implement the function neighbor_digits. neighbor_digits takes in an integer num and an optional argument prev_digit. neighbor_digits outputs the number of digits in num that have the same digit to its right or left. 12345678&gt;&gt;&gt; neighbor_digits(111)3&gt;&gt;&gt; neighbor_digits(123)0&gt;&gt;&gt; neighbor_digits(112)2&gt;&gt;&gt; neighbor_digits(1122)4 Solution 123456def neighbor_digits(num, prev_digit=-1): if num &lt; 10:2 return num == prev_digit3 rest = num // 10 last = num % 10return int(prev_digit == last or rest % 10 == last) + neighbor_digits(rest, last) Q2: Has Subsequence Problem Statement Implement the function has_subseq, which takes in a number n and a “sequence” of digits seq. The function returns whether n contains seq as a subsequence, which does not have to be consecutive. 12345678910&gt;&gt;&gt; has_subseq(123, 12)True&gt;&gt;&gt; has_subseq(141, 11)True&gt;&gt;&gt; has_subseq(144, 12)False&gt;&gt;&gt; has_subseq(144, 1441)False&gt;&gt;&gt; has_subseq(1343412, 134)True Solution 12345678def has_subseq(n, seq): if seq == 0: return True if n == 0: return False if seq % 10 == n % 10: return has_subseq(n // 10, seq // 10) return has_subseq(n // 10, seq) Code Writing Questions Q3: Num eights Write a recursive function num_eights that takes a positive integer pos and returns the number of times the digit 8 appears in pos. Important: Use recursion; the tests will fail if you use any assignment statements. (You can however use function definitions if you so wish.) 1234567891011121314151617181920212223242526def num_eights(pos): &quot;&quot;&quot;Returns the number of times 8 appears as a digit of pos. &gt;&gt;&gt; num_eights(3) 0 &gt;&gt;&gt; num_eights(8) 1 &gt;&gt;&gt; num_eights(88888888) 8 &gt;&gt;&gt; num_eights(2638) 1 &gt;&gt;&gt; num_eights(86380) 2 &gt;&gt;&gt; num_eights(12345) 0 &gt;&gt;&gt; from construct_check import check &gt;&gt;&gt; # ban all assignment statements &gt;&gt;&gt; check(HW_SOURCE_FILE, &#x27;num_eights&#x27;, ... [&#x27;Assign&#x27;, &#x27;AnnAssign&#x27;, &#x27;AugAssign&#x27;, &#x27;NamedExpr&#x27;]) True &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; if pos &lt; 10: return int(pos == 8) return num_eights(pos // 10) + int(pos % 10 == 8) Q4: Ping-pong The ping-pong sequence counts up starting from 1 and is always either counting up or counting down. At element k, the direction switches if k is a multiple of 8 or contains the digit 8. The first 30 elements of the ping-pong sequence are listed below, with direction swaps marked using brackets at the 8th, 16th, 18th, 24th, and 28th elements: Index 1 2 3 4 5 6 7 [8] 9 10 11 12 13 14 15 [16] 17 [18] 19 20 21 22 23 PingPong Value 1 2 3 4 5 6 7 [8] 7 6 5 4 3 2 1 [0] 1 [2] 1 0 -1 -2 -3 Index (cont.) [24] 25 26 27 [28] 29 30 PingPong Value [-4] -3 -2 -1 [0] -1 -2 Implement a function pingpong that returns the nth element of the ping-pong sequence without using any assignment statements. (You are allowed to use function definitions.) You may use the function num_eights, which you defined in the previous question. Important: Use recursion; the tests will fail if you use any assignment statements. (You can however use function definitions if you so wish.) Hint: If you’re stuck, first try implementing pingpong using assignment statements and a while statement. Then, to convert this into a recursive solution, write a helper function that has a parameter for each variable that changes values in the body of the while loop. Hint: There are a few pieces of information that we need to keep track of. One of these details is the direction that we’re going (either increasing or decreasing). Building off of the hint above, think about how we can keep track of the direction throughout the calls to the helper function. 123456789101112131415161718192021222324252627282930313233343536373839404142def pingpong(n): &quot;&quot;&quot;Return the nth element of the ping-pong sequence. &gt;&gt;&gt; pingpong(8) 8 &gt;&gt;&gt; pingpong(10) 6 &gt;&gt;&gt; pingpong(15) 1 &gt;&gt;&gt; pingpong(21) -1 &gt;&gt;&gt; pingpong(22) -2 &gt;&gt;&gt; pingpong(30) -2 &gt;&gt;&gt; pingpong(68) 0 &gt;&gt;&gt; pingpong(69) -1 &gt;&gt;&gt; pingpong(80) 0 &gt;&gt;&gt; pingpong(81) 1 &gt;&gt;&gt; pingpong(82) 0 &gt;&gt;&gt; pingpong(100) -6 &gt;&gt;&gt; from construct_check import check &gt;&gt;&gt; # ban assignment statements &gt;&gt;&gt; check(HW_SOURCE_FILE, &#x27;pingpong&#x27;, ... [&#x27;Assign&#x27;, &#x27;AnnAssign&#x27;, &#x27;AugAssign&#x27;, &#x27;NamedExpr&#x27;]) True &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; def helper(res, cur, step): if cur == n: return res if cur % 8 == 0 or num_eights(cur) &gt; 0: return helper(res - step, cur + 1, -step) else: return helper(res + step, cur + 1, step) return helper(1, 1, 1) Q5: Count coins Given a positive integer change, a set of coins makes change for change if the sum of the values of the coins is change. Here we will use standard US Coin values: 1, 5, 10, 25. For example, the following sets make change for 15: 15 1-cent coins 10 1-cent, 1 5-cent coins 5 1-cent, 2 5-cent coins 5 1-cent, 1 10-cent coins 3 5-cent coins 1 5-cent, 1 10-cent coin Thus, there are 6 ways to make change for 15. Write a recursive function count_coins that takes a positive integer change and returns the number of ways to make change for change using coins. You can use either of the functions given to you: get_larger_coin will return the next larger coin denomination from the input, i.e. get_larger_coin(5) is 10. get_smaller_coin will return the next smaller coin denomination from the input, i.e. get_smaller_coin(5) is 1. There are two main ways in which you can approach this problem. One way uses get_larger_coin, and another uses get_smaller_coin. Important: Use recursion; the tests will fail if you use loops. Hint: Refer the implementation of count_partitions for an example of how to count the ways to sum up to a final value with smaller parts. If you need to keep track of more than one value across recursive calls, consider writing a helper function. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162def get_larger_coin(coin): &quot;&quot;&quot;Returns the next larger coin in order. &gt;&gt;&gt; get_larger_coin(1) 5 &gt;&gt;&gt; get_larger_coin(5) 10 &gt;&gt;&gt; get_larger_coin(10) 25 &gt;&gt;&gt; get_larger_coin(2) # Other values return None &quot;&quot;&quot; if coin == 1: return 5 elif coin == 5: return 10 elif coin == 10: return 25def get_smaller_coin(coin): &quot;&quot;&quot;Returns the next smaller coin in order. &gt;&gt;&gt; get_smaller_coin(25) 10 &gt;&gt;&gt; get_smaller_coin(10) 5 &gt;&gt;&gt; get_smaller_coin(5) 1 &gt;&gt;&gt; get_smaller_coin(2) # Other values return None &quot;&quot;&quot; if coin == 25: return 10 elif coin == 10: return 5 elif coin == 5: return 1def count_coins(change): &quot;&quot;&quot;Return the number of ways to make change using coins of value of 1, 5, 10, 25. &gt;&gt;&gt; count_coins(15) 6 &gt;&gt;&gt; count_coins(10) 4 &gt;&gt;&gt; count_coins(20) 9 &gt;&gt;&gt; count_coins(100) # How many ways to make change for a dollar? 242 &gt;&gt;&gt; count_coins(200) 1463 &gt;&gt;&gt; from construct_check import check &gt;&gt;&gt; # ban iteration &gt;&gt;&gt; check(HW_SOURCE_FILE, &#x27;count_coins&#x27;, [&#x27;While&#x27;, &#x27;For&#x27;]) True &quot;&quot;&quot; &quot;*** YOUR CODE HERE ***&quot; def dfs(change, currrent_coin): if change == 0: return 1 elif change &lt; 0 or currrent_coin == None: return 0 with_cur = dfs(change - currrent_coin, currrent_coin) without_cur = dfs(change, get_larger_coin(currrent_coin)) return with_cur + without_cur return dfs(change, 1) Optional Questions Homework assignments will also contain prior exam-level questions for you to take a look at. These questions have no submission component; feel free to attempt them if you’d like a challenge! Fall 2017 MT1 Q4a: Digital Summer 2018 MT1 Q5a: Won’t You Be My Neighbor? Fall 2019 Final Q6b: Palindromes","categories":[],"tags":[{"name":"CS61A","slug":"CS61A","permalink":"http://www.misaka-9982.com/tags/CS61A/"}]},{"title":"FTP文件传输协议分析","slug":"FTP文件传输协议分析","date":"2022-03-26T09:21:08.000Z","updated":"2022-03-26T16:45:58.287Z","comments":true,"path":"2022/03/26/FTP文件传输协议分析/","link":"","permalink":"http://www.misaka-9982.com/2022/03/26/FTP%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/","excerpt":"","text":"安装 FTP 在服务器上安装 vsftpd 这个 ftp 客户端 1sudo apt-get install vsftpd 修改登录和对匿名用户的设置 /etc/vsftpd.conf文件如下： 12345678910write_enable=YES //是否对登录用户开启写权限。属全局性设置。默认NOlocal_enable=YES //是否允许本地用户登录FTP服务器。默认为NOanonymous_enable=YES //设置是否允许匿名用户登录FTP服务器。默认为YESftp_username=ftp //定义匿名用户的账户名称，默认值为ftp。no_anon_password=YES //匿名用户登录时是否询问口令。设置为YES，则不询问。默 认NOanon_world_readable_only=YES //匿名用户是否允许下载可阅读的文档，默认为YES。anon_upload_enable=YES //是否允许匿名用户上传文件。只有在write_enable设置local_root=/var/ftp // 设置本地用户登录后所在的目录。默认配置文件中没有设置该项，此时用户登录FTP服务器后，所在的目录为该用户的主目录，对于root用户，则为/root目录。anon_root=/var/ftp //设置匿名用户登录后所在的目录。若未指定，则默认为/var/ftp目录。chroot_list_enable=YES // 设置是否启用chroot_list_file配置项指定的用户列表文件。设置为YES则除了列在j/etc/vsftpd/chroot_list文件中的的帐号外，所有登录的用户都可以进入ftp根目录之外的目录。默认NO 我们只需要修改其中这一项： 1#write_enable=YES 将 # 号去掉即可添加使 FTP 用户对目录进行写操作的权限 可以事分别先在客户端和服务器端准备两个文件进行传输使用 12wget http://gaia.cs.umass.edu/wireshark-labs/alice.txtwget https://web.stanford.edu/class/cs144/vm_howto/setup_dev_env.sh 使用 FTP 接下来打开 wireshark 按照如下操作进行文件的上传和下载： 在客户端中输入 ftp ipadderss,连接客户端 输入FTP用户名 输入 FTP 用户密码 使用 ls 指令，查看当前目录文件 在服务器端 查看当前目录文件 将客户端的文件 alice.txt 上传到服务器端，对应命令为 put alice.txt 等待上传结束后，在服务器端输入 ls 指令，可以看到比传输开始之前多了一个 alice.txt 的文件 将服务器端的 setup_dev_env.sh 下载下来，对应的命令为 get setup_dev_env.sh 关闭客户端与服务器的连接，对应命令为 close 退出 FTP 程序， 命令为 quit 可以看到客户端多了个 setup_dev_env.sh 文件 数据包分析 在wireshark 的过滤规则中输入 ip.addr == 192.168.0.101 &amp;&amp; ip.addr == 192.168.0.112 &amp;&amp; tcp 可以看到，在FTP的文件传输协议开始使用之前，客户端和服务器会先进行三次握手以建立TCP连接，在服务器端发送给客户端的第一个FTP协议报文的TCP状态标识为PSH,表示有数据传输。 其中，41号报文，43号报文，44号报文分别如下图所示，可以看出，服务器端与客户端进行通信的端口号分别为 21 和 59353 端口 21用于传输控制流，并且是命令通向 ftp 服务器的进口，这里是用来打开服务器端口与客户端进行通信 在 wireshark的过滤规则中输入 ip.addr == 192.168.0.101 &amp;&amp; ip.addr == 192.168.0.112 &amp;&amp; ftp,可以得到如下图所示的数据流图 登陆用户 45号报文中的 FTP如下所示，其中状态码 220 表示服务器准备就绪 12345File Transfer Protocol (FTP) 220 (vsFTPd 3.0.3)\\r\\n Response code: Service ready for new user (220) Response arg: (vsFTPd 3.0.3)[Current working directory: ] 客户端则显示：220 (vsFTPd 3.0.3) 47号报文的 FTP 记录了客户端输入用户名发送到服务器端，并且明文显示系统需要登陆的用户名 1234File Transfer Protocol (FTP) USER misaka\\r\\n Request command: USER Request arg: misaka 49号报文：输入用户名后，服务器响应状态码 331， 表示要求密码 1234File Transfer Protocol (FTP) 331 Please specify the password.\\r\\n Response code: User name okay, need password (331) Response arg: Please specify the password. 52号报文：客户端输入密码发送给服务器端，明文传输 1234File Transfer Protocol (FTP) PASS ********\\r\\n Request command: PASS Request arg: ******** 54号报文：服务器端收到密码后，返回给客户端 230 号状态码，表示用户登录，请继续。 1234File Transfer Protocol (FTP) 230 Login successful.\\r\\n Response code: User logged in, proceed (230) Response arg: Login successful. LIST 命令 56号报文：是客户端中输入 ls 命令时的发送给服务器端的接受数据的激活端口号为 59354 此时，服务器与客户端通信的TCP为：Transmission Control Protocol, Src Port: 59353, Dst Port: 21, Seq: 29, Ack: 78, Len: 28， 仍然是 59353 和 21 号端口 Command frame: 60 : 表示对应的命令在 60 号数据报正式发出 123456789File Transfer Protocol (FTP) PORT 192,168,0,101,231,218\\r\\n Request command: PORT Request arg: 192,168,0,101,231,218 Active IP address: 192.168.0.101 Active port: 59354[Current working directory: ][Command: LIST][Command frame: 60] 58号报文：服务器端响应状态码200，表示命令没问题，在客户端显示为200 PORT command successful. Consider using PASV. 1234File Transfer Protocol (FTP) 200 PORT command successful. Consider using PASV.\\r\\n Response code: Command okay (200) Response arg: PORT command successful. Consider using PASV. 60号报文：客户端对服务器发起的命令为 LIST Command response first frame表示响应该命令的第一个数据帧为 66号 Command response last frame表示响应该命令的最后一个数据帧为 66号 123456789File Transfer Protocol (FTP) LIST\\r\\n Request command: LIST[Current working directory: ][Command response frames: 1][Command response bytes: 659][Command response first frame: 66][Command response last frame: 66][Setup frame: 56] 72号数据报：服务器发送给客户端的状态码为226，表示请求的文件操作成功，并正在关闭数据连接 1234File Transfer Protocol (FTP) 226 Directory send OK.\\r\\n Response code: Closing data connection (226) Response arg: Directory send OK. 66 号 数据帧如下所示，其中，红色方框内的内容与客户端显示的东西刚好对应，是明文传输 数据报： 客户端： PUT操作 85号数据报：是客户端中输入 put alice.txt 命令时的发送给服务器端的接受数据的激活端口号为 59355 Command response first frame表示响应该命令的第一个数据帧为 95 号 Command response last frame表示响应该命令的最后一个数据帧为 217 号 Command frame: 85 表示对应的命令在 85 号数据报正式发出 1234567891011121314151617Transmission Control Protocol, Src Port: 59353, Dst Port: 21, Seq: 63, Ack: 192, Len: 28File Transfer Protocol (FTP) PORT 192,168,0,101,231,219\\r\\n Request command: PORT Request arg: 192,168,0,101,231,219 Active IP address: 192.168.0.101 Active port: 59355[Current working directory: ][Command response frames: 108][Command response bytes: 155736][Command response first frame: 95][Command response last frame: 217][Response duration: 303ms][Response bitrate: 4111Kbps][Setup frame: 85][Command: PORT 192,168,0,101,231,219][Command frame: 85] 86号数据报：服务器端响应状态码200，表示命令没问题，在客户端显示为200 PORT command successful. Consider using PASV. 1234File Transfer Protocol (FTP) 200 PORT command successful. Consider using PASV.\\r\\n Response code: Command okay (200) Response arg: PORT command successful. Consider using PASV. 88号数据报：客户端发送给服务器端的FTP 命令为 STOR 表示接收数据并且在服务器站点保存为文件，arg为参数 ：alice.txt 1234File Transfer Protocol (FTP) STOR alice.txt\\r\\n Request command: STOR Request arg: alice.txt 92号数据报：服务器端发送给客户端的状态码为 150，表示文件状态正常并即将打开数据连接。 1234File Transfer Protocol (FTP) 150 Ok to send data.\\r\\n Response code: File status okay; about to open data connection (150) Response arg: Ok to send data. 231号数据报：服务器发送给客户端的状态码为226，表示请求的文件操作成功，并正在关闭数据连接 1234File Transfer Protocol (FTP) 226 Transfer complete.\\r\\n Response code: Closing data connection (226) Response arg: Transfer complete. 数据流的报文简略如下： 1234595 29.695807 192.168.0.101 192.168.0.112 FTP-DATA 1514 FTP Data: 1448 bytes (PORT) (PORT 192,168,0,101,231,219)96 29.695812 192.168.0.101 192.168.0.112 FTP-DATA 1514 FTP Data: 1448 bytes (PORT) (PORT 192,168,0,101,231,219)97 29.695814 192.168.0.101 192.168.0.112 FTP-DATA 1514 FTP Data: 1448 bytes (PORT) (PORT 192,168,0,101,231,219)...217 29.997952 192.168.0.101 192.168.0.112 FTP-DATA 866 FTP Data: 800 bytes (PORT) (PORT 192,168,0,101,231,219) 可以发现，数据最长为 1514 字节，其中有效数据为 1448 字节，其其余 66 个字节为首部信息总的长度 GET 操作 239号报文：是客户端中输入 get setup_dev_env.sh 命令时的发送给服务器端的接受数据的激活端口号为 59356 123456File Transfer Protocol (FTP) PORT 192,168,0,101,231,220\\r\\n Request command: PORT Request arg: 192,168,0,101,231,220 Active IP address: 192.168.0.101 Active port: 59356 240号报文：服务器端响应状态码200，表示命令没问题，在客户端显示为200 PORT command successful. Consider using PASV. 1234File Transfer Protocol (FTP) 200 PORT command successful. Consider using PASV.\\r\\n Response code: Command okay (200) Response arg: PORT command successful. Consider using PASV. 242号报文: 客户端发送给服务器端的 Request command 为 RETR，Request arg 为 setup_dev_env.sh, 表示传输 setup_dev_env.sh文件副本 Command response first frame表示响应该命令的第一个数据帧为 248 号 Command response last frame表示响应该命令的最后一个数据帧为 249 号 Setup frame: 85 表示是 239 号数据帧设置的命令 12345678910111213Transmission Control Protocol, Src Port: 59353, Dst Port: 21, Seq: 135, Ack: 340, Len: 23File Transfer Protocol (FTP) RETR setup_dev_env.sh\\r\\n Request command: RETR Request arg: setup_dev_env.sh[Current working directory: ][Command response frames: 2][Command response bytes: 1515][Command response first frame: 248][Command response last frame: 249][Response duration: 0ms][Response bitrate: 4294967295Kbps][Setup frame: 239] 247号报文：服务器的 Response code 表示文件状态正常，即将打开数据连接 在客户端会显示出150 Opening BINARY mode data connection for setup_dev_env.sh (1515 bytes). 1234File Transfer Protocol (FTP) 150 Opening BINARY mode data connection for setup_dev_env.sh (1515 bytes).\\r\\n Response code: File status okay; about to open data connection (150) Response arg: Opening BINARY mode data connection for setup_dev_env.sh (1515 bytes). 255号报文:服务器发送给客户端的状态码为226，表示请求的文件操作成功，并正在关闭数据连接 1234File Transfer Protocol (FTP) 226 Transfer complete.\\r\\n Response code: Closing data connection (226) Response arg: Transfer complete. 在过滤规则中输入ip.addr == 192.168.0.101 &amp;&amp; ip.addr == 192.168.0.112 &amp;&amp; ftp-data，数据连接发送的报文如下： 12248 50.915641 192.168.0.112 192.168.0.101 FTP-DATA 1514 FTP Data: 1448 bytes (PORT) (RETR setup_dev_env.sh)249 50.915641 192.168.0.112 192.168.0.101 FTP-DATA 133 FTP Data: 67 bytes (PORT) (RETR setup_dev_env.sh) 关闭FTP 269号报文:客户端发送给服务器的 FTP 命令 为 QUIT, 表示请求断开连接 123File Transfer Protocol (FTP) QUIT\\r\\n Request command: QUIT 270号报文:服务器响应的Response code 为 221，表示服务器正在关闭连接，客户端显示 221 Goodbye. 1234File Transfer Protocol (FTP) 221 Goodbye.\\r\\n Response code: Service closing control connection (221) Response arg: Goodbye. 在这之后服务器和客户端会经过一次四次挥手的过程关闭他们之间的通信 四次挥手 第一次挥手： 272号报文的信息： Source IP Address: 192.168.0.112 Destination IP Address: 192.168.0.101 Source Port: 21 Destination Port: 59353 Fin: 1 Acknowledgment Number： 2006995353 ，164（relative ack number） Sequence Number：1380144531， 454 （relative sequence number） TCP连接释放报文段首部中 终止位FIN和确认为ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认 序号seq字段的值设置为u，它等于TCP客户进程之前已传送过的数据的最后一个字节的序号加1 确认号ack字段的值设置为v，它等于TCP客户进程之前已收到的、数据的最后一个字节的序号加1 第二次挥手： 273号报文的信息： Source IP Address: 192.168.0.101 Destination IP Address: 192.168.0.112 Source Port: 59353 Destination Port: 21 Acknowledgment Number： 1380144532 ，455（relative ack number）是 272号报文的 Sequence Number + 1 Sequence Number：2006995353， 164 （relative sequence number）和 272号报文的Acknowledgment Number一致 TCP服务器进程收到TCP连接释放报文段后，会发送一个普通的TCP确认报文段并进入关闭等待状态 普通的TCP确认报文段首部中 确认位ACK的值被设置为1，表明这是一个普通的TCP确认报文段 序号seq字段的值设置为v，它等于TCP服务器进程之前已传送过的数据的最后一个字节的序号加1，这也与之前收到的TCP连接释放报文段中的确认号匹配 确认号ack字段的值设置为u+1，这是对TCP连接释放报文段的确认 TCP客户进程收到TCP确认报文段后就进入终止等待2状态，等待TCP服务器进程发出的TCP连接释放报文段 若使用TCP服务器进程的应用进程已经没有数据要发送了，应用进程就通知其TCP服务器进程释放连接 由于TCP连接释放是由TCP客户进程主动发起的，因此TCP服务器进程对TCP连接的释放称为被动关闭连接 第三次挥手： 274号报文的信息： Source IP Address: 192.168.0.101 Destination IP Address: 192.168.0.112 Source Port: 59353 Destination Port: 21 Fin ：1 Acknowledgment Number： 1380144532 ，455（relative ack number）和 273 号报文的 Acknowledgment Number 一致 Sequence Number：2006995353， 164 （relative sequence number）和 273 号报文的 Sequence Number 一致 TCP服务器进程发送TCP连接释放报文段并进入最后确认状态 该报文段首部中 终止位FIN和确认位ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认 序号seq字段的值为w，这是因为在半关闭状态下，TCP服务器进程可能又发送 确认号ack字段的值为u+1，这是对之前收到的TCP连接释放报文段的重复确认 第四次挥手： 275号报文的信息： Source IP Address: 192.168.0.112 Destination IP Address: 192.168.0.101 Source Port: 21 Destination Port: 59353 Acknowledgment Number： 2006995354 ，165（relative ack number）是 274 号报文 的 Sequence Number + 1 Sequence Number：1380144532， 455 （relative sequence number）和 274 号报文 的 Acknowledgment Number 一致 TCP客户进程收到TCP连接释放报文段后，必须针对该报文段发送普通的TCP确认报文段，之后进入时间等待状态 该报文段首部中 确认为ACK的值被设置为1，表明这是一个普通的TCP确认报文段 序号seq字段的值设置为u+1，这是因为TCP客户进程之前发送的TCP连接释放报文段虽然不携带数据，但要消耗掉一个序号 确认号ack字段的值设置为w+1，这是对所收到的TCP连接释放报文段的确认 TCP服务器进程收到该报文段后就进入关闭状态，而TCP客户进程还要进过2MSL后才能进入关闭状态 FTP命令： 命令 RFC 描述 ABOR (ABORT)此命令使服务器终止前一个FTP服务命令以及任何相关数据传输。 ACCT (ACCOUNT)此命令的参数部分使用一个Telnet字符串来指明用户的账户。 ADAT RFC 2228 (AUTHENTICATION/SECURITY DATA)认证/安全数据 ALLO 为接收一个文件分配足够的磁盘空间 APPE 增加 AUTH RFC 2228 认证/安全机制 CCC RFC 2228 清除命令通道 CDUP 改变到父目录 CONF RFC 2228 机密性保护命令 CWD 改变工作目录 DELE 删除文件 ENC RFC 2228 隐私保护通道 EPRT RFC 2428 为服务器指定要连接的扩展地址和端口 EPSV RFC 2428 进入扩展被动模式 FEAT RFC 2389 获得服务器支持的特性列表 HELP 如果指定了命令，返回命令使用文档；否则返回一个通用帮助文档 LANG RFC 2640 语言协商 LIST 如果指定了文件或目录，返回其信息；否则返回当前工作目录的信息 LPRT RFC 1639 为服务器指定要连接的长地址和端口 LPSV RFC 1639 进入长被动模式 MDTM RFC 3659 返回指定文件的最后修改时间 MIC RFC 2228 完整性保护命令 MKD 创建目录 MLSD RFC 3659 如果目录被命名，列出目录的内容 MLST RFC 3659 提供命令行指定的对象的数据 MODE 设定传输模式（流、块或压缩） NLST 返回指定目录的文件名列表 NOOP 无操作（哑包；通常用来保活） OPTS RFC 2389 为特性选择选项 PASS 认证密码 PASV 进入被动模式 PBSZ RFC 2228 保护缓冲大小 PORT 指定服务器要连接的地址和端口 PROT RFC 2228 数据通道保护级别 PWD 打印工作目录，返回主机的当前目录 QUIT 断开连接 REIN 重新初始化连接 REST 从指定点重新开始传输 RETR 传输文件副本 RMD 删除目录 RNFR 从…重命名 RNTO 重命名到… SITE 发送站点特殊命令到远端服务器 SIZE RFC 3659 返回文件大小 SMNT 挂载文件结构 STAT 返回当前状态 STOR 接收数据并且在服务器站点保存为文件 STOU 唯一地保存文件 STRU 设定文件传输结构 SYST 返回系统类型 TYPE 设定传输模式（ASCII/二进制). USER 认证用户名 XCUP RFC 775 改变之当前工作目录的父目录 XMKD RFC 775 创建目录 XPWD RFC 775 打印当前工作目录 XRCP RFC 743 XRMD RFC 775 删除目录 XRSQ RFC 743 XSEM RFC 737 发送，否则邮件 XSEN RFC 737 发送到终端 FTP响应码： https://www.w3.org/Protocols/rfc959/4_FileTransfer.html 参考资料 https://en.wikipedia.org/wiki/File_Transfer_Protocol https://www.w3.org/Protocols/rfc959/4_FileTransfer.html http://docs.52im.net/extend/docs/book/tcpip/vol1/27/","categories":[],"tags":[{"name":"Network","slug":"Network","permalink":"http://www.misaka-9982.com/tags/Network/"},{"name":"Wireshark","slug":"Wireshark","permalink":"http://www.misaka-9982.com/tags/Wireshark/"}]},{"title":"Wireshark基本使用","slug":"Wireshark基本使用","date":"2022-03-20T16:06:34.000Z","updated":"2022-03-21T04:58:49.818Z","comments":true,"path":"2022/03/21/Wireshark基本使用/","link":"","permalink":"http://www.misaka-9982.com/2022/03/21/Wireshark%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"","text":"一、实验目的与要求 学习安装、使用协议分析软件，掌握基本的数据报捕获、过滤和协议的分析技巧，能对抓取数据包进行分析。 二、实验内容与方法 1、使用具有Internet连接的Windows操作系统； 2、抓包软件Wireshark。 协议分析软件的安装和使用、学会抓取数据包的方法并对对抓取数据包进行分析 三、实验步骤与过程 认识Wireshark 安装Wireshark软件 根据以下步骤进行抓包： 点击Option 按钮，可以看到有多张网卡 在Interface中选择对应的网卡 点击 Start 按钮开始抓包 可以看到Wireshark 窗口中有不同颜色的数据包 在Wireshark主界面，报文会显示各种各样的颜色，它们表示不同的含义。这些颜色，是由色彩规则控制的。 可以通过在 View 选项中点击 Color Rules 来显示Wireshark 中不同协议对应数据包对应的颜色规则 颜色规则： Wireshark 窗口各个信息： 表达式过滤： 协议过滤 比如TCP，只显示TCP协议。 IP 过滤 比如 ip.src ==192.168.0.102 显示源地址为192.168.0.102 ip.dst==192.168.1.102, 目标地址为192.168.1.102 端口过滤 tcp.port ==80, 端口为80的 tcp.srcport == 80, 只显示TCP协议的愿端口为80的。 Http模式过滤 http.request.method==“GET”, 只显示HTTP GET方法的。 逻辑运算符 复合过滤表达式 分析数据包 打开Wireshark程序执行抓包，访问如下网站（看网页和看视频），分别分析DNS、HTTP、TCP、UDP数据包 http://www.szu.edu.cn/board/ http://www.szu.edu.cn/tv/ http://www.youku.com http://www.sina.com.cn 1.DNS 打开http://www.szu.edu.cn/board/ 分析DNS数据包 在抓包开始前先将浏览器缓存清空 在wireshark过滤窗口中输入 dns &amp;&amp; ip.addr == 192.168.0.102并同时开始进行抓包 在浏览器中输入http://www.szu.edu.cn/board/，得到如下页面 可以看到图中8号数据包的Info中有Standard query 0xa9c7 A www.szu.edu.cn的信息 点击该数据包可以看到源IP地址为192.168.0.102，目的地址为103.27.24.2 传输层使用了UDP对报文进行封装，源端口号为61028，目的端口号为53， 查询的域名为www.szu.edu.cn，Type 为 A，class in 响应本数据包对应的数据包序号为18 点击18号数据包 可以看到，18号数据包的Info为Standard query response 0xa9c7 A www.szu.edu.cn A 210.39.4.1 源IP地址为102.27.24.2，目的IP地址为192.168.0.102 传输层使用了UDP协议对报文进行封装，源端口号为53，目的端口号为61028 Queries为8号数据包发出的查询，Answer部分为对应的回答， 域名解析www.szu.edu.cn: type A, class IN, addr 210.39.4.1 其中Type为A，class IN，对应的IP地址为210.39.4.1 使用ping命令在命令行窗口查询www.szu.edu.cn的ip地址，其中查到的ip地址为210.39.4.1 2.HTTP 打开 http://www.szu.edu.cn/tv/ 分析HTTP数据包 可以看到数据包中有许多TCP，SSL数据包，这是由于客户端和服务器都是在HTTP协议的基础上通过SSL加密隧道变成https进行通信的，Wireshark 没有再次设置的情况下是没有办法抓到包的 https 的数据包。所以没有抓取到http数据包 解决方法： 在终端中执行： 1/Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome --user-data-dir=/tmp/chrome --ssl-key-log-file=/tmp/.ssl-key.log 打开 Wireshark ，Wireshark - Perferences - Protocols - TLS ，在 (Pre)-Master-Secret log filename 输入 /tmp/.ssl-key.log 重新开始抓包 在过滤器中输入ip.addr == 192.168.0.102 &amp;&amp; http &amp;&amp; ip.addr == 210.39.4.1 可以看到已经可以抓取到数据包了 接下来对数据包进行分析 可以从Info中看出浏览器和服务器运行的都是1.1版本的HTTP协议 Request 方法为 GET 方法 浏览器从服务器接受的语言是zh-CN 请求的URI 为http://www.szu.edu.cn/tv/ 响应报文为第56号报文 服务器响应报文为56号报文 响应状态码：HTTP/1.1 302 Moved Temporarily\\r\\n 响应文件内容：Line-based text data: text/html (7 lines) Content-Length: 137 该资源原本确实存在，但已经被临时改变了位置 继续请求，77号数据包，响应为82号数据包，82号响应状态码为HTTP/1.1 302 Found\\r\\n下 一个请求为84号数据包，响应帧为88号，88号帧的响应状态码为404 Not Found 3.TCP 3.打开http://www.youku.com 分析 TCP 数据包 在终端中执行： 1/Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome --user-data-dir=/tmp/chrome --ssl-key-log-file=/tmp/.ssl-key.log 在Wireshark过滤器输入 http 在浏览器输入优酷网址，可以看到Wireshark中http数据包的Info有 youku的字样 右键，Follow -&gt; TCP Stream,追踪TCP数据流 可以得到如下页面： 点击Statistics -&gt; Flow 可以得到如下页面： 在其中的Flow Type中选择TCP Flows，并选择时间戳和我们要分析的TCP数据流一致的数据，点击Limit to display filiter，可以得到如下窗口： 可以看出我的IP地址为192.168.0.102 优酷的IP地址为59.82.31.118 在客户端和youku.com之间启动 TCP 连接的 TCP SYN 区段的相对\b $Sequence number$ 是0，绝对 $Sequence number$ 是 $2758883771$，这是一个随机值 根据三次握手，客户端应该发送 SYN 请求请求建立连接，我找到发送的第一个请求并且发现客户端（我的电脑）将 SYN 标志标 0 用来请求建立连接。这一步也是三次握手的第一步 Youku.com发送给客户的 相对$Acknowledgement\\ number$ 是 $1$ 绝对 $Acknowledgement\\ number$是 $2758883772$ 相对 $Sequence\\ number$为$0$ 绝对 $Sequence\\ number$为 $1687385211$，这也是一个随机值 可以发现，服务器端的 $Acknowledgement\\ number$ = 客户端的$Sequence\\ number + 1$ 意思是服务器接收到我的连接请求并且发 SYN-ACK 确认，这是三次握手的第二步。 客户端再次发送TCP报文段给服务器端的 相对$Sequence\\ number$为 $1$ 绝对$Sequence\\ number$为 $2758883772$ 相对$Acknowledgement\\ number$的值为 $1$ 绝对$Acknowledgement\\ number$的值为 $1687385212$ TCP服务器进程收到该确认报文段后也进入连接已建立状态 现在，TCP双方都进入了连接已建立状态，它们可以基于已建立好的TCP连接，进行可靠的数据传输 点击Statistics-&gt; TCP Stream Graph-&gt; Time Sequence (tcptrace）,可得下图 可以发现，跟踪文件中没有重新传输的段。我们可以通过检查跟踪文件中TCP数据段的序列号来验证这一点。在该轨迹的时间序列图(Stevens)中，从源(192.168.0.102)到目的地(59.82.31.118)的所有序列号都随着时间单调递增。如果存在重传数据段，则该重传数据段的序列号应小于其相邻数据段的序列号。 4.UDP 打开http://www.sina.com.cn 分析 UDP 数据包 在过滤器中输入ip.addr == 192.168.0.102 &amp;&amp; udp &amp;&amp; ip.addr == 103.27.24.2 UDP标头有4个字段，分别为： Source Port Destination Port Length Checksum UDP的源端口号为49947，目的端口号为53，长度为41，校验和为0x41b2 每个标头字段各自占两个bytes，总共为 $4 \\times 2 = 8$ 个bytes 由于占两个bytes，所以UDP 的有效载荷最大值为$ 2 ^{16} - 1 - 8 = 65527$ 最大的端口号可能为$ 2 ^ {16} - 1 = 65535$ UDP payload 为 33 bytes $Length = UDP payload + 4 * 2 = 33 + 8 = 41$ IP数据包中的UDP协议号为17，十六进制为0x11 响应该报文的数据包序号为 10 10号报文段： 请求报文和响应报文之间的关系： 请求和响应的 Source Port 和 Destination Port 相互对应 请求和响应的 Source IP 和 Destination IP 相互对应 请求： 响应：","categories":[],"tags":[{"name":"Network","slug":"Network","permalink":"http://www.misaka-9982.com/tags/Network/"},{"name":"Wireshark","slug":"Wireshark","permalink":"http://www.misaka-9982.com/tags/Wireshark/"}]},{"title":"Wireshark-Lab12 SSL","slug":"Wireshark-Lab12","date":"2022-03-13T16:27:31.000Z","updated":"2023-02-22T13:07:14.708Z","comments":true,"path":"2022/03/14/Wireshark-Lab12/","link":"","permalink":"http://www.misaka-9982.com/2022/03/14/Wireshark-Lab12/","excerpt":"","text":"Lab:SSL In this lab, we’ll investigate the Secure Sockets Layer (SSL) protocol, focusing on the SSL records sent over a TCP connection. We’ll do so by analyzing a trace of the SSL records sent between your host and an e-commerce server. We’ll investigate the various SSL record types as well as the fields in the SSL messages. You may want to review Section 8.6 in the text1 . 在本实验中，我们将研究安全套接层（SSL）协议，我们将会重点关注通过 TCP连接发送的 SSL 记录。我们将会通过您的主机和电子商务服务器发送的 SSL 记录的跟踪来实现。 我们将研究各种 SSL 记录类型以及 SSL 消息中的字段。您可能会需要重新查看课本中的 8.6 节。 1. Capturing packets in an SSL session 在 SSL 会话中抓包 The first step is to capture the packets in an SSL session. To do this, you should go to your favorite e-commerce site and begin the process of purchasing an item (but terminating before making the actual purpose!). After capturing the packets with Wireshark, you should set the filter so that it displays only the Ethernet frames that contain SSL records sent from and received by your host. (An SSL record is the same thing as an SSL message.) You should obtain something like screenshot on the previous page. 第一步是在 SSL 会话中捕获数据包。要做这一步，您应该去你最喜欢电子商务网站开始购买物品（但是请勿真的购买）。使用 Wireshark 捕获数据包后，应设置过滤器，使其仅显示包含主机发送和接收的 SSL 记录的以太网帧。 （SSL 记录就是SSL 消息）您应该获得如上屏幕截图所示的内容。 If you have difficulty creating a trace, you should download the zip file http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip and extract the ssl-ethereal\u0002 trace-1 packet trace. 如果您抓包跟踪遇到困难，建议下载作者的抓包结果并且解压 ssl-ethereal-trace-1**进行分析（http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip）。 2. A look at the captured trace 分析抓包结果 Your Wireshark GUI should be displaying only the Ethernet frames that have SSL records. It is important to keep in mind that an Ethernet frame may contain one or more SSL records. (This is very different from HTTP, for which each frame contains either one complete HTTP message or a portion of a HTTP message.) Also, an SSL record may not completely fit into an Ethernet frame, in which case multiple frames will be needed to carry the record. 您使用的 Wireshark 界面应该仅仅显示含有 SSL 记录的以太网帧。建议您记住：每个以太网帧可能包含一个或多个的 SSL 记录，这点很重要。（这与 HTTP 消息不同，每个以太网帧包含一个完整的 HTTP 消息或者仅仅包含 HTTP 消息的一部分）因此，SSL 记录不仅仅需要一个以太网帧，这样的话，将有多个以太网承载。 Whenever possible, when answering a question below, you should hand in a printout of the packet(s) within the trace that you used to answer the question asked. Annotate the printout2 to explain your answer. To print a packet, use File-&gt;Print, choose Selected packet only, choose Packet summary line, and select the minimum amount of packet detail that you need to answer the question 请尽量清晰的展示您的答案，必要时您可以在图中用标记辅以说明。您的答案应该简单可读。 For each of the first 8 Ethernet frames, specify the source of the frame (client or server), determine the number of SSL records that are included in the frame, and list the SSL record types that are included in the frame. Draw a timing diagram between client and server, with one arrow for each SSL record. 对于前 8 个以太网帧，请分别指出每一个帧的来源（客户端和服务器），确定每个帧包含的 SSL 记录的数量，并且列出包含 SSL 记录的类型。绘制客户端和服务器含有箭头指向的时序图。 Each of the SSL records begins with the same three fields (with possibly different values). One of these fields is “content type” and has length of one byte. List all three fields and their lengths. 每个 SSL 记录都以相同的三个字段（可能具有不同的值）开头。 其中一个字段是“内容类型”，长度为一个字节。 请列出所有三个字段及其长度。 ClientHello Record: 客户端发出请求 (ClientHello) 记录 Expand the ClientHello record. (If your trace contains multiple ClientHello records, expand the frame that contains the first one.) What is the value of the content type? 展开 ClientHello 记录（如果您的跟踪包含多个 ClientHello 记录，请展开包含第一个记录的以太网帧），内容类型的值是多少？ Does the ClientHello record contain a nonce (also known as a “challenge”)? If so, what is the value of the challenge in hexadecimal notation? ClientHello 记录是否包含随机数（也称为“挑战码”（ challenge））？ 如果是这样，十六进制的挑战码值是多少？ Does the ClientHello record advertise the cyber suites it supports? If so, in the first listed suite, what are the public-key algorithm, the symmetric-key algorithm, and the hash algorithm? ClientHello 记录是否通知了它所支持密码加密套件（suite）？如果是这样，请在第一个密码套件， 分别指出非对称密钥加密算法，对称密钥加密算法，哈希算法分别都是什么？ ServerHello Record: 服务器回应(ServerHello) 记录 Locate the ServerHello SSL record. Does this record specify a chosen cipher suite? What are the algorithms in the chosen cipher suite? 找到 ServerHello SSL 记录。 此记录是否指定了之前的密码套件之一？ 选择的密码套件中有哪些算法？ Does this record include a nonce? If so, how long is it? What is the purpose of the client and server nonces in SSL? 此记录是否包含随机数？如过有，它有多长？SSL 中客户端和服务器段随机数用来干什么？ Does this record include a session ID? What is the purpose of the session ID? 此记录是否包含会话 ID？ 会话 ID 的目的是什么？ Does this record contain a certificate, or is the certificate included in a separate record. Does the certificate fit into a single Ethernet frame? 此记录是否包含证书，或者证书是否包含在单独的记录中。 证书是否适合一个单独的以太网帧传输？ Client Key Exchange Record: 客户端密钥交换记录 Locate the client key exchange record. Does this record contain a pre-master secret? What is this secret used for? Is the secret encrypted? If so, how? How long is the encrypted secret? 找到客户端密钥交换记录。 此记录是否包含前主密钥(pre-master secret)？这个前主密钥用于什么？ 前主密钥加密了吗？ 如果是这样，为什么？ 加密的前主密钥有多长？ Change Cipher Spec Record (sent by client) and Encrypted Handshake Record: 由客户端发送编码改变记录和加密握手记录： What is the purpose of the Change Cipher Spec record? How many bytes is the record in your trace? 编码改变记录目的是什么？在您的跟踪中本记录有多少字节。 In the encrypted handshake record, what is being encrypted? How? 在加密的握手记录中，什么是加密的？ 为什么？ Does the server also send a change cipher record and an encrypted handshake record to the client? How are those records different from those sent by the client? 服务器是否还向客户端发送更改编码记录和加密的握手记录？ 这些记录与客户发送的记录有何不同？ Application Data 应用数据 How is the application data being encrypted? Do the records containing application data include a MAC? Does Wireshark distinguish between the encrypted application data and the MAC? 如何加密应用程序数据？ 包含应用程序数据的记录是否包含消息认证码MAC？ Wireshark 是否区分加密的应用程序数据和消息认证码 MAC？ Comment on and explain anything else that you found interesting in the trace. 请您指出和解释您在跟踪中发现的任何其他内容。","categories":[],"tags":[{"name":"Network","slug":"Network","permalink":"http://www.misaka-9982.com/tags/Network/"},{"name":"Wireshark","slug":"Wireshark","permalink":"http://www.misaka-9982.com/tags/Wireshark/"}]},{"title":"Wireshark-Lab11 WiFi 802.11","slug":"Wireshark-Lab11","date":"2022-03-12T16:46:15.000Z","updated":"2023-02-22T13:07:14.708Z","comments":true,"path":"2022/03/13/Wireshark-Lab11/","link":"","permalink":"http://www.misaka-9982.com/2022/03/13/Wireshark-Lab11/","excerpt":"","text":"Lab:802.11 In this lab, we’ll investigate the 802.11 wireless network protocol. Before beginning this lab, you might want to re-read Section 7.3 in the text1 . Since we’ll be delving a bit deeper into 802.11 than is covered in the text, you might want to check out “A Technical Tutorial on the 802.11Protocol,” by Pablo Brenner (Breezecom Communications), http://www.sss-mag.com/pdf/802_11tut.pdf, and “Understanding 802.11 Frame Types,” by Jim Geier, http://www.wi-fiplanet.com/tutorials/article.php/1447501. And, of course, there is the “bible” of 802.11 - the standard itself, “ANSI/IEEE Std 802.11, 1999 Edition (R2003),” http://gaia.cs.umass.edu/wireshark-labs/802.11-1999.pdf. In particular, you may find Table 1 on page 36 of the standard particularly useful when looking through the wireless trace. 在本实验中，我们将研究 802.11 无线协议。在开始本实验之前，建议您重新阅读课本的中第 7.3 节。因为我们将比课本深入研究 802.11 协议内容，因此您可能需要查看 Pablo Brenner (Breezecom Communications)写的《802.11 协议技术指南》(A Technical Tutorial on the 802.11Protocol ) (http://www.sss-mag.com/pdf/802_11tut.pdf) 以及 Jim Geier 写的《了解 802.11 帧类型》(Understanding 802.11 Frame Types) (http://www.wi-fiplanet.com/tutorials/article.php/1447501) 。当然，您还需要查阅802.11 的圣经-它的标准书《ANSI / IEEE 标准 802.11,1999 版（R2003）》(ANSI/IEEE Std 802.11, 1999 Edition (R2003))(http://gaia.cs.umass.edu/wireshark\u0002labs/802.11-1999.pdf )。您可能会发现标准书第 36 页的表 1 在分析无线跟踪特别有用。 In all of the Wireshark labs thus far, we’ve captured frames on a wired Ethernet connection. Here, since 802.11 is a wireless link-layer protocol, we’ll be capturing frames “in the air.” Unfortunately, many device drivers for wireless 802.11 NICs don’t provide the hooks to capture/copy received 802.11 frames for use in Wireshark (see Figure 1 in Lab 1 for an overview of packet capture). Thus, in this lab, we’ll provide a trace of captured 802.11 frames for you to analyze and assume in the questions below that you are using this trace. If you’re able to capture 802.11 frames using your version of Wireshark, you’re welcome to do so. Additionally, if you’re really into frame capture, you can buy a small USB device, AirPcap, http://www.cacetech.com, that captures 802.11 frames and provides integrated support for Wireshark. 在除本次实验以外其它的 Wireshark 实验中，我们都是在有线以太网连接进行抓包（捕获帧）。在本实验中，因为 802.11 是无线链路层协议，我们将在“空中”捕获帧。不幸的是，带有 802.11 协议的无线网卡（NIC）设备驱动无法提供钩子将捕获/接收的 802.11 帧用于 Wireshark 实验分析。因此，在本实验中，您可能会使用作者捕获的 802.11 帧（抓包结果）进行分析。如果您有能力自己捕获，欢迎您自己动手。如果您乐意自己跟踪，或许你可以买一个小的 USB 网卡 AirPcap 用以捕获802.1 帧（www.cacetech.com）。 1. Getting Started 开始实验 Download the zip file http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip and extract the file Wireshark_802_11.pcap. This trace was collected using AirPcap and Wireshark running on a computer in the home network of one of the authors, consisting of a Linksys 802.11g combined access point/router, with two wired PCs and one wireless host PC attached to the access point/router. The author is fortunate to have other access points in neighboring houses available as well. In this trace file, we’ll see frames captured on channel 6. Since the host and AP that we are interested in are not the only devices using channel 6, we’ll see a lot of frames that we’re not interested in for this lab, such as beacon frames advertised by a neighbor’s AP also operating on channel 6. The wireless host activities taken in the trace file are: 从 http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip 下载压缩包并且得到Wireshark_802_11.pcap。本结果由团队的一个作者在家庭网络使用 AirPcap 以及运行 Wireshark 的计算机得到，结果其中包括 Linksys 802.11g 的组合接入点（路由器），该接入点为两台有线 PC 和一台无线 PC 提供服务。作者幸运邻居也使用无线接入点。在此跟踪文件中，我们能看到在通道 6 上捕获的帧。由于我们需要分析主机和接入点不是使用通道 6 的唯一组合，我们也会看到其他例如邻居接入点使用通道 6 被作者收集到。跟踪文件中采用的无线主机活动包括： The host is already associated with the 30 Munroe St AP when the trace begins. 跟踪开始时，主机已经与 30 Munroe St 接入点关联（associated）。 At t = 24.82, the host makes an HTTP request to http://gaia.cs.umass.edu/wireshark-labs/alice.txt. The IP address of gaia.cs.umass.edu is 128.119.245.12. 在时间 24.82 时刻，主机向 IP 地址 128.119.245.12 的服务器发送 HTTP 请求，请求内容是 http://gaia.cs.umass.edu/wireshark-labs/alice.txt 。 At t=32.82, the host makes an HTTP request to http://www.cs.umass.edu, whose IP address is 128.119.240.19. 在时间 32.82 时刻，主机向 IP 地址 128.119.240.19.的服务器发送 HTTP 请求，请求内容是 http://www.cs.umass.edu 。 At t = 49.58, the host disconnects from the 30 Munroe St AP and attempts to connect to the linksys_ses_24086. This is not an open access point, and so the host is eventually unable to connect to this AP. 在时间 49.58 的时刻，主机断开了与 30 Munroe St 接入点的关联，并且尝试连接到 linksys_ses_24086 接入点。该接入点不是开放的接入点，因此主机始终没有成功与该接入点关联成功。 At t=63.0 the host gives up trying to associate with the linksys_ses_24086 AP, and associates again with the 30 Munroe St access point. 在时间 63.0 时刻，主机放弃尝试关联 linksys_ses_24086 接入点，并且再次连接 30 Munroe St 接入点关联。 Once you have downloaded the trace, you can load it into Wireshark and view the trace using the File pull down menu, choosing Open, and then selecting the Wireshark_802_11.pcap trace file. The resulting display should look just like Figure 1. 下载作者的抓包结果后，使用 Wireshark 的 File 菜单打开该文件Wireshark_802_11.pcap，您应该看到与图 1 显示相同的结果。 Figure 1: Wireshark window, after opening the Wireshark_802_11.pcap file **图 1：**打开 Wireshark_802_11.pcap 文件后的 Wireshark 窗口 2. Beacon Frames 信标帧 Recall that beacon frames are used by an 802.11 AP to advertise its existence. To answer some of the questions below, you’ll want to look at the details of the “IEEE 802.11” frame and subfields in the middle Wireshark window. Whenever possible, when answering a question below, you should hand in a printout of the packet(s) within the trace that you used to answer the question asked. Annotate the printout2 to explain your answer. To print a packet, use File-&gt;Print, choose Selected packet only, choose Packet summary line, and select the minimum amount of packet detail that you need to answer the question. 回想一下，802.11 接入点使用信标帧表示其存在。要回答下面的问题，您或许应该展开 IEEE 802.11 帧并在 Wireshark 中间窗口看到它的字段详细信息。请尽量清晰的展示您的答案，必要时您可以在图中用标记辅以说明。您的答案应该简单可读。 What are the SSIDs of the two access points that are issuing most of the beacon frames in this trace? 发送最多信标帧的两个接入点的服务集标识符是多少（SSID）？ What are the intervals of time between the transmissions of the beacon frames the linksys_ses_24086 access point? From the 30 Munroe St. access point? (Hint: this interval of time is contained in the beacon frame itself). linksys_ses_24086 接入点和 30 Munroe St.接入点的信标帧传输时间是多少？（提示：此时间间隔包含在信标帧本身之中。） What (in hexadecimal notation) is the source MAC address on the beacon frame from 30 Munroe St? Recall from Figure 7.13 in the text that the source, destination, and BSS are three addresses used in an 802.11 frame. For a detailed discussion of the 802.11 frame structure, see section 7 in the IEEE 802.11 standards document (cited above). 请以十六进制表示法找到 30 Munroe St 接入点的源 MAC 地址。回想课本中图 7-13，并说明源地址，目的地址，基本服务集（BSS）的地址是什么。有关 802.11 帧结构的详细讨论说明，请参阅 IEEE 802.11 标准文档（上文所提）中的第 7 节。 What (in hexadecimal notation) is the destination MAC address on the beacon frame from 30 Munroe St?? 30 Munroe St 接入点的信标帧目的地址十六进制表示是什么？ What (in hexadecimal notation) is the MAC BSS id on the beacon frame from 30 Munroe St? 30 Munroe St 接入点的 BSS ID 地址是什么？ The beacon frames from the 30 Munroe St access point advertise that the access point can support four data rates and eight additional “extended supported rates.” What are these rates? 来自 30 Munroe St 接入点的信标帧宣告接入点可以支持四种数据速率和八种额外的“扩展支持速率”。这些速率是多少？ 3. Data Transfer 数据传输 Since the trace starts with the host already associated with the AP, let first look at data transfer over an 802.11 association before looking at AP association/disassociation. Recall that in this trace, at t = 24.82, the host makes an HTTP request to http://gaia.cs.umass.edu/wireshark-labs/alice.txt. The IP address of gaia.cs.umass.edu is 128.119.245.12. Then, at t=32.82, the host makes an HTTP request to http://www.cs.umass.edu. 由于作者抓包开始时，主机已经与 AP 关联，因此在做下面 AP 关联/解除关联之前，我们首先研究已经主机与关联 802.11 AP 的数据传输。回想一下，在作者抓包结果中，在时间 24.82 的时刻，主机向 http://gaia.cs.umass.edu/wireshark\u0002-labs/alice.txt 发出 HTTP 请求。 gaia.cs.umass.edu 的 IP 地址是 128.119.245.12。然后，在 32.82 时刻，主机向 http://www.cs.umass.edu 发出 HTTP 请求。 Find the 802.11 frame containing the SYN TCP segment for this first TCP session (that downloads alice.txt). What are three MAC address fields in the 802.11 frame? Which MAC address in this frame corresponds to the wireless host (give the hexadecimal representation of the MAC address for the host)? To the access point? To the first-hop router? What is the IP address of the wireless host sending this TCP segment? What is the destination IP address? Does this destination IP address correspond to the host, access point, first-hop router, or some other network-attached device? Explain. 找到包含第一个 TCP SYN TCP 报文（下载 alice.txt 会话）的 802.11 帧。802.11 帧中三个 MAC 地址字段分别是什么？此帧中那个 MAC 地址对应十六进制的无线主机的 MAC 地址？那个对应接入点 MAC 地址，第一跳路由器的 MAC 地址？发送此 TCP 报文的无线主机 IP 是什么？目的地 IP 地址是什么？此目的地是否与主机地址，接入点地址，第一跳路由器地址或者某些其他网络设备相对应，解释并且说明。 Find the 802.11 frame containing the SYNACK segment for this TCP session. What are three MAC address fields in the 802.11 frame? Which MAC address in this frame corresponds to the host? To the access point? To the first-hop router? Does the sender MAC address in the frame correspond to the IP address of the device that sent the TCP segment encapsulated within this datagram? (Hint: review Figure 6.19 in the text if you are unsure of how to answer this question, or the corresponding part of the previous question. It’s particularly important that you understand this). 找到包含此 TCP 会话 SYN ACK 报文的 802.11 帧。该帧中三个 MAC 地址字段是什么？那个 MAC 地址对应十六进制的无线主机的 MAC 地址？那个对应接入点 MAC 地址，第一跳路由器的 MAC 地址？帧中的发送方 MAC地址是否与发送此 TCP 报文的设备的 IP 地址相对应？ 4. Association/Disassociation 关联/解除关联 Recall from Section 7.3.1 in the text that a host must first associate with an access point before sending data. Association in 802.11 is performed using the ASSOCIATE REQUEST frame (sent from host to AP, with a frame type 0 and subtype 0, see Section 7.3.3 in the text) and the ASSOCIATE RESPONSE frame (sent by the AP to a host with a frame type 0 and subtype of 1, in response to a received ASSOCIATE REQUEST). For a detailed explanation of each field in the 802.11 frame, see page 34 (Section 7) of the 802.11 spec at http://gaia.cs.umass.edu/wireshark-labs/802.11-1999.pdf. 回想一下课本的第 7.3.1 节，主机在发送数据之前必须与接入点关联。802.11 中的关联使用 ASSOCIATE REQUEST 帧（从主机发送到 AP，帧类型 0 和子类型 0，参见本文中的第 7.3.3 节）和 ASSOCIATE RESPONSE 帧（由 AP 发送给具有主机，帧类型 0 和子类型 1，响应于接收到的 ASSOCIATE REQUEST）。有关 802.11 帧中每个字段的详细说明，请参阅 http://gaia.cs.umass.edu/wireshark-labs/802.11-1999.pdf 中 802.11 规范的第 34 页（第 7 节）。 What two actions are taken (i.e., frames are sent) by the host in the trace just after t=49, to end the association with the 30 Munroe St AP that was initially in place when trace collection began? (Hint: one is an IP-layer action, and one is an 802.11-layer action). Looking at the 802.11 specification, is there another frame that you might have expected to see, but don’t see here? 在时间 49 的时刻，主机在跟踪中使用那两个动作（例如：发送帧）解除在跟踪开始之前就已经连接的 30 Munroe St AP 的关联。（提示：一个是 IP 层多宗，一个是 802.11 层动作）。在查看 802.11 规范之后，请找出抓包结果中未显示一个动作帧。 Examine the trace file and look for AUTHENICATION frames sent from the host to an AP and vice versa. How many AUTHENTICATION messages are sent from the wireless host to the linksys_ses_24086 AP (which has a MAC address of Cisco_Li_f5:ba:bb) starting at around t=49? . 在抓包结果中，找到主机发送给无线 AP 的 AUTHENICATION 帧，同时也找无线 AP 的回复响应帧。在时间 49 时刻之后，无线主机向linksys_ses_24086 AP（MAC 地址包括 Cisco_Li_f5:ba:bb）发送了多少AUTHENTICATION 消息？ Does the host want the authentication to require a key or be open? 主机是否希望身份认证和关联 AP？ Do you see a reply AUTHENTICATION from the linksys_ses_24086 AP in the trace? 您是否在跟踪中看到来自 linksys_ses_24086 AP 回的 AUTHENTICATION？ Now let’s consider what happens as the host gives up trying to associate with the linksys_ses_24086 AP and now tries to associate with the 30 Munroe St AP. Look for AUTHENICATION frames sent from the host to and AP and vice versa. At what times are there an AUTHENTICATION frame from the host to the 30 Munroe St. AP, and when is there a reply AUTHENTICATION sent from that AP to the host in reply? (Note that you can use the filter expression “wlan.fc.subtype == 11and wlan.fc.type == 0 and wlan.addr == IntelCor_d1:b6:4f” to display only the AUTHENTICATION frames in this trace for this wireless host.) 现在让我们来分析当主机放弃尝试与 linksys_ses_24086 AP 关联并且现在尝试与 30 Munroe St AP 关联发生什么。查找从主机发送到 AP 的AUTHENICATION 帧，同时也找无线 AP 的回复响应帧。在什么时间有一个主机到 30 Munroe St AP 的帧，在什么时间无线 AP 回主机该帧的回复。（注意：您可以使用“ wlan.fc.subtype == 11and wlan.fc.type == 0 and wlan.addr == IntelCor_d1:b6:4f ”(不含引号)在此跟踪中仅显示无线主机的AUTHENTICATION 帧） An ASSOCIATE REQUEST from host to AP, and a corresponding ASSOCIATE RESPONSE frame from AP to host are used for the host to associated with an AP. At what time is there an ASSOCIATE REQUEST from host to the 30 Munroe St AP? When is the corresponding ASSOCIATE REPLY sent? (Note that you can use the filter expression “wlan.fc.subtype &lt; 2 and wlan.fc.type == 0 and wlan.addr == IntelCor_d1:b6:4f” to display only the ASSOCIATE REQUEST and ASSOCIATE RESPONSE frames for this trace.) 从主机到 AP 的关联请求，以及相应的 AP 对主机关联请求的响应。在什么时候有来自主机到 AP 关联请求，什么时候 AP 对主机关联请求响应。（注意：你可以使用过滤表达式“wlan.fc.subtype &lt; 2 and wlan.fc.type == 0 and wlan.addr == IntelCor_d1:b6:4f”来仅显示 ASSOCIATE REQUEST 和ASSOCIATE RESPONSE 帧。 What transmission rates is the host willing to use? The AP? To answer this question, you will need to look into the parameters fields of the 802.11 wireless LAN management frame. 主机和 AP 愿意使用什么传输速率？要回答此问题，您或许要查看 802.11 无线管理帧的字段。 5. Other Frame types 其他帧类型 Our trace contains a number of PROBE REQUEST and PROBE RESPONSE frames. 作者的抓包结果中含许多 PROBE REQUEST 和 PROBE RESPONSE 帧。 What are the sender, receiver and BSS ID MAC addresses in these frames? What is the purpose of these two types of frames? (To answer this last question, you’ll need to dig into the online references cited earlier in this lab). 这些帧中的发送方，接收方和 BSS ID MAC 地址是什么？ 这两种帧的目的是什么？ （要回答最后一个问题，您需要深入研究本实验前面引用说明的在线参考资料）。","categories":[],"tags":[{"name":"Network","slug":"Network","permalink":"http://www.misaka-9982.com/tags/Network/"},{"name":"Wireshark","slug":"Wireshark","permalink":"http://www.misaka-9982.com/tags/Wireshark/"}]},{"title":"Wireshark-Lab10 ARP","slug":"Wireshark-Lab10","date":"2022-03-12T14:07:23.000Z","updated":"2023-02-22T13:07:14.708Z","comments":true,"path":"2022/03/12/Wireshark-Lab10/","link":"","permalink":"http://www.misaka-9982.com/2022/03/12/Wireshark-Lab10/","excerpt":"","text":"Lab10:ARP In this lab, we’ll investigate the Ethernet protocol and the ARP protocol. Before beginning this lab, you’ll probably want to review sections 6.4.1 (Link-layer addressing and ARP) and 6.4.2 (Ethernet) in the text1 . RFC 826 (ftp://ftp.rfc-editor.org/in-notes/std/std37.txt) contains the gory details of the ARP protocol, which is used by an IP device to determine the IP address of a remote interface whose Ethernet address is known. 在本实验中，我们将研究以太网协议和 ARP 协议。在开始实验之前，您可以查看课本的 6.4.1 节（链路层地址和 ARP）和 6.4.2（以太网）,您也可以去看 RFC 826(ftp://ftp.rfc-editor.org/in-notes/std/std37.txt)了解关于ARP 的协议详细信息,该协议可以根据 IP 地址获取远程主机的的物理地址。 1. Capturing and analyzing Ethernet frames 捕获和分析以太网帧 Let’s begin by capturing a set of Ethernet frames to study. Do the following : 让我们从捕获一组以太网帧开始研究。 请执行下列操作 ： First, make sure your browser’s cache is empty. To do this under Mozilla Firefox V3, select Tools-&gt;Clear Recent History and check the box for Cache. For Internet Explorer, select Tools-&gt;Internet Options-&gt;Delete Files. Start up the Wireshark packet sniffer 首先，确保浏览器的缓存为空(清除浏览器缓存)。 要在 Mozilla Firefox V3下执行此操作，请选择工具 - &gt;清除最近历史记录，然后选中缓存框。 对于Internet Explorer，选择工具 - &gt; Internet 选项 - &gt;删除文件。 然后启动Wireshark 数据包嗅探器 Enter the following URL into your browser http://gaia.cs.umass.edu/wireshark-labs/HTTP-ethereal-lab-file3.html Your browser should display the rather lengthy US Bill of Rights. 打开以下 URL http://gaia.cs.umass.edu/wireshark-labs/HTTP-ethereal-lab-file3.html 您的浏览器应显示相当冗长的美国权利法案。 Stop Wireshark packet capture. First, find the packet numbers (the leftmost column in the upper Wireshark window) of the HTTP GET message that was sent from your computer to gaia.cs.umass.edu, as well as the beginning of the HTTP response message sent to your computer by gaia.cs.umass.edu. You should see a screen that looks something like this (where packet 4 in the screen shot below contains the HTTP GET message) 接下来停止 Wireshark 数据包捕获，找到您向 gaia.cs.umass.edu 的 HTTP GET 消息的数据包编号以及 gaia.cs.umass.edu 相应您的 HTTP 回应。您的抓包结果应看起来向下面一样: Since this lab is about Ethernet and ARP, we’re not interested in IP or higher\u0002 layer protocols. So let’s change Wireshark’s “listing of captured packets” window so that it shows information only about protocols below IP. To have Wireshark do this, select Analyze-&gt;Enabled Protocols. Then uncheck the IP box and select OK. You should now see an Wireshark window that looks like: 由于本实验是关于以太网和 ARP 的，我们对 IP 或更高层协议不感兴趣。 因此，让我们更改 Wireshark 的“捕获数据包列表”窗口，以便它仅显示有关 IP以下协议的信息。 要让 Wireshark 执行此操作，请选择 Analyze-&gt; Enabled Protocols(分析-启用的协议)。 然后取消选中 IP 框(译者注：这里指的 IPV4协议，下面有搜索)并选择确定。 您现在 Wireshark 窗口应该如下所示： In order to answer the following questions, you’ll need to look into the packet details and packet contents windows (the middle and lower display windows in Wireshark). 为了回答以下问题，您需要查看数据包详细信息和数据包内容窗口（Wireshark 中的中间和下部显示窗口，译者注: 若您看到的不是如此-建议您重置布局（视图-重置布局））。 Select the Ethernet frame containing the HTTP GET message. (Recall that the HTTP GET message is carried inside of a TCP segment, which is carried inside of an IP datagram, which is carried inside of an Ethernet frame; reread section 1.5.2 in the text if you find this encapsulation a bit confusing). Expand the Ethernet II information in the packet details window. Note that the contents of the Ethernet frame (header as well as payload) are displayed in the packet contents window. 选择包含 HTTP GET 消息的以太网帧。 （回想一下，HTTP GET 请求是被加上TCP 头封装到 TCP 段进行传输,TCP 段加上 IP 头被封装到 IP 数据报进行传输,IP 数据报又被加上以太网头封装成以太网帧进行传输;如果你发现这个封装有点令人困惑，请重读文本中的第 1.5.2 节）。 在数据包详细信息窗口中展开以太网 II 信息。请注意，以太网帧的内容（标题以及有效负载）显示在数据包内容窗口中 Answer the following questions, based on the contents of the Ethernet frame containing the HTTP GET message. Whenever possible, when answering a question you should hand in a printout of the packet(s) within the trace that you used to answer the question asked. Annotate the printout3 to explain your answer. To print a packet, use File-&gt;Print, choose Selected packet only, choose Packet summary line, and select the minimum amount of packet detail that you need to answer the question. 根据包含 HTTP GET 消息的以太网帧进行分析，如果有可能建议您使用标记的方式展现您的答案。 What is the 48-bit Ethernet address of your computer? 你的电脑 48 位的地址是多少 00:d0:59:a9:3d:68 What is the 48-bit destination address in the Ethernet frame? Is this the Ethernet address of gaia.cs.umass.edu? (Hint: the answer is no). What device has this as its Ethernet address? [Note: this is an important question, and one that students sometimes get wrong. Re-read pages 468-469 in the text and make sure you understand the answer here.] 以太网帧中的 48 位目标地址是什么？这是 gaia.cs.umass.edu 的以太网地址吗？（提示：答案是否定的）。那么它是什么?注意这一题可能会犯错，请阅读 468-469(中文版 305-308 页)然后理解它 目标地址是 00:06:25:da:af:73 不是gaia.cs.umass.edu的以太网地址。 它是路由器的地址，这是用于出子网的链路。 Give the hexadecimal value for the two-byte Frame type field. What upper layer protocol does this correspond to? 以太网帧上层协议 16 进制值是什么?这对应的上层协议是什么？ 0x800 IP协议 How many bytes from the very start of the Ethernet frame does the ASCII “G” in “GET” appear in the Ethernet frame? 从以太帧的开始，一直到“GET”中的 ASCII“G”出现在以太网帧中為止，有多少字节？ ASCII“G”出现在距离以太网帧的开始 55 B的地方 Next, answer the following questions, based on the contents of the Ethernet frame containing the first byte of the HTTP response message. 接下来，根据包含 HTTP 响应消息的第一个字节的以太网帧的内容，回答以下问题。 What is the value of the Ethernet source address? Is this the address of your computer, or of gaia.cs.umass.edu (Hint: the answer is no). What device has this as its Ethernet address? 这个以太网帧中，以太网源地址的值是多少？这是你的计算机的地址，还是gaia.cs.umass.edu 的地址（提示：答案是否定的）。拥有这个以太网地址的设备是什么？ 00:06:25:da:af:73 都不是 这是我的Linksys路由器的地址，这是用于进入我的子网的链路。 What is the destination address in the Ethernet frame? Is this the Ethernet address of your computer? 以太网帧中的目的地址是什么？这是您的计算机的以太网地址吗？ 00:d0:59:a9:3d:68 是 Give the hexadecimal value for the two-byte Frame type field. What upper layer protocol does this correspond to? 以太网帧上层协议 16 进制值是什么?这对应的上层协议是什么？ 0x800 IP协议 How many bytes from the very start of the Ethernet frame does the ASCII “O” in “OK” (i.e., the HTTP response code) appear in the Ethernet frame? 从以太帧的开始，一直到“OK”中的 ASCII“O”出现在以太网帧中为止，有多少字节？ 有13 个字节 2. The Address Resolution Protocol 地址解析协议 In this section, we’ll observe the ARP protocol in action. We strongly recommend that you re-read section 6.4.1 in the text before proceeding. 在本节中，我们将观察 ARP 协议的作用。我们强烈建议您在继续实验之前重读课文 6.4.1 节 ARP Caching(ARP 缓存) Recall that the ARP protocol typically maintains a cache of IP-to-Ethernet address translation pairs on your comnputer The arp command (in both MSDOS and Linux/Unix) is used to view and manipulate the contents of this cache. Since the arp command and the ARP protocol have the same name, it’s understandably easy to confuse them. But keep in mind that they are different - the arp command is used to view and manipulate the ARP cache contents, while the ARP protocol defines the format and meaning of the messages sent and received, and defines the actions taken on message transmission and receipt. 回想一下，ARP 协议通常在您的计算机上维护 IP 到以太网地址转换对的缓存.arp命令（在 MSDOS 和 Linux / Unix 中）用于查看和操作此缓存的内容。由于 arp 命令和 ARP 协议具有相同的名称，因此很容易混淆它们。但请记住，它们是不同的: arp 命令用于查看和操作 ARP 缓存内容，而 ARP 协议定义了发送和接收的消息的格式和含义，并定义了对消息传输和接收所采取的操作。 Let’s take a look at the contents of the ARP cache on your computer: 我们来看看您计算机上 ARP 缓存的内容： MS-DOS. The arp command is in c:\\windows\\system32, so type either “arp” or “c:\\windows\\system32\\arp” in the MS-DOS command line (without quotation marks). MS-DOS：arp 命令位于 c:\\windows\\system32 中，因此在 MS-DOS 命令行中输入“arp”或“c:\\windows\\system32\\arp”（没有引号） Linux/Unix/MacOS. The executable for the arp command can be in various places. Popular locations are /sbin/arp (for linux) and /usr/etc/arp (for some Unix variants). Linux/Unix/MacOS. 根据安装位置不同路径而不同，一般有/sbin/arp (linux)和/usr/etc/arp (Unix) The Windows arp command with no arguments will display the contents of the ARP cache on your computer. Run the arp command. 没有参数的 Windows arp 命令将显示计算机上 ARP 缓存的内容。运行 ARP 命令。 (译者注:我在做实验发现单单一个命令并不能显示 ARP 表，应该运行 arp -a 才对) Write down the contents of your computer’s ARP cache. What is the meaning of each column value? 写下计算机 ARP 缓存的内容。每个列值的含义是什么？ Internet地址列包含IP地址、物理地址列包含MAC地址，类型指示协议类型。 In order to observe your computer sending and receiving ARP messages, we’ll need to clear the ARP cache, since otherwise your computer is likely to find a needed IP-Ethernet address translation pair in its cache and consequently not need to send out an ARP message. 为了观察您的计算机发送和接收 ARP 消息，我们需要清除 ARP 缓存，否则您的计算机很可能在其缓存中找到所需的 IP-Ethernet 地址转换关系，因此不会发送 ARP消息。 MS-DOS. The MS-DOS *arp –d ** command will clear your ARP cache. The –d flag indicates a deletion operation, and the * is the wildcard that says to delete all table entries. MS-DOS：MS-DOS arp -d *命令将清除 ARP 缓存。-d 标志指示删除操作，*是表示删除所有表项的通配符。 Linux/Unix/MacOS. The *arp –d ** will clear your ARP cache. In order to run this command you’ll need root privileges. If you don’t have root privileges and can’t run Wireshark on a Windows machine, you can skip the trace collection part of this lab and just use the trace discussed in the earlier footnote. Linux/Unix/MacOS: 清除 arp 缓存的 arp –d *需要 root 权限，如果您没有也没办法使用 Windows 系统进行实验，请下载作者的抓包结果。 Observing ARP in action 抓取 ARP 消息 Do the following : 请进行以下操作 Clear your ARP cache, as described above. 清除你的 ARP 缓存，如上所述。 Next, make sure your browser’s cache is empty. To do this under Mozilla Firefox V3, select Tools-&gt;Clear Recent History and check the box for Cache. For Internet Explorer, select Tools-&gt;Internet Options-&gt;Delete Files. 接下来，确保浏览器的缓存是空的。要在 Mozilla Firefox V3 下执行此操作，请选择工具-&gt;清除最近的历史并检查缓存的方框。对于 Internet Explorer，选择工具-&gt; Internet 选项&gt;删除文件 Start up the Wireshark packet sniffer 启动 Wireshark 捕捉封包 Enter the following URL into your browser http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-lab-file3.html Your browser should again display the rather lengthy US Bill of Rights. 打开以下 URL，http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-lab\u0002-file3.html。你的浏览器应该再次显示相当长的美国权利法案 Stop Wireshark packet capture. Again, we’re not interested in IP or higher-layer protocols, so change Wireshark’s “listing of captured packets” window so that it shows information only about protocols below IP. To have Wireshark do this, select Analyze-&gt;Enabled Protocols. Then uncheck the IP box and select OK. You should now see an Wireshark window that looks like: 同样设置不显示 IP 和更高层协议，请选择 Analyze-&gt; Enabled Protocols(分析-启用的协议)。 然后取消选中 IP 框(译者注：这里指的 IPV4 协议，下面有搜索)并选择确定。 您现在 Wireshark 窗口应该如下所示： In the example above, the first two frames in the trace contain ARP messages (as does the 6 th message). The screen shot above corresponds to the trace referenced in footnote 1. 图示是作者的抓包结果截图，您可以发现第 1，2，6 帧都包含 ARP 消息。 Answer the following questions: (回答下列问题) What are the hexadecimal values for the source and destination addresses in the Ethernet frame containing the ARP request message? 包含 ARP 请求消息的以太网帧中源和目标地址的十六进制值是什么？ 源地址是 00:d0:59:a9:3d:68 目标地址是 ff:ff:ff:ff:ff:ff ，广播地址 Give the hexadecimal value for the two-byte Ethernet Frame type field. What upper layer protocol does this correspond to? 以太网帧上层协议 16 进制值是什么? 0x0806 ARP的以太网帧类型字段为0x0806。 Download the ARP specification from ftp://ftp.rfc-editor.org/in-notes/std/std37.txt. A readable, detailed discussion of ARP is also at http://www.erg.abdn.ac.uk/users/gorry/course/inet-pages/arp.html. 下载 ARP 规范(ftp://ftp.rfc-editor.org/in-notes/std/std37.txt.),讨论请移步(http://www.erg.abdn.ac.uk/users/gorry/course/inet-pages/arp.html) a) How many bytes from the very beginning of the Ethernet frame does the ARP opcode field begin? ARP 操作码字段开始从以太网帧的最开始有多少字节？ 距离以太网帧最开始 20 个字节的地方 b) What is the value of the opcode field within the ARP-payload part of the Ethernet frame in which an ARP request is made? 在进行 ARP 请求的以太网帧的 ARP 负载部分中，操作码字段的值是多少？ 进行 ARP 请求的以太网帧的 ARP 负载部分中的操作码的值为0x0001 c) Does the ARP message contain the IP address of the sender? ARP 消息是否包含发送方的 IP 地址？ 包含，在本例中发送方的 IP 地址为 192.168.1.105 d) Where in the ARP request does the “question” appear – the Ethernet address of the machine whose corresponding IP address is being queried? 在 ARP 请求中从哪里看出我们要查询相应 IP 的以太网地址? 将“Target MAC address”字段设置为00：00：00：00：00：00来对其对应的IP地址(192.168.1.1)提问。 Now find the ARP reply that was sent in response to the ARP request. 找到相应 ARP 请求的而发送 ARP 回复 a) How many bytes from the very beginning of the Ethernet frame does the ARP opcode field begin? ARP 操作码字段开始从以太网帧的最开始有多少字节？ 20 个字节 b) What is the value of the opcode field within the ARP-payload part of the Ethernet frame in which an ARP response is made? 在进行 ARP 响应的以太网帧的 ARP 负载部分中，操作码字段的值是多少？ 0x0002 请求的ARP有效负载为0x0002的操作码字段，用于应答。 c) Where in the ARP message does the “answer” to the earlier ARP request appear – the IP address of the machine having the Ethernet address whose corresponding IP address is being queried? 在响应 ARP 中从哪里看出现早期 ARP 请求的答案? Target MAC address 为 00:d0:59:a9:3d:68 Target IP address 为 192.168.1.105 这两项与之前的ARP Sender MAC address， Sender IP address 对应 What are the hexadecimal values for the source and destination addresses in the Ethernet frame containing the ARP reply message? 包含 ARP 回复消息的以太网帧中的源地址和目标地址的十六进制值是多少？ source address ： 00:06:25:da:af:73 destination address ： 00:d0:59:a9:3d:68 . Open the ethernet-ethereal-trace-1 trace file in http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip. The first and second ARP packets in this trace correspond to an ARP request sent by the computer running Wireshark, and the ARP reply sent to the computer running Wireshark by the computer with the ARP-requested Ethernet address. But there is yet another computer on this network, as indicated by packet 6 – another ARP request. Why is there no ARP reply (sent in response to the ARP request in packet 6) in the packet trace? 在作者抓包结果中，他有两台电脑，一台运行 wireshark 进行抓包，一台没有，那么为什么运行 wireshark 那台电脑发送 ARP 请求得到了应答，另外一台电脑的 ARP 请求没有得到应答?(没有相应第 6 帧的 ARP 的请求) 这个ARP请求没有回复，因为我们不在发送请求的计算机上。ARP请求是广播的，但ARP回复直接发回发送方的以太网地址。 Extra Credit 额外实验 EX-1. The arp command: arp 命令: arp -s InetAddr EtherAddr allows you to manually add an entry to the ARP cache that resolves the IP address InetAddr to the physical address EtherAddr. What would happen if, when you manually added an entry, you entered the correct IP address, but the wrong Ethernet address for that remote interface? 这个命令允许你手动添加 arp 记录到缓存表中。它会把您输入的 IP 地址(InetAddr)解析为物理地址(EtherAddr)，请问您输入正确 IP 地址但是物理地址错误会发生什么。 EX-2. What is the default amount of time that an entry remains in your ARP cache before being removed. You can determine this empirically (by monitoring the cache contents) or by looking this up in your operation system documentation. Indicate how/where you determined this value. 在删除 ARP 缓存之前，请问它们默认的有效时间是多少，您可以通过不定时的查看缓存内容得出结论或者查询相应的操作系统文档。","categories":[],"tags":[{"name":"Network","slug":"Network","permalink":"http://www.misaka-9982.com/tags/Network/"},{"name":"Wireshark","slug":"Wireshark","permalink":"http://www.misaka-9982.com/tags/Wireshark/"}]},{"title":"Wireshark-Lab9 NAT","slug":"Wireshark-Lab9","date":"2022-03-12T10:52:54.000Z","updated":"2023-02-22T13:07:14.708Z","comments":true,"path":"2022/03/12/Wireshark-Lab9/","link":"","permalink":"http://www.misaka-9982.com/2022/03/12/Wireshark-Lab9/","excerpt":"","text":"Lab9:NAT In this lab, we’ll investigate the behavior of the NAT protocol. This lab will be different from our other Wireshark labs, where we’ve captured a trace file at a single Wireshark measurement point. Because we’re interested in capturing packets at both the input and output sides of the NAT device, we’ll need to capture packets at two locations. Also, because many students don’t have easy access to a NAT device or to two computers on which to take Wireshark measurements, this isn’t a lab that is easily done “live” by a student. Therefore in this lab, you will use Wireshark trace files that we’ve captured for you. Before beginning this lab, you’ll probably want to review the material on NAT section 4.3.4 in the text1 . 在本实验中，我们将研究 NAT 协议内容。本次实验不同于过去以往实验，我们将会在每个 Wireshark 捕获点抓包（译者注：在多个位置网络位置抓包，见下文）：我们将会在 NAT 设备出口和入口两个位置都要抓包。由于学生们可能没有轻松在NAT 设备抓包的权限以及学生没有两台以上的电脑用以抓包，所以可能此实验不能由学生亲自完成，请使用作者提供的跟踪文件进行分析。另外，建议开始本实验之前，翻看课本中 4.3.4 节关于 NAT 内容。 1. NAT Measurement Scenario NAT 侦测场景 In this lab, we’ll capture packets from a simple web request from a client PC in a home network to a www.google.com server. Within the home network, the home network router provides a NAT service, as discussed in Chapter 4. Figure 1 shows our Wireshark trace-collection scenario. As in our other Wireshark labs, we collect a Wireshark trace on the client PC in our home network. This file is called NAT_home_side2 . Because we are also interested in the packets being sent by the NAT router into the ISP, we’ll collect a second trace file at a PC (not shown) tapping into the link from the home router into the ISP network, as shown in Figure 1. (The hub device shown on the ISP side of the router is used to tap into the link between the NAT router and the first hop router in the ISP). Client-to-server packets captured by Wireshark at this point will have undergone NAT translation. The Wireshark trace file captured on the ISP side of the home router is called NAT_ISP_side. 在本实验中，我们将会用在家庭网络的一个客户端 PC 发送到 www.google.com 简 单 HTTP 请求并且捕获它。在家庭网络中，家庭网络路由器会提供如课本第四章所讲的 NAT 服务。图 1 显示我们的 Wireshark NAT 实验抓包收集方案。正如我们其它 Wireshark 实验一样，我们将会在该客户端 PC 进行抓包并存为 NAT_home_side文件。同样我们因为需要研究 NAT 路由器发送到 ISP 网络的数据包感兴趣，因此我们将会一个图 1 中的未展示 PC 收集从 NAT 路由到 ISP 网络的第二数据包。路由左侧连接 ISP 网络的集线器将会起到连接 NAT 路由器和 ISP 的第一跳路由（第一级路由的作用）。我们将位于 NAT 路由连 ISP 网络的 Wireshark 的抓包结果称为 NAT_ISP_side。 Open the NAT_home_side file and answer the following questions. You might find it useful to use a Wireshark filter so that only frames containing HTTP messages are displayed from the trace file. 打开 NAT_home_side 文件并回答以下问题。 请使用 HTTP 过滤器过滤跟踪文件降低分析难度。 Whenever possible, when answering a question below, you should hand in a printout of the packet(s) within the trace that you used to answer the question asked. Annotate the printout3 to explain your answer. To print a packet, use File-&gt;Print, choose Selected packet only, choose Packet summary line, and select the minimum amount of packet detail that you need to answer the question 请尽量清晰的展示您的答案，必要时您可以在图中用标记辅以说明。您的答案应该简单可读。 What is the IP address of the client? 客户端的 IP 地址是多少？ 192.168.1.100 The client actually communicates with several different Google servers in order to implement “safe browsing.” (See extra credit section at the end of this lab). The main Google server that will serve up the main Google web page has IP address 64.233.169.104. In order to display only those frames containing HTTP messages that are sent to/from this Google, server, enter the expression “http &amp;&amp; ip.addr == 64.233.169.104” (without quotes) into the Filter: field in Wireshark . 客户端实际上与几个不同的 Google 服务器通信，以实现“安全浏览”。（请参阅本实验结束的额外问题）。提供主要 Google 网页的服务器地址是64.233.169.104，为了仅仅显示客户端的请求和服务器的响应，请在Wireshark 过滤器输入以下过滤式“ http &amp;&amp; ip.addr == 64.233.169.104 ”（不包括引号）。 Consider now the HTTP GET sent from the client to the Google server (whose IP address is IP address 64.233.169.104) at time 7.109267. What are the source and destination IP addresses and TCP source and destination ports on the IP datagram carrying this HTTP GET? 请选择在 7.109267 s 时间的客户端发送到 Google 服务器（其 IP 地址为 IP 地 址 64.233.169.104）的 HTTP GET。承载此 HTTP GET 的 IP 数据报上的源IP 地址和目标 IP 地址以及 TCP 源和目标端口是什么？ Source IP address: 192.168.1.100 Source Port: 4335 Destination IP address: 64.233.169.104 Destination Port: 80 At what time4 is the corresponding 200 OK HTTP message received from the Google server? What are the source and destination IP addresses and TCP source and destination ports on the IP datagram carrying this HTTP 200 OK message? 什么时候从 Google 服务器收到相应的状态码 200、状态 OK 的 HTTP 响应消息？ 携带状态码 200、状态 OK 的 HTTP 响应消息的 IP 数据报上的源和目标 IP 地址以及 TCP 源和目标端口是什么？ Time: 7.158798 s Source IP address: 64.233.169.104 Source Port: 80 Destination IP address: 192.168.1.100 Destination Port: 4335 Recall that before a GET command can be sent to an HTTP server, TCP must first set up a connection using the three-way SYN/ACK handshake. At what time is the client-to-server TCP SYN segment sent that sets up the connection used by the GET sent at time 7.109267? What are the source and destination IP addresses and source and destination ports for the TCP SYN segment? What are the source and destination IP addresses and source and destination ports of the ACK sent in response to the SYN. At what time is this ACK received at the client? (Note: to find these segments you will need to clear the Filter expression you entered above in step 2. If you enter the filter “tcp”, only TCP segments will be displayed by Wireshark). 回想一下，在将 GET 请求发送到 HTTP 服务器之前，TCP 必须首先使用三次SYN/ACK 消息建立连接。在什么时间客户端发送了含有 TCP SYN 的报文建立连接消息用于发送在 7.109267 s 的 GET 请求？TCP SYN 报文的源 IP 地址和目标 IP地址以及源端口和目标端口是什么？ 为响应 SYN 报文而发送的 ACK 报文的源和目标 IP 地址以及源和目标端口是什么？在客户端收到此 ACK 报文什么时间？（注意您需要清除在第 2 题中的过滤器表达式并且输入“tcp”（不含引号）表达式，仅仅显示 tcp 报文消息。 7.075657 s Source: 192.168.1.100, 4335 Destination: 64.233.169.104,80 Source: 64.233.169.104, 80 Destination: 192.168.1.100, 4335 7.108986 s In the following we’ll focus on the two HTTP messages (GET and 200 OK) and the TCP SYN and ACK segments identified above. Our goal below will be to locate these two HTTP messages and two TCP segments in the trace file (NAT_ISP_side) captured on the link between the router and the ISP. Because these captured frames will have already been forwarded through the NAT router, some of the IP address and port numbers will have been changed as a result of NAT translation. 在接下来实验中，我们将会重点关注 HTTP GET 和 HTTP 200 OK 消息以及刚才提到的 TCP SYN 报文和 TCP ACK 报文。我们的目标是在路由器和 ISP 之间的链路上捕获的跟踪文件（NAT_ISP_side）中找到这两个 HTTP 消息和两个 TCP 报文。由于这些捕获的帧已经通过 NAT 路由器转发，因此一些 IP 地址和端口号将因NAT 转换而被更改。 Open the NAT_ISP_side*. Note that the time stamps in this file and in NAT_home_side* are not synchronized since the packet captures at the two locations shown in Figure 1 were not started simultaneously. (Indeed, you should discover that the timestamps of a packet captured at the ISP link is actually less that the timestamp of the packet captured at the client PC). 打开作者抓包文件 NAT_ISP_side。请注意此文件的时间戳不用于刚才的NAT_home_side 的时间戳，因为两个位置捕获的信息并不是同步的。（实际上，您应该发现在 ISP 链路与 NAT 路由器的抓包时间戳小于在客户端 PC 上抓包的数据包的时间戳*）* In the NAT_ISP_side trace file, find the HTTP GET message was sent from the client to the Google server at time 7.109267 (where t=7.109267 is time at which this was sent as recorded in the NAT_home_side trace file). At what time does this message appear in the NAT_ISP_side trace file? What are the source and destination IP addresses and TCP source and destination ports on the IP datagram carrying this HTTP GET (as recording in the NAT_ISP_side trace file)? Which of these fields are the same, and which are different, than in your answer to question 3 above? 在 NAT_ISP_side 跟踪文件中，找到跟刚才客户端 7.109267s 同样目的地发送的 HTTP GET 消息（这个时间是在 NAT_home_side 跟踪文件中记录的时间）。该消息何时出现在 NAT_ISP_side 跟踪文件中？ 承载此 HTTP GET 消息的 IP 数据报的源和目标 IP 地址以及 TCP 源和目标端口是什么？与您对上述问题 3 的回答相比，哪些字段相同，哪些字段不同？ 6.069168 s Source IP address: 71.192.34.104 Source Port: 4335 Destination IP address: 64.233.169.104 Destination Port: 80 只有 Source IP address 不同 Are any fields in the HTTP GET message changed? Which of the following fields in the IP datagram carrying the HTTP GET are changed: Version, Header Length, Flags, Checksum. If any of these fields have changed, give a reason (in one sentence) stating why this field needed to change. HTTP GET 消息中的任何字段是否已更改？ 携带 HTTP GET 的 IP 数据报中的以下哪个字段发生了变化：版本，标题长度，标志，校验和。 如果这些字段中的任何一个发生了变化，请说明为什么。 fields in the HTTP GET message : No Version Answer: No Header Length : No Flags: No Checksum : Yes 因为Checksum包括Source IP address，Source IP address 改变也会改变Checksum In the NAT_ISP_side trace file, at what time is the first 200 OK HTTP message received from the Google server? What are the source and destination IP addresses and TCP source and destination ports on the IP datagram carrying this HTTP 200 OK message? Which of these fields are the same, and which are different than your answer to question 4 above? 在 NAT_ISP_side 跟踪文件中，从 Google 服务器收到的第一条 HTTP200 OK消息在什么时间？ 携带此 HTTP 200 OK 消息的 IP 数据报上的源和目标 IP地址以及 TCP 源和目标端口是什么？ 与您第 4 问回答的 NAT_home_side 结果相比哪些字段相同，哪些字段不同？ 6.117570 s Source IP address: 64.233.169.104 Source Port: 80 Destination IP address: 71.192.34.10 Destination Port: 4335 只有 Destination IP address 字段不同 In the NAT_ISP_side trace file, at what time were the client-to-server TCP SYN segment and the server-to-client TCP ACK segment corresponding to the segments in question 5 above captured? What are the source and destination IP addresses and source and destination ports for these two segments? Which of these fields are the same, and which are different than your answer to question 5 above? 在 NAT_ISP_side 跟踪文件中，跟上面的问题 5 相同地址的客户端到服务器TCP SYN 报文和服务器到客户端 TCP ACK 报文在什么时间出现？这两个段的源和目标 IP 地址以及源和目标端口是什么？ 与您的问题 5 相比，哪些字段相同，哪些字段与不同？ 6.035475 s 和 6.067775 s SYN: Source: 71.192.34.104, 4335 Destination: 64.233.169.104, 80 ACK: Source: 64.233.169.104, 80 Destination: 71.192.34.104, 4335 SYN 的 源IP地址和 ACK 的目标 IP 地址变了 端口号没变 Figure 4.25 in the text shows the NAT translation table in the NAT router. 课本中的图 4.25 显示了 NAT 路由器中的 NAT 转换表。 Using your answers to 1-8 above, fill in the NAT translation table entries for HTTP connection considered in questions 1-8 above. 使用您的第 1 到 8 题的答案，做出跟课本类似的 HTTP 连接的 NAT 转换表。 NAT 转换表 WAN 端 LAN 端 71.192.34.104, 4335 192.168.1.100, 4335 Extra Credit: The trace files investigated above have additional connections to Google servers above and beyond the HTTP GET, 200 OK request/response studied above. For example, in the NAT_home_side trace file, consider the client-to-server GET at time 1.572315, and the GET at time 7.573305. Research the use of these two HTTP messages and write a half page explanation of the purpose of each of these messages. 额外问题：在作者上面的抓包结果中，除了上面提到的 HTTP GET 消息和 HTTP 200 OK 消息以外，还与其他 Google 服务器有额外的连接，例如，在NAT_home_side 跟踪文件中，分析时间为 1.572315 s 的客户端到服务器 GET 消息，以及时间为 7.573305s 的 GET 消息。 仔细研究这两个 HTTP 消息的使用并写出说明解释这些消息的目的。","categories":[],"tags":[{"name":"Network","slug":"Network","permalink":"http://www.misaka-9982.com/tags/Network/"},{"name":"Wireshark","slug":"Wireshark","permalink":"http://www.misaka-9982.com/tags/Wireshark/"}]},{"title":"Wireshark-Lab8 DHCP","slug":"Wireshark-Lab8","date":"2022-03-08T01:20:05.000Z","updated":"2023-02-22T13:07:14.708Z","comments":true,"path":"2022/03/08/Wireshark-Lab8/","link":"","permalink":"http://www.misaka-9982.com/2022/03/08/Wireshark-Lab8/","excerpt":"","text":"Lab8:DHCP In this lab, we’ll take a quick look at DHCP. DHCP is covered in Section 4.4.3 of the text1 . Recall that DHCP is used extensively in corporate, university and home-network wired and wireless LANs to dynamically assign IP addresses to hosts (as well as to configure other network configuration information). 在本实验中，我们将快速了解 DHCP 动态主机设置协议。 DHCP 在课本的第 4.4.3节中介绍。 回想一下，DHCP 广泛用于企业，大学和家庭网络有线和无线 LAN，以动态地为主机分配 IP 地址（以及配置其他网络配置信息）。 This lab is brief, as we’ll only examine the DHCP packets captured by a host. If you also have administrative access to your DHCP server, you may want to repeat this lab after making some configuration changes (such as the lease time). If you have a router at home, you most likely can configure your DHCP server. Because many linux/Unix machines (especially those that serve many users) have a static IP address and because manipulating DHCP on such machines typically requires super-user privileges, we’ll only present a Windows version of this lab below. 这是一个小实验，我们只要通过分析我们本机的捕获 DHCP 数据包。不过如果您有对 DHCP 服务器管理访问权限，则您可以试试进行一些更改 DHCP 配置（例如租用时间）后重复此实验。同样的如果您家里有路由器，您或许也会配置 DHCP服务器。因为许多 Linux / Unix 机器（特别是为许多用户提供服务的机器，译注：这里指的是 DHCP 服务器）需要具有静态 IP 地址，并且因为在这些机器上操作DHCP 通常需要超级用户权限，所以（为了实验简单）我们将仅在下面提供此实验的 Windows 版本。 DHCP Experiment DHCP 实验 In order to observe DHCP in action, we’ll perform several DHCP-related commands and capture the DHCP messages exchanged as a result of executing these commands. Do the following2 : 为了了解 DHCP 如何的工作，我们将执行几个与 DHCP 相关的命令，并捕获由于执行这些命令而传输的 DHCP 消息。 请执行下列操作 ： Begin by opening the Windows Command Prompt application (which can be found in your Accessories folder). As shown in Figure 1, enter “ipconfig /release”. The executable for ipconfig is in C:\\windows\\system32. This command releases your current IP address, so that your host’s IP address becomes 0.0.0.0. 首先打开 Windows 命令提示符应用程序（可在“附件”文件夹中找到）。 如 图 1 所示，输入“ ipconfig /release ”（注意是引号内容，且不包括引号）。ipconfig 的可执行程序位于 C:\\windows\\system32 中。 此命令会释放您当前的 IP 地址，以便主机的 IP 地址变为 0.0.0.0 Start up the Wireshark packet sniffer, as described in the introductory Wireshark lab and begin Wireshark packet capture. 打开 Wireshark 并且进行抓包。 Now go back to the Windows Command Prompt and enter “ipconfig /renew”. This instructs your host to obtain a network configuration, including a new IP address. In Figure 1, the host obtains the IP address 192.168.1.108 现在继续在 Windows 命令提示符并输入 “ ipconfig /renew ” （注意是引号内容，且不包括引号）。 这会指示您的主机获取网络配置，包括新的 IP 地址。 在图 1 中，主机获得 IP 地址 192.168.1.108 Wait until the “ipconfig /renew” has terminated. Then enter the same command “ipconfig /renew” again. 等到“ ipconfig /renew ” 命令执行完毕。 然后再次输入相同的命令“ipconfig / renew”。 When the second “ipconfig /renew” terminates, enter the command “ipconfig/release” to release the previously-allocated IP address to your computer. 等到第二遍“ ipconfig /renew ” 命令执行完毕。再次在命令提示符输入“ ipconfig /release ”命令释放您刚获取的 IP。 Finally, enter “ipconfig /renew” to again be allocated an IP address for your computer. 最后，输入 “ipconfig /renew”命令再次为您的计算机分配一个 IP 地址。 Stop Wireshark packet capture. 停止抓包。 Figure 1 Command Prompt window showing sequence of *ipconfig* commands that you should enter. 图 1 您应该在命令提示符所输入一系列 ipconfig 命令 Now let’s take a look at the resulting Wireshark window. To see only the DHCP packets, enter into the filter field “bootp”. (DHCP derives from an older protocol called BOOTP. Both BOOTP and DHCP use the same port numbers, 67 and 68. To see DHCP packets in the current version of Wireshark, you need to enter “bootp” and not “dhcp” in the filter.) We see from Figure 2 that the first ipconfig renew command caused four DHCP packets to be generated: a DHCP Discover packet, a DHCP Offer packet, a DHCP Request packet, and a DHCP ACK packet. 现在让我们来看看抓包结果。 要仅查看 DHCP 数据包，请进入过滤器字段“bootp”。 （DHCP 来自一个名为 BOOTP 的旧协议.BOOTP 和 DHCP 都使用相同的端口号 67 和 68.要查看当前版本的 Wireshark 中的 DHCP 数据包，您需要在过滤器中输入“bootp”而不是“dhcp”。） 我们从图 2 中看到，第一个“ipconfig/ renew”命令导致生成四个 DHCP 数据包：DHCP Discover 数据包，DHCP Offer 数据包，DHCP Request 数据包和 DHCP ACK数据包。 Figure 2 Wireshark window with first DHCP packet – the DHCP Discover packet – expanded. 图 2 Wireshark 窗口展开详细显示第一个 DHCP 数据包 - DHCP Discover 数据包 What to Hand In: 回答问题 You should hand in a screen shot of the Command Prompt window similar to Figure 1 above. Whenever possible, when answering a question below, you should hand in a printout of the packet(s) within the trace that you used to answer the question asked. Annotate the printout3 to explain your answer. To print a packet, use File-&gt;Print, choose Selected packet only, choose Packet summary line, and select the minimum amount of packet detail that you need to answer the question. 请尽量清晰的展示您的答案，必要时您可以在图中用标记辅以说明。您的答案应该简单可读。 Answer the following questions: 请您回答以下问题 Are DHCP messages sent over UDP or TCP? DHCP 消息是通过 UDP 还是 TCP 发送的？ UDP Draw a timing datagram illustrating the sequence of the first four-packet Discover/Offer/Request/ACK DHCP exchange between the client and server. For each packet, indicated the source and destination port numbers. Are the port numbers the same as in the example given in this lab assignment? 绘制时间流图形。说明客户端和服务器之间第一次四个 DHCP 发现，DHCP提供，DHCP 请求以及 DHCP 响应的顺序，说明您的结果中对于每个数据包，指示源和目标端口号是否与本实验分配中给出的示例相同？ Statistics -&gt; Flow Graph What is the link-layer (e.g., Ethernet) address of your host? 主机的链路层（例如以太网）地址是什么？ 00:08:74:4f:36:23 What values in the DHCP discover message differentiate this message from the DHCP request message? DHCP 发现消息中的哪些值将此消息与 DHCP 请求消息区不同？ 区别在于“Option 53: DHCP Message Type”. What is the value of the Transaction-ID in each of the first four (Discover/Offer/Request/ACK) DHCP messages? What are the values of the Transaction-ID in the second set (Request/ACK) set of DHCP messages? What is the purpose of the Transaction-ID field? 第一次四个 DHCP 发现，DHCP 提供，DHCP 请求以及 DHCP 响应的Transaction-ID 值是多少？Transaction-ID 字段目的是什么。 0x3e5e0ce3，使用 Transaction-ID字段的目的是为了便于DHCP服务器可以在请求过程中区分客户端请求。 A host uses DHCP to obtain an IP address, among other things. But a host’s IP address is not confirmed until the end of the four-message exchange! If the IP address is not set until the end of the four-message exchange, then what values are used in the IP datagrams in the four-message exchange? For each of the four DHCP messages (Discover/Offer/Request/ACK DHCP), indicate the source and destination IP addresses that are carried in the encapsulating IP datagram. 主机使用 DHCP 获取 IP 地址。主机在 DHCP 的 4 次问询和回答之后获取了地址。请问如果在这 4 次 DHCP 问询和回答中，如果主机没有 IP 地址，那么 IP 数据报的值是什么？请分别指出这 4 个 DHCP 的消息 IP 数据报源头和目标 IP。 DHCP客户机和服务器都使用255.255.255.255作为Destination IP address。客户端使用源IP地址0.0.0.0，而服务器使用其作为源的实际IP地址。 What is the IP address of your DHCP server? 您的 DHCP 服务器的 IP 地址是多少？ 192.168.1.1 What IP address is the DHCP server offering to your host in the DHCP Offer message? Indicate which DHCP message contains the offered DHCP address. 发送 DHCP Offer 消息的 DHCP 服务器 IP 是什么，指示哪条 DHCP 消息包含提供的 DHCP 地址。 DHCP服务器将IP地址192.168.1.101提供给我的客户端。DHCP消息类型=DHCP提供的DHCP消息包含提供的IP。 In the example screenshot in this assignment, there is no relay agent between the host and the DHCP server. What values in the trace indicate the absence of a relay agent? Is there a relay agent in your experiment? If so what is the IP address of the agent? 在作者的例子中，主机和 DHCP 服务器之间没有中继代理。 跟踪中的哪些值表明没有中继代理？ 您的实验中是否有中继代理？ 如果是这样，代理的IP 地址是什么？ 中继代理IP地址为0.0.0.0，表示没有使用DHCP中继。在我的实验中没有使用中继代理。 Explain the purpose of the router and subnet mask lines in the DHCP offer message. 解释 DHCP offer 消息中路由器和子网掩码字段的用途。 路由器行向客户端指示其默认网关是什么。子网掩码行告诉客户端应该使用哪个子网掩码。 In the DHCP trace file noted in footnote 2, the DHCP server offers a specific IP address to the client (see also question 8. above). In the client’s response to the first server OFFER message, does the client accept this IP address? Where in the client’s RESPONSE is the client’s requested address? 在脚注 2 作者提供的抓包结果中，DHCP 服务器会向作者提供特定的 IP 地址（请见上面问题 8）。请问客户端接受使用是否对第一个提供 DHCP offer消息的 DHCP 地址？客户端的响应（DHCP 请求中）哪里是它所要求的地址。 接受，在第二个DHCP中的客户端Source地址就是第一个提供 DHCP offer消息的 DHCP 地址 响应中的Option（50）是它所要求的地址 Explain the purpose of the lease time. How long is the lease time in your experiment? 解释租约时间的目的。 您的实验中的租约时间有多长？ 租约时间是DHCP服务器分配IP的时间量给客户的地址。在租约期间，DHCP服务器不会分配IP提供给客户端给另一个客户端，除非它是由客户端释放的。一旦租约时间已过，DHCP服务器可以重复使用该IP地址以提供给另一个客户。在我的实验中，租赁期是1天。 What is the purpose of the DHCP release message? Does the DHCP server issue an acknowledgment of receipt of the client’s DHCP request? What would happen if the client’s DHCP release message is lost? DHCP 释放消息的目的是什么？DHCP 服务器是否发出收到客户端 DHCP 释放请求的确认。如果客户端的 DHCP 释放消息丢了会发生什么。 客户端发送DHCP Release消息以取消其对IP的租用DHCP服务器为其提供的地址。 DHCP服务器不会发送向客户端发回确认DHCP释放消息的消息。 如果如果来自客户端的DHCP Release消息丢失，则DHCP服务器必须等待该IP地址的租用期结束，直到它可以将其重新用于另一个客户。 Clear the bootp filter from your Wireshark window. Were any ARP packets sent or received during the DHCP packet-exchange period? If so, explain the purpose of those ARP packets. 从 Wireshark 窗口中清除 bootp 过滤器。 在 DHCP 数据包交换期间是否发送或接收了任何 ARP 数据包？ 如果接收到了，请说明这些 ARP 数据包的用途。 是的，DHCP服务器发出了ARP请求。在提供IP地址分配给客户端，则DHCP服务器会针对提供的IP发出ARP请求以确保该IP地址未被另一台工作站使用。","categories":[],"tags":[{"name":"Network","slug":"Network","permalink":"http://www.misaka-9982.com/tags/Network/"},{"name":"Wireshark","slug":"Wireshark","permalink":"http://www.misaka-9982.com/tags/Wireshark/"}]},{"title":"Wireshark-Lab7 ICMP","slug":"Wireshark-Lab7","date":"2022-03-07T08:31:32.000Z","updated":"2023-02-22T13:07:14.706Z","comments":true,"path":"2022/03/07/Wireshark-Lab7/","link":"","permalink":"http://www.misaka-9982.com/2022/03/07/Wireshark-Lab7/","excerpt":"","text":"Lab7:ICMP In this lab, we’ll explore several aspects of the ICMP protocol: 在本实验中，我们将探讨 ICMP 协议的几个方面： ICMP messages generating by the Ping program; Ping 程序生成的 ICMP 消息; ICMP messages generated by the Traceroute program; Traceroute 程序生成的 ICMP 消息; the format and contents of an ICMP message. ICMP 消息的格式和内容。 Before attacking this lab, you’re encouraged to review the ICMP material in section 5.6 of the text1 . We present this lab in the context of the Microsoft Windows operating system. However, it is straightforward to translate the lab to a Unix or Linux environment. 在开始本实验之前，我们建议您查看课本的 5.6 节中的 ICMP 章节。此实验是在Windows 下完成的，如果您使用其他系统也不用担心，因为大体都相同。 1. ICMP and Ping ICMP 协议和 Ping 程序 Let’s begin our ICMP adventure by capturing the packets generated by the Ping program. You may recall that the Ping program is simple tool that allows anyone (for example, a network administrator) to verify if a host is live or not. The Ping program in the source host sends a packet to the target IP address; if the target is live, the Ping program in the target host responds by sending a packet back to the source host. As you might have guessed (given that this lab is about ICMP), both of these Ping packets are ICMP packets. 让我们通过捕获 Ping 程序生成的数据包开始我们的 ICMP 实验。 您可能还记得Ping 程序是一个简单的工具，允许任何人（例如：网络管理员）验证主机是否存标主机中的 Ping 程序将会发送响应 Ping 数据包证明他在线，这两个 Ping 数据包都是 ICMP 数据包。 因此您可能猜出我们这个实验都是关于 ICMP 的实验了。 Do the following : 请按照以下动作做： Let’s begin this adventure by opening the Windows Command Prompt application (which can be found in your Accessories folder). 打开 windows 的命令提示符。 Start up the Wireshark packet sniffer, and begin Wireshark packet capture. 启动 Wireshark 数据包嗅探器，并开始 Wireshark 数据包捕获。 The ping command is in c:\\windows\\system32, so type either “ping –n 10 hostname” or “c:\\windows\\system32\\ping –n 10 hostname” in the MS-DOS command line (without quotation marks), where hostname is a host on another continent. If you’re outside of Asia, you may want to enter www.ust.hk for the Web server at Hong Kong University of Science and Technology. The argument “-n 10” indicates that 10 ping messages should be sent. Then run the Ping program by typing return. Ping 程序在 c:\\windows\\system32 目录中，所以您在命令提示符中输入“ping –n 10 hostname” 或 “c:\\windows\\system32\\ping –n 10 hostname”都是正确的（注意命令是引号里的内容）。其中 hostname 是另一个大陆的主机名。如您如果在非亚洲地区，建议您访问香港科技大学 www.ust.hk ， 参数-n 10代表发送 10 个 Ping 消息，然后按下回车执行命令。 When the Ping program terminates, stop the packet capture in Wireshark. 当 Ping 程序终止时，停止在 Wireshark 中捕获数据包。 At the end of the experiment, your Command Prompt Window should look something like Figure 1. In this example, the source ping program is in Massachusetts and the destination Ping program is in Hong Kong. From this window we see that the source ping program sent 10 query packets and received 10 responses. Note also that for each response, the source calculates the round-trip time (RTT), which for the 10 packets is on average 375 msec. 在实验结束时，您的命令提示符窗口应如图 1 所示。在此示例中，源 ping 程序位于马萨诸塞州，目标 Ping 程序位于香港。 从这个窗口我们看到源 ping 程序发送了10 个查询包并收到了 10 个响应。 另请注意，对于每个响应，源计算往返时间（RTT），对于 10 个数据包平均为 375 毫秒。 Figure 1 Command Prompt window after entering Ping command. 图 1 输入 Ping 命令后的命令提示符窗口。 Figure 2 provides a screenshot of the Wireshark output, after “icmp” has been entered into the filter display window. Note that the packet listing shows 20 packets: the 10 Ping queries sent by the source and the 10 Ping responses received by the source. Also note that the source’s IP address is a private address (behind a NAT) of the form 192.168/12; the destination’s IP address is that of the Web server at HKUST. Now let’s zoom in on the first packet (sent by the client); in the figure below, the packet contents area provides information about this packet. We see that the IP datagram within this packet has protocol number 01, which is the protocol number for ICMP. This means that the payload of the IP datagram is an ICMP packet. 如图 2，在将“icmp”输入过滤器显示窗口后 Wireshark 输出的屏幕截图。 请注意，数据包列表显示 20 个数据包：源发送的 10 个 Ping 查询和源接收的 10 个 Ping 响应。 另请注意，源的 IP 地址是 192.168 / 12 格式的私有地址（通过 NAT 协议连接互联网）; 目的地的 IP 地址是香港科技大学网络服务器的 IP 地址。 现在让我们点击显示第一个由客户端发送的数据包; 在图中的下方，数据包内容区域提供有关此数据包的信息。 我们看到该数据包中的 IP 数据报具有协议号 01，这是 ICMP 的协议号。 这意味着 IP 数据报的有效载荷是 ICMP 数据包。 Figure 2 Wireshark output for Ping program with Internet Protocol expanded. 图 2 在 Wireshark 中过滤 ICMP 协议并且选中某个 ICMP 消息 Figure 3 focuses on the same ICMP but has expanded the ICMP protocol information in the packet contents window. Observe that this ICMP packet is of Type 8 and Code 0 - a so-called ICMP “echo request” packet. (See Figure 5.19 of text.) Also note that this ICMP packet contains a checksum, an identifier, and a sequence number. 图 3 同样使用相同的 ICMP 过滤器，展开可以看到该 ICMP 包的详情信息。 观察到该 ICMP 数据包是类型 8 和代码 0 ——所谓的 ICMP“回应请求”数据包。 （请参见书本的图 5.19。）此外，此 ICMP 数据包包含校验和，标识符和序列号。 Figure 3 Wireshark capture of ping packet with ICMP packet expanded. 图 3 选择展开 ICMP 包的详情信息 What to Hand In: 回答问题 You should hand in a screen shot of the Command Prompt window similar to Figure 1 above. Whenever possible, when answering a question below, you should hand in a printout of the packet(s) within the trace that you used to answer the question asked. Annotate the printout3 to explain your answer. To print a packet, use File-&gt;Print, choose Selected packet only, choose Packet summary line, and select the minimum amount of packet detail that you need to answer the question. 请善用标记来展示您的答案请尽量清晰的展示您的答案，必要时您可以在图中用标记辅以说明。您的答案应该简单可读。 You should answer the following questions: 请回答以下问题： What is the IP address of your host? What is the IP address of the destination host? 您的主机的 IP 地址是多少？ 目标主机的 IP 地址是多少？ 我的主机IP：192.168.1.101 目标主机IP：143.89.14.34 Why is it that an ICMP packet does not have source and destination port numbers? 为什么 ICMP 数据包没有源端口号和目的端口号？ The ICMP packet does not have source and destination port numbers because it was designed to communicate network-layer information between hosts and routers, not between application layer processes. Each ICMP packet has a “Type” and a “Code”. The Type/Code combination identifies the specific message being received. Since the network software itself interprets all ICMP messages, no port numbers are needed to direct the ICMP message to an application layer process. ICMP数据包没有源端口号和目的端口号，因为它旨在主机和路由器之间通信网络层信息，而不是在应用层进程之间。每个ICMP数据包都有一个“类型”和一个“代码”。类型/代码组合标识正在接收的特定消息。由于网络软件本身解释所有ICMP消息，因此不需要端口号将ICMP消息定向到应用层进程。 Examine one of the ping request packets sent by your host. What are the ICMP type and code numbers? What other fields does this ICMP packet have? How many bytes are the checksum, sequence number and identifier fields? 查看任意的请求 ICMP 数据包， ICMP 类型和代码是什么？ 该 ICMP 数据包还有哪些其他字段？ 校验和，序列号和标识符字段有多少字节？ The ICMP type is 8, and the code number is 0. The ICMP packet also has checksum, identifier, sequence number, and data fields. The checksum, sequence number and identifier fields are two bytes each. ICMP类型为8，码号为0，ICMP数据包还具有Checksum、Identifier、Sequence Number和Data字段。校验和、序列号和标识符字段各为两个字节。 Examine the corresponding ping reply packet. What are the ICMP type and code numbers? What other fields does this ICMP packet have? How many bytes are the checksum, sequence number and identifier fields? 查看任意的响应 ICMP 数据包， ICMP 类型和代码是什么？ 该 ICMP 数据包还有哪些其他字段？ 校验和，序列号和标识符字段有多少字节？ The ICMP type is 0, and the code number is 0. The ICMP packet also has checksum, identifier, sequence number, and data fields. The checksum, sequence number and identifier fields are two bytes each. ICMP类型为8，码号为0，ICMP数据包还具有Checksum、Identifier、Sequence Number和Data字段。校验和、序列号和标识符字段各为两个字节。 2. ICMP and Traceroute ICMP 协议和 Traceroute 命令 Let’s now continue our ICMP adventure by capturing the packets generated by the Traceroute program. You may recall that the Traceroute program can be used to figure out the path a packet takes from source to destination. Traceroute is discussed in Section 1.4 and in Section 5.6 of the text. 现在让我们通过捕获 Traceroute 程序生成的数据包继续我们的 ICMP 实验。 您可能还记得 Traceroute 程序可用于确定数据包从源到目的地的路径。 Traceroute 命令可以在课本中的 1.4 节和 5.6 节中找到。 Traceroute is implemented in different ways in Unix/Linux/MacOS and in Windows. In Unix/Linux, the source sends a series of UDP packets to the target destination using an unlikely destination port number; in Windows, the source sends a series of ICMP packets to the target destination. For both operating systems, the program sends the first packet with TTL=1, the second packet with TTL=2, and so on. Recall that a router will decrement a packet’s TTL value as the packet passes through the router. When a packet arrives at a router with TTL=1, the router sends an ICMP error packet back to the source. In the following, we’ll use the native Windows tracert program. A shareware version of a much nice Windows Traceroute program is pingplotter (www.pingplotter.com). We’ll use pingplotter in our Wireshark IP lab since it provides additional functionality that we’ll need there. 每个系统有不同路由跟踪实现办法，在 Unix / Linux 中，路由跟踪 traceroute 使用发送不可到达（无使用的）端口的 UDP 包来实现，在 Windows 中，路由跟踪tracert 仅使用 ICMP 数据包来实现，但是对于他们来说，都是发送 TTL 增加的数据包，例如 TTL=1,TTL=2，回想下，每经过一个路由器，TTL 就会减一，当 TTL=1的包达到路由器，该路由器会将该包丢弃，并且发送 ICMP 错误给请求的机器，在本次实验，我们使用 window 自带的 tracert。有一个跨平台 Windows Traceroute 程序的是 pingplotter（www.pingplotter.com）（收费但可以试用）。 我们将在Wireshark IP 实验室中使用 pingplotter，因为它提供了我们在那里需要的其他功能。 Do the following4 : 请执行以下步骤 Let’s begin by opening the Windows Command Prompt application (which can be found in your Accessories folder). 打开 windows 的命令提示符。 Start up the Wireshark packet sniffer, and begin Wireshark packet capture. 启动 Wireshark 数据包嗅探器，并开始 Wireshark 数据包捕获。 The tracert command is in c:\\windows\\system32, so type either “tracert hostname” or “c:\\windows\\system32\\tracert hostname” in the MS-DOS command line (without quotation marks), where hostname is a host on another continent. (Note that on a Windows machine, the command is “tracert” and not “traceroute”.) If you’re outside of Europe, you may want to enter www.inria.fr for the Web server at INRIA, a computer science research institute in France. Then run the Traceroute program by typing return. tracert 程序在 c:\\windows\\system32 目录中，所以您在命令提示符中输入“tracert hostname” 或 “c:\\windows\\system32\\ tracert hostname”都是正确的（注意命令是引号里的内容）。其中 hostname 是另一个大陆的主机名。如您如果在非欧洲地区，建议您访问法国 INRIA（计算机科学研究所）www.inria.fr 然后按下回车执行命令。 When the Traceroute program terminates, stop packet capture in Wireshark. 当 Traceroute 程序终止时，停止在 Wireshark 中捕获数据包。 At the end of the experiment, your Command Prompt Window should look something like Figure 4. In this figure, the client Traceroute program is in Massachusetts and the target destination is in France. From this figure we see that for each TTL value, the source program sends three probe packets. Traceroute displays the RTTs for each of the probe packets, as well as the IP address (and possibly the name) of the router that returned the ICMP TTL-exceeded message. 在实验结束时，您的命令提示符窗口应如图 4 所示。在此图中，客户端 Traceroute程序主机位于马萨诸塞州，目标主机位于法国。 从该图中我们看到，对于每个TTL 值，源程序发送三个探测包。 Traceroute 显示每个探测包的 RTT，以及返回ICMP TTL 超出消息的路由器的 IP 地址（可能还有名称）。 Figure 4 Command Prompt window displays the results of the Traceroute program. 图 4“命令提示符”窗口显示 Traceroute 程序的结果。 Figure 5 displays the Wireshark window for an ICMP packet returned by a router. Note that this ICMP error packet contains many more fields than the Ping ICMP messages. 图 5 显示了路由器返回的 ICMP 数据包的 Wireshark 窗口。 请注意，此 ICMP 错误数据包包含的字段比 Ping ICMP 消息多得多。 Figure 5 Wireshark window of ICMP fields expanded for one ICMP error packet. 图 5 为一个 ICMP 错误数据包扩展的 ICMP 字段的 Wireshark 窗口。 What to Hand In: 回答问题 For this part of the lab, you should hand in a screen shot of the Command Prompt window. Whenever possible, when answering a question below, you should hand in a printout of the packet(s) within the trace that you used to answer the question asked. Annotate the printout to explain your answer. To print a packet, use File-&gt;Print, choose Selected packet only, choose Packet summary line, and select the minimum amount of packet detail that you need to answer the question. 请尽量清晰的展示您的答案，必要时您可以在图中用标记辅以说明。您的答案应该简单可读。 Answer the following questions: 请回答以下问题： What is the IP address of your host? What is the IP address of the target destination host? 您的主机的 IP 地址是多少？ 目标目标主机的 IP 地址是多少？ 我的主机IP：192.168.1.101 目标主机IP：138.96.146.2 If ICMP sent UDP packets instead (as in Unix/Linux), would the IP protocol number still be 01 for the probe packets? If not, what would it be? 如果 ICMP 发送了 UDP 数据包（如在 Unix / Linux 中），那么探测数据包的IP 协议号仍然是 01 吗？ 如果没有，它会是什么？ No. If ICMP sent UDP packets instead, the IP protocol number should be 0x11. 不，如果ICMP改为发送UDP数据包，则IP协议号应为0x11。 Examine the ICMP echo packet in your screenshot. Is this different from the ICMP ping query packets in the first half of this lab? If yes, how so? 检查屏幕截图中的 ICMP 响应数据包。 这与本实验的前半部分中的 ICMP ping 查询数据包不同吗？ 如果不同，请解释为什么？ The ICMP echo packet has the same fields as the ping query packets. Examine the ICMP error packet in your screenshot. It has more fields than the ICMP echo packet. What is included in those fields? 检查屏幕截图中的 ICMP 错误数据包。 它具有比 ICMP 响应数据包更多的字段。 这个数据包含哪些内容？ The ICMP error packet is not the same as the ping query packets. It contains both the IP header and the first 8 bytes of the original ICMP packet that the error is for. ICMP错误包与ping查询包不同它包含错误所针对的原始ICMP数据包的IP标头和前8个字节。 错误数据包 原始ICMP数据包 Examine the last three ICMP packets received by the source host. How are these packets different from the ICMP error packets? Why are they different? 检查源主机收到的最后三个 ICMP 数据包。 这些数据包与 ICMP 错误数据包有何不同？ 他们为什么不同？ The last three ICMP packets are message type 0 (echo reply) rather than 11 (TTL expired). They are different because the datagrams have made it all the way to the destination host before the TTL expired. 最后三个ICMP数据包是消息类型0(回应回复)，而不是11(TTL过期)。它们是不同的，因为数据报在TTL到期之前一直到达目标主机。 Within the tracert measurements, is there a link whose delay is significantly longer than others? Refer to the screenshot in Figure 4, is there a link whose delay is significantly longer than others? On the basis of the router names, can you guess the location of the two routers on the end of this link? 在 tracert 跟踪测量中，是否有一个连接的延迟比其他连接长得多？ 请参阅图 4 中的屏幕截图，是否有连接的延迟明显长于其他连接？ 根据路由器名称，您能猜出这个连接末端的两个路由器的位置吗？ There is a link between steps 11 and 12 that has a significantly longer delay. This is a transatlantic link from New York to Aubervilliers, France. In figure 4 from the lab, the link is from New York to Pastourelle, France. 3. Extra Credit 额外问题 For one of the programming assignments you created a UDP client ping program. This ping program, unlike the standard ping program, sends UDP probe packets rather than ICMP probe packets. Use the client program to send a UDP packet with an unusual destination port number to some live host. At the same time, use Wireshark to capture any response from the target host. Provide a Wireshark screenshot for the response as well as an analysis of the response. 对于一个编程任务，您可能创建了一个 UDP 客户端 ping 程序。 与标准 ping 程序不同，此 ping 程序发送 UDP 探测包而不是 ICMP 探测包。 使用客户端程序将具有异常目标端口号的 UDP 数据包发送到某个活动主机。 同时，使用 Wireshark 捕获目标主机的任何响应。 提供响应的 Wireshark 屏幕截图以及响应分析。","categories":[],"tags":[{"name":"Network","slug":"Network","permalink":"http://www.misaka-9982.com/tags/Network/"},{"name":"Wireshark","slug":"Wireshark","permalink":"http://www.misaka-9982.com/tags/Wireshark/"}]},{"title":"Wireshark-Lab6 IP","slug":"Wireshark-Lab6","date":"2022-03-04T11:30:35.000Z","updated":"2023-02-22T13:07:14.708Z","comments":true,"path":"2022/03/04/Wireshark-Lab6/","link":"","permalink":"http://www.misaka-9982.com/2022/03/04/Wireshark-Lab6/","excerpt":"","text":"Lab6:IP 在本实验中，我们将研究 IP 协议，重点关注 IP 数据报(IP datagram)。我们将通过分析在执行 traceroute 程序发送和接收的一系列 IP 数据报的过程来完成这个实验（traceroute 程序本身则是在 Wireshark ICMP 实验室中进行了更详细的探讨），我们将研究 IP datagram 中的各个字段(fields)，并详细研究 IP fragmentation 的方法。 在开始本实验之前，希望您复习课本中的 1.4.3 节 和观看 RFC 2151 文件的 3.4 节中的内容[ftp://ftp.rfc-editor.org/in-notes/rfc2151.txt]，让自己更了解 traceroute 程序的操作。您还需要阅读文中的第 4.4 节，或许还需要看看 RFC 791 [ftp://ftp.rfc\u0002-editor.org/in-notes/rfc791.txt]，让自己对 IP 协议有基础的认识。 Capturing packets from an execution of traceroute (捕获执行 traceroute的数据包) 为了生成本实验的一系列 IP 数据报，我们将使用 traceroute 程序向不同的目的地 X发送不同大小的数据报。回想一下，traceroute 通过首先发送一个或多个带有生存时间(TTL: Time-to-Live)字段设置为 1 的数据报；然后发送一个或多个带有生存时间(TTL: Time-to-Live)字段设置为 2 的数据报到同一个目的地；然后发送一个或多个带有生存时间(TTL: Time-to-Live)字段设置为 3 的数据报到同一个目的地，以此类推，直到目的地真正收到此数据报为止。回想一下，路由器必须将每个接收到的数据报中的 TTL 减 1（实际上，RFC 791 文献中表示路由器必须将 TTL 减少至少一个）。如果 TTL 达到 0，路由器会向来源主机发送 ICMP 消息（类型 11 - 超出TTL）。由于这种行为，TTL 为 1 的数据报（由执行 traceroute 的主机发送）将导致距发送方一次跳跃的路由器，将 ICMP TTL 超出的消息发送回发送方主机；以TTL 为 2 发送的数据报将导致距离为两次跳跃的路由器，将 ICMP 消息发送回发送方主机；以 TTL 为 3 发送的数据报将导致距离为两次跳跃的路由器，将 ICMP 消息发送回发送方主机，等等。以这种方式，执行 traceroute 的主机可以通过查看包含ICMP TTL 超出消息的数据报中的来源 IP 地址来获知其自身与目的地 X 之间的路由器的身份。 我们想要运行 traceroute 并让它发送各种长度的数据报。 Windows 操作系统：Windows 提供的 tracert 程序（曾被使用于我们的 ICMP Wireshark 实验中）不允许更改 tracert 程序发送的 ICMP echo 请求（ping）消息的大小。因此，一个更好的 Windows traceroute 程序是 pingplotter，可在 http://www.pingplotter.com 上以免费版和共享软件版本获得。下载并安装pingplotter，并通过对您喜欢的站点执行一些 traceroute 来测试它。通过选择菜单项 Edit-&gt; Options-&gt; Packet Options 然后填写 Packet Size 字段，可以在pingplotter 中显式设置 ICMP echo 请求消息的大小。默认数据包大小为 56个字节。一旦 pingplotter 发送了一系列具有递增的 TTL 值的数据包，它会在等待 Trace Interval 时间后再次以 TTL 为 1 重新启动发送进程。同时，我们可以在 pingplotter 中明确设置 Trace Interval 的值和间隔数。(备注：PinPlotter 5 需要使用到 Standar 版或是 Professional 版才能够自定义 packet参数，有 14 天的试用版可以使用) Linux/Unix/MacOS. With the Unix/MacOS traceroute command, the size of the UDP datagram sent towards the destination can be explicitly set by indicating the number of bytes in the datagram; this value is entered in the traceroute command line immediately after the name or address of the destination. For example, to send traceroute datagrams of 2000 bytes towards gaia.cs.umass.edu, the command would be: %traceroute gaia.cs.umass.edu 2000 Do the following: (依照下列步骤执行：) 启动 Wireshark 并开始数据包捕获（Capture-&gt; Start），然后在 Wireshark 数据包捕获选项屏幕上按 OK（我们不需要在此处选择任何选项）。 如果您使用的是 Windows 平台，请启动 pingplotter 并在“要跟踪的地址窗口”中输入目标目标的名称。在“要跟踪的次数”字段中输入 3，这样您就不会收集太多数据。选择菜单项编辑 - &gt;高级选项 - &gt;数据包选项，然后在数据包大小字段中输入值 56，然后按确定。然后按 Trace 按钮。你应该看到一个看起来像这样的 pingplotter 窗口：(备注：新版 PingPlotter5 中没有跟踪次数的设定，可以在 count 到达 3 的时候按下暂停键，停止收集数据包) 接下来，通过选择编辑 -&gt;高级选项 -&gt;数据包选项并在数据包大小字段中输入值 2000，然后按确定，发送一组长度较长的数据报。然后按“继续”按钮。 最后，通过选择 Edit-&gt; Advanced Options-&gt; Packet Options 并在 Packet Size字段中输入值 3500，然后按 OK，发送一组长度较长的数据报。然后按“继 续”按钮。 Stop Wireshark tracing. (停止 Wireshark 数据包撷取) 如果您使用的是 Unix 或 Mac 平台，请输入三个 traceroute 命令，一个长度为 56 个字节，一个长度为 2000 个字节，另一个长度为 3500 个字节。 Stop Wireshark tracing. (停止 Wireshark 数据包撷取) 如果您无法在实际的网络连接上运行 Wireshark，则可以下载在作者的某台Windows 计算器上执行上述步骤时捕获的数据包跟踪文件。当您探索下面的问题时，即使您已经捕获了自己的跟踪数据并使用它，如同您自己的跟踪数据一般，您也可能会发现下载此跟踪数据对你的实验很有帮助。 在您的跟踪数据包中，您应该能够看到计算器发送的一系列的 ICMP Echo 请求讯息（在 Windows 计算器的情况下）或 UDP 区段（在 Unix 的情况下）以及由中间路由器发送到计算器的 ICMP TTL 超出的讯息。在下面的问题中，我们假设您使用的是 Windows 机器；对于 Unix 机器的相应问题应该是清楚的。只要有可能，在回答下面的问题时，您应该提交用于回答问题的跟踪内的数据包的打印输出。当您提交作业时，请对输出进行注释，以便清楚地显示输出中您获得答案信息的位置（例如，对于我们的课程，我们要求学生用笔标记纸本答案，或者使用带注释的电子副本。若要打印数据包，请使用文件 - &gt;打印，选择仅选择数据包，选择数据包摘要行，然后选择回答本问题时所需的最小数据包的详细信息量。 选择计算器发送的第一个 ICMP Echo Request 消息，然后在 packet details window 中展开数据包的 Internet 协议部分。 您的计算器的 IP 地址是多少？ 192.168.1.102 在 IP header 中，上层协议字段的值是多少？ 上层协议是ICMP，根据 IPV4 头部协议号列表，ICMP 协议的值是 1 IP header 有多少 bytes？ IP datagram 的有效负载中有多少 bytes？ 说明如何确定 payload bytes 的数。 Total Length：84，Header Length： 20， 有效负载中总共有$84 - 20 = 64$ 此 IP 数据报是否已被分段(fragmented)？解释您如何确定数据报是否已被分段(fragmented)。 fragments offset 为 0，所以数据没有被分段 接下来，通过单击 Source 列标题，根据 IP 源地址对跟踪的数据包进行排序，一个小的向下箭头应出现在 Source 旁边，如果箭头指向上方请再次单击“Source column header”。选择计算器发送的第一个 ICMP Echo Request 消息，然后展开“details of selected packet header”窗口中的 Internet 协议部分。在“listing of captured packets”窗口中，您应该在第一个 ICMP 下面看到所有后续 ICMP 消息（可能还有计算器上运行的其他协议发送的其他散布数据包），使用向下箭头浏览计算器发送的 ICMP 消息。 在您的计算器发送的这一系列 ICMP 消息中，IP 数据报中的哪些字段一直有改变？ Identification, Time to live and Header checksum 哪些字段保持不变？ 哪个字段必须保持不变？ 哪些字段必须更改？ 为什么？ The fields that stay constant across the IP datagrams are: Version (since we are using IPv4 for all packets) header length (since these are ICMP packets) source IP (since we are sending from the same source) destination IP (since we are sending to the same dest) Differentiated Services (since all packets are ICMP they use the sameType of Service class) Upper Layer Protocol (since these are ICMP packets) The fields that must stay constant are: Version (since we are using IPv4 for all packets) header length (since these are ICMP packets) source IP (since we are sending from the same source) destination IP (since we are sending to the same dest) Differentiated Services (since all packets are ICMP they use the sameType of Service class) Upper Layer Protocol (since these are ICMP packets) The fields that must change are:* Identification(IP packets must have different ids) Time to live (traceroute increments each subsequent packet) Header checksum (since header changes, so must checksum) 描述您在 IP datagram 的 Identification field 中的值中所看到的 The pattern is that the IP header Identification fields increment with each ICMP Echo (ping) request. 这部分是不相同的，且是逐渐递增的，用来区分每个 IP 数据报和处理 IP 分片。 下一步（数据包仍按来源地址排序）查找最近的（第一跳）路由器发送到您的计算器的一系列 ICMP TTL 超出的回复讯息。 ID 字段和 TTL 字段的值是多少？ Identification: 42507 TTL: 224 对于最近（第一跳）路由器发送到您的计算器的所有 ICMP TTL 超出的回复，这些值是否保持不变？为什么？ The identification field changes for all the ICMP TTL-exceeded replies because the identification field is a unique value. When two or more IP datagrams have the same identification value, then it means that these IP datagrams are fragments of a single large IP datagram.The TTL field remains unchanged because the TTL for the first hop router is always the same. 所有ICMP TTL超出应答的标识字段都会更改，因为标识字段是唯一值。当两个或多个IP数据报具有相同的标识值时，则意味着这些IP数据报是单个大型IP数据报的片段。TTL字段保持不变，因为第一跳路由器的TTL始终相同 Fragmentation 单击“时间”列，再次按时间对数据包列表进行排序。 在将 pingplotter 中的数据包大小更改为 2000 后，查找计算机发送的第一个ICMP Echo Request 消息。该消息是否已碎片化为多个 IP 数据报？ [注意：如果你发现你的数据包没有被分割，你应该下载 zip 文件http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip 并提取 ip-ethereal\u0002-trace-1packet 跟踪。 如果您的计算机具有以太网接口，则数据包大小为2000 会导致碎片。] 是的 打印出碎片 IP 数据报的第一个片段。 IP 头中的哪些信息表明数据报已碎片化？ IP 头中的哪些信息表明这是第一个片段还是后一个片段？ 这个 IP 数据报有多长？ Flags ： 0x20， More Fragment Fragment Offset ：0 Data ： 1480 bytes， Header Length ： 20 bytes， Total Length ： 1480 + 20 = 1500 bytes 打印出碎片 IP 数据报的第二个片段。 IP 标头中的哪些信息表明这不是第一个数据报片段？ 是否还有更多的片段？ 你是如何知道的？ Fragment Offset： 1480 Flags：0x00 在第一个和第二个片段中，IP 标头中哪些字段发生了变化？ The IP header fields that changed between the fragments are: total length, flags, fragment offset, and checksum. 现在，在将 pingplotter 中的数据包大小更改为 3500 后，找到计算机发送的第一个ICMP Echo Request 消息。 从原始数据报创建了多少个片段？ After switching to 3500, there are 3 packets created from the original datagram.* 片段中 IP 标头中的哪些字段发生了变化？ The IP header fields that changed between all of the packets are: fragment offset, and checksum. Between the first two packets and the last packet, we see a change in total length, and also in the flags. The first two packets have a total length of 1500, with the more fragments bit set to 1, and the last packet has a total length of 540, with the more fragments bit set to 0. 在所有数据包之间更改的IP报头字段为：片段偏移量和校验和。在前两个数据包和最后一个数据包之间，我们看到总长度发生了变化，标志也发生了变化。前两个数据包的总长度为1500，More Fragments位设置为1，最后一个数据包的总长度为540，More Fragments位设置为0","categories":[],"tags":[{"name":"Network","slug":"Network","permalink":"http://www.misaka-9982.com/tags/Network/"},{"name":"Wireshark","slug":"Wireshark","permalink":"http://www.misaka-9982.com/tags/Wireshark/"}]},{"title":"Wireshark-Lab5 TCP","slug":"Wireshark-Lab5","date":"2022-03-04T09:40:23.000Z","updated":"2023-02-22T13:07:14.708Z","comments":true,"path":"2022/03/04/Wireshark-Lab5/","link":"","permalink":"http://www.misaka-9982.com/2022/03/04/Wireshark-Lab5/","excerpt":"","text":"Lab5:TCP 在本实验中，我们将详细研究著名的 TCP 协议的行为。 我们将通过从您的电脑向远程服务器传输一份 150KB 的文件（一份 Lewis Carrol 的“爱丽丝梦游仙境”文本），并分析 TCP 传输内容的发送和接收过程来实现。 我们将研究 TCP 对序列和确认号的使用，以提供可靠的数据传输；我们将看到 TCP 的拥塞控制算法 – 慢启动和拥塞避免 – 在过程中，我们将看看 TCP 的接收器发送流量控制的机制。 我们还将简要地观察 TCP 连线的设置，我们还会研究计算机和服务器之间 TCP 连线的性能（吞吐量和往返时间）。 在开始本实验之前，您应该先查看课本中的第 3.5 和 3.7 节。 1. Capturing a bulk TCP transfer from your computer to a remote server (捕获从计算机到远程服务器的批量 TCP 传输) 在开始我们对 TCP 的探索之前，我们需要使用 Wireshark 来获取文件从计算机到远程服务器的 TCP 传输的数据包内容。您可以通过访问一个网页，在网页上输入您计算机上⬀储的文件名称（包含 Alice in Wonderland 的 ASCII 文本），然后使用HTTP POST 方法将文件传输到 Web 服务器（见文中第 2.2.3 节）。我们使用POST 方法而不是 GET 方法，因为我们希望将大量数据从您的计算机传输到另一台计算机。当然，我们将在此期间运行 Wireshark 以获取从您的计算机发送和接收的 TCP 区段的内容。 执行以下步骤： 启动 Web 浏览器。 在 http://gaia.cs.umass.edu/wireshark-labs/alice.txt 查看Alice in Wonderland 的 ASCII 档案文件。 将此文件⬀储在计算机上的某个位置。 接下来去 http://gaia.cs.umass.edu/wireshark-labs/TCP-wireshark-file1.html. 你将会看到如下图的网页 使用此表单中的“Browse…”按钮在计算机上输入包含 Alice in Wonderland 的文件名(完整路径名)(或手动执行)。这个时候请不要按下“Upload alice.txt file”按钮。 启动 Wireshark 并开始数据包捕获 (Capture-&gt; Start)，然后在 Wireshark 数据包捕获选项视窗上按 OK (我们不需要在此处选择任何选项)(详细操作因Wireshark 版本略有不同)。 返回浏览器，按“Upload alice.txt file”按钮将文件上传到 gaia.cs.umass.edu服务器。文件上传后，浏览器窗口中会显示一条简短的祝贺消息。 停止 Wireshark 数据包捕获。 您的 Wireshark 视窗内容应该类似于下面显示的内容。 如果您无法在实际的网路上运行 Wireshark，则可以下载在作者的计算机上执行上述步骤时捕获的数据包跟踪文件。当您探索下面的问题时，即使您已经捕获了自己的传输内容并使用它来回答下面的问题，您也可能会发现这份下载的跟踪包很有参考价值。 2. A first look at the captured trace (跟蹤包的初步觀察) 在详细分析 TCP 连接的行为之前，让我们先概观看一下跟踪包的内容。 首先，在 Wireshark 视窗顶部的显示的过滤器指定窗口中输入“tcp”（小写，无引号，并且不要忘记在输入后按 enter 键！），过滤 Wireshark 视窗中显示的数据包。 您应该看到的是计算机和 gaia.cs.umass.edu 之间的一系列 TCP 和 HTTP 讯息。您应该看到包含 SYN 讯息的初始三次握手。您应该看到 HTTP POST 讯息。根据您使用的 Wireshark 的版本，您可能会看到从您的计算机向 gaia.cs.umass.edu 发送一系列“HTTP Continuation”讯息。 回想一下我们在早期的 HTTP Wireshark 实验室中的讨论，这不是 HTTP Continuation 消息 – 这是 Wireshark 指示有多个 TCP 区段用于承载单个 HTTP 讯息的方式。在 Wireshark 的最新版本中，您将在 Wireshark显示的 Info 列中看到“[重新组装的 PDU 的 TCP 段]”，以指示此 TCP 区段包含属于上层协议讯息的数据（在我们的示例中为，HTTP）。您还应该看到从gaia.cs.umass.edu 返回到您的计算机的 TCP ACK 区段。 利用下载的 http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip 档案，打开其中的 Wireshark 捕获的数据包文件 tcp-ethereal-trace-1 来回答以下问题（即下载跟踪包并打开 Wireshark 中的跟踪包；见附注 2）。在回答问题时，您应该提交用于回答问题的跟踪内的数据包的列印输出。 加上适当的注释以解释您的答案。 要印出数据包，请使用文件 - &gt;列印，选择仅选定数据包，选择数据包摘要行，然后选择回答问题所需的最小数据包详细信息量。 将文件传输到 gaia.cs.umass.edu 的客户端计算机（源）使用的 IP 地址和TCP 端口号是什么？ 要回答这个问题，最简单的方法是使用“所选数据包标头的详细信息”视窗，选择 HTTP 讯息并探索用于携带此 HTTP 讯息的TCP 数据包的详细信息（如果你不确定是哪一个 Wireshark 视窗。请参阅“Getting Started with Wireshark”实验中的图 2 ） 分析作者提供的抓包结果 作者 IP：192.168.1.102，TCP 发送端口 1161 gaia.cs.umass.edu 的 IP 地址是什么？ 在哪个端口号上发送和接收此连接的TCP 区段？ 接收 IP：128.119.245.12，TCP 接受端口 80 如果您能够连网并使用 Wireshark 创建自己的跟踪包，请回答以下问题： 客户端计算机（源）将文件传输到 gaia.cs.umass.edu 所使用的 IP 地址和TCP 端口号是多少？ 略 由于本实验是关于 TCP 而不是 HTTP，让我们更改 Wireshark 的“捕获数据包列表”视窗，以便显示有关包含 HTTP 讯息的 TCP 区段的信息，而不是 HTTP 讯息。 要让 Wireshark 执行此操作，请选择 Analyze-&gt; Enabled Protocols。 然后取消勾选 HTTP 框，并选择确定。 您现在应该看到一个 Wireshark 窗口，如下所示： 这就是我们正在寻找的 – 在您的计算机和 gaia.cs.umass.edu 之间发送的一系列 TCP区段。我们将使用您捕获的数据包跟踪（和/或 http://gaia.cs.umass.edu/wireshark\u0002-labs/wireshark-traces.zip 中的数据包跟踪 tcp-ethereal-trace-1：请参阅前面的脚注 ） 在本实验的其余部分研究 TCP 行为。 3. TCP Basics (TCP 基础) 回答下列关于 TCP 区段的问题： 用于在客户端计算机和 gaia.cs.umass.edu 之间启动 TCP 连接的 TCP SYN 区段的序列号是什么？ 将区段标识为 SYN 区段的区段有什么功能？ SYN相对序列号为 0， 绝对序列号为 232129012 根据三次握手，客户端应该发送 SYN 请求请求建立连接，我找到发送的第一个请求并且发现客户端（我的电脑）将 SYN 标志标 0 用来请求建立连接。$Sequence \\ number =232129012$ 这是个随机值，这一步也是三次握手的第一步 gaia.cs.umass.edu 发送给客户端计算机以回复 SYN 的 SYNACK 区段的序列号是多少？ SYNACK 区段中的 Acknowledgment 栏位的值是多少？Gaia.cs.umass.edu 是如何确定此 Acknowledgment 的数值的？ 在将区段标识为 SYNACK 区段的区段在连线中有什么功能？ SYN 为 0 $Acknowledgment \\ = 1\\ (232129013)$ $Acknowledgment$ 为 客户端的 $Sequence Number \\ (232129012) + 1$ 意思是服务器接收到我的连接请求并且发 SYN-ACK 确认，这是三次握手的第二步。 包含 HTTP POST 命令的 TCP 区段的序列号是多少？ 请注意，为了找到POST 命令，您需要深入了解 Wireshark 窗口底部的数据包内容⫿段，在其DATA 栏位中查找带有“POST”的区段。 $Seqence Number = 1$ Info 一栏中 [PSH, ACK] 里面的 PSH 即包含 HTTP POST 命令 其中http post相关信息包含在[Reassembled PDU in frame: 199] 将包含 HTTP POST 的 TCP 区段视为 TCP 连接中的第一个区段。在这个TCP 连线中前六个 TCP 区段的序列号是什么（包括包含 HTTP POST 的段）？ 每区段发送的时间是什么时候？ 收到的每个区段的 ACK 是什么时候？ 鉴于发送每个 TCP 区段的时间与收到确认的时间之间的差异，六个区段中每个区段的 RTT 值是多少？ 收到每个 ACK 后，EstimatedRTT 值（参见本节中的第 3.5.3 节，第 242 页）是什么？ 假设第一个 EstimatedRTT 的值等于第一个区段的测量 RTT，然后使用课本第 242 页的 EstimatedRTT 公式计算所有后续区段。（译注：中译本的页数可能不同） **注意：**Wireshark有一个很好的功能，允许您为发送的每个 TCP 区段绘制RTT。 在从客户端发送到gaia.cs.umass.edu服务器的“捕获的数据包列表”窗口中选择一个TCP段。 然后选择：Statistics-&gt; TCP Stream Graph-&gt; Round Trip Time Graph。 ACK时间在SEQ/ACK analysis字段中，其中frame后的数字为对应的 PSH 帧的回应 PSH No 序列号 发送时间 回应 No ACK时间 RTT EstimatedRTT 4 1 0.026477 6 0.053937000 0.027460000 0.02746 5 566 0.041737 9 0.077294000 0.035557000 0.028472125 7 2026 0.054026 12 0.124085000 0.070059000 0.033670484375 8 3486 0.054690 14 0.169118000 0.114428000 0.043765173828125 10 4946 0.077405 15 0.217299000 0.139894000 0.05578127709960937 11 6406 0.078157 16 0.267802000 0.189645000 0.07251424246215821 $EstimatedRTT = 0.875 * EstimatedRTT + 0.125 * SampleRTT$ EstimatedRTT after the receipt of the ACK of segment 1: $EstimatedRTT = RTT for Segment 1 = 0.02746 second$ EstimatedRTT after the receipt of the ACK of segment 2: $EstimatedRTT = 0.875 * 0.02746 + 0.125 * 0.035557 = 0.0285$ EstimatedRTT after the receipt of the ACK of segment 3: $EstimatedRTT = 0.875 * 0.0285 + 0.125 * 0.070059 = 0.0337$ EstimatedRTT after the receipt of the ACK of segment 4: $EstimatedRTT = 0.875 * 0.0337+ 0.125 * 0.11443 = 0.0438$ EstimatedRTT after the receipt of the ACK of segment 5: $EstimatedRTT = 0.875 * 0.0438 + 0.125 * 0.13989 = 0.0558$ EstimatedRTT after the receipt of the ACK of segment 6: $EstimatedRTT = 0.875 * 0.0558 + 0.125 * 0.18964 = 0.0725$ 前六个 TCP 区段的长度是多少？ Segment 1 sequence length: $566 - 1 = 565$ Segment 2 sequence length: $2026 - 566 = 1460$ Segment 3 sequence length: $3486 - 2026 = 1460$ Segment 4 sequence length: $4946 - 3486 = 1460$ Segment 5 sequence length: $6406 - 4946 = 1460$ Segment 6 sequence length: $7866 - 6406 = 1460$ 对于整个跟踪包，收到的最小可用缓冲区空间量是多少？ 缺少接收器缓冲区空间是否会限制发送方传送 TCP 区段？ The minimum amount of buffer space (receiver window) advertised at gaia.cs.umass.edu for the entire trace is 5840 bytes,which shows in the first acknowledgement from the server. This receiver window grows steadily until a maximum receiver buffer size of 62780 bytes. The sender is never throttled due to lacking of receiver buffer space by inspecting this trace. 在gaia.cs.umass.edu为整个跟踪通告的最小缓冲区空间量(接收器窗口)是5840字节，这显示在来自服务器的第一个确认中。该接收器窗口稳步增长，直到最大接收器缓冲器大小达到62780字节。通过检查此跟踪，发送器永远不会因为接收器缓冲区空间不足而受到抑制。 在跟踪文件中是否有重传的区段？ 为了回答这个问题，您检查了什么（在跟踪包中）？ There are no retransmitted segments in the trace file. We can verify this by checking the sequence numbers of the TCP segments in the trace file. In the Time\u0002Sequence-Graph (Stevens) of this trace, all sequence numbers from the source (192.168.1.102) to the destination (128.119.245.12) are increasing monotonically with respect to time. If there is a retransmitted segment, the sequence number of this retransmitted segment should be smaller than those of its neighboring segments. 跟踪文件中没有重新传输的段。我们可以通过检查跟踪文件中TCP数据段的序列号来验证这一点。在该轨迹的时间序列图(Stevens)中，从源(192.168.1.102)到目的地(128.119.245.12)的所有序列号都随着时间单调递增。如果存在重传数据段，则该重传数据段的序列号应小于其相邻数据段的序列号。 接收器通常在 ACK 中确认多少数据？ 您是否可以识别接收方每隔一个接收到的区段才发送确认的情况（参见本文第 250 页的表 3.2）。 The difference between the acknowledged sequence numbers of two consecutive ACKs indicates the data received by the server between these two ACKs. By inspecting the amount of acknowledged data by each ACK, there are cases where the receiver is ACKing every other segment. For example, segment of No. 80 acknowledged data with 2920 bytes = 1460*2 bytes. 两个连续ACK的确认序列号之间的差异表示服务器在这两个ACK之间接收的数据。通过检查每个ACK确认的数据量，可能会出现接收方每隔一个数据段进行ACK的情况。例如，第80号确认数据的段，2920字节=1460*2字节。 TCP 连接的吞吐量（每单位时间传输的⫿节数）是多少？ 解释你如何计算这个值。 Solution: The computation of TCP throughput largely depends on the selection of averaging time period. As a common throughput computation, in this question, we select the average time period as the whole connection time. Then, the average throughput for this TCP connection is computed as the ratio between the total amount data and the total transmission time. The total amount data transmitted can be computed by the difference between the sequence number of the first TCP segment (i.e. 1 byte for No. 4 segment) and the acknowledged sequence number of the last ACK (164091 bytes for No. 202 segment). Therefore, the total data are 164091 - 1 = 164090 bytes. The whole transmission time is the difference of the time instant of the first TCP segment (i.e., 0.026477 second for No.4 segment) and the time instant of the last ACK (i.e., 5.455830 second for No. 202 segment). Therefore, the total transmission time is 5.455830 - 0.026477 = 5.4294 seconds. Hence, the throughput for the TCP connection is computed as 164090/5.4294 = 30.222 KByte/sec. TCP吞吐量的计算在很大程度上取决于平均时间段的选择。作为一种常见的吞吐量计算，在本问题中，我们选择平均时间周期作为整个连接时间。然后，该TCP连接的平均吞吐量被计算为总数据量与总传输时间之间的比率。可以通过第一个TCP数据段的序列号(即，对于第4号数据段为1字节)和最后一个确认确认的序列号(对于第202号数据段，为164091字节)之间的差来计算发送的总数据量。因此，总数据为164091-1=164090字节。整个传输时间是第一个TCP报文段的时刻(即，对于4号报文段为0.026477秒)和最后一个确认的时刻(即，对于202号报文段为5.455830秒)的时间差。因此，总传输时间为5.455830-0.026477=5.4294秒。因此，tcp连接的吞吐量计算为164090/5.4294=30.222千字节/秒。 统计图结果： 4.TCP congestion control in action (TCP 壅塞控制) 现在让我们检查从客户端服务器的每单位时间发送的数据量。 而不是（繁琐地！）从 Wireshark 窗口中的原始数据计算这些数值，我们将使用 Wireshark 的TCP 图形工具 – 时序图（Stevens） - 来绘制数据。 在 Wireshark 的“捕获数据包列表”窗口中选择一个 TCP 区段。然后选择菜单：Statistics-&gt; TCP Stream Graph-&gt; Time-Sequence-Graph（Stevens）。您应该看到一个类似于下图的图，该图是根据 http://gaia.cs.umass.edu/wireshark\u0002-labs/wireshark-traces.zip 中的跟踪数据包 tcp-ethereal-trace-1 中捕获的资料所创建的。（见前面的附注）： 这里，每个点代表一个发送的 TCP 区段，绘制区段的序列号与发送的时间。 请注意，堆叠在一起的一组点表示发送方背靠背发送的一系列数据包。 根据在 http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip 中的数据跟踪包tcp-ethereal-trace-1 内容回答以下有关 TCP 区段的问题 使用时序图（Stevens）绘图工具查看从客户端发送到 gaia.cs.umass.edu 服务器的区段的序列号与时间关系图。您能否确定 TCP 的慢启动阶段的开始和结束位置，以及拥塞避免接管的位置？ 评论测量数据与我们在文本中研究的 TCP 的理想化行为的不同之处。 一开始是慢启动，后续应该没有拥塞的情况 根据你使用 Wireshark 所收集到的资料（将文件从计算机传输到gaia.cs.umass.edu 时的跟踪包信息），回答问题 13 中的两个问题。 略","categories":[],"tags":[{"name":"Network","slug":"Network","permalink":"http://www.misaka-9982.com/tags/Network/"},{"name":"Wireshark","slug":"Wireshark","permalink":"http://www.misaka-9982.com/tags/Wireshark/"}]},{"title":"Wireshark-Lab4 UDP","slug":"Wireshark-Lab4","date":"2022-03-04T05:52:42.000Z","updated":"2023-02-22T13:07:14.708Z","comments":true,"path":"2022/03/04/Wireshark-Lab4/","link":"","permalink":"http://www.misaka-9982.com/2022/03/04/Wireshark-Lab4/","excerpt":"","text":"Lab4:UDP 在本实验中，我们将快速了解 UDP 传输协议。 正如我们在本文第 3 章中所看到的，UDP 是一种简化的协议。 在进行本实验之前，您可能需要重新阅读课本中的第 3.3 节。 由于 UDP 简单易理解，您只需要一点花费时间就能做这个实验。我们默认认同您已经熟悉 Wireshark 的操作，因此我们不会提供详细的截图说明和操作步骤。 开始在 Wireshark 中捕获数据包，然后执行一些会导致主机发送和接收多个 UDP数据包的操作。 您也可以什么也不做，仅执行 wireshark 捕获以便获取其他程序发给您的 UDP 数据包。 有一种特殊情况：简单网络管理协议（SNMP - 请参阅课本中的第 5.7 节）在 UDP 内部发送 SNMP 消息，因此您可能会在跟踪中找到一些SNMP 消息（以及 UDP 数据包）。 停止数据包捕获后，设置数据包筛选器，以便 Wireshark 仅显示在主机上发送和接收的 UDP 数据包。 选择其中一个 UDP 数据包并在详细信息窗口中展开 UDP 字段。 如果您无法找到 UDP 数据包或无法在实时网络连接上运行 Wireshark，则可以下载包含某些 UDP 数据包的数据包跟踪。 如果可能的话建议您使用 wireshark 的文件-&gt;打印功能将您跟踪回答数据包最小详细结果打印出来，并且通过注释圈出。 从跟踪中选择一个 UDP 数据包。 从此数据包中，确定 UDP 标头中有多少字段。 （建议不要查看课本，直接根据您的数据包跟踪结果回答），并为这些字段命名。 4个字段 Source Port Destination Port Length Checksum 中括号部分不是字段 通过查询 Wireshark 的数据包内容字段中显示的信息，确定每个 UDP 报头字段的长度（以字节为单位）。 The UDP header consists of four fields each of 2 bytes in length: Source Port (UDP packets from a client use this to indicate the session on the local client that originated the packet.) Destination Port (UDP packets from a client use this to indicate the service required from the remote server. UDP length (The number of bytes comprising the combined UDP header information and payload data) UDP Checksum (A checksum to verify that the end to end data has not been corrupted by routers or bridges in the network or by the processing in an end system. The algorithm to compute the checksum is the Standard Internet Checksum algorithm. This allows the receiver to verify that it was the intended destination of the packet, because it covers the IP addresses, port numbers and protocol number, and it verifies that the packet is not truncated or padded, because it covers the size field. Therefore, this protects an application against receiving corrupted payload data in place of, or in addition to, the data that was sent. In the cases where this check is not required, the value of 0x0000 is placed in this field, in which case the data is not checked by the receiver. 由于UDP报头就4个部分，每部分2Byte=16Bit，因此每个UDP报头8Byte=64Bit。 长度字段中的值是指的是什么？（此问题您可以参考课本）。 使用捕获的UDP 数据包验证您的声明。 长度字段指报文长度，如上图1中，Length:144，为 $UDP\\ payload + UDP\\ header$ 的长度和，即 $144 = 136 + 2 \\times 4$ UDP 有效负载中可包含的最大字节数是多少？ （提示：这个问题的答案可以通过你对上述 2 的回答来确定） UDP header 中的 length 字段为2个 Byte 即 16 Bit，所以整个UDP的有效负载可包含的最大字节数为$2 ^{16} - 1 = 65535$，去除头部字段的 8 个Byte 则剩下 $65535 - 8 = 65527$ 最大可能的源端口号是多少？ （提示：见 4 中的提示） Source Port 和 Destination Port 的长度都为16 Bit 所以最大的端口号为 $2^{16} - 1 = 65535$ UDP 的协议号是什么？ 以十六进制和十进制表示法给出答案。 要回答这个问题，您需要查看包含此 UDP 段的 IP 数据报的 Protocol 字段（参见书中的图 4.13 和 IP 头字段的讨论）。 UDP的协议号 ： UDP(17) （十进制）， x11 （十六进制） 观察发送 UDP 数据包后接收响应的 UDP 数据包，这是对发送的 UDP 数据包的回复，请描述两个数据包中端口号之间的关系。（提示：对于响应UDP 目的地应该为发送 UDP 包的地址） 请求 响应 请求和响应的 Source Port 和 Destination Port 相互对应 ​","categories":[],"tags":[{"name":"Network","slug":"Network","permalink":"http://www.misaka-9982.com/tags/Network/"},{"name":"Wireshark","slug":"Wireshark","permalink":"http://www.misaka-9982.com/tags/Wireshark/"}]},{"title":"Wireshark-Lab3 DNS","slug":"Wireshark-Lab3","date":"2022-03-03T15:59:33.000Z","updated":"2023-02-22T13:07:14.708Z","comments":true,"path":"2022/03/03/Wireshark-Lab3/","link":"","permalink":"http://www.misaka-9982.com/2022/03/03/Wireshark-Lab3/","excerpt":"","text":"Lab3:DNS 如书中第2.5节所述，域名系统(DNS)将主机名转换为IP地址，在互联网基础架构中发挥关键作用。在本实验中，我们将仔细查看DNS在客户端的细节。回想一下，客户端在DNS中的角色相对简单——客户端向其本地DNS服务器发送请求，并接收一个响应。如书中的图2.21和2.22所示，由于DNS分层服务器之间相互通信，可以递归地或迭代地解析客户端的DNS查询请求，而大多数操作是不可见的。然而，从DNS客户端的角度来看，协议非常简 ——将查询指向为本地DNS服务器，并从该服务器接收到响应。 在开始本实验之前，您可能需要阅读书中的第2.5节来了解DNS。另外，您可能需要查看关于本地DNS服务器，DNS缓存，DNS记录和消息，以及DNS记录中的TYPE字段的资料。 1. nslookup 在本实验中，我们将大量使用nslookup工具，这个工具在现在的大多数Linux/Unix和Microsoft平台中都有。要在Linux/Unix中运行nslookup，您只需在命令行中键入nslookup命令即可。要在Windows中运行，请打开命令提示符并在命令行上运行nslookup。 在这是最基本的操作，nslookup工具允许主机查询任何指定的DNS服务器的DNS记录。DNS服务器可以是根DNS服务器，顶级域DNS服务器，权威DNS服务器或中间DNS服务器（有关这些术语的定义，请参阅书本）。要完成此任务，nslookup将DNS查询发送到指定的DNS服务器，然后接收DNS回复，并显示结果。 上面的屏幕截图显示了三个不同nslookup命令的结果（显示在Windows命令提示符中）。在此示例中，客户端主机位于布鲁克林理工大学校园，默认本地DNS服务器为dns-prime.poly.edu。运行nslookup时，如果没有指定DNS服务器，则nslookup会将查询发送到默认的DNS服务器（在这种情况下为dnsprime.poly.edu）。来看第一个命令： nslookup www.mit.edu 说这个命令是说，请告诉我主机 www.mit.edu 的IP地址。如屏幕截图所示，此命令的响应提供两条信息：（1）提供响应的DNS服务器的名称和IP地址；（2）响应本身，即 www.mit.edu 的主机名和IP地址。虽然响应来自理工大学的本地DNS服务器，但本地DNS服务器很可能会迭代地联系其他几个DNS服务器来获得结果，如书中第2.4节所述。 现在来看第二个命令： nslookup -type=NS mit.edu 在这个例子中，我们添加了选项&quot;-type=NS&quot;和域名&quot;mit.edu&quot;。这将使得nslookup将NS记录发送到默认的本地DNS服务器。换句话说，“请给我发送mit.edu的权威DNS的主机名” （当不使用-type选项时，nslookup使用默认值，即查询A类记录。）上述屏幕截图中，首先显示了提供响应的DNS服务器（这是默认本地DNS服务器）以及三个MIT域名服务器。这些服务器中的每一个确实都是麻省理工学院校园主机的权威DNS服务器。然而，nslookup也表明该响应是非权威的，这意味着这个响应来自某个服务器的缓存，而不是来自权威MIT DNS服务器。最后，响应结果还显示了麻省理工学院权威DNS服务器的IP地址。 （即使nslookup生成的NS类型查询没有明确要求IP地址，本地DNS服务器依然”免费“返回了这些信息，然后被nslookup显示出来。） 最后来看第三个命令： nslookup www.aiit.or.kr bitsy.mit.edu 在这个例子中，我们希望将查询请求发送到DNS服务器 bitsy.mit.edu ，而不是默认的DNS服务器（dns-prime.poly.edu）。因此，查询和响应事务直接发生在我们的主机和 bitsy.mit.edu 之间。在这个例子中，DNS服务器 bitsy.mit.edu 提供主机 www.aiit.or.kr 的IP地址，它是高级信息技术研究所（韩国）的Web服务器。 现在我们了解了一些示例，您现在可能想知道nslookup命令的一般语法。语法是： nslookup -option1 -option2 host-to-find dns-server 一般来说，nslookup可以不添加选项，或者添加一两个甚至更多选项。正如我们在上面的示例中看到的，dns-server也是可选的；如果这项没有提供，查询将发送到默认的本地DNS服务器。 现在我们提供了总览了nslookup，现在是你自己驾驭它的时候了。执行以下操作（并记下结果）： 运行nslookup以获取一个亚洲的Web服务器的IP地址。该服务器的IP地址是什么？ www.baidu.com IP地址为 182.61.200.6 123456Non-authoritative answer:www.baidu.com canonical name = www.a.shifen.com.Name: www.a.shifen.comAddress: 182.61.200.6Name: www.a.shifen.comAddress: 182.61.200.7 运行nslookup来确定一个欧洲的大学的权威DNS服务器。 12345678910111213nslookup -type=NS cam.ac.ukServer: Address: Non-authoritative answer:cam.ac.uk nameserver = auth0.dns.cam.ac.uk.cam.ac.uk nameserver = ns1.mythic-beasts.com.cam.ac.uk nameserver = dns0.eng.cam.ac.uk.cam.ac.uk nameserver = ns3.mythic-beasts.com.cam.ac.uk nameserver = dns0.cl.cam.ac.uk.cam.ac.uk nameserver = ns2.ic.ac.uk.Authoritative answers can be found from: 运行nslookup，使用问题2中一个已获得的DNS服务器，来查询Yahoo!邮箱的邮件服务器。它的IP地址是什么？ 不指定DNS服务器 ： 1234567891011$ nslookup mail.yahoo.com Server: Address: Non-authoritative answer:mail.yahoo.com canonical name = edge.gycpi.b.yahoodns.net.Name: edge.gycpi.b.yahoodns.netAddress: 69.147.88.7Name: edge.gycpi.b.yahoodns.netAddress: 69.147.88.8 指定DNS服务器：(似乎会因为GFW的原因导致失败) 12345nslookup mail.yahoo.com dns0.eng.cam.ac.ukServer: dns0.eng.cam.ac.ukAddress: 129.169.8.8#53** server can&#x27;t find mail.yahoo.com: REFUSED 2. ipconfig ipconfig（对于Windows）和ifconfig（对于Linux / Unix）是主机中最实用的程序，尤其是用于调试网络问题时。这里我们只讨论ipconfig，尽管Linux / Unix的ifconfig与其非常相似。 ipconfig可用于显示您当前的TCP/IP信息，包括您的地址，DNS服务器地址，适配器类型等。例如，您只需进入命令提示符，输入 ipconfig /all 所有关于您的主机信息都类似如下面的屏幕截图所显示。 ipconfig对于管理主机中存储的DNS信息也非常有用。在第2.5节中，我们了解到主机可以缓存最近获得的DNS记录。要查看这些缓存记录，在 C:\\&gt; 提示符后输入以下命令： ipconfig /displaydns 每个条目显示剩余的生存时间（TTL）（秒）。要清除缓存，请输入 ipconfig /flushdns 清除了所有条目并从hosts文件重新加载条目。 3. 使用Wireshark追踪DNS 现在，我们熟悉nslookup和ipconfig，我们准备好了一些正经的事情。首先让我们捕获一些由常规上网活动生成的DNS数据包。 使用ipconfig清空主机中的DNS缓存。 打开浏览器并清空浏览器缓存。 （若使用Internet Explorer，转到工具菜单并选择Internet选项；然后在常规选项卡中选择删除文件。） 打开Wireshark，然后在过滤器中输入“ip.addr==your_IP_address”，您可以先使用ipconfig获取你的IP地址。此过滤器将删除既从你主机不发出也不发往你主机的所有数据包。 在Wireshark中启动数据包捕获。 使用浏览器访问网页： http://www.ietf.org 停止数据包捕获。 如果您无法在你的网络连接上运行Wireshark，则可以下载一个捕获了数据包的文件，这个文件是本书作者在自己计算机上 按照上述步骤捕获的（原文注：Download the zip file http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip and extract the file dnsethereal-trace-1. The traces in this zip file were collected by Wireshark running on one of the author’s computers, while performing the steps indicated in the Wireshark lab. Once you have downloaded the trace, you can load it into Wireshark and view the trace using the File pull down menu, choosing Open, and then selecting the dns-ethereal-trace-1 trace file. ）。回答下列问题。您应该在解答中尽可能展示你使用了哪些你捕获到的数据包，并注释出来（原文注：What do we mean by “annotate”? If you hand in a paper copy, please highlight where in the printout you’ve found the answer and add some text (preferably with a colored pen) noting what you found in what you ‘ve highlight. If you hand in an electronic copy, it would be great if you could also highlight and annotate. ）。若要打印数据包，请使用文件-&gt;打印，只勾选仅选中分组，和概要行，并选中你所需要用于解答问题的数据包。 找到DNS查询和响应消息。它们是否通过UDP或TCP发送？ 通过 UDP 发送 DNS查询消息的目标端口是什么？ DNS响应消息的源端口是什么？ 查询消息：Destination Port ：53， Source Port ： 52975 响应消息：Source Port ：53， Destination Port：52975 DNS查询消息发送到哪个IP地址？使用ipconfig来确定本地DNS服务器的IP地址。这两个IP地址是否相同？ 发送到 172.20.10.1 在MacBook中输入cat /etc/resolv.conf查询DNS服务器地址，nameserver即为DNS 的IP地址 检查DNS查询消息。DNS查询是什么&quot;Type&quot;的？查询消息是否包含任何&quot;answers&quot;？ 查询 Type : A，没有 answers 检查DNS响应消息。提供了多少个&quot;answers&quot;？这些答案具体包含什么？ 1个 “answer”的个数不是固定的，1个以上，主要包括查询的主机别名消息，主机地址消息等。 考虑从您主机发送的后续TCP SYN数据包。 SYN数据包的目的IP地址是否与DNS响应消息中提供的任何IP地址相对应？ 没有找到DNS响应消息中IP地址对应的TCP SYN 数据包 这个网页包含一些图片。在获取每个图片前，您的主机是否都发出了新的DNS查询？ 并不是，只是部分重新发出了新的DNS查询 现在让我们玩玩nslookup（原文注：If you are unable to run Wireshark and capture a trace file, use the trace file dns-ethereal-trace-2 in the zip file http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip ）。 启动数据包捕获。 使用nslookup查询 www.mit.edu 停止数据包捕获。 你应该得到类似下图所示的捕获结果： 我们从上面的屏幕截图看到，nslookup实际上发送了三个DNS查询，并收到了三个DNS响应。只考虑本次实验相关结果，在回答以下问题时，请忽略前两组查询/响应，因为nslookup的一些特殊性，这些查询通常不是由标准网络应用程序生成的。您应该专注于最后一个查询和响应消息。 DNS查询消息的目标端口是什么？ DNS响应消息的源端口是什么？ 都是53 DNS查询消息的目标IP地址是什么？这是你的默认本地DNS服务器的IP地址吗？ 是本地DNS服务器的IP地址 检查DNS查询消息。DNS查询是什么&quot;Type&quot;的？查询消息是否包含任何&quot;answers&quot;？ Type ： A， 不包含 检查DNS响应消息。提供了多少个&quot;answers&quot;？这些答案包含什么？ 3个， 提供屏幕截图。 现在重复上一个实验，但换成以下命令： nslookup -type=NS mit.edu 回答下列问题： DNS查询消息发送到的IP地址是什么？这是您的默认本地DNS服务器的IP地址吗？ 是的 检查DNS查询消息。DNS查询是什么&quot;Type&quot;的？查询消息是否包含任何&quot;answers&quot;？ Type： NS，不包含 answers 检查DNS响应消息。响应消息提供的MIT域名服务器是什么？此响应消息还提供了MIT域名服务器的IP地址吗？ 域名服务器： 不包含域名服务器的IP地址 提供屏幕截图。 现在重复上一个实验，但换成以下命令： nslookup www.aiit.or.kr bitsy.mit.edu 回答下列问题： 12$ nslookup www.aiit.or.kr bitsy.mit.edu;; connection timed out; no servers could be reached 指令超时，使用作者提供的抓包结果进行分析： 1http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip 对应文件： 1dns-ethereal-trace-4 DNS查询消息发送到的IP地址是什么？这是您的默认本地DNS服务器的IP地址吗？如果不是，这个IP地址是什么？ Destination IP: 18.72.0.3 检查DNS查询消息。DNS查询是什么&quot;Type&quot;的？查询消息是否包含任何&quot;answers&quot;？ Type：A， 不包含 answers 检查DNS响应消息。提供了多少个&quot;answers&quot;？这些答案包含什么？ 1个answers，包含主机的ip地址，类型等等。 提供屏幕截图。","categories":[],"tags":[{"name":"Network","slug":"Network","permalink":"http://www.misaka-9982.com/tags/Network/"},{"name":"Wireshark","slug":"Wireshark","permalink":"http://www.misaka-9982.com/tags/Wireshark/"}]},{"title":"Wireshark-Lab2 HTTP","slug":"Wireshark-Lab2","date":"2022-03-02T08:31:28.000Z","updated":"2023-02-22T13:07:14.708Z","comments":true,"path":"2022/03/02/Wireshark-Lab2/","link":"","permalink":"http://www.misaka-9982.com/2022/03/02/Wireshark-Lab2/","excerpt":"","text":"Lab2:HTTP 在介Wireshark实验-入门里，我们已经初步使用了Wireshark包嗅探器，我们现在可以操作Wireshark来查看网络协议。在这个实验中，我们会探索HTTP协议的几个方面：基本的GET/response交互，HTTP消息格式，检索大型HTML文件，检索具有嵌入对象的HTML文件，HTTP认证和安全性。在开始这些实验之前，您可能想查看书中第2.2节。 1.基本HTTP GET/response交互 我们开始探索HTTP，方法是下载一个非常简单的HTML文件 非常短，并且不包含嵌入的对象。执行以下操作： 启动您的浏览器。 启动Wireshark数据包嗅探器，如Wireshark实验-入门所述（还没开始数据包捕获）。在display-filter-specification窗口中输入“http”（只是字母，不含引号标记），这样就在稍后的分组列表窗口中只捕获HTTP消息。（我们只对HTTP协议感兴趣，不想看到其他所有的混乱的数据包）。 稍等一会儿（我们将会明白为什么不久），然后开始Wireshark数据包捕获。 在浏览器中输入以下内容 http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file1.html 您的浏览器应显示非常简单的单行HTML文件。 停止Wireshark数据包捕获。 你的Wireshark窗口应该类似于图1所示的窗口。如果你无法连接网络并运行Wireshark，您可以根据后面的步骤下载已捕获的数据包： 下载zip文件 http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip 解压缩文件 http-ethereal-trace-1。这个zip文件中的数据是由本书作者之一使用Wireshark在作者电脑上收集的，并且是按照Wireshark实验中的步骤做的。 如果你下载了数据文件，你可以将其加载到Wireshark中，并使用文件菜单选择打开并查看数据，然后选择http-ethereal-trace-1文件。 结果显示应与图1类似。（在不同的操作系统上，或不同的Wireshark版本上，Wireshark的界面会不同）。 图1：Wireshark显示 http://gaia.cs.umass.edu/wireshark-labs/HTTPwireshark-file1.html 已被您的浏览器打开 图1中的示例在分组列表窗口中显示了两个被捕获的HTTP消息：GET消息（从您的浏览器发送到gaia.cs.umass.edu 的web服务器）和从服务器到浏览器的响应消息。分组内容窗口显示所选消息的详细信息（在这种情况下为HTTP OK消息，其在分组列表窗口中高亮显示）。回想一下，因为HTTP消息被装载在TCP报文段内，该报文段是在IP分组封装吗，进而在以太网帧，和帧中封装，所以界面中显示了帧，以太网，IP，TCP分组信息以及HTTP报文信息。我们想最小化非HTTP数据的显示（我们这里只对HTTP感兴趣，这些其他协议将在以后的实验中研究），所以确保帧，以太网，IP和TCP行的信息被隐藏，注意左边有一个加号或一个向右的三角形（这意味着有信息被隐藏），而HTTP行具有减号或向下三角形（表示显示有关HTTP消息的所有信息）。 （注意：您应该忽略与favicon.ico相关的任何HTTP GET和response。 如果你看到一个关于这个文件的引用，这是你的浏览器自动询问服务器是否有一个图标文件应显示在浏览器的URL旁边。 我们会忽略这个引起麻烦的引用。） 通过查看HTTP GET和响应消息中的信息，回答以下问题。 在回答以下问题时，您应该打印出GET和响应消息（请参阅Wireshark-入门实验以获取信息），并指出您在消息中的哪个具体位置找到了回答以下问题的信息。 当您上交作业时，请注明输出，显示您在哪些地方表示了您的答案（例如，对于我们的课程，我们要求学生用笔标记纸质副本，或用彩色字体在电子副本的中注释文本）。 您的浏览器是否运行HTTP版本1.0或1.1？服务器运行什么版本的HTTP？ 浏览器和服务器的HTTP版本都是1.1。 您的浏览器会从接服务器接受哪种语言（如果有的话）？ en-US, zh-CN 您的计算机的IP地址是什么？ gaia.cs.umass.edu服务器地址呢？ 本机：192… gaia.cs.umass.edu服务器地址：128.119.245.12 服务器返回到浏览器的状态代码是什么？ Expert Info (Chat/Sequence): HTTP/1.1 200 OK\\r\\n 服务器上HTML文件的最近一次修改是什么时候？ Thu, 03 Mar 2022 06:59:01 GMT 服务器返回多少字节的内容到您的浏览器？ 128 通过检查数据包内容窗口中的原始数据，你是否看到有协议头在数据包列表窗口中未显示？ 如果是，请举一个例子。 TCP, DNS, SSL 在您对上述问题5的回答中，您可能会惊讶地发现您刚才检索的文档在下载文档之前最近一次修改是一分钟前。 那是因为（对于这个特定文件），gaia.cs.umass.edu服务器将文件的最后修改时间设置为当前时间，并且每分钟执行一次。 因此，如果您在两次访问之间等待一分钟，则该文件看起来已被修改，因此您的浏览器将下载文档的“新”副本。 2.HTTP条件Get/response交互 回顾书的第2.2.5节，大多数Web浏览器使用对象缓存，从而在检索HTTP对象时执行条件GET。执行以下步骤之前，请确保浏览器的缓存为空。（要在Firefox下执行此操作，请选择“工具” - &gt; “清除最近历史记录”，然后检查缓存框，对于Internet Explorer，选择“工具” - &gt;“Internet选项” - &gt;“删除文件”；这些操作将从浏览器缓存中删除缓存文件。 现在按下列步骤操作： 启动您的浏览器，并确保您的浏览器的缓存被清除，如上所述。 启动Wireshark数据包嗅探器。 在浏览器中输入以下URL http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file2.html 您的浏览器应显示一个非常简单的五行HTML文件。 再次快速地将相同的URL输入到浏览器中（或者只需在浏览器中点击刷新按钮）。 停止Wireshark数据包捕获，并在display-filter-specification窗口中输入“http”，以便只捕获HTTP消息，并在数据包列表窗口中显示。 （注意：如果无法连接网络并运行Wireshark，则可以使用http-ethereal-trace-2数据包跟踪来回答以下问题；请参见上文注释。） 回答下列问题： 检查第一个从您浏览器到服务器的HTTP GET请求的内容。您在HTTP GET中看到了“IF-MODIFIED-SINCE”行吗？ 没有“IF-MODIFIED-SINCE” 检查服务器响应的内容。服务器是否显式返回文件的内容？ 你是怎么知道的？ 显式返回文件的内容，因为返回了如下内容： 现在，检查第二个HTTP GET请求的内容。 您在HTTP GET中看到了“IF-MODIFIED-SINCE:”行吗？ 如果是，“IF-MODIFIED-SINCE:”头后面包含哪些信息？ 是 针对第二个HTTP GET，从服务器响应的HTTP状态码和短语是什么？服务器是否明确地返回文件的内容？请解释。 HTTP/1.1 304 Not Modified\\r\\n 没有直接返回文件内容，因为不包含Line-based text data。 3.检索长文件 在我们到目前为止的例子中，检索的文档是简短的HTML文件。 接下来我们来看看当我们下载一个长的HTML文件时会发生什么。 按以下步骤操作： 启动您的浏览器，并确保您的浏览器缓存被清除，如上所述。 启动Wireshark数据包嗅探器 在您的浏览器中输入以下URL http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file3.html 您的浏览器应显示相当冗长的美国权利法案。 停止Wireshark数据包捕获，并在display-filter-specification窗口中输入“http”，以便只显示捕获的HTTP消息。 （注意：如果无法连接网络并运行Wireshark，则可以使用http-ethereal-trace-3数据包跟踪来回答以下问题；请参见上文注释。） 在分组列表窗口中，您应该看到您的HTTP GET消息，然后是对您的HTTP GET请求的多个分组的TCP响应。这个多分组响应值得进行一点解释。回顾第2.2节（见文中的图2.9），HTTP响应消息由状态行组成，后跟标题行，后跟一个空行，后跟实体主体。在我们的HTTP GET这种情况下，响应中的实体主体是整个请求的HTML文件。在我们的例子中，HTML文件相当长，4500字节太大，一个TCP数据包不能容纳。因此，单个HTTP响应消息由TCP分成几个部分，每个部分包含在单独的TCP报文段中（参见书中的图1.24）。在Wireshark的最新版本中，Wireshark将每个TCP报文段指定为独立的数据包，并且单个HTTP响应在多个TCP数据包之间分段的事实由Wireshark显示的Info列中的“重组PDU的TCP段”指示。 Wireshark的早期版本使用“继续”短语表示HTTP消息的整个内容被多个TCP段打断。我们在这里强调，HTTP中没有“继续”消息！ 回答下列问题： 您的浏览器发送多少HTTP GET请求消息？哪个数据包包含了美国权利法案的消息？ 一个HTTP GET请求，第91个数据包。 哪个数据包包含响应HTTP GET请求的状态码和短语？ 第91个数据包 响应中的状态码和短语是什么？ 200 OK 需要多少包含数据的TCP段来执行单个HTTP响应和权利法案文本？ 4个 4.具有嵌入对象的HTML文档 现在我们已经看到Wireshark如何显示捕获的大型HTML文件的数据包流量，我们可以看看当浏览器使用嵌入的对象下载文件时，会发生什么，即包含其他对象的文件（在下面的例子中是图像文件） 的服务器。 执行以下操作： 启动您的浏览器。 启动Wireshark数据包嗅探器。 在浏览器中输入以下URL http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file4.html 您的浏览器应显示包含两个图像的短HTML文件。这两个图像在基本HTML文件中被引用。也就是说，图像本身不包含在HTML文件中；相反，图像的URL包含在已下载的HTML文件中。如书中所述，您的浏览器将不得不从指定的网站中检索这些图标。我们的出版社的图标是从 www.aw-bc.com 网站检索的。而我们第5版（我们最喜欢的封面之一）的封面图像存储在manic.cs.umass.edu服务器。 停止Wireshark数据包捕获，并在display-filter-specification窗口中输入“http”，以便只显示捕获的HTTP消息。 （注意：如果无法连接网络并运行Wireshark，则可以使用http-ethereal-trace-4数据包跟踪来回答以下问题；请参见上文注释。） 回答下列问题： 您的浏览器发送了几个HTTP GET请求消息？ 这些GET请求发送到哪个IP地址？ 3个 128.119.245.12（原始网页，http://gaia.cs.umass.edu/wireshark-labs/HTTP-wireshark-file4.html） 128.119.245.12（图1，http://gaia.cs.umass.edu/pearson.png） 178.79.137.164（图2，http://kurose.cslash.net/8E_cover_small.jpg） 浏览器从两个网站串行还是并行下载了两张图片？请说明。 串行，两个数据包的到达时间不一样 5.HTTP认证 最后，我们尝试访问受密码保护的网站，并检查网站的HTTP消息交换的序列。URL http://gaia.cs.umass.edu/wireshark-labs/protected_pages/HTTP-wireshark-file5.html 是受密码保护的。用户名是“wireshark-students”（不包含引号），密码是“network”（再次不包含引号）。所以让我们访问这个“安全的”受密码保护的网站。执行以下操作： 请确保浏览器的缓存被清除，如上所述，然后关闭你的浏览器，再然后启动浏览器 启动Wireshark数据包嗅探器。 在浏览器中输入以下URL http://gaia.cs.umass.edu/wireshark-labs/protected_pages/HTTP-wiresharkfile5.html 在弹出框中键入所请求的用户名和密码。 停止Wireshark数据包捕获，并在display-filter-specification窗口中输入“http”，以便只显示捕获的HTTP消息。 （注意：如果无法连接网络并运行Wireshark，则可以使用http-ethereal-trace-5数据包跟踪来回答以下问题；请参见上文注释。） 现在来看看Wireshark输出。 您可能需要首先阅读HTTP身份验证相关信息，方法是在 http://frontier.userland.com/stories/storyReader$2159 上查看“HTTP Access Authentication Framework ”上的易读材料。 回答下列问题： 对于您的浏览器的初始HTTP GET消息，服务器响应（状态码和短语）是什么响应？ 401 Unauthorized 当您的浏览器第二次发送HTTP GET消息时，HTTP GET消息中包含哪些新字段？ 第一次发送： 第二次发送： 多了Cache-Control，Authorization两个字段。 您输入的用户名（wireshark-students）和密码（network）按照客户端HTTP GET消息中请求头的“Authorization: Basic ”的字符串（d2lyZXNoYXJrLXN0dWRlbnRzOm5ldHdvcms=）编码。虽然您的用户名和密码可能加密，但它们只是以一种称为Base64格式的格式进行编码。用户名和密码并没有加密！要确认这些，请访问 http://www.motobit.com/util/base64-decoder-encoder.asp 并输入base64编码的字符串d2lyZXNoYXJrLXN0dWRlbnRz 并进行解码。瞧！您已从Base64编码转换为ASCII编码，因此应该看到您的用户名！要查看密码，请输入字符串Om5ldHdvcms=的剩余部分，然后按解码。因为任何人都可以下载像Wireshark这样的工具，而且可以通过网络适配器嗅探数据包（不仅仅是自己的），任何人都可以从Base64转换为ASCII（你刚刚就这么做了！），所以你应该很清楚，WWW网站上的简单密码并不安全，除非采取其他措施。 不要害怕！ 正如我们将在第8章中看到的，有一些方法可以使WWW访问更加安全。然而，我们显然需要一些超出基本HTTP认证框架的知识！","categories":[],"tags":[{"name":"Network","slug":"Network","permalink":"http://www.misaka-9982.com/tags/Network/"},{"name":"Wireshark","slug":"Wireshark","permalink":"http://www.misaka-9982.com/tags/Wireshark/"}]},{"title":"Wireshark-Lab1 Getting Started","slug":"Wireshark-Lab1","date":"2022-03-02T05:32:26.000Z","updated":"2023-02-22T13:07:14.708Z","comments":true,"path":"2022/03/02/Wireshark-Lab1/","link":"","permalink":"http://www.misaka-9982.com/2022/03/02/Wireshark-Lab1/","excerpt":"","text":"Lab1:Getting Started 加深对网络协议的理解通常可以通过观察协议的运行和不断调试协议来大大加深，具体而言，就是观察两个协议实体之间交换的报文序列，深入了解协议操作的细节，执行某些动作，然后观察这些动作产生的结果。这可以在仿真环境中或在诸如因特网的真实网络环境中完成。您将在本课程中进行这些Wireshark实验，您将使用自己的电脑在不同的场景下运行各种网络应用程序（如果您无法h获得计算机，或无法安装/运行Wireshark，您可以借用朋友的电脑）。您将观察您的计算机中网络协议与Internet其他主机的协议实体进行交换消息的动作。因此，您和您的计算机将是这些“实时”实验室的一部分。你会通过动手实践观察到并学习到许多。 在第一个Wireshark实验中，你会熟悉Wireshark，并做一些简单的抓包和观察。 ​ 用于观察执行协议实体之间交换的消息的基本工具称为分组嗅探器(packet sniffer)。顾名思义，分组嗅探器捕获（“嗅探”）从计算机发送/接收的消息; 它还将存储并显示这些捕获的消息中各种协议字段的内容。分组嗅探器本身是被动的。它只是观察有计算机上运行的应用程序和协议发送和接收的消息，但本身不会发送分组。类似地，接收的分组也不会直接到达分组嗅探器。相反，分组嗅探器接收一份从您的机器中的应用程序和协议发送/接收的分组的副本。 ​ 图1显示了分组嗅探器的结构。在图1的右侧通常是在您计算机上运行的协议（在这种情况下为Internet协议）和应用程序（如Web浏览器或ftp客户端）。图1中虚线框中显示的分组嗅探器是计算机中一种进阶的常规软件，并且包含两部分。分组捕获库接收从计算机发送或接收的每个链路层帧的副本。回顾书中第1.5节的讨论（图1-24），较高层协议（如HTTP，FTP，TCP，UDP，DNS或IP）交换的消息最终将被封装在通过物理介质传输的链路层帧中，例如以太网电缆。在图1中，假设的物理介质是以太网，因此所有上层协议最终被封装在以太网帧中。捕获所有链路层帧可以让您从计算机中获得所有协议和应用程序发送/接收的消息。 图1 - 分组嗅探器结构 ​ 分组嗅探器的第二个组件是分组分析器(packet analyzer)，显示协议消息中所有字段的内容。为了做到这一点，分组分析器必须“理解”协议交换的所有消息的结构。 例如，假设我们有兴趣在图1中的HTTP协议交换的消息中显示各种字段。分组分析器了解以太网帧的格式，因此可以识别以太网帧中的IP数据报。它还可以理解IP数据报格式，从而可以提取IP数据报中的TCP段。 最后，它理解TCP段结构，因此可以提取TCP段中包含的HTTP消息。 最终，它还理解HTTP协议，因此，就可以知道HTTP消息的第一部分将包含字符串“GET”，“POST”或“HEAD”，如书中的图2-8所示。 ​ 我们将使用Wireshark分组嗅探器( http://www.wireshark.org/ )进行这些实验，从而显示在协议栈不同级别的协议发送/接收的消息的内容。(从技术上讲，Wireshark是一个使用计算机中的分组捕获库的分组分析器)。 Wireshark是一种免费的网络协议分析器，可在Windows，Mac和Linux / Unix计算机上运行。 它是我们实验室的理想分组分析器 - 因为它稳定，具有庞大的用户基础和文档支持，包括用户指南( http://www.wireshark.org/docs/wsug_html_chunked/ )，手册( http://www.wireshark.org/docs/man-pages/ )和常见问题细节( http://www.wireshark.org/faq.html )，丰富的功能，包括分析数百种协议，以及精心设计的用户界面。 它可以运行在使用以太网，串行(PPP和SLIP)，802.11无线局域网和许多其他链路层技术的计算机上(如果操作系统支持Wireshark这样做)。 获取Wireshark ​ 为了运行Wireshark，您需要一台支持Wireshark和libpcap或WinPCap分组捕获库的计算机。当您安装Wireshark时，如果您的操作系统中未安装libpcap软件，它将会自动安装。有关支持的操作系统和下载站点的列表，请访问http://www.wireshark.org/download.html 下载并安装Wireshark软件： 转到http://www.wireshark.org/download.html 下载并安装计算机的Wireshark安装包。 Wireshark FAQ有一些有用的提示和有趣的信息，尤其是您在安装或运行Wireshark时遇到问题的时候。 运行Wireshark 当您运行Wireshark程序时，您将看到一个类似下面的启动界面： 图2 - Wireshark初始界面 注意界面的左上角，你会看到一个“接口列表”。这是您的计算机上的网络接口列表。一旦你选择了一个接口，并将捕获这个接口上的所有数据包。在上面的例子中，有一个以太网接口（Gigabit network Connection ）和一个无线网络接口（“Microsoft” ）。 如果您点击其中一个接口启动分组捕获（即，Wireshark开始捕获从该接口发送的所有分组），将显示如下所示的界面，包含有关正在捕获的分组的信息。启动分组捕获后，可以使用“捕获”下拉菜单并选择“停止”来停止分组捕获。 图3-Wireshark抓包和分析时的用户界面 Wireshark界面有五个主要组件： **命令菜单(command menus)**是位于窗口顶部的标准下拉菜单。我们现在感兴趣的是文件和捕获菜单。文件菜单允许您保存捕获的分组数据或打开先前捕获的分组数据的文件，并退出Wireshark应用程序。捕获菜单允许您开始分组捕获。 **分组列表窗口(packet-listing window)**为每个捕获的分组显示一行摘要，包括分组编号（由Wireshark分配；任何协议首部并不包含该编号），分组的时间，源地址和目的地址，协议类型以及分组中包含的协议特定信息。可以通过单击列名称或者其他类似栏目对分组列表进行排序。协议类型字段列出了发送或接收该分组的最高级协议，即作为该分组的源或最终接收的协议。 **分组首部详细信息窗口(packet-header details window)**提供分组列表窗口中被选中（高亮显示）分组的详细信息。 （要在分组列表窗口中选择分组，请将光标放在分组列表窗口中的单行摘要中，然后单击鼠标左键。）这些细节包括有关以太网帧的信息（假定分组通过以太网接口发送/接收）和包含该分组的IP数据报。通过在分组详细信息窗口中单击以太网帧左侧的加减号框或IP数据报行，可以扩展或最小化显示的以太网和IP层详细信息。如果分组通过TCP或UDP传输，TCP或UDP的详细信息也将被显示，同样可以扩展或最小化。最后还提供了有关发送或接收此分组的最高级别协议的详细信息。 分组正文窗口(packet-contents window)以ASCII和十六进制格式显示捕获帧的全部内容。 Wireshark界面的顶部是分组显示过滤器(packet display filter field)，可以向其中输入协议名称或其他信息，以过滤分组列表窗口中显示的信息（分组首部窗口和分组内容窗口同理）。在下面的示例中，我们将使用分组显示过滤器字段来使Wireshark隐藏（不显示）除了与HTTP消息相关的分组。 用Wireshark做一次运行测试 了解任何新软件的最好方法是尝试一下！ 我们假设您的计算机通过有线以太网接口连接到Internet。 事实上，我建议您在具有有线以太网连接的计算机上执行此第一个实验室，而不仅仅是无线连接。 请执行以下操作 启动您喜欢的网页浏览器，显示您选择的主页。 启动Wireshark软件。 您最初将看到类似于图2所示的窗口.Wireshark尚未开始捕获分组。 要开始分组捕获，请选择“捕获”下拉菜单，然后选择“选项”。 这将显示“Wireshark：Capture Interfaces”窗口，如图4所示。 图4-Wireshark抓包接口窗口 您将看到计算机上的接口列表以及到目前为止在该接口上观察到的分组的计数。单击“开始”以开始分组捕获的接口（这个例子下，就是&quot;Gigabit network Connection&quot;）。分组捕获现在将开始 - Wireshark正在捕获从您的计算机发送/接收的所有分组！ 一旦开始分组捕获，将出现类似于图3所示的窗口。此窗口显示正在捕获的分组。通过选择捕获下拉菜单并选择停止，您可以停止分组捕获。但是现在不要停止分组捕获。我们首先捕获一些有趣的分组。为此，我们需要产生一些网络流量。让我们使用Web浏览器，这将使用我们将在课堂上详细研究过的HTTP协议来从网站下载内容。 当Wireshark正在运行时，输入URL：http://gaia.cs.umass.edu/wireshark-labs/INTRO-wireshark-file1.html ，并在浏览器中显示该页面。为了显示此页面，您的浏览器将通过gaia.cs.umass.edu与HTTP服务器链接，并与服务器交换HTTP消息，以便下载此页面，如书中第2.2节所述。包含这些HTTP消息（以及通过以太网的所有其他帧）的以太网帧将被Wireshark捕获。 在浏览器显示INTRO-wireshark-file1.html页面后（这是一行简单的祝贺消息），在Wireshark捕获窗口中点击停止按钮来停止Wireshark分组捕获。现在Wireshark主窗口看起来与图3相似。您现在有了计算机和其他网络实体之间交换的所有协议的实时分组数据！与gaia.cs.umass.edu 的Web服务器交换的HTTP消息应该出现在捕获分组的列表中。但是，这里还会显示许多其他类型的分组（例如，图3中的协议列中显示了许多不同的协议类型）。即使你唯一的动作仅仅是下载了一个网页，但显然还有许多其他协议在您的计算机上运行，这些是用户所看不见的。通过书中内容，我们将更多地了解这些协议！现在，你会亲眼看到许多事情即将发生！ 在主Wireshark窗口顶部的分组显示过滤器窗口中，键入“http”（不含引号，且小写 - Wireshark中的所有协议名称均为小写）。然后选择应用（在您输入“http”位置的右侧）。这样就可以只让HTTP消息显示在分组列表窗口中。 找到从您的计算机发送到gaia.cs.umass.edu HTTP服务器的HTTP GET消息。 （在Wireshark分组列表窗口中查找HTTP GET消息（见图3），其后的gaia.cs.umass.edu URL中显示“GET”）当您选择该HTTP GET消息，那么它的以太网帧，IP数据报，TCP段和HTTP消息首部将显示在分组首部窗口中，通过点击左侧的“+”和“ - ”或向右和向下箭头的分组详细信息窗口，将帧，以太网，IP协议和TCP协议的信息最小化，同时将HTTP协议的信息最大化，您的Wireshark显示屏现在应该如图5所示。（注意，特别是除了HTTP之外的所有协议的协议信息的最小量以及在分组报头窗口中用于HTTP的协议信息的最大量）。 图5-执行第9步之后的Wireshark窗口 退出Wireshark 恭喜！你现在已经完成了第一个实验。 需要提交的内容 第一个实验的目的主要是向你介绍Wireshark。以下问题将证明您已经能够使Wireshark启动并运行，并且已经探索了其中一些功能。根据您的Wireshark实验回答以下问题： 列出上述步骤7中出现在未过滤的分组列表窗口的协议列中的3种不同的协议。 TCP DNS TLSV1.2 从HTTP GET消息发送到HTTP OK回复需要多长时间？ (默认情况下，分组列表窗口中的时间列的值是自Wireshark开始捕获以来的时间(以秒为单位)。要想以日期格式显示时间，请选择Wireshark的“视图”下拉菜单，然后选择“时间显示格式”，然后选择“日期和时间”。) gaia.cs.umass.edu(也称为wwwnet.cs.umass.edu)的Internet地址是什么？您的计算机的Internet地址是什么？ gaia.cs.umass.edu：128.119.245.12 本机：192. … 打印问题2提到的两个HTTP消息(GET和OK)。要这样做，从Wireshark的“文件”菜单中选择“打印”，然后选择“仅选中分组”和“按当前显示”按钮，然后单击确定。 HTTP GET: HTTP OK ：","categories":[],"tags":[{"name":"Network","slug":"Network","permalink":"http://www.misaka-9982.com/tags/Network/"},{"name":"Wireshark","slug":"Wireshark","permalink":"http://www.misaka-9982.com/tags/Wireshark/"}]},{"title":"第五讲 动态规划","slug":"Acwing-算法基础课-动态规划","date":"2021-11-21T10:41:06.000Z","updated":"2023-02-22T13:07:14.708Z","comments":true,"path":"2021/11/21/Acwing-算法基础课-动态规划/","link":"","permalink":"http://www.misaka-9982.com/2021/11/21/Acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"AcWing 2. 01背包问题 状态表示 $f(i, j)$ 表示体积 j 的情况下 装下前 i 个物品的最优解 状态计算 $f(i , j) = max(f(i - 1, j), f(i - 1, j - v(i)) + w(i))$ $f(i - 1, j)$表示不选第 i 个物品的最大价值 $f(i - 1, j - v(i)) + w(i)$ 表示选择了第 i 个物品的最大价值，第 i 个物品占了$v(i)$的空间，价值为$w(i)$ 优化： 状态表示 $f(j)$ 表示容量 j 下的最优解 $backup(i)$数组在下一轮迭代开始之前将当前的$f(i)$ 数组备份起来 状态计算 每次计算下一轮的状态的时候，需要使用上一轮迭代更新的结果，使用一个新的数组备份上一轮的迭代结果可以使下一轮的计算不受自己这一轮计算结果的影响 正序计算： $f(j) = max(f(j), backup(j - v(i)) + w(i))$，其中 j 从0递增到背包最大容量 更简洁的有使用逆序迭代进行计算 ， 不需要使用另外的数组备份上一轮的状态： $f(j) = max(f(j), f(j - v(i)) + w(i))$, 其中 $j 从背包最大容量递减到v(i)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;using namespace std;const int N = 1010;int n, m;int v[N], w[N];int f[N];int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; v[i] &gt;&gt; w[i]; for(int i = 1; i &lt;= n; i ++) for(int j = m; j &gt;= v[i]; j --) f[j] = max(f[j], f[j - v[i]] + w[i]); cout &lt;&lt; f[m] &lt;&lt; endl; return 0;&#125;/*#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1010;int n, m;int v[N], w[N];int f[N][N];int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; v[i] &gt;&gt; w[i]; for(int i = 1; i &lt;= n; i ++) for(int j = 0; j &lt;= m; j ++) &#123; f[i][j] = f[i - 1][j]; if(j &gt;= v[i]) f[i][j] = max(f[i][j], f[i-1][j - v[i]] + w[i]); &#125; cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0;&#125;*/ AcWing 3. 完全背包问题 状态表示 $f(i, j)$ 表示容量 j 的条件下， 前 i 件物品的最优解 状态计算 $f(i, j) = max(f(i - 1, j - k v) + k w), k = 0, 1, 2 …(j &gt;= k v)$ 等价变形 $f(i,j) = max(f(i - 1, j), f(i - 1, j - v) + w, f(i - 1, j - 2 v) + 2 w, f(i - 1, j - 3 v) + 3 w, …)$ $f(i,j - v) = max( f(i - 1, j - v), f(i - 1, j - 2 v) + w, f(i - 1, j - 3 v) + 2 w, …)$ 得： $f(i, j) = max(f(i - 1, j), f(i, j - vi) + wi)$ 优化 $f(j) = max(f(j), f(j - vi)+ wi)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//最终版#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1010;int n, m;int v[N], w[N];int f[N];int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i]; for(int i = 1; i &lt;= n; i ++ ) for(int j = v[i]; j &lt;= m; j ++ ) f[j] = max(f[j], f[j - v[i]] + w[i]); cout &lt;&lt; f[m] &lt;&lt; endl; return 0;&#125;//优化版/*#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1010;int n, m;int v[N], w[N];int f[N][N];int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; v[i] &gt;&gt; w[i]; for(int i = 1; i &lt;= n; i ++) for(int j = 0; j &lt;= m; j ++) &#123; f[i][j] = f[i - 1][j]; if(j &gt;= v[i]) f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i]); &#125; cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0;&#125;*///朴素法/*#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1010;int n, m;int v[N], w[N];int f[N][N];int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; v[i] &gt;&gt; w[i]; for(int i = 1; i &lt;= n; i ++) for(int j = 0; j &lt;= m; j ++) for(int k = 0; k * v[i] &lt;= j; k ++) f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k); cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0;&#125;*/ AcWing 4. 多重背包问题 状态计算 $f(i, j) = max(f(i - 1, j), f(i - 1, j - k v) + k w)$ 优化 $f(j) = max(f(j), f(j - k v) + k w)$ 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 110;int n, m;int f[N];int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i ++ ) &#123; int v, w, s; cin &gt;&gt; v &gt;&gt; w &gt;&gt; s; for(int j = m; j &gt;= 0; j -- ) for(int k = 1; k &lt;= s &amp;&amp; k * v &lt;= j; k ++ ) f[j] = max(f[j], f[j - k * v] + k * w); &#125; cout &lt;&lt; f[m] &lt;&lt; endl; return 0;&#125; AcWing 5. 多重背包问题 II 状态计算 $f(i, j) = max(f(i - 1, j), f(i - 1, j - k v) + k w)$ 优化 $f(j) = max(f(j), f(j - k v) + k w)$ 接着优化 利用二进制的思想方法，将物品按照$1, 2, 4, 8, …$ 的等比序列也就是$0001, 0010, 0100,1000$这样的二进制序列对物品进行打包，多出来的物品独自打包成一份。 例如 ： $11 = 1 + 2 + 4 + 4$,那么利用$1, 2, 4, 4$ 这几个数字就可以表示$11$以内的所有数字 例如： $10 = 2 + 4 + 4$, $9 = 1 + 4 + 4$, $8 = 4 + 4$,…其他数字也是一样的道理 这样子每个打包完的物品组只要选择拿或者不拿，就能把这个==多重背包==问题抽象成==01背包==问题，使得时间复杂度降低 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 25000;int n, m;int v[N], w[N];int f[N];int main()&#123; cin &gt;&gt; n &gt;&gt; m; int cnt = 0; for(int i = 1; i &lt;= n; i ++) &#123; int a, b, s; cin &gt;&gt; a &gt;&gt; b &gt;&gt; s; int k = 1; while(k &lt;= s) &#123; cnt ++; v[cnt] = a * k; w[cnt] = b * k; s -= k; k *= 2; &#125; if(s &gt; 0) &#123; cnt ++; v[cnt] = a * s; w[cnt] = b * s; &#125; &#125; n = cnt; for(int i = 1; i &lt;= n; i ++ ) for(int j = m; j &gt;= v[i]; j -- ) f[j] = max(f[j], f[j - v[i]] + w[i]); cout &lt;&lt; f[m] &lt;&lt; endl; return 0;&#125; AcWing 9. 分组背包问题 状态表示 $f(i, j)$ 表示 体积 j 下前 i 组物品中的最优解 状态计算 $f(i, j) = max(f(i - 1, j), f(i - 1, j -v(i, k)) + w(i, k)))$ 等价变形 $f(j) = max(f(j), f(j - v(i, k) + w(i, k)))$ 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 110;int n, m;int v[N][N], w[N][N], s[N];int f[N];int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i ++) &#123; cin &gt;&gt; s[i]; for(int j = 0; j &lt; s[i]; j ++ ) cin &gt;&gt; v[i][j] &gt;&gt; w[i][j]; &#125; for(int i = 1; i &lt;= n; i ++ ) for(int j = m; j &gt;= 0; j -- ) for(int k = 0; k &lt; s[i]; k ++ ) if(v[i][k] &lt;= j) f[j] = max(f[j], f[j - v[i][k]] + w[i][k]); cout &lt;&lt; f[m] &lt;&lt; endl; return 0;&#125; AcWing 898. 数字三角形 可以自下而上选择下方两个数字的较大值加上自己本身的值，直到三角形最上方为所求的值 也可以自上而下进行操作 状态表示：$f[i][j]$表示走到坐标为$(i, j)$的点的最小路径和 状态转移方程： 自底向上 $f[i][j] = a[i][j] + min(f[i + 1][j], f[i + 1][j + 1])$ ,最底层的$f[i][j] = a[i][j]$,$res = f[0][0]$ 自顶向下$f[i][j] = a[i][j] + min(f[i - 1][j], f[i - 1][j - 1])$,初始状态$f[0][0] = a[0][0]$,$res = min(f[n]_{0,1, …, n})$ 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;const int N = 510, INF = 1e9;int n;int a[N][N];int f[N][N];int main()&#123; scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i ++ ) for(int j = 1; j &lt;= i; j ++ ) scanf(&quot;%d&quot;, &amp;a[i][j]); for(int i = 0; i &lt;= n; i ++) for(int j = 0; j &lt;= i + 1; j ++) f[i][j] = -INF; f[1][1] = a[1][1]; for(int i = 2; i &lt;= n; i ++ ) for(int j = 1; j &lt;= i; j ++) f[i][j] = max(f[i - 1][j - 1], f[i - 1][j]) + a[i][j]; int res = -INF; for(int i = 1; i &lt;= n; i ++ ) res = max(res, f[n][i]); printf(&quot;%d\\n&quot;, res); return 0;&#125; AcWing 895. 最长上升子序列 状态表示 $f[i]$ 表示以$a[i]$ 结尾最长的上升子序列的长度值 状态计算 $f[i] = max(f[i], f[j] + 1),if (a[j] &lt; a[i])$ $res = max(f[i])$ 例： 12a: 3 1 2 1 8 5 6f: 1 1 2 1 3 3 4 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;const int N = 1010;int n;int a[N], f[N];int main()&#123; scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]); for(int i = 1; i &lt;= n; i ++ ) &#123; f[i] = 1; for(int j = 1; j &lt; i; j ++ ) if(a[j] &lt; a[i]) f[i] = max(f[i], f[j] + 1); &#125; int res = 0; for(int i = 1; i &lt;= n; i ++ ) res = max(res, f[i]); printf(&quot;%d\\n&quot;, res); return 0;&#125; AcWing 896. 最长上升子序列 II 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;const int N = 100010;int n;int a[N];int st[N];int tt = 0;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]); st[tt] = a[0]; for(int i = 1 ; i &lt; n ; i++) &#123; //如果该元素大于栈顶元素,将该元素入栈 if(a[i] &gt; st[tt]) st[++ tt] = a[i]; //替换掉第一个大于或者等于这个数字的那个数 else &#123; int l = 0 , r = tt; while(l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if(st[mid] &gt;= a[i]) r = mid; else l = mid + 1; &#125; st[l] = a[i]; &#125; &#125; printf(&quot;%d&quot;,tt + 1); return 0;&#125; 这个栈 不用于记录最终的最长子序列，而是 以stk[i]结尾的子串长度最长为i 或者说 长度为i的递增子串中，末尾元素最小的是stk[i]。理解了这个问题以后就知道为什么新进来的元素要不就在末尾增加，要不就替代第一个大于等于它元素的位置。 这里的 替换 就蕴含了一个贪心的思想，对于同样长度的子串，我们当然希望它的末端越小越好，这样以后也有更多机会拓展。 AcWing 897. 最长公共子序列 状态表示 $f[i][j]$表示a的前i个字符中与b的前j个字符中最长的公共子序列的长度 状态计算 $a[i] ~!= ~b[j]$时 a[i] 不在最长公共子序列中， $f[i - 1][j]$ b[j] 不在最长公共子序列中， $f[i][j - 1]$ $a[i] ~==~ b[j]$时，$f[i - 1][j - 1] + 1$ 状态转移 $f[i][j] = max(f[i - 1][j], f[i][j - 1]);$ $f[i][j] = max(f[i][j], f[i - 1][j - 1] + (a[i] == b[j]));$ 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;const int N = 1010;int n, m;char a[N], b[N];int f[N][N];int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); scanf(&quot;%s%s&quot;, a + 1, b + 1); for(int i = 1; i &lt;= n; i ++ ) for(int j = 1; j &lt;= m; j ++ ) &#123; f[i][j] = max(f[i - 1][j], f[i][j - 1]); if(a[i] == b[j]) f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1); &#125; printf(&quot;%d\\n&quot;, f[n][m]); return 0;&#125; AcWing 902. 最短编辑距离 状态表示 $f[i][j]$表示将字符串a 的前i个字符 转换成字符串b前j个字符的最少操作次数 状态计算 删除操作 ： 删去a[i] 之后, a的前 i - 1个字符和 b 的前j个字符相同，$f[i -1][j] + 1$ 插入操作： 插入 b[j] 之前, a的前i 个字符和 b 的前 j - 1个字符相同， $f[i][j -1] + 1$ 修改操作： 将 a[i] 修改为 b[j] 前，a 的前 i - 1个字符 与 b的前 j - 1个字符相同 如果 a[i] == b[j], $f[i - 1][j - 1] + 0$， 否则a[i] != b[j], $f[i - 1][j - 1] + 1$ 状态转移方程 $f[i][j] = min(f[i - 1][j], f[i][j - 1]) + 1;$ $f[i][j] = min(f[i][j], f[i - 1][j - 1] + (a[i] != b[j]));$ 初始化 $f[0][i] = i;$ a的长度为0， 变成b的前i个字符需要添加i个字符 $f[i][0] = i;$ b的长度为0， 变成b的前i个字符需要删除i个字符 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;const int N = 1010;int n, m;char a[N], b[N];int f[N][N];int main()&#123; scanf(&quot;%d%s&quot;, &amp;n, a + 1); scanf(&quot;%d%s&quot;, &amp;m, b + 1); for( int i = 0; i &lt;= m; i ++ ) f[0][i] = i; for( int i = 0; i &lt;= n; i ++ ) f[i][0] = i; for( int i = 1; i &lt;= n; i ++ ) for( int j = 1; j &lt;= m; j ++ ) &#123; f[i][j] = min(f[i - 1][j], f[i][j - 1]) + 1; f[i][j] = min(f[i][j], f[i - 1][j - 1] + (a[i] != b[j])); &#125; printf(&quot;%d\\n&quot;, f[n][m]); return 0;&#125; AcWing 899. 编辑距离 思路同AcWing 902. 最短编辑距离 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;const int N = 15, M = 1010;int n, m;int f[N][N];char str[M][N];int edit_distance(char a[], char b[])&#123; int la = strlen(a + 1), lb = strlen(b + 1); for(int i = 0; i &lt;= lb; i ++ ) f[0][i] = i; for(int i = 0; i &lt;= la; i ++ ) f[i][0] = i; for(int i = 1; i &lt;= la; i ++ ) for(int j = 1; j &lt;= lb; j ++ ) &#123; f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1); f[i][j] = min(f[i][j], f[i - 1][j - 1] + (a[i] != b[j])); &#125; return f[la][lb];&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 0; i &lt; n; i ++ ) scanf(&quot;%s&quot;, str[i] + 1); while(m -- ) &#123; char s[N]; int limit; scanf(&quot;%s%d&quot;, s + 1, &amp;limit); int res = 0; for(int i = 0; i &lt; n; i ++ ) if(edit_distance(str[i], s) &lt;= limit) res ++; printf(&quot;%d\\n&quot;, res); &#125; return 0;&#125; AcWing 282. 石子合并 因为只能够让相邻的两堆石子进行合并，所以不是哈夫曼算法，不能使用贪心。 状态表示 $f[i][j]$表示将第i堆石子到第j堆石子合并成一堆石子的最小代价 状态计算 $f[i][j]=min(f[i][k] + f[k + 1][j] + s[j] - s[i - 1])$ $k ∈[i,j - 1]$ 边界条件 $f[i][i] = 0$， 同一堆石子不用合并 合并这些石子的代价为$f[1][n]$ 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;const int N = 310;int n;int s[N];int f[N][N];int main()&#123; scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;s[i]); //前缀和，便于计算 for(int i = 1; i &lt;= n; i ++ ) s[i] += s[i - 1]; for(int len = 2; len &lt;= n; len ++ ) //len 表示区间长度 for(int i = 1; i + len - 1 &lt;= n; i ++ ) // &#123; int l = i, r = i + len - 1; //l为起点， r为终点 f[l][r] = 0x3f3f3f3f; for(int k = l; k &lt; r; k ++ ) //k为分界点，用于状态计算 f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]); &#125; printf(&quot;%d\\n&quot;, f[1][n]); return 0;&#125; AcWing 900. 整数划分 可以将这个问题抽象成完全背包问题 把数字1，2，3，…，n分别看成n个物体的体积，每个物体可以不限次数使用，问恰好装满体积为n的背包共有几种方案 状态表示 $f(i, j)$ 表示 前 $i$ 个整数$(1, 2, 3, …, i)$恰好拼成整数 $j$的方案数量 状态计算 将各个集合中选择了0个i， 1个i，2个i，...的集合数值累加起来 $f(i, j) = f(i - 1, j) + f(i - 1, j - i) + f(i - 1, j - 2 i) + f(i - 1, j - 3 i) + …$ $f(i,j - i) = f(i - 1, j - i) + f(i - 1,j - 2 i) + f(i - 1, j - 3 i) + …$ 得：$f(i, j) = f(i, j - i) + f(i-1, j)$ 边界条件 $f[1][1] = 1$ 等价变形 $f(j) = f(j ) + f(j - i)$ 边界条件 $f[0] = 1$,容量为0，前 i 个数全都不选也是一种方案 1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;const int N = 1010, mod = 1e9 + 7;int n;int f[N][N];int main()&#123; cin &gt;&gt; n; f[1][1] = 1; for(int i = 2; i &lt;= n; i ++ ) for(int j = 1; j &lt;= i; j ++ ) f[i][j] = (f[i - 1][j - 1] + f[i - j][j]) % mod; int res = 0; for(int i = 1; i &lt;= n; i ++ ) res = (res + f[n][i]) % mod; cout &lt;&lt; res &lt;&lt; endl;&#125; 等价变形 123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;const int N = 1010, mod = 1e9 + 7;int n;int f[N];int main()&#123; cin &gt;&gt; n; f[0] = 1; for(int i = 1; i &lt;= n; i ++ ) for(int j = i; j &lt;= n; j ++ ) f[j] = (f[j] + f[j - i]) % mod; cout &lt;&lt; f[n] &lt;&lt; endl; return 0;&#125; AcWing 338. 计数问题 求$[a, ~b]$区间中的数字$k（k ∈[0, 9]）$出现的次数， 可以将这个问题转换成求数字$k$在区间$[0, a]$中出现的次数，记作$count(b)$， 和在区间$[0, b]$ 出现的次数，记作$count(b)$，$count(b) - count(a)$就是所求的数字出现次数 思想类似于前缀和 例： 给定数字 $n = abcdef$ 求数字 x 在第四位出现的次数 分类讨论 1 前三位数的大小范围在区间$[0, abc - 1]$中，第四位数为$x$，出现的次数为$(abc - 1 + 1) \\cdot 100$ 2 . 前三位数等于$abc$ 第四位数要为 $x$, 则应满足的条件为 $d &gt;= x$ ① $d &lt; x$ : 后两位，第四位为x的数字大于$abcdef$,无解 ② $d == x$:第四位为$x$ 的数字后两位数字取值范围为$[0, ef]$，个数为$ef + 1$ ③ $d~ &gt; ~x$: 第四位为$x$ 的数字后两位数字取值范围为$[0, 99]$， 个数为100 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;//截取num的 第 l ~ r 位数字int get(vector&lt;int&gt; num, int l, int r)&#123; int res = 0; for(int i = l; i &gt;= r; i -- ) res = res * 10 + num[i]; return res;&#125;//计算10的x次幂int power10(int x)&#123; int res = 1; while (x -- ) res *= 10; return res;&#125;int count(int n, int x)&#123; if (!n) return 0; //用数组存储数字 n ，便于取每个位上的数字 vector&lt;int&gt; num; while (n) &#123; num.push_back(n % 10); n /= 10; &#125; n = num.size(); int res = 0; //最高位不能为 0 ， x == 0 时，可以少循环一次 //计算 x 在每位数字上面出现的次数， 加起来就是总共的出现次数 for (int i = n - 1 - !x; i &gt;= 0; i -- ) &#123; // i == n - 1时，是数字的个位，不需要乘上10的幂次 if (i &lt; n - 1) &#123; //abc * power10(i) res += get(num, n - 1, i + 1) * power10(i); //计算0的出现次数时，数字首位不能为0 //即 当 x == 0 时， abc 不能为 000 if (!x) res -= power10(i); &#125; //d == x 的情况 if (num[i] == x) res += get(num, i - 1, 0) + 1; // d &gt; x 的情况 else if (num[i] &gt; x) res += power10(i); &#125; cout &lt;&lt; num[n - 1] &lt;&lt; &quot; &quot;; return res;&#125;int main()&#123; int a, b; while (cin &gt;&gt; a &gt;&gt; b , a) &#123; if (a &gt; b) swap(a, b); for (int i = 0; i &lt;= 9; i ++ ) cout &lt;&lt; count(b, i) - count(a - 1, i) &lt;&lt; &#x27; &#x27;; cout &lt;&lt; endl; &#125; return 0;&#125; AcWing 291. 蒙德里安的梦想 当横着摆放的小方块摆放完成之后，剩下的位置就只能摆放竖着的小方块了，所以棋盘上的小方块总的摆放方案数量等于横着摆放小方块的方案数量 状态表示 $f(i, j)$表示前$i - 1$列已经摆好，伸出到第 $i$ 列的状态是 $j$ 的所有方案， 其中 $j$ 是一个二进制数，用来表示哪一行的小方块是横着放的，位数与棋盘的行数一致，1表示哪几行小方块是横着伸出来的，0表示哪几行不是横着伸出来的。 状态计算 状态转移 第 $i$ 列是固定的，首先从第 $i - 2$列转移到 $i - 1$ 列开始，假设此时的状态为 $k$，它对应的方案数应该为 $f(i -1, k)$，即前 $i - 2$ 列都摆完了，且从第 $i - 2$ 列伸到第 $i - 1$ 列的状态为 $k$ 的所有方案数。 k 需要满足以下几点要求 ： 1.1. $k &amp;j == 0$，即 $k$ 和 $j$ 不是在同一行横着摆放的小方块，他们之间摆放的小方块不会发生冲突 1.2. 横着的小方块摆放完之后，剩余的空着的位置是留着给竖着摆放的小方块的，长度应该为偶数。 最终答案的表达式应该为$f[m][0]$，表示第$m - 1$列已经摆放完，且第$m$列没有伸出的小方块，其状态表示的值$k = 0$ 状态计算 $f[i][j] += f[i - 1][k]$，其中 $i ∈[1, m], j∈[0, 1 &lt;&lt; n], k∈state[j]$ 边界条件 $f[0][0] = 1$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef long long LL;//每列每个空格都可以选择放或者不放，所以是 2 ^ Nconst int N = 12, M = 1 &lt;&lt; N;int n, m;LL f[N][M];// 记录每个能成功状态转移的二进制序列vector&lt;int&gt; state[M];/* 第 i-2 列伸到 i-1 列的状态为 k ， * 是否能成功转移到 第 i-1 列伸到 i 列的状态为 j * st[j|k]=true 表示能成功转移 */ bool st[M];int main()&#123; while (cin &gt;&gt; n &gt;&gt; m, n || m) &#123; //预处理 st数组，将空格数量为偶数的状态找出来 for (int i = 0; i &lt; 1 &lt;&lt; n; i ++ ) &#123; //记录当前列状态中 0 的个数 int cnt = 0; bool is_valid = true; for (int j = 0; j &lt; n; j ++ ) if (i &gt;&gt; j &amp; 1) &#123; //空格数量为奇数 if (cnt &amp; 1) &#123; is_valid = false; break; &#125; cnt = 0; &#125; else cnt ++ ; //空格数量为奇数 if (cnt &amp; 1) is_valid = false; st[i] = is_valid; &#125; //将可以合法转移的状态记录下来 //即第 i - 1列伸出的小方块不会与第 i 列冲突 for (int i = 0; i &lt; 1 &lt;&lt; n; i ++ ) &#123; state[i].clear(); for (int j = 0; j &lt; 1 &lt;&lt; n; j ++ ) //表示 在 k列状态 i，k - 1 列状态 j 的情况下是合法的 if ((i &amp; j) == 0 &amp;&amp; st[i | j]) state[i].push_back(j); &#125; //状态计算 memset(f, 0, sizeof f); f[0][0] = 1; for (int i = 1; i &lt;= m; i ++ ) for (int j = 0; j &lt; 1 &lt;&lt; n; j ++ ) for (auto k : state[j]) f[i][j] += f[i - 1][k]; cout &lt;&lt; f[m][0] &lt;&lt; endl; &#125; return 0;&#125; AcWing 91. 最短Hamilton路径 用二进制序列来表示所有走过的点 例如走过点$0，1，2，4$则表示为$10111$，走过$0，2，3$则表示为$01101$ 状态表示 $f(i, j)$ 表示所有走到点 $j$ ，且所有走过的点是 $i$ 的所有路径长度 状态计算 $f[i][j] = min(f[i][j], f[i - (1 &lt;&lt; j)][k] + w[k][j])$ 其中 $i∈[0, 1 &lt;&lt; n], j ∈ [0, n -1], k∈[0, n - 1]$ 边界条件 ：$f[1][0] = 0;$ 最终结果：$f[(1 &lt;&lt; n) - 1][n - 1]$ ，表示 $(1 &lt;&lt; n) - 1$ 每个点都经过， $n - 1$ 表示到达终点 123456789101112131415161718192021222324252627282930313233#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 20, M = 1 &lt;&lt; N;int n;int w[N][N];int f[M][N];int main()&#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; n; j ++ ) cin &gt;&gt; w[i][j]; memset(f, 0x3f, sizeof f); //初始化为较大的常数 f[1][0] = 0; //起点不需要任何花费 for (int i = 0; i &lt; 1 &lt;&lt; n; i ++ ) //枚举所有路径 for (int j = 0; j &lt; n; j ++ ) //枚举所有点 if (i &gt;&gt; j &amp; 1) //路径 i 是否经过点 j for (int k = 0; k &lt; n; k ++ ) //枚举走到 j 的点 k if (i &gt;&gt; k &amp; 1) //判断到达 j 的点 k 是否为最优路径 f[i][j] = min(f[i][j], f[i - (1 &lt;&lt; j)][k] + w[k][j]); cout &lt;&lt; f[(1 &lt;&lt; n) - 1][n - 1] &lt;&lt; endl; //输出最终答案 return 0;&#125; AcWing 285. 没有上司的舞会 状态表示： $f[u][0]$:以u为根节点的子树中，u不在场的快乐值最大值 $f[u][1]$:以u为根节点的子树中，u在场的快乐值最大值 状态计算： u节点不选时，子节点选择使快乐值最大的情况 $f[u][0] += max(f[j][0], f[j][1])$ u节点选择时，子节点一定不能选 $f[u][1] += (f[j][0])$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int N = 6010;int n;int happy[N];int h[N], e[N], ne[N], idx;int f[N][2];bool has_father[N]; //标记是否有直属上司void add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;&#125;void dfs(int u)&#123; //上司在的时候，加上这个上司的快乐值 f[u][1] = happy[u]; for(int i = h[u]; ~i; i = ne[i]) &#123; int j = e[i]; //子节点 dfs(j); //搜索子节点 //上司不在，选取直属下属去或不去的最大值 f[u][0] += max(f[j][0], f[j][1]); //上司在，加上直属下属不去的快乐值 f[u][1] += f[j][0]; &#125;&#125;int main()&#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; happy[i]; memset(h, -1, sizeof h); for(int i = 0; i &lt; n - 1; i ++ ) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; has_father[a] = true; add(b, a); &#125; int root = 1; while(has_father[root]) root ++ ; dfs(root); //取根节点去不去的最大值 cout &lt;&lt; max(f[root][0], f[root][1]); return 0;&#125; AcWing 901. 滑雪 记忆化搜索形式类似于搜索，是DP的一种实现方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;const int N = 310;int n, m;int h[N][N];int f[N][N];//偏移量，使当前坐标偏移int dx[4] = &#123;-1, 0, 1, 0&#125;;int dy[4] = &#123;0, 1, 0, -1&#125;;int dp(int x, int y)&#123; int&amp; v = f[x][y]; //该点已经被遍历过 if(v != -1) return v; v = 1; //思路类似于BFS for(int i = 0; i &lt; 4; i ++ ) &#123; int a = x + dx[i], b = y + dy[i]; //确保当前的坐标值未出界，并且对应的高度可以下滑 //这一步可以将遍历过的坐标对应可以下滑的最大值记录进f数组 if(a &gt;= 1 &amp;&amp; a &lt;= n &amp;&amp; b &gt;= 1 &amp;&amp; b &lt;= m &amp;&amp; h[a][b] &lt; h[x][y]) v = max(v, dp(a, b) + 1); &#125; return v;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i ++ ) for(int j = 1; j &lt;= m; j ++ ) cin &gt;&gt; h[i][j]; memset(f, -1, sizeof f); int res = 0, x, y; for(int i = 1; i &lt;= n; i ++ ) for(int j = 1; j &lt;= m; j ++ ) &#123; if(res &lt; dp(i, j)) &#123; res = dp(i, j); x = i, y = j; &#125; &#125; cout &lt;&lt; res &lt;&lt; endl; // //输出路径 // queue&lt;pair&lt;int, int&gt;&gt; q; // vector&lt;pair&lt;int, int&gt;&gt; path; // q.push(&#123;x, y&#125;); // while(!q.empty()) &#123; // auto t = q.front(); // path.push_back(t); // q.pop(); // x = t.first, y = t.second; // for(int i = 0; i &lt; 4; i ++ ) &#123; // auto a = x + dx[i], b = y + dy[i]; // if(a &gt;= 1 &amp;&amp; a &lt;= n &amp;&amp; b &gt;= 1 &amp;&amp; b &lt;= m &amp;&amp; h[a][b] == h[x][y] - 1) // q.push(&#123;a, b&#125;); // &#125; // &#125; // for(auto i : path) &#123; // cout &lt;&lt; i.first &lt;&lt; &quot; &quot; &lt;&lt; i.second &lt;&lt; endl; // &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.misaka-9982.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Acwing","slug":"Acwing","permalink":"http://www.misaka-9982.com/tags/Acwing/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.misaka-9982.com/tags/Algorithm/"}]},{"title":"第四讲 数学知识","slug":"Acwing-算法基础课-数学知识","date":"2021-10-29T07:10:07.000Z","updated":"2023-02-22T13:07:14.708Z","comments":true,"path":"2021/10/29/Acwing-算法基础课-数学知识/","link":"","permalink":"http://www.misaka-9982.com/2021/10/29/Acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/","excerpt":"","text":"视频教学资料","categories":[{"name":"算法","slug":"算法","permalink":"http://www.misaka-9982.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Acwing","slug":"Acwing","permalink":"http://www.misaka-9982.com/tags/Acwing/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.misaka-9982.com/tags/Algorithm/"}]},{"title":"第三讲 搜索与图论","slug":"Acwing-算法基础课-搜索与图论","date":"2021-10-29T06:55:57.000Z","updated":"2023-02-22T13:07:14.706Z","comments":true,"path":"2021/10/29/Acwing-算法基础课-搜索与图论/","link":"","permalink":"http://www.misaka-9982.com/2021/10/29/Acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/","excerpt":"","text":"AcWing 842. 排列数字 本题用的算法思想为回溯法 排列数字1，2，3的解空间树： 可行解共有6种 顺序图解： 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;const int N = 10;int n;int path[N];bool st[N];void dfs(int u)&#123; if(u == n) //边界条件 &#123; for(int i = 0; i &lt; n; i ++ ) printf(&quot;%d &quot;, path[i]); puts(&quot;&quot;); return; &#125; for(int i = 1; i &lt;= n; i ++ ) if(!st[i]) &#123; path[u] = i; st[i] = true; //记录状态 dfs(u + 1); st[i] = false; //恢复原有状态 &#125;&#125;int main()&#123; cin &gt;&gt; n; dfs(0); return 0;&#125; AcWing 843. n-皇后问题 因为每行每列每条对角线都只能有一个皇后，所以可以将各行的皇后映射到同一列上，枚举每列每条对角线是否有皇后。 接着分析，对角线上的皇后。 皇后坐标为(i，j) 正对角线映射到一个数组dg中，由于此时 i = j + c1的c1可能为负数，所以需要加上一个偏移量保证c1为正数，用dg[i - j + n] 记录这条正对角线 反对角线映射到一个数组udg，此时i = - j + c2 ,c2必定为正数，用udg[ i + j ]记录这条反对角线 在回溯的过程中只要满足!col[i] &amp;&amp; !dg[u - i + n] &amp;&amp; !udg[u + i]这个条件就表示当前的坐标能够容纳新的皇后，如此去递归枚举每个位置，找出所有合法的皇后排列即可 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;using namespace std;const int N = 20;int n;char g[N][N];bool col[N], dg[N], udg[N];void dfs(int u)&#123; if(u == n) &#123; for(int i = 0; i &lt; n; i ++ ) puts(g[i]); puts(&quot;&quot;); return; &#125; for(int i = 0; i &lt; n; i ++ ) &#123; if(!col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[n - u + i]) &#123; g[u][i] = &#x27;Q&#x27;; col[i] = dg[u + i] = udg[n - u + i] = true; dfs(u + 1); col[i] = dg[u + i] = udg[n - u + i] = false; g[u][i] = &#x27;.&#x27;; &#125; &#125;&#125;int main()&#123; cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++ ) for(int j = 0; j &lt; n; j ++ ) g[i][j] = &#x27;.&#x27;; dfs(0); return 0;&#125; AcWing 844. 走迷宫 引用自深度优先搜索和广度优先搜索的深入讨论 （一）深度优先搜索的特点是： （1）无论问题的内容和性质以及求解要求如何不同，它们的程序结构都是相同的，即都是深度优先算法（一）和深度优先算法（二）中描述的算法结构，不相同的仅仅是存储结点数据结构和产生规则以及输出要求。 （2）深度优先搜索法有递归以及非递归两种设计方法。一般的，当搜索深度较小、问题递归方式比较明显时，用递归方法设计好，它可以使得程序结构更简捷易懂。当搜索深度较大时，当数据量较大时，由于系统堆栈容量的限制，递归容易产生溢出，用非递归方法设计比较好。 （3）深度优先搜索方法有广义和狭义两种理解。广义的理解是，只要最新产生的结点（即深度最大的结点）先进行扩展的方法，就称为深度优先搜索方法。在这种理解情况下，深度优先搜索算法有全部保留和不全部保留产生的结点的两种情况。而狭义的理解是，仅仅只保留全部产生结点的算法。本书取前一种广义的理解。不保留全部结点的算法属于一般的回溯算法范畴。保留全部结点的算法，实际上是在数据库中产生一个结点之间的搜索树，因此也属于图搜索算法的范畴。 （4）不保留全部结点的深度优先搜索法，由于把扩展望的结点从数据库中弹出删除，这样，一般在数据库中存储的结点数就是深度值，因此它占用的空间较少，所以，当搜索树的结点较多，用其他方法易产生内存溢出时，深度优先搜索不失为一种有效的算法。 （5）从输出结果可看出，深度优先搜索找到的第一个解并不一定是最优解。 二、广度优先搜索法的显著特点是： （1）在产生新的子结点时，深度越小的结点越先得到扩展，即先产生它的子结点。为使算法便于实现，存放结点的数据库一般用队列的结构。 （2）无论问题性质如何不同，利用广度优先搜索法解题的基本算法是相同的，但数据库中每一结点内容，产生式规则，根据不同的问题，有不同的内容和结构，就是同一问题也可以有不同的表示方法。 （3）当结点到跟结点的费用（有的书称为耗散值）和结点的深度成正比时，特别是当每一结点到根结点的费用等于深度时，用广度优先法得到的解是最优解，但如果不成正比，则得到的解不一定是最优解。这一类问题要求出最优解，一种方法是使用后面要介绍的其他方法求解，另外一种方法是改进前面深度（或广度）优先搜索算法：找到一个目标后，不是立即退出，而是记录下目标结点的路径和费用，如果有多个目标结点，就加以比较，留下较优的结点。把所有可能的路径都搜索完后，才输出记录的最优路径。 （4）广度优先搜索算法，一般需要存储产生的所有结点，占的存储空间要比深度优先大得多，因此程序设计中，必须考虑溢出和节省内存空间得问题。 （5）比较深度优先和广度优先两种搜索法，广度优先搜索法一般无回溯操作，即入栈和出栈的操作，所以运行速度比深度优先搜索算法法要快些。 总之，一般情况下，深度优先搜索法占内存少但速度较慢，广度优先搜索算法占内存多但速度较快，在距离和深度成正比的情况下能较快地求出最优解。因此在选择用哪种算法时，要综合考虑。决定取舍。 走迷宫过程图解： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#define x first#define y secondusing namespace std;const int N = 110;typedef pair&lt;int, int&gt; PII;int n, m;int g[N][N]; //输入图int d[N][N]; //记录距离，标记是否已经遍历过PII q[N * N]; //队列int bfs()&#123; int hh = 0, tt = 0; q[0] = &#123;0, 0&#125;; //初始化，未遍历的点会被标记为-1 memset(d, -1, sizeof d); d[0][0] = 0; //偏移量 int dx[4] = &#123;-1, 0, 1, 0&#125;; int dy[4] = &#123;0, 1, 0, -1&#125;; while(hh &lt;= tt) &#123; auto t = q[hh ++ ]; for(int i = 0; i &lt; 4; i ++ ) &#123; int a = t.x + dx[i], b = t.y + dy[i]; if(a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= m) //点在这个图的范围内 continue; if(g[a][b] == 0 &amp;&amp; d[a][b] == -1) //该点可行且未被遍历过 &#123; d[a][b] = d[t.x][t.y] + 1; //距离 + 1 q[ ++ tt] = &#123;a, b&#125;; //入队 &#125; &#125; &#125; return d[n - 1][m - 1]; &#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i ++ ) for(int j = 0; j &lt; m; j ++ ) cin &gt;&gt; g[i][j]; cout &lt;&lt; bfs() &lt;&lt; endl; return 0;&#125; STL版本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;string.h&gt;using namespace std;const int N = 110, M = 110;typedef pair&lt;int, int&gt; PII;queue&lt;PII&gt; que;int n, m;int g[N][N];int d[N][N];int bfs()&#123; que.push(&#123;0, 0&#125;); memset(d, -1, sizeof d); d[0][0] = 0; int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;; while(!que.empty()) &#123; auto t = que.front(); que.pop(); for(int i=0; i&lt;4; i++) &#123; int x = t.first + dx[i], y = t.second + dy[i]; if(x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; g[x][y] == 0 &amp;&amp; d[x][y] == -1) &#123; d[x][y] = d[t.first][t.second] + 1; que.push(&#123;x, y&#125;); &#125; &#125; &#125; return d[n-1][m-1];&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i=0; i&lt;n; i++) for(int j=0; j&lt;m; j++) cin &gt;&gt; g[i][j]; cout &lt;&lt; bfs() &lt;&lt; endl; return 0;&#125; AcWing 845. 八数码 求最少操作步数，若无法变换则返回-1 可以利用BFS求出最小交换步数 可以将矩阵转换为字符串，用字符串来表示矩阵当前的状态 转换方法 12queue&lt;string&gt; q; //队列直接存转换后的字符串unordered_map&lt;string, int&gt; d; //利用哈希表将转换后的字符串和操作次数绑定在一起 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;unordered_map&gt;#include&lt;queue&gt;using namespace std;int bfs(string start)&#123; //目标状态 string end = &quot;12345678x&quot;; //利用哈希表将转换后的字符串和操作次数绑定在一起 queue&lt;string&gt; q; //利用哈希表将转换后的字符串和操作次数绑定在一起 unordered_map&lt;string, int&gt; d; q.push(start); d[start] = 0; int dx[4] = &#123;-1, 0, 1, 0&#125;； int dy[4] = &#123;0, 1, 0, -1&#125;; while(q.size()) &#123; auto t = q.front(); q.pop(); int distance = d[t]; if(t == end) return distance; //查找x的下标并转换为二维坐标 int k = t.find(&#x27;x&#x27;); int x = k / 3, y = k % 3; for(int i = 0; i &lt; 4; i ++ ) &#123; //转移后的x坐标 int a = x + dx[i], b = y + dy[i]; //x坐标未越界 if(a &gt;= 0 &amp;&amp; a &lt; 3 &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; 3) &#123; //形态变换 swap(t[k], t[a * 3 + b]); //如果状态t没有被遍历过 if(!d.count(t)) &#123; d[t] = distance + 1; q.push(t); &#125; //恢复原位 swap(t[a * 3 + b], t[k]); &#125; &#125; &#125; return -1;&#125;int main()&#123; string start; for(int i = 0; i &lt; 9; i ++ ) &#123; char c; cin &gt;&gt; c; start += c; &#125; cout &lt;&lt; bfs(start) &lt;&lt; endl; return 0;&#125; AcWing 846. 树的重心 dfs(4)时，节点4有3，6两个子节点，两个子节点所在的连通块的节点数加起来的值为size 节点4的父节点1所在连通块的节点数为n - size - 1 每个节点删去后的连通块节点数量最大值为size = max(size, n - size - 1)， 找出使得连通块的节点数量最大值最小的点，这个点就是树的重心，利用一个全局变量ans来记录最小值，更新方式为ans = min(ans, size) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1e5 + 10, M = 2 * N;int n;int h[N], e[M], ne[M], idx;int ans = N;bool st[N]; //记录节点是否被遍历过//使用单链表的形式将树存储进来void add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;&#125;int dfs(int u)&#123; st[u] = true; int size = 0, sum = 0; //遍历节点u的子节点 for(int i = h[u]; i != -1; i = ne[i]) &#123; int j = e[i]; if(st[j]) continue; int s = dfs(j); //size 记录所有子节点所在块的最大值 size = max(size, s); //sum 将子节点所在块的值加起来 sum += s; &#125; //更新size，ans size = max(size, n - sum - 1); ans = min(ans, size); //sum初始化为0 //而当前这个点(根节点)也是上一层调用dfs的根节点子节点所在连通块内的一点 return sum + 1;&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); memset(h, -1, sizeof h); for(int i = 0; i &lt; n - 1; i ++ ) &#123; int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); add(a, b), add(b, a); &#125; dfs(1); printf(&quot;%d\\n&quot;, ans); return 0;&#125; AcWing 847. 图中点的层次 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int N = 1e5 + 10;queue&lt;int&gt; que;int n, m;int h[N], e[N], ne[N], idx;int d[N], q[N]; //队列和距离数组//用邻接表将图存储void add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;&#125;int bfs()&#123; //层序遍历 que.push(1); memset(d, -1, sizeof d); d[1] = 0; while(!que.empty()) &#123; int t = que.front(); que.pop(); for(int i = h[t]; i != -1; i = ne[i]) &#123; int j = e[i]; //若未被遍历过，则距离加一 if(d[j] == -1) &#123; d[j] = d[t] + 1; que.push(j); &#125; &#125; &#125; return d[n];&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; memset(h, -1, sizeof h); for(int i = 0; i &lt; m; i ++ ) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; add(a, b); &#125; cout &lt;&lt; bfs() &lt;&lt; endl; return 0;&#125; AcWing 848. 有向图的拓扑序列 将入度为0的节点入队，并将这个节点的子节点入度都减一，如果入度为0，就将节点入队，如此循环，直至所有节点都入队为止。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e5 + 10;int n, m;int h[N], ne[N], e[N], idx;int q[N], d[N];//q表队列，d表入度void add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;&#125;bool topSort()&#123; int hh = 0, tt = -1; for(int i = 1; i &lt;= n; i ++ ) //入度为0，入队 if(!d[i]) q[ ++ tt] = i; //若队列不为空 while(hh &lt;= tt) &#123; //弹出队首元素 int t = q[hh ++ ]; for(int i = h[t]; i != -1; i = ne[i]) &#123; //与h[t]元素相关联的元素入度均减一 int j = e[i]; d[j] --; if(d[j] == 0) q[ ++ tt] = j; &#125; &#125; return tt == n - 1;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; memset(h, -1, sizeof h); for(int i = 0; i &lt; m; i ++ ) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; add(a, b); d[b] ++ ; &#125; if(topSort()) &#123; for(int i = 0; i &lt; n; i ++ ) printf(&quot;%d &quot;, q[i]); puts(&quot;&quot;); &#125; else cout &lt;&lt; -1 &lt;&lt; endl; return 0;&#125; AcWing 849. Dijkstra求最短路 I Dijkstra算法介绍 Dijkstra的主要特点是以起始点为中心向外层层拓展（广度优先搜索思想），直到拓展到终点为止。 算法特点： 迪科斯彻算法使用了广度优先搜索解决赋权有向图或者无向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。 算法的思路 Dijkstra算法采用的是一种贪心的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T，初始时，原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s。 然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，OK，此时完成一个顶点， 然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。 然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。 算法核心：松弛操作 1234567891011121314151617//迭代n次，每次可以确定一个点到起点的最短路 for(int i = 0; i &lt; n; i ++ ) &#123; //t存储当前访问的点 int t = - 1; //该步骤即寻找还未确定最短路的点中路径最短的点 for(int j = 1; j &lt;= n; j ++ ) if(!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j; st[t] = true; //依次更新每个点所到相邻的点路径值 for(int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], dist[t] + g[t][j]); &#125; 过程图解 距离更新过程： 总结起来就是：每次选一个点，更新邻点，循环$n-1$次就可以了 时间复杂度$O(n \\cdot n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 510;int n, m;int g[N][N];int dist[N];//用于存储每个点到起点的最短距离bool st[N];//用于在更新最短距离时//判断当前的点的最短距离是否确定 是否需要更新int dijkstra()&#123; memset(dist, 0x3f, sizeof dist); dist[1] = 0;//一号点到一号点的距离为0 //迭代n次，每次可以确定一个点到起点的最短路 for(int i = 0; i &lt; n; i ++ ) &#123; //t存储当前访问的点 int t = - 1; //该步骤即寻找还未确定最短路的点中路径最短的点 for(int j = 1; j &lt;= n; j ++ ) if(!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j; st[t] = true; //依次更新每个点所到相邻的点路径值 for(int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], dist[t] + g[t][j]); &#125; if(dist[n] == 0x3f3f3f3f) return -1; return dist[n];&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(g, 0x3f, sizeof g); while(m --) &#123; int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); g[a][b] = min(g[a][b], c); &#125; int t = dijkstra(); printf(&quot;%d\\n&quot;, t); return 0;&#125; AcWing 850. Dijkstra求最短路 II 堆优化的主要思想就是使用一个优先队列（就是每次弹出的元素一定是整个队列中最小的元素）来代替最近距离的查找，用邻接表代替邻接矩阵，这样可以大幅度节约时间开销。 在这里有几个细节需要处理： 首先来讲，优先队列的数据类型应该是怎样的呢？ 我们知道优先队列应该用于快速寻找距离最近的点。由于优先队列只是将最小的那个元素排在前面，因此我们应该定义一种数据类型，使得它包含该节点的编号以及该节点当前与起点的距离。这里使用pair数组来储存。 我们应该在什么时候对队列进行操作呢？ 队列操作的地方，首先就是搜索刚开始，要为起点赋初始值，此时必须将起点加入优先队列中。该队列元素的节点编号为起点的编号，该节点当前与起点的距离为0。 那么如果一个节点到起点的最短距离通过其他的运算流程发生了变化，那么如何处理队列中的那个已经存入的元素？ 事实上，你不需要理会队列中的元素，而是再存入一个就行了。因为如果要发生变化，只能将节点与起点之间的距离变得更小，而优先队列恰好是先让最小的那个弹出。 因此，轮到某一个队列元素弹出的时候，如果有多个元素的节点编号相同，那么被弹出的一定是节点编号最小的一个。等到后面再遇到这个节点编号的时候，我们只需要将它忽略掉就行了 时间复杂度$O(m log n)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 1e6 + 10;int n, m;int h[N], e[N], w[N], ne[N], idx;int dist[N];bool st[N];void add(int a, int b, int c)&#123; e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;&#125;int dijkstra()&#123; memset(dist, 0x3f, sizeof dist); dist[1] = 0; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; heap.push(&#123;0, 1&#125;); while(heap.size()) &#123; auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if(st[ver]) continue; //如果该点已经标记过，就跳过这一轮循环 st[ver] = true; for(int i = h[ver]; i != -1; i = ne[i]) &#123; int j = e[i]; if(dist[j] &gt; distance + w[i]) &#123; dist[j] = distance + w[i]; heap.push(&#123;dist[j], j&#125;); //将更新过的点插入到堆中 &#125; &#125; &#125; if(dist[n] == 0x3f3f3f3f) return -1; return dist[n];&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(h, -1, sizeof h); while(m -- ) &#123; int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); add(a, b, c); &#125; int t = dijkstra(); printf(&quot;%d\\n&quot;, t); return 0;&#125; AcWing 853. 有边数限制的最短路 Bellman-Ford算法的优点是可以发现负圈，缺点是时间复杂度比Dijkstra算法高。 而SPFA算法是使用队列优化的Bellman-Ford版本，其在时间复杂度和编程难度上都比其他算法有优势。 参考文献 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int N = 510, M = 1e4 + 10;int n, m, k;int dist[N], backup[N];struct Edge&#123; int a, b, w;&#125;edges[M];int bellman_ford()&#123; memset(dist, 0x3f, sizeof dist); dist[1] = 0; for(int i=0; i &lt; k; i++) &#123; memcpy(backup, dist, sizeof dist); for(int j = 0; j &lt; m; j ++) &#123; int a = edges[j].a, b = edges[j].b, w = edges[j].w; dist[b] = min(dist[b], backup[a] + w); &#125; &#125; if(dist[n] &gt; 0x3f3f3f3f / 2) return -1; return dist[n];&#125;int main()&#123; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k); for(int i=0; i&lt;m; i++) &#123; int a, b, w; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;w); edges[i] = &#123;a, b, w&#125;; &#125; int t = bellman_ford(); if(t == -1) puts(&quot;impossible&quot;); else printf(&quot;%d\\n&quot;, t); return 0;&#125; AcWing 851. spfa求最短路 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int N = 1e5 + 10;int n, m;int h[N], w[N], e[N], ne[N], idx;int dist[N];bool st[N];void add(int a, int b, int c)&#123; e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;&#125;int spfa()&#123; memset(dist, 0x3f, sizeof dist); dist[1] = 0; queue&lt;int&gt; q; q.push(1); st[1] = true; while(q.size()) &#123; int t = q.front(); q.pop(); st[t] = false; for(int i = h[t]; i != -1; i = ne[i]) &#123; int j = e[i]; if(dist[j] &gt; dist[t] + w[i]) &#123; dist[j] = dist[t] + w[i]; if(!st[j]) &#123; q.push(j); st[j] = true; &#125; &#125; &#125; &#125; if(dist[n] == 0x3f3f3f3f) return -1; return dist[n];&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(h, -1, sizeof h); while(m -- ) &#123; int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); add(a, b, c); &#125; int t = spfa(); if(t == -1) puts(&quot;impossible&quot;); else printf(&quot;%d\\n&quot;, t); return 0;&#125; AcWing 852. spfa判断负环 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int N = 1e5 + 10;int n, m;int h[N], w[N], e[N], ne[N], idx;int dist[N], cnt[N];bool st[N];void add(int a, int b, int c)&#123; e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;&#125;int spfa()&#123; queue&lt;int&gt; q; for(int i = 1; i &lt;= n; i ++ ) &#123; st[i] = true; q.push(i); &#125; while(q.size()) &#123; int t = q.front(); q.pop(); st[t] = false; for(int i = h[t]; i != -1; i = ne[i]) &#123; int j = e[i]; if(dist[j] &gt; dist[t] + w[i]) &#123; dist[j] = dist[t] + w[i]; cnt[j] = cnt[t] + 1; if(cnt[j] &gt;= n) return true; if(!st[j]) &#123; q.push(j); st[j] = true; &#125; &#125; &#125; &#125; return false;&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(h, -1, sizeof h); while(m--) &#123; int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); add(a, b, c); &#125; if(spfa()) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); return 0;&#125; AcWing 854. Floyd求最短路 基本思想： 弗洛伊德算法定义了两个二维矩阵： 矩阵D记录顶点间的最小路径 例如D[0][3]= 10，说明顶点0 到 3 的最短路径为10； 矩阵P记录顶点间最小路径中的中转点 例如P[0][3]= 1 说明，0 到 3的最短路径轨迹为：0 -&gt; 1 -&gt; 3。 它通过3重循环，k为中转点，v为起点，w为终点，循环比较D[v][w] 和D[v][k] + D[k][w]最小值，如果D[v][k] + D[k][w] 为更小值，则把D[v][k] + D[k][w] 覆盖保存在D[v][w]中。 算法核心 过程图解 时间复杂度$O(n \\cdot n \\cdot n)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 210, INF = 1e9;int n, m, Q;int d[N][N];void floyd()&#123; for(int k = 1; k &lt;= n; k ++ ) for(int i = 1; i &lt;= n; i ++ ) for(int j = 1; j &lt;= n; j ++ ) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; Q; for(int i = 1; i &lt;= n; i ++ ) for(int j = 1; j &lt;= n; j ++ ) if(i == j) d[i][j] = 0; else d[i][j] = INF; while(m -- ) &#123; int a, b, w; cin &gt;&gt; a &gt;&gt; b &gt;&gt; w; d[a][b] = min(d[a][b], w); &#125; floyd(); while(Q -- ) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; if(d[a][b] &gt; INF / 2) puts(&quot;impossible&quot;); else cout &lt;&lt; d[a][b]; &#125; return 0;&#125; AcWing 858. Prim算法求最小生成树 连通图：在无向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该无向图为连通图。 强连通图：在有向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该有向图为强连通图。 连通网：在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网。 生成树：一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环。 最小生成树：在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。 Prim过程图解： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 510, INF = 0x3f3f3f3f;int n, m;int g[N][N];int dist[N];bool st[N];int prim()&#123; memset(dist, 0x3f, sizeof dist); int res = 0; for(int i = 0; i &lt; n; i ++ ) &#123; int t = -1; //找出距离生成树最小的点 for(int j = 1; j &lt;= n; j ++ ) if(!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j; //判断该点到生成树之间是否存在边 if(i &amp;&amp; dist[t] == INF) return INF; if(i) res += dist[t]; //利用新并入生成树集合的点更新其他点到生成树集合的距离 for(int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]); st[t] = true;//将点并入集合 &#125; return res;&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(g, 0x3f, sizeof g); while(m--) &#123; int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); g[a][b] = g[b][a] = min(g[a][b], c); &#125; int t = prim(); if(t == INF) puts(&quot;impossible&quot;); else printf(&quot;%d\\n&quot;, t); return 0;&#125; AcWing 859. Kruskal算法求最小生成树 此算法可以称为“加边法”，初始最小生成树边数为0 利用并查集来维护每条边所属的集合 每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。 把图中的所有边按边权从小到大排序； 把图中的n个顶点看成独立的n棵树组成的森林； 按权值从小到大选择边，所选的边连接的两个顶点应属于两个不同的集合，并将这两颗集合合并。如果所选的两个点属于同一个集合，那么将这条边加入集合后，将会形成一个环，不符合树的定义。 重复(3),直到所有顶点都在一颗树内或者有n-1条边为止。 Kruskal过程图解： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 2e5 + 10;int n, m;int p[N];struct Edge&#123; int a, b, w; bool operator&lt; (const Edge &amp;W)const &#123; return w &lt; W.w; &#125;&#125;edges[N];int find(int x)&#123; if(p[x] != x) p[x] = find(p[x]); return p[x];&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 0; i &lt; m; i ++ ) &#123; int a, b, w; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;w); edges[i] = &#123;a, b, w&#125;; &#125; sort(edges, edges + m); for(int i = 1; i &lt;= n; i ++ ) p[i] = i; int res = 0, cnt = 0; for(int i = 0; i &lt; m; i ++ ) &#123; int a = edges[i].a, b = edges[i].b, w = edges[i].w; a = find(a), b = find(b); if(a != b) &#123; p[a] = b; res += w; cnt ++; &#125; &#125; if(cnt &lt; n - 1) puts(&quot;impossible&quot;); else printf(&quot;%d\\n&quot;, res); return 0;&#125; AcWing 860. 染色法判定二分图 奇数环：由奇数条边形成的一个环 把一个图的顶点划分为两个不相交子集 ，使得每一条边都分别连接两个集合中的顶点。如果存在这样的划分，则此图为一个二分图 二分图可能含有偶数环，但一定没有奇数环，一下图形都是二分图 利用dfs对图中的点进行染色，可以判断该图是否为二分图 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e5 + 10, M = 2e5 + 10;int n, m;int h[N], e[M], ne[M], idx;int color[N];void add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;&#125;//返回是否可以成功将u染色为cbool dfs(int u, int c)&#123; //修改当前颜色 color[u] = c; //尝试染链接边的颜色 for(int i = h[u]; i != -1; i = ne[i]) &#123; int j = e[i]; //如果color[j]没有染过色 if(!color[j]) &#123; //如果不能将j成功染色 if(!dfs(j, 3 - c)) return false; &#125; else if(color[j] == c) return false; //如果染过颜色且和u相同 &#125; return true;&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(h, -1, sizeof h); while(m -- ) &#123; int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); add(a, b), add(b, a); &#125; bool flag = true; for(int i = 1; i &lt;= n; i ++ ) //如果未染色 if(!color[i]) &#123; //如果dfs返回false 说明出现矛盾 if(!dfs(i, 1)) &#123; flag = false; break; &#125; &#125; if(flag) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); return 0;&#125; AcWing 861. 二分图的最大匹配 匈牙利算法几乎是二分图匹配的核心算法，除了二分图多重匹配外均可使用 先试着给1号男生找妹子，发现第一个和他相连的1号女生还名花无主，连上一条蓝线 接着给2号男生找妹子，发现第一个和他相连的2号女生名花无主 接下来是3号男生，很遗憾1号女生已经有主了，怎么办呢？ 我们试着给之前1号女生匹配的男生（也就是1号男生）另外分配一个妹子。 (黄色表示这条边被临时拆掉) 与1号男生相连的第二个女生是2号女生，但是2号女生也有主了 我们再试着给2号女生的原配重新找个妹子 2号男生可以找3号妹子~~~~~~~~ 1号男生可以找2号妹子了~~~~~~~~ 3号男生可以找1号妹子 结果就是这样 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 510, M = 1e5 + 10;int n1, n2, m;int h[N], e[M], ne[M], idx;int match[N];bool st[N];void add(int a, int b)&#123; e[idx] = b, ne[idx] = h[a], h[a] = idx ++;&#125;bool find(int x)&#123; //遍历自己喜欢的女孩 for(int i = h[x]; i != -1; i = ne[i]) &#123; int j = e[i]; //如果在这一轮模拟匹配中,这个女孩尚未被预定 if(!st[j]) &#123; st[j] = true;//那x就预定这个女孩了 //如果女孩j没有男朋友， //或者她原来的男朋友能够预定其它喜欢的女孩。 //配对成功,更新match if(match[j] == 0 || find(match[j])) &#123; match[j] = x; return true; &#125; &#125; &#125; //自己中意的全部都被预定了。配对失败。 return false;&#125;int main()&#123; scanf(&quot;%d%d%d&quot;, &amp;n1, &amp;n2, &amp;m); memset(h, -1, sizeof h); while(m --) &#123; int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); add(a, b); &#125; int res = 0; for(int i = 1; i &lt;= n1; i ++ ) &#123; //因为每次模拟匹配的预定情况都是不一样的 //所以每轮模拟都要初始化 memset(st, false, sizeof st); if(find(i)) res ++; &#125; printf(&quot;%d\\n&quot;, res); return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.misaka-9982.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Acwing","slug":"Acwing","permalink":"http://www.misaka-9982.com/tags/Acwing/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.misaka-9982.com/tags/Algorithm/"}]},{"title":"第二讲 数据结构","slug":"Acwing-算法基础课-数据结构","date":"2021-10-28T03:54:52.000Z","updated":"2023-02-22T13:07:14.708Z","comments":true,"path":"2021/10/28/Acwing-算法基础课-数据结构/","link":"","permalink":"http://www.misaka-9982.com/2021/10/28/Acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"AcWing 826. 单链表 e[i]: 存放需要存入的值 ne[i]：存放下一个节点的下标 idx :记录当前的操作的位置 插入头结点 利用一个head指针记录头结点的位置 1234void add_to_head(int x)&#123; e[idx] = x, ne[idx] = head, head = idx ++ ;&#125; 插入操作 1234567void add(int k, int x)&#123; e[idx] = x; //e[idx]记录新插入的节点的值 ne[idx] = ne[k]; //新节点的next指针指向 newPoint, newPoint -&gt; next = k -&gt; next ne[k] = idx; //原位于位置k的节点的next指针指向新节点,k -&gt; next = newPoint idx ++ ; //更新idx的值&#125; ①ne[idx] = ne[k]; ② ne[k] = idx; 删除操作 相当于 p -&gt; next = p -&gt; next -&gt; next 1234void remove(int k)&#123; ne[k] = ne[ne[k]];&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int e[N], ne[N];int head, idx;void init()&#123; head = -1; idx = 0;&#125;void add_to_head(int x)&#123; e[idx] = x, ne[idx] = head, head = idx ++ ;&#125;void add(int k, int x)&#123; e[idx] = x, ne[idx] = ne[k], ne[k] = idx ++ ;&#125;void remove(int k)&#123; ne[k] = ne[ne[k]];&#125;int main()&#123; int m; cin &gt;&gt; m; init(); while(m -- ) &#123; int k, x; char op; cin &gt;&gt; op; if(op == &#x27;H&#x27;) &#123; cin &gt;&gt; x; add_to_head(x); &#125; else if(op == &#x27;D&#x27;) &#123; cin &gt;&gt; k; if(!k) head = ne[head]; remove(k - 1); &#125; else &#123; cin &gt;&gt; k &gt;&gt; x; add(k - 1, x); &#125; &#125; for(int i = head; i != -1; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; return 0;&#125; AcWing 827. 双链表 初始化 123456void init()&#123; r[0] = 1; //head -&gt; next = tail l[1] = 0; //tail -&gt; pre = head idx = 2;&#125; 假设p为新节点 插入节点 123456789void add(int k, int x)&#123; e[idx] = x; r[idx] = r[k]; // p -&gt; next = k -&gt; next l[idx] = k; // p -&gt; pre = k l[r[k]] = idx; // p -&gt; next -&gt; pre = p r[k] = idx; // k -&gt; next = p idx ++;&#125; 删除节点 12345void remove(int k)&#123; r[l[k]] = r[k]; // k -&gt; pre -&gt; next = k -&gt; next; l[r[k]] = l[k]; // k -&gt; next -&gt; pre = k -&gt; pre;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int m;int e[N], r[N], l[N], idx;void init()&#123; r[0] = 1, l[1] = 0; idx = 2;&#125;void add(int k, int x)&#123; e[idx] = x; r[idx] = r[k]; l[idx] = k; l[r[k]] = idx; r[k] = idx; idx ++;&#125;void remove(int k)&#123; r[l[k]] = r[k]; l[r[k]] = l[k];&#125;int main()&#123; cin &gt;&gt; m; init(); while(m--) &#123; string op; cin &gt;&gt; op; int k, x; if(op == &quot;L&quot;) &#123; cin &gt;&gt; x; add(0, x); &#125; else if(op == &quot;R&quot;) &#123; cin &gt;&gt; x; add(l[1], x); &#125; else if(op == &quot;D&quot;) &#123; cin &gt;&gt; k; remove(k + 1); &#125; else if(op == &quot;IL&quot;) &#123; cin &gt;&gt; k &gt;&gt; x; add(l[k + 1], x); &#125; else &#123; cin &gt;&gt; k &gt;&gt; x; add(k + 1, x); &#125; &#125; for(int i=r[0]; i!=1; i=r[i]) cout &lt;&lt; e[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; return 0;&#125; AcWing 828. 模拟栈 数组模拟栈 tt表示top指针，记录栈顶元素于数组中的位置 tt == 0时，栈为空 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;const int N = 100010;int m;int stk[N], tt;int main()&#123; cin &gt;&gt; m; while (m -- ) &#123; string op; int x; cin &gt;&gt; op; if (op == &quot;push&quot;) &#123; cin &gt;&gt; x; stk[ ++ tt] = x; &#125; else if (op == &quot;pop&quot;) tt -- ; else if (op == &quot;empty&quot;) cout &lt;&lt; (tt ? &quot;NO&quot; : &quot;YES&quot;) &lt;&lt; endl; else cout &lt;&lt; stk[tt] &lt;&lt; endl; &#125; return 0;&#125; AcWing 3302. 表达式求值 “表达式求值”问题，两个核心关键点： （1）双栈，一个操作数栈，一个运算符栈； （2）运算符优先级，栈顶运算符和即将入栈的运算符的优先级比较： 如果栈顶的运算符优先级低，新运算符直接入栈，定义一个哈希表记录各个符号对用的优先级，小括号的优先级最高。 pr&#123;&#123;'+', 1&#125;, &#123;'-', 1&#125;, &#123;'*', 2&#125;, &#123;'/', 2&#125;&#125; 如果栈顶的运算符优先级高，先出栈计算，新运算符再入栈 这个方法的时间复杂度为O(n)，整个字符串只需要扫描一遍。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;#include &lt;stack&gt;using namespace std;void eval(stack&lt;int&gt;&amp; num, stack&lt;char&gt;&amp; op)&#123; int b = num.top(); num.pop(); int a = num.top(); num.pop(); char c = op.top(); op.pop(); int x; if (c == &#x27;+&#x27;) x = a + b; else if (c == &#x27;-&#x27;) x = a - b; else if (c == &#x27;*&#x27;) x = a * b; else x = a / b; num.push(x);&#125;int main()&#123; unordered_map&lt;char, int&gt; pr&#123;&#123;&#x27;+&#x27;, 1&#125;, &#123;&#x27;-&#x27;, 1&#125;, &#123;&#x27;*&#x27;, 2&#125;, &#123;&#x27;/&#x27;, 2&#125;&#125;; stack&lt;int&gt; num; stack&lt;char&gt; op; string str; cin &gt;&gt; str; for (int i = 0; i &lt; str.size(); i ++ ) &#123; char c = str[i]; if (isdigit(c)) &#123; int j = i, x = 0; while (j &lt; str.size() &amp;&amp; isdigit(str[j])) x = x * 10 + str[j ++ ] - &#x27;0&#x27;; num.push(x); i = j - 1; &#125; else if (c == &#x27;(&#x27;) op.push(c); else if (c == &#x27;)&#x27;) &#123; while (op.top() != &#x27;(&#x27;) eval(num, op); op.pop(); &#125; else &#123; while (op.size() &amp;&amp; pr[op.top()] &gt;= pr[c]) eval(num, op); op.push(c); &#125; &#125; while (op.size()) eval(num, op); cout &lt;&lt; num.top() &lt;&lt; endl; return 0;&#125; AcWing 829. 模拟队列 hh为队头指针，记录队首在数组中的位置 tt为队尾指针，记录队尾在数组中的位置 hh &gt; tt 时，队列为空 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;const int N = 100010;int m;int q[N], hh, tt = -1;int main()&#123; cin &gt;&gt; m; while (m -- ) &#123; string op; int x; cin &gt;&gt; op; if (op == &quot;push&quot;) &#123; cin &gt;&gt; x; q[ ++ tt] = x; &#125; else if (op == &quot;pop&quot;) hh ++ ; else if (op == &quot;empty&quot;) cout &lt;&lt; (hh &lt;= tt ? &quot;NO&quot; : &quot;YES&quot;) &lt;&lt; endl; else cout &lt;&lt; q[hh] &lt;&lt; endl; &#125; return 0;&#125; AcWing 830. 单调栈 数组模拟 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int n;int stk[N], tt;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for(int i = 0; i &lt; n; i ++ ) &#123; int x; scanf(&quot;%d&quot;, &amp;x); while(tt &amp;&amp; stk[tt] &gt;= x) tt -- ; //栈不为空且栈顶元素大于等于x，则弹出栈顶元素 if(tt) printf(&quot;%d &quot;, stk[tt]); //若栈不为空，则输出栈顶元素 else printf(&quot;-1 &quot;);//否则输出-1 stk[ ++ tt] = x;//x入栈 &#125; return 0;&#125; STL 123456789101112131415161718#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;int main()&#123; int x, n; scanf(&quot;%d&quot;, &amp;n); stack&lt;int&gt; st; for(int i = 0; i &lt; n; i ++ ) &#123; scanf(&quot;%d&quot;, &amp;x); while(!st.empty() &amp;&amp; st.top() &gt;= x) st.pop(); if(!st.empty()) printf(&quot;%d &quot;, st.top()); else printf(&quot;-1 &quot;); st.push(x); &#125; return 0;&#125; AcWing 154. 滑动窗口 单调队列，类似于单调栈的思想方法 q[i]：记录数组a[i]的元素下标 解决队首已经出窗口的问题，队首下标应在当前窗口覆盖的范围内 解决队尾与当前元素a[i]不满足单调性的问题，不满足单调性的，就直接弹出队尾，直到满足单调性为止 将当前元素下标加入队尾; 如果满足条件则输出队首元素; 以下是一个例子： 该数组为[1 3 -1 -3 5 3 6 7]，k为3。 窗口位置 最小值 最大值 [1 3 -1] -3 5 3 6 7 -1 3 1 [3 -1 -3] 5 3 6 7 -3 3 1 3 [-1 -3 5] 3 6 7 -3 5 1 3 -1 [-3 5 3] 6 7 -3 5 1 3 -1 -3 [5 3 6] 7 3 6 1 3 -1 -3 5 [3 6 7] 3 7 如图，其中q数组记录数值，p数组记录下标 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int n, k;int a[N], q[N];int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for(int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]); int hh = 0, tt = -1; for(int i = 0; i &lt; n; i ++ ) &#123; if(hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh]) hh ++ ; while(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt -- ; q[ ++ tt] = i; if(i &gt;= k - 1) printf(&quot;%d &quot;, a[q[hh]]); &#125; puts(&quot;&quot;); hh = 0, tt = -1; for(int i = 0; i &lt; n; i ++ ) &#123; if(hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh]) hh ++ ; while(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt -- ; q[ ++ tt] = i; if(i &gt;= k - 1) printf(&quot;%d &quot;, a[q[hh]]); &#125; puts(&quot;&quot;); return 0;&#125; AcWing 831. KMP字符串 一、暴利匹配的模式 第一个过程：子串“goo”部分与主串相等，'g’不等，结束比对，进行回溯。 第二个过程：开始时就不匹配，直接回溯 第三个过程：开始时即不匹配，直接回溯 第四个过程：开始时即不匹配，直接回溯 第五个过程：匹配成功 模式串长度为m，匹配串长度为n，时间复杂度为$O(n*m)$ 二、KMP算法 前置概念 公式： 动图演示： 求出模式串的next数组之后进行字符串匹配 以目标串：s，指针为 i ；模式串：t 指针为 j ; 为例 上图表示：“si-j ~ si-1” == “t 0 ~ t j-1”，si != tj（前面都相等，但比较到 t j 时发现不相等了）且next[j] == k。 根据 next 数组的定义得知 “t k ~ t j-1” == “t 0 ~ t k-1”，所以 “t 0 ~ t k-1” == “si-k ~ si-1” 将模式串右移，得到上图，这样就避免了目标穿的指针回溯。 思想方法和分形相似 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;const int N = 1e5 + 10, M = 1e6 + 10;int n, m;char p[N], s[M];int ne[N];int main()&#123; cin &gt;&gt; n &gt;&gt; p + 1 &gt;&gt; m &gt;&gt; s + 1; for(int i = 2, j = 0; i &lt;= n; i ++ ) &#123; while(j &amp;&amp; p[i] != p[j + 1]) j = ne[j]; if(p[i] == p[j + 1]) j ++ ; ne[i] = j; &#125; for(int i = 1, j = 0; i &lt;= m; i ++ ) &#123; while(j &amp;&amp; s[i] != p[j + 1]) j = ne[j]; if(s[i] == p[j + 1]) j ++ ; if(j == n) &#123; cout &lt;&lt; i - n &lt;&lt; &quot; &quot;; j = ne[j]; &#125; &#125; return 0;&#125; AcWing 835. Trie字符串统计 son[i][26]:存放子节点的指针 例如son[1][0] = 2表示存放节点1的子节点a的指针为2 cnt[i]：利用每个字符串最后一个字符的位置可以记录每个字符串出现的次数 插入函数： 1234567891011121314void insert(char str[])&#123; int p = 0; //从根结点开始遍历 for(int i = 0; str[i]; i ++ ) &#123; int u = str[i] - &#x27;a&#x27;; if(!son[p][u]) son[p][u] = ++ idx; //说明该节点没有走过，给它编号 p = son[p][u]; //走到p的子结点u &#125; cnt[p] ++ ; //标记该节点为字符串的末尾，或者记录信息&#125; 查询函数 123456789101112int query(char str[])&#123; int p = 0; for(int i = 0; str[i]; i ++ ) &#123; int u = str[i] - &#x27;a&#x27;; if(!son[p][u]) return 0;//该字符没有插入过 p = son[p][u]; //相当于 p = p -&gt; next 的操作 &#125; return cnt[p];&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int son[N][26], cnt[N]; //每个节点编号都可能作为一个字符串的末尾int idx; //全局变量，记录所有节点的数量char str[N];void insert(char str[])&#123; int p = 0;//从根结点开始遍历 for(int i = 0; str[i]; i ++ ) &#123; int u = str[i] - &#x27;a&#x27;; if(!son[p][u]) son[p][u] = ++ idx; //说明该节点没有走过，给它编号 p = son[p][u]; //走到p的子结点 &#125; cnt[p] ++ ;//标记该节点为字符串的末尾，或者记录信息&#125;int query(char str[])&#123; int p = 0; for(int i = 0; str[i]; i ++ ) &#123; int u = str[i] - &#x27;a&#x27;; if(!son[p][u]) return 0;//该字符没有插入过 p = son[p][u]; &#125; return cnt[p];&#125;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); while(n -- ) &#123; char op[2]; scanf(&quot;%s%s&quot;, op, str); if(op[0] == &#x27;I&#x27;) insert(str); else printf(&quot;%d\\n&quot;, query(str)); &#125; return 0;&#125; AcWing 143. 最大异或对 以二进制数的形式将每个数字存进字典树 然后查询的时候优先寻找是否存在高位数字的异或，没有异或位再去找相同位 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1e5 + 10, M = 31 * N;int n;int a[N];int son[M][2], idx;void insert(int x)&#123; int p = 0; for(int i = 30; i &gt;= 0; i -- ) &#123; int u = x &gt;&gt; i &amp; 1; if(!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; &#125;&#125;int query(int x)&#123; int p = 0, res = 0; for(int i = 30; i &gt;= 0; i -- ) //从高位数字开始 &#123; int u = x &gt;&gt; i &amp; 1; if(son[p][!u]) //优先异或位 &#123; p = son[p][!u]; res = res * 2 + !u; &#125; else &#123; p = son[p][u]; res = res * 2 + u; &#125; &#125; return res;&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for(int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]); int res = 0; for(int i = 0; i &lt; n; i ++ ) &#123; insert(a[i]); int t = query(a[i]); res = max(res, a[i] ^ t); &#125; printf(&quot;%d\\n&quot;, res); return 0;&#125; AcWing 836. 合并集合 并查集是一个树形的结构，每个集合都有一个祖宗节点，每次查找集合成员都会递归的返回该节点对应的父亲节点 12345int find(int x)&#123; if(x != fa[x]) return find(fa[x]); return x;&#125; 路径压缩:将每次查询的节点的父亲节点直接改为祖宗节点 12345int find(int x)&#123; if(p[x] != x) p[x] = find(p[x]); return p[x];&#125; 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int n, m;int p[N];int find(int x)&#123; if(p[x] != x) p[x] = find(p[x]); return p[x];&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i ++ ) p[i] = i; while(m -- ) &#123; char op[2]; int a, b; cin &gt;&gt; op &gt;&gt; a &gt;&gt; b; if(op[0] == &#x27;M&#x27;) p[find(a)] = find(b); else &#123; if(find(a) == find(b)) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; &#125; return 0;&#125; AcWing 837. 连通块中点的数量 利用并查集的特性维护一个记录每个集合有多少个点的数组，cnt数组中祖宗节点对应的下标记录每个集合的点的数量。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int n, m;int p[N], Size[N];int find(int x)&#123; if(p[x] != x) p[x] = find(p[x]); return p[x];&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i ++ ) &#123; p[i] = i; Size[i] = 1; &#125; while(m -- ) &#123; char op[5]; int a, b; cin &gt;&gt; op; if(op[0] == &#x27;C&#x27;) &#123; cin &gt;&gt; a &gt;&gt; b; if(find(a) == find(b)) continue; Size[find(b)] += Size[find(a)]; p[find(a)] = find(b); &#125; else if(op[1] == &#x27;1&#x27;) &#123; cin &gt;&gt; a &gt;&gt; b; if(find(a) == find(b)) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; else &#123; cin &gt;&gt; a; cout &lt;&lt; Size[find(a)] &lt;&lt; endl; &#125; &#125;&#125; AcWing 240. 食物链 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;using namespace std;const int N = 50010;int n, m;int p[N], d[N];int find(int x)&#123; if (p[x] != x) &#123; int t = find(p[x]); //路径压缩，将该点的父节点更新为祖宗节点，并将距离更新 d[x] += d[p[x]]; p[x] = t; &#125; return p[x];&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) p[i] = i; int res = 0; while (m -- ) &#123; int t, x, y; scanf(&quot;%d%d%d&quot;, &amp;t, &amp;x, &amp;y); if (x &gt; n || y &gt; n) res ++ ; else &#123; int px = find(x), py = find(y); //t = 1，x和y应该为同类 if (t == 1) &#123; //当x和y到根节点的距离之差不为0时为假话 if (px == py &amp;&amp; (d[x] - d[y]) % 3) res ++ ; //合并两个集合 else if (px != py) &#123; p[px] = py; d[px] = d[y] - d[x]; &#125; &#125; //t = 2，x和y之间应该为吃与被吃的关系 else &#123; //如果是吃与被吃的关系，那么两点到根节点的距离之差的绝对值应该为1 if (px == py &amp;&amp; (d[x] - d[y] - 1) % 3) res ++ ; //合并集合 else if (px != py) &#123; p[px] = py; d[px] = d[y] + 1 - d[x]; &#125; &#125; &#125; &#125; printf(&quot;%d\\n&quot;, res); return 0;&#125; AcWing 838. 堆排序 为什要从i = n / 2开始down？ 首先要明确要进行down操作时必须满足左儿子和右儿子已经满足堆的性质，即左右子树都是堆。 开始创建堆的时候，元素是随机插入的，所以不能从根节点开始down，而是要找到满足下面三个性质的结点： 左右儿子满足堆的性质。 下标最大（因为要往上遍历） 不是叶结点（叶节点一定满足堆的性质） 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1e5 + 10;int n, m;int h[N], cnt;void down(int u)&#123; int t = u; //t标记最小值 if(u * 2 &lt;= cnt &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; if(u * 2 + 1 &lt;= cnt &amp;&amp; h[2 * u + 1] &lt; h[t]) t = u * 2 + 1; if(u != t) //根结点不是最小值 &#123; swap(h[u], h[t]); down(t); &#125;&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;h[i]); cnt = n; for(int i = n / 2; i; i -- ) down(i); while(m -- ) &#123; printf(&quot;%d &quot;, h[1]); h[1] = h[cnt]; cnt -- ; down(1); &#125; return 0;&#125; AcWing 839. 模拟堆 hp是heap pointer的缩写，表示堆数组中下标到第k个插入的映射 ph是pointer heap的缩写，表示第k个插入到堆数组中的下标的映射 hp和ph数组是互为反函数的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;const int N = 100010;int h[N], ph[N], hp[N], cnt;void heap_swap(int a, int b)&#123; swap(ph[hp[a]],ph[hp[b]]); swap(hp[a], hp[b]); swap(h[a], h[b]);&#125;void down(int u)&#123; int t = u; if (u * 2 &lt;= cnt &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; if (u * 2 + 1 &lt;= cnt &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1; if (u != t) &#123; heap_swap(u, t); down(t); &#125;&#125;void up(int u)&#123; while (u / 2 &amp;&amp; h[u] &lt; h[u / 2]) &#123; heap_swap(u, u / 2); u &gt;&gt;= 1; &#125;&#125;int main()&#123; int n, m = 0; scanf(&quot;%d&quot;, &amp;n); while (n -- ) &#123; char op[5]; int k, x; scanf(&quot;%s&quot;, op); if (!strcmp(op, &quot;I&quot;)) &#123; scanf(&quot;%d&quot;, &amp;x); cnt ++ ; m ++ ; //记录第几次插入 ph[m] = cnt, hp[cnt] = m; //每次插入都是在堆尾插入 h[cnt] = x; //记录插入的值 up(cnt); &#125; else if (!strcmp(op, &quot;PM&quot;)) printf(&quot;%d\\n&quot;, h[1]); else if (!strcmp(op, &quot;DM&quot;)) &#123; heap_swap(1, cnt); cnt -- ; down(1); &#125; else if (!strcmp(op, &quot;D&quot;)) &#123; scanf(&quot;%d&quot;, &amp;k); k = ph[k]; //必须要保存当前被删除结点的位置 heap_swap(k, cnt); //第k个插入的元素移到了堆尾，此时ph[k]指向堆尾 cnt -- ; //删除堆尾 up(k); //k是之前记录被删除的结点的位置 down(k); &#125; else &#123; scanf(&quot;%d%d&quot;, &amp;k, &amp;x); k = ph[k]; h[k] = x; up(k); down(k); &#125; &#125; return 0;&#125; AcWing 840. 模拟散列表 1.拉链法 用一个数组存放头结点，然后将用单链表将对应的数值取模后存进对应的链表中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1e5 + 3;int h[N], e[N], ne[N], idx;void insert(int x)&#123; int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx++;&#125;bool find(int x)&#123; int k = (x % N + N) % N; for(int i = h[k]; i != -1; i = ne[i]) if(e[i] == x) return true; return false;&#125;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); memset(h, -1, sizeof h); while(n--) &#123; char op[2]; int x; scanf(&quot;%s%d&quot;, op, &amp;x); if(*op == &#x27;I&#x27;) insert(x); else &#123; if(find(x)) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; &#125; return 0;&#125; 2.开放寻址法 哈希运算后的位置pos有冲突的话，pos ++直到不冲突为止 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 200003, null = 0x3f3f3f3f;int h[N];int find(int x)&#123; int t = (x % N + N) % N; while (h[t] != null &amp;&amp; h[t] != x) &#123; t ++ ; if (t == N) t = 0; &#125; return t;&#125;int main()&#123; memset(h, 0x3f, sizeof h); int n; scanf(&quot;%d&quot;, &amp;n); while (n -- ) &#123; char op[2]; int x; scanf(&quot;%s%d&quot;, op, &amp;x); if (*op == &#x27;I&#x27;) h[find(x)] = x; else &#123; if (h[find(x)] == null) puts(&quot;No&quot;); else puts(&quot;Yes&quot;); &#125; &#125; return 0;&#125; AcWing 841. 字符串哈希 时间复杂度 $O(n)+O(m)$ 全称字符串前缀哈希法，把字符串变成一个p进制数字（哈希值），实现不同的字符串映射到不同的数字。 对形如 $X1X2X3⋯Xn−1Xn$ 的字符串,采用字符的ascii 码乘上 P 的次方来计算哈希值。 映射公式 $(X1×Pn−1+X2×Pn−2+⋯+Xn−1×P1+Xn×P0)modQ$ 前缀和公式 $h[i+1]=h[i]×P+s[i], i∈[0,n−1]$，h为前缀和数组，s为字符串数组 区间和公式 $h[l,r]=h[r]−h[l−1]×Pr−l+1$ 区间和公式的理解: ABCDE 与 ABC 的前三个字符值是一样，只差两位， 乘上P2把 ABC 变为 ABC00，再用ABCDE - ABC00得到 DE 的哈希值 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;using namespace std;typedef unsigned long long ULL;const int N = 1e5 + 10, P = 131;int n, m;char str[N];ULL h[N], p[N];ULL get(int l, int r)&#123; return h[r] - h[l - 1] * p[r - l + 1];&#125;int main()&#123; scanf(&quot;%d%d%s&quot;, &amp;n, &amp;m, str + 1); p[0] = 1; for(int i = 1; i &lt;= n; i ++) &#123; p[i] = p[i - 1] * P; h[i] = h[i - 1] * P + str[i]; &#125; while(m -- ) &#123; int l1, r1, l2, r2; scanf(&quot;%d%d%d%d&quot;, &amp;l1, &amp;r1, &amp;l2, &amp;r2); if(get(l1, r1) == get(l2, r2)) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.misaka-9982.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Acwing","slug":"Acwing","permalink":"http://www.misaka-9982.com/tags/Acwing/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.misaka-9982.com/tags/Algorithm/"}]},{"title":"第一讲 基础算法","slug":"Acwing-算法基础课-基础算法","date":"2021-10-23T07:29:54.000Z","updated":"2023-02-22T13:07:14.708Z","comments":true,"path":"2021/10/23/Acwing-算法基础课-基础算法/","link":"","permalink":"http://www.misaka-9982.com/2021/10/23/Acwing-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/","excerpt":"","text":"AcWing 785. 快速排序 快速排序本质上是分治法 分解成子问题 递归处理子问题 合并子问题 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int n;int q[N];void quick_sort(int q[], int l, int r)&#123; //递归的边界情况，到这个时候子问题不能继续分解 if(l &gt;= r) return; //分解为子问题 int x = q[(l + r) &gt;&gt; 1], i = l - 1, j = r + 1; while(i &lt; j) &#123; do i ++ ; while(q[i] &lt; x); do j -- ; while(q[j] &gt; x); if(i &lt; j) swap(q[i], q[j]); &#125; //递归处理子问题 quick_sort(q, l, j); quick_sort(q, j + 1, r);&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for(int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;q[i]); quick_sort(q, 0, n - 1); for(int i = 0; i &lt; n; i ++ ) printf(&quot;%d &quot;, q[i]); return 0;&#125; AcWing 786. 第k个数 减治法，分治法的一种形式 每次只需要判断k在左区间还是右区间，一直递归查找k所在区间，另外的一个区间则舍去 最后只剩一个数时，只会有数组[k]一个数，返回数组[k]的值就是答案 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int n, k;int q[N];int quick_sort(int l, int r, int k)&#123; if(l == r) return q[l]; int x = q[l], i = l - 1, j = r + 1; while(i &lt; j) &#123; while(q[ ++ i] &lt; x); while(q[ -- j] &gt; x); if(i &lt; j) swap(q[i], q[j]); &#125; //判断k所在的区间，sl表示左区间的长度 int sl = j - l + 1; //k在左区间 if(k &lt;= sl) return quick_sort(l, j, k); //k在右区间，k - sl表示 k 在右区间的位置 else return quick_sort(j + 1, r, k - sl); &#125;int main()&#123; cin &gt;&gt; n &gt;&gt; k; for(int i = 0; i &lt; n; i ++ ) cin &gt;&gt; q[i]; cout &lt;&lt; quick_sort(0, n - 1, k) &lt;&lt; endl; return 0;&#125; AcWing 787. 归并排序 分治法的典型 分解成子问题 递归处理子问题 合并子问题 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int n;int q[N], tmp[N]; //tmp作为辅助数组void merge_sort(int q[], int l, int r)&#123; //子问题不能再接着分解了 if(l &gt;= r) return; //分解子问题 int mid = l + r &gt;&gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); //合并子问题 int k = 0, i = l, j = mid + 1; while(i &lt;= mid &amp;&amp; j &lt;= r) &#123; if(q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; &#125; while(i &lt;= mid) tmp[k ++ ] = q[i ++ ]; while(j &lt;= r) tmp[k ++ ] = q[j ++ ]; for(i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for(int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;q[i]); merge_sort(q, 0, n - 1); for(int i = 0; i &lt; n; i ++ ) printf(&quot;%d &quot;, q[i]); return 0;&#125; AcWing 788. 逆序对的数量 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;using namespace std;typedef long long LL;const int N = 1e6 + 10;int n;int q[N], tmp[N];LL merge_sort(int l, int r)&#123; if(l &gt;= r) return 0; int mid = l + r &gt;&gt; 1; LL res = merge_sort(l, mid) + merge_sort(mid + 1, r); int k = 0, i = l, j = mid + 1; while(i &lt;= mid &amp;&amp; j &lt;= r) if(q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ]; else &#123; tmp[k ++ ] = q[j ++ ]; res += mid - i + 1; &#125; while(i &lt;= mid) tmp[k ++ ] = q[i ++ ]; while(j &lt;= r) tmp[k ++ ] = q[j ++ ]; for(int i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j]; return res;&#125;int main()&#123; cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++ ) cin &gt;&gt; q[i]; cout &lt;&lt; merge_sort(0, n - 1) &lt;&lt; endl; return 0;&#125; AcWing 789. 数的范围 一道典型的二分法处理的题目 当想找不满足性质的边界值(蓝色区域的右边界值) 找中间值 mid = (l+r+1)/2 if(check(mid))等于true或者是false check(m)是检查m是在不满足性质的区间(检查是不是在蓝色区间) 更新l或者r 此时check函数检查mid是否在蓝色区间内 if check(mid)== true :说明mid在蓝色区间内，那么应该在区间[mid, r]寻找蓝色区间的右边界值，l = mid if check(mid)== false:说明mid在红色区间内，那么应该在区间[l, mid - 1]寻找蓝色区间的右边界值，r = mid - 1 当想找满定在质的五界值(红色区域的差边界值) 找中间值mid = (l+r)/2 if(check(mid))等于true或者是false check(m)是检查m是在满足性质的区间(检查是不是在红色区间) 更新l或者r 此时check函数检查mid是否在红色区间内 if check(mid)== false:说明mid在蓝色区间内，那么，应该在区间[mid + 1, r]中寻找红色区间的左边界值，即l= mid + 1 if check(mid)== true:说明mid在红色区间内，那么，应该在区间[l, mid]中寻找红色区间的左边界值，即r = mid 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int n, m;int q[N];int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;q[i]); while(m -- ) &#123; int x; scanf(&quot;%d&quot;, &amp;x); int l = 0, r = n - 1; //检查左边界 while(l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if(q[mid] &gt;= x) r = mid; else l = mid + 1; &#125; if(q[l] != x) cout &lt;&lt; &quot;-1 -1&quot; &lt;&lt; endl; else &#123; cout &lt;&lt; l &lt;&lt; &quot; &quot;; int l = 0, r = n - 1; //检查右边界 while(l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; if(q[mid] &lt;= x) l = mid; else r = mid - 1; &#125; cout &lt;&lt; r &lt;&lt; endl; &#125; &#125; return 0;&#125; AcWing 790. 数的三次方根 二分法处理问题 123456789101112131415161718#include&lt;iostream&gt;using namespace std;int main()&#123; double x; cin &gt;&gt; x; double l = -10000, r = 10000; while(r - l &gt; 1e-8) &#123; double mid = (l + r) / 2; if(mid * mid * mid &gt;= x) r = mid; else l = mid; &#125; printf(&quot;%lf&quot;, l); return 0;&#125; AcWing 791. 高精度加法 模拟一下列竖式进行加法运算，使用一个变量carry，进行进位的操作， 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123; vector&lt;int&gt; C; int t; for(int i = 0; i &lt; A.size() || i &lt; B.size(); i ++ ) &#123; if(i &lt; A.size()) t += A[i]; if(i &lt; B.size()) t += B[i]; C.push_back(t % 10); t /= 10; &#125; if(t) C.push_back(1); return C;&#125;int main()&#123; string a, b; vector&lt;int&gt; A, B; cin &gt;&gt; a &gt;&gt; b; for(int i = a.size() - 1; i &gt;= 0; i -- ) A.push_back(a[i] - &#x27;0&#x27;); for(int i = b.size() - 1; i &gt;= 0; i -- ) B.push_back(b[i] - &#x27;0&#x27;); auto C = add(A, B); for(int i = C.size() - 1; i &gt;= 0; i -- ) printf(&quot;%d&quot;, C[i]); return 0;&#125; AcWing 792. 高精度减法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;bool cmp(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123; if(A.size() != B.size()) return A.size() &gt; B.size(); for(int i = A.size() - 1; i &gt;= 0; i -- ) if(A[i] != B[i]) return A[i] &gt; B[i]; return true;&#125;vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123; vector&lt;int&gt; C; for(int i = 0, t = 0; i &lt; A.size(); i ++ ) &#123; t = A[i] - t; if(i &lt; B.size()) t -= B[i]; C.push_back((t + 10) % 10); if(t &lt; 0) t = 1; else t = 0; &#125; while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C; &#125;int main()&#123; string a, b; vector&lt;int&gt; A, B; cin &gt;&gt; a &gt;&gt; b; for(int i = a.size() - 1; i &gt;= 0; i -- ) A.push_back(a[i] - &#x27;0&#x27;); for(int i = b.size() - 1; i &gt;= 0; i -- ) B.push_back(b[i] - &#x27;0&#x27;); if(cmp(A, B)) &#123; auto C = sub(A, B); for(int i = C.size() - 1; i &gt;= 0; i -- ) printf(&quot;%d&quot;, C[i]); &#125; else &#123; auto C = sub(B, A); printf(&quot;-&quot;); for(int i = C.size() - 1; i &gt;= 0; i -- ) printf(&quot;%d&quot;, C[i]); &#125; return 0;&#125; AcWing 793. 高精度乘法 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123; vector&lt;int&gt; C(A.size() + B.size()); for(int i = 0; i &lt; A.size(); i ++ ) for(int j = 0; j &lt; B.size(); j ++ ) C[i + j] += A[i] * B[j]; for(int i = 0, t = 0; i &lt; C.size() || t; i ++ ) &#123; t += C[i]; if(i &gt;= C.size()) C.push_back(t % 10); else C[i] = t % 10; t /= 10; &#125; while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C;&#125;int main()&#123; string a, b; cin &gt;&gt; a &gt;&gt; b; vector&lt;int&gt; A, B; for(int i = a.size() - 1; i &gt;= 0; i -- ) A.push_back(a[i] - &#x27;0&#x27;); for(int i = b.size() - 1; i &gt;= 0; i -- ) B.push_back(b[i] - &#x27;0&#x27;); auto C = mul(A, B); for(int i = C.size() - 1; i &gt;= 0; i -- ) cout &lt;&lt; C[i]; puts(&quot;&quot;); return 0;&#125; AcWing 794. 高精度除法 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;vector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)&#123; vector&lt;int&gt; C; r = 0; for(int i = A.size() - 1; i &gt;= 0; i -- ) &#123; r = r * 10 + A[i]; C.push_back(r / b); r = r % b; &#125; reverse(C.begin(), C.end()); while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C;&#125;int main()&#123; string a; int b; cin &gt;&gt; a &gt;&gt; b; vector&lt;int&gt; A; for(int i = a.size() - 1; i &gt;= 0; i -- ) A.push_back(a[i] - &#x27;0&#x27;); int r; auto C = div(A, b, r); for(int i = C.size() - 1; i &gt;= 0; i -- ) printf(&quot;%d&quot;, C[i]); cout &lt;&lt; endl &lt;&lt; r &lt;&lt; endl; return 0;&#125; AcWing 795. 前缀和 原数组: a[1], a[2], a[3], a[4], a[5], …, a[n] 前缀和:S[i] = a[1] + a[2] + a[3] + … + a[i] 作用：可以快速求出数组中某一段连续区间的和 用法：求数组a[l],a[l + 1], a[l + 2], ..., a[r]的和，即S[r] - S[l - 1] 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int n, m;int a[N], s[N];int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]); for(int i = 1; i &lt;= n; i ++ ) s[i] = s[i - 1] + a[i]; while(m -- ) &#123; int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); printf(&quot;%d\\n&quot;, s[r] - s[l - 1]); &#125; return 0;&#125; AcWing 796. 子矩阵的和 S[i, j]表示从a[1, 1] 到 a[i, j] 这个矩阵的元素的和 $S[i,j]=S[i,j−1]+S[i−1,j]−S[i−1,j−1]+a[i,j]$ (x1,y1) 到 (x2, y2)这个子矩阵的计算公式 $S[x2,y2]−S[x1−1,y2]−S[x2,y1−1]+S[x1−1,y1−1]$ 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;const int N = 1010;int m, n, q;int a[N][N], s[N][N];int main()&#123; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q); for(int i = 1; i &lt;= n; i ++ ) for(int j = 1; j &lt;= m; j ++ ) scanf(&quot;%d&quot;, &amp;a[i][j]); for(int i = 1; i &lt;= n; i ++ ) for(int j = 1; j &lt;= m; j ++ ) s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j]; while(q -- ) &#123; int x1, y1, x2, y2; scanf(&quot;%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2); printf(&quot;%d\\n&quot;, s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]); &#125; return 0;&#125; AcWing 797. 差分 首先给定一个原数组a：$a[1], a[2], a[3], a[n];$ 然后我们构造一个数组b ：$b[1] ,b[2] , b[3], b[i];$ 使得 $a[i] = b[1] + b[2 ]+ b[3] +, + b[i]$ $a[0 ]= 0;$ $b[1] = a[1] - a[0];$ $b[2] = a[2] - a[1];$ $b[3] =a [3] - a[2];$ … $b[n] = a[n] - a[n-1];$ 由公式可以得知，数组a是数组b的前缀和数组，反过来，数组b是数组a的差分数组 应用场景： 给定区间[l ,r]，让我们把a数组中的[l, r]区间中的每一个数都加上c,即 $a[l] + c , a[l+1] + c , a[l+2] + c ,… , a[r] + c;$ 如果单纯使用for循环去做加法，那么m次加上c的时间复杂度则为$O(n \\cdot m)$ 这个时候要将时间复杂度降低就可以使用差分数组了 a数组是b数组的前缀和数组，比如对b数组的b[i]的修改，会影响到a数组中从a[i]及往后的每一个数。 首先让差分b数组中的 $b[l] + c$ ,a数组变成 $a[l] + c ,a[l+1] + c,…, a[n] + c$; 然后为了避免对数组中坐标r之后的值造成影响，$b[r+1] - c$, a数组变成 $a[r+1] - c,a[r+2] - c,…,a[n] - c$; 因此一维差分对a数组的[l, r]区间同时加上一个数c，只需要对其差分数组b，做出$b[l] += c$, $b[r + 1] -= c$ 的操作，时间复杂度为$O(1)$，m次操作的总体时间复杂度则从$O(n*m)$降低到$O(m)$ 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int n, m;int a[N], b[N];void insert(int l, int r, int c)&#123; b[l] += c; b[r + 1] -= c;&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]); for(int i = 1; i &lt;= n; i ++ ) insert(i, i, a[i]); while(m -- ) &#123; int l, r, c; scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;c); insert(l, r, c); &#125; for(int i = 1; i &lt;= n; i ++ ) b[i] += b[i - 1]; for(int i = 1; i &lt;= n; i ++ ) printf(&quot;%d &quot;, b[i]); return 0;&#125; AcWing 798. 差分矩阵 与一维前缀和延伸至二维前缀和的过程类似 一维差分延伸至二维差分 核心操作： $b[x1][y1] += c;$ $b[x2 + 1][y1] -= c;$ $b[x1][y2 + 1] -= c;$ $b[x2 + 1][y2 + 1] += c;$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;const int N = 1010;int n, m, q;int a[N][N], b[N][N];void insert(int x1, int y1, int x2, int y2, int c)&#123; b[x1][y1] += c; b[x2 + 1][y1] -= c; b[x1][y2 + 1] -= c; b[x2 + 1][y2 + 1] += c;&#125;int main()&#123; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q); for(int i = 1; i &lt;= n; i ++ ) for(int j = 1; j &lt;= m; j ++ ) scanf(&quot;%d&quot;, &amp;a[i][j]); for(int i = 1; i &lt;= n; i ++ ) for(int j = 1; j &lt;= m; j ++ ) insert(i, j, i, j, a[i][j]); while(q -- ) &#123; int x1, y1, x2, y2, c; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c; insert(x1, y1, x2, y2, c); &#125; for(int i = 1; i &lt;= n; i ++ ) for(int j = 1; j &lt;= m; j ++ ) b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1]; for(int i = 1; i &lt;= n; i ++ ) &#123; for(int j = 1; j &lt;= m; j ++ ) printf(&quot;%d &quot;, b[i][j]); puts(&quot;&quot;); &#125; return 0;&#125; AcWing 799. 最长连续不重复子序列 双指针算法。 使用一个数组s维护当前找到的区间 [i, j] 中数字的个数。 如果出现重复数字，那么指针 i 向后移动一位，并且哈希表中这个数字的出现次数减一，直到没有重复字符为止，使用了一个while循环实现 如果没有重复数组，那么指针 j 向后移动一位，同时s中对应的数字出现次数加一 在这个过程中使用res记录子序列长度的最大值。 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int a[N], s[N];int n;int main()&#123; cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++ ) cin &gt;&gt; a[i]; int res = 0; for(int i = 0, j = 0; i &lt; n; i ++ ) &#123; s[a[i]] ++ ; while(s[a[i]] &gt; 1) &#123; s[a[j]] -- ; j ++ ; &#125; res = max(res, i - j + 1); &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; AcWing 800. 数组元素的目标和 i从 0开始 从前往后遍历 j从 m - 1开始 从后向前遍历,j指针不会回退 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int n, m, x;int a[N], b[N];int main()&#123; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;x); for(int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]); for(int i = 0; i &lt; m; i ++ ) scanf(&quot;%d&quot;, &amp;b[i]); for(int i = 0, j = m - 1; i &lt; n; i ++ ) &#123; while(j &gt; 0 &amp;&amp; a[i] + b[j] &gt; x) j -- ; if(j &gt;= 0 &amp;&amp; a[i] + b[j] == x) cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl; &#125; return 0;&#125; AcWing 2816. 判断子序列 j指针用来扫描整个b数组，i指针用来扫描a数组。若发现a[i]==b[j]，则让i指针后移一位。 整个过程中，j指针不断后移，而i指针只有当匹配成功时才后移一位，若最后若i==n，则说明匹配成功。 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int n, m;int a[N], b[N];int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i ++ ) cin &gt;&gt; a[i]; for(int i = 0; i &lt; m; i ++ ) cin &gt;&gt; b[i]; int j = 0; for(int i = 0; i &lt; m; i ++ ) if(b[i] == a[j]) j ++ ; if(j == n) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; return 0;&#125; AcWing 801. 二进制中1的个数 按位与运算 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;int lowBit(int x)&#123; return x &amp; -x;&#125;int main()&#123; int n; cin &gt;&gt; n; while(n -- ) &#123; int x; cin &gt;&gt; x; int res = 0; while(x) &#123; x -= lowBit(x); res ++ ; &#125; cout &lt;&lt; res &lt;&lt; &quot; &quot;; &#125; return 0;&#125; AcWing 802. 区间和 题解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 3e5 + 10;int n, m;int a[N], s[N];vector&lt;int&gt; all;vector&lt;PII&gt; add, query;int find(int x)&#123; int l = 0, r = all.size() - 1; while(l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if(all[mid] &gt;= x) r = mid; else l = mid + 1; &#125; return r + 1;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i ++ ) &#123; int x, c; cin &gt;&gt; x &gt;&gt; c; add.push_back(&#123;x, c&#125;); all.push_back(x); &#125; for(int i = 0; i &lt; m; i ++ ) &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; query.push_back(&#123;l, r&#125;); all.push_back(l); all.push_back(r); &#125; sort(all.begin(), all.end()); all.erase(unique(all.begin(), all.end()), all.end()); for(auto item : add) &#123; int x = find(item.first); a[x] += item.second; &#125; for(int i = 1; i &lt;= all.size(); i ++ ) s[i] = s[i - 1] + a[i]; for(auto item : query) &#123; int l = find(item.first), r = find(item.second); cout &lt;&lt; s[r] - s[l - 1] &lt;&lt; endl; &#125; return 0;&#125; AcWing 803. 区间合并 思想方法类似于贪心 先给每个区间按左端点排序 遍历每个区间 如果第二个区间起点小于第一个区间终点，那么就是有交集，将第一个区间的终点更新为第二个区间的终点 如果没有交集，那么将前面更新完毕的区间存储起来 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;typedef pair&lt;int, int&gt; PII;int n;vector&lt;PII&gt; seg;void merge(vector&lt;PII&gt; &amp;Seg)&#123; vector&lt;PII&gt; res; int st = -2e9, ed = -2e9; sort(Seg.begin(), Seg.end()); for(auto seg : Seg) &#123; if(ed &lt; seg.first) &#123; if(ed != -2e9) res.push_back(&#123;st, ed&#125;); st = seg.first; ed = seg.second; &#125; else ed = max(ed, seg.second); &#125; if(st != -2e9) res.push_back(&#123;st, ed&#125;); Seg = res; &#125;int main()&#123; cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++ ) &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; seg.push_back(&#123;l, r&#125;); &#125; merge(seg); cout &lt;&lt; seg.size() &lt;&lt; endl; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.misaka-9982.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Acwing","slug":"Acwing","permalink":"http://www.misaka-9982.com/tags/Acwing/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.misaka-9982.com/tags/Algorithm/"}]},{"title":"CPP-OJ","slug":"CPP-OJ","date":"2021-07-12T04:51:16.000Z","updated":"2023-02-22T13:07:14.708Z","comments":true,"path":"2021/07/12/CPP-OJ/","link":"","permalink":"http://www.misaka-9982.com/2021/07/12/CPP-OJ/","excerpt":"","text":"题目源自某高校C++的OJ 将做过的C++ OJ题目整理合并了一下，总共有一百多道题目，手动合并自然是不可能的 这个时候我们就可以使用shell脚本来取代这种机械化的重复劳动了，由于写成博客需要使用Markdown文档，我们就结合md文档的语法来编写这个merge.sh脚本吧 1vim merge.sh 脚本内容： 123456789101112#!/usr/bin/env bashls *.cpp |while read file_name;do echo &quot;### $&#123;file_name%.*&#125;:&quot; &gt;&gt; all.md echo &#x27;```cpp&#x27; &gt;&gt; all.md cat &quot;$file_name&quot; &gt;&gt; all.md echo &quot;&quot; &gt;&gt; all.md echo &#x27;```&#x27; &gt;&gt; all.md echo &quot;&quot; &gt;&gt; all.mddone 最后赋予执行权限： 12chmod +x merge.sh./merge.sh 大功告成啦 郑重声明 代码仅供参考，请勿直接抄袭，本文字数过多，请善用Ctrl + F进行检索 A. 身体评估（类与对象）: 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;class Person&#123;public: string name; double high, weight, yao; double a, b, BMI, percent; void ope() &#123; a = yao * 0.74; b = weight * 0.082 + 34.89; BMI = weight / (high * high); percent = (a - b) / weight; if(BMI - (int)BMI &gt;= 0.5) BMI = (int) BMI + 1; else BMI = (int) BMI; &#125; void print() &#123; cout &lt;&lt; name; printf(&quot;的BMI指数为%.0lf--体脂率为%.2lf\\n&quot;, BMI, percent); &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; Person p; cin &gt;&gt; p.name &gt;&gt; p.high &gt;&gt; p.weight &gt;&gt; p.yao; p.ope(); p.print(); &#125; return 0;&#125; B. 最胖的加菲（类与对象+数组）: 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;class Cat&#123; string name; int weight;public: void get() &#123; cin &gt;&gt; name &gt;&gt; weight; &#125; int wei() &#123; return weight; &#125; string getName() &#123; return name; &#125;&#125;;bool cmp(Cat A, Cat B)&#123; return A.wei() &lt; B.wei();&#125;int main()&#123; int t; cin &gt;&gt; t; Cat *cat = new Cat[t]; for(int i = 0; i &lt; t; i ++ ) cat[i].get(); sort(cat, cat + t, cmp); for(int i = 0; i &lt; t; i ++ ) cout &lt;&lt; cat[i].getName() &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; return 0;&#125; C. 音像制品（类与对象）: 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;class Product&#123; string lei[4] = &#123;&quot;黑胶片&quot;, &quot;CD&quot;, &quot;VCD&quot;, &quot;DVD&quot;&#125;; string st[2] = &#123;&quot;未出租&quot;,&quot;已出租&quot;&#125;; int leixin, price, state, cnt; string name;public: Product() &#123; cin &gt;&gt; leixin &gt;&gt; name &gt;&gt; price &gt;&gt; state; cin &gt;&gt; cnt; &#125; void Print() &#123; cout &lt;&lt; lei[leixin - 1] &lt;&lt; &quot;[&quot; &lt;&lt; name &lt;&lt; &quot;]&quot; &lt;&lt; st[state] &lt;&lt; endl; if(cnt) &#123; if(cnt * price &amp;&amp; state) &#123; cout &lt;&lt; &quot;当前租金为&quot; &lt;&lt; cnt * price &lt;&lt; endl; &#125; else cout &lt;&lt; &quot;未产生租金&quot; &lt;&lt; endl; &#125; &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; Product p; p.Print(); &#125; return 0;&#125; D. 三角形类(构造与析构): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;class Triangle&#123;public: double a[3]; string lei; Triangle() &#123; cin &gt;&gt; a[0] &gt;&gt; a[1] &gt;&gt; a[2]; sort(a, a + 3); if(a[0] + a[1] &lt;= a[2]) cout &lt;&lt; &quot;no triangle&quot; &lt;&lt; endl; else &#123; double p = (a[0] + a[1] + a[2]) / 2; double S = sqrt(p * (p - a[0]) * (p - a[1]) * (p - a[2])); double b = a[0] * a[0], c = a[1] * a[1], d = a[2] * a[2]; if(b + c - d &lt; 1e-3) &#123; if(a[0] == a[1]) lei = &quot;isosceles right triangle&quot;; else lei = &quot;right triangle&quot;; &#125; else if(a[0] == a[1] &amp;&amp; a[1] == a[2]) lei = &quot;equilateral triangle&quot;; else lei = &quot;general triangle&quot;; cout &lt;&lt; lei; printf(&quot;, %.1lf\\n&quot;, S); &#125; &#125; ~Triangle() &#123; for(int i = 0; i &lt; 3; i ++ ) a[i] = 0; lei = &quot;none&quot;; &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; Triangle tri; &#125; return 0;&#125; E. CPU调度（类与对象）: 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;class Process&#123; string name; int time_wait, time_run, level;public: void getLevel(); void display(); int Le();&#125;;int Process::Le() &#123; return level;&#125;void Process::getLevel()&#123; cin &gt;&gt; name &gt;&gt; time_wait &gt;&gt; time_run; level = time_wait / time_run;&#125;void Process::display()&#123;cout &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; time_wait &lt;&lt; &quot; &quot; &lt;&lt; time_run &lt;&lt; &quot; &quot; &lt;&lt; level &lt;&lt; endl;&#125;bool cmp(Process A, Process B)&#123; return A.Le() &gt; B.Le();&#125;int main()&#123; Process p[3]; for(int i = 0; i &lt; 3; i ++ ) &#123; p[i].getLevel(); &#125; sort(p, p + 3, cmp); p[0].display(); return 0;&#125; F. 手机取款（类与对象数组）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;class Count&#123; //��Ա���� string CardId, Phone, Password; int num;public: void get()//�����Ա���� &#123; cin &gt;&gt; CardId &gt;&gt; Phone &gt;&gt; Password &gt;&gt; num; &#125; string getPhone() &#123; return Phone;//���ص绰�����ֵ &#125; bool SignIn(string pa) &#123; if(pa != Password)//������� &#123; cout &lt;&lt; &quot;�������&quot; &lt;&lt; endl; return 0; &#125;else return 1; &#125; void getMoney(int n)//ȡǮ &#123; //Ǯ���� if(n &gt; num) cout &lt;&lt; &quot;����&quot; &lt;&lt; CardId &lt;&lt; &quot;--����&quot; &lt;&lt; endl; else//Ǯ���ˣ���Ǯ &#123; num -= n; cout &lt;&lt; &quot;����&quot; &lt;&lt; CardId &lt;&lt; &quot;--���&quot; &lt;&lt; num &lt;&lt; endl; &#125; &#125;&#125;;int main()&#123; int n; cin &gt;&gt; n; Count custom[n]; for(int i = 0; i &lt; n; i ++ ) &#123; custom[i].get();//��ȡ���������Ա������ &#125; int k; cin &gt;&gt; k;//�����ٴβ��� while(k -- ) &#123; string Phone, PassWord; int num, flag = 0, i; cin &gt;&gt; Phone &gt;&gt; PassWord &gt;&gt; num; for(i = 0; i &lt; n; i ++ )//ѭ����������������ֻ��� &#123; if(custom[i].getPhone() == Phone) &#123; flag = 1;//flag ����ֻ����Ƿ���� break; &#125; &#125; if(!flag) cout &lt;&lt; &quot;�ֻ��Ų�����&quot; &lt;&lt; endl; else &#123; int res = custom[i].SignIn(PassWord); if(res != 0)//res ����Ƿ��¼�ɹ� &#123; custom[i].getMoney(num); &#125; &#125; &#125;&#125; G. Point&amp;Circle(复合类与构造): 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;class Point&#123;public: double x, y; Point() &#123; x = 0, y = 0; &#125;&#125;;class Circle&#123;public: Point centre; double radius; Circle() &#123; centre.x = 0, centre.y = 0; radius = 1; &#125; Circle(double new_x, double new_y, double r) &#123; centre.x = new_x, centre.y = new_y, radius = r; &#125; void setCentre(double new_x, double new_y) &#123; centre.x = new_x, centre.y = new_y; &#125; int contain(Point &amp;t) &#123; double a = (t.x - centre.x) * (t.x - centre.x); double b = (t.y - centre.y) * (t.y - centre.y); if(a + b - radius * radius &lt;= 1e-3) cout &lt;&lt; &quot;inside&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;outside&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; int x, y, r; cin &gt;&gt; x &gt;&gt; y &gt;&gt; r; Circle ci(x, y, r); int n; cin &gt;&gt; n; Point p[n]; for(int i = 0; i &lt; n; i ++ ) &#123; cin &gt;&gt; p[i].x &gt;&gt; p[i].y; &#125; for(int i = 0; i &lt; n; i ++ ) &#123; ci.contain(p[i]); &#125; cout &lt;&lt; &quot;after move the centre of circle:&quot; &lt;&lt; endl; cin &gt;&gt; x &gt;&gt; y; ci.setCentre(x, y); for(int i = 0; i &lt; n; i ++ ) &#123; ci.contain(p[i]); &#125; return 0;&#125; H. Equation(类与对象+构造): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;class Equation&#123; double a, b, c;public: Equation() &#123; a = 1, b = 1, c = 0; &#125; void set() &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; &#125; void getRoot() &#123; double x1, x2, delta; delta = b * b - 4 * a * c; if(delta &gt; 0) &#123; x1 = (-b + sqrt(delta)) / (2 * a); x2 = (-b - sqrt(delta)) / (2 * a); printf(&quot;x1=%.2lf x2=%.2lf\\n&quot;, x1, x2); &#125; else if(delta == 0) &#123; x1 = -b / (2 * a); printf(&quot;x1=x2=%.2lf\\n&quot;, x1); &#125; else &#123; double an = sqrt(-delta) / (2 * a); x1 =(-b)/ (2 * a); printf(&quot;x1=%.2lf+%.2lfi x2=%.2lf-%.2lfi\\n&quot;, x1, an, x1, an); &#125; &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; Equation e; e.set(); e.getRoot(); &#125; return 0;&#125; I. Complex(类与对象+构造): 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;class Complex&#123; int shi, xu;public: Complex() &#123; shi = 1, xu = 1; &#125; Complex(int a, int b) &#123; shi = a, xu = b; &#125; Complex &amp;add(Complex &amp;C) &#123; shi += C.shi, xu += C.xu; return *this; &#125; Complex &amp;sub(Complex &amp;C) &#123; shi -= C.shi, xu -= C.xu; return *this; &#125; void Print1() &#123; cout &lt;&lt; &quot;sum:&quot;; if(shi != 0) cout &lt;&lt; shi; if(xu &gt; 1 &amp;&amp; shi != 0) cout &lt;&lt; &quot;+&quot; &lt;&lt; xu &lt;&lt; &quot;i&quot;; else if(xu == 1 &amp;&amp; shi != 0) cout &lt;&lt; &quot;+&quot; &lt;&lt; &quot;i&quot;; else if(xu &gt; 1 &amp;&amp; shi == 0) cout &lt;&lt; xu &lt;&lt; &quot;i&quot;; else if(xu == 1 &amp;&amp; shi == 0) cout &lt;&lt; &quot;i&quot;; else if(xu &lt; 0) cout &lt;&lt; xu &lt;&lt; &quot;i&quot;; if(shi == 0 &amp;&amp; xu == 0) cout &lt;&lt; 0; cout &lt;&lt; endl; &#125; void Print0() &#123; cout &lt;&lt; &quot;remainder:&quot;; if(shi != 0) cout &lt;&lt; shi; if(xu &gt; 1 &amp;&amp; shi != 0) cout &lt;&lt; &quot;+&quot; &lt;&lt; xu &lt;&lt; &quot;i&quot;; else if(xu == 1 &amp;&amp; shi != 0) cout &lt;&lt; &quot;+&quot; &lt;&lt; &quot;i&quot;; else if(xu &gt; 1 &amp;&amp; shi == 0) cout &lt;&lt; xu &lt;&lt; &quot;i&quot;; else if(xu == 1 &amp;&amp; shi == 0) cout &lt;&lt; &quot;i&quot;; else if(xu &lt; 0) cout &lt;&lt; xu &lt;&lt; &quot;i&quot;; if(shi == 0 &amp;&amp; xu == 0) cout &lt;&lt; 0; cout &lt;&lt; endl; &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; int a, b, c, d; while(t -- ) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; Complex co(a, b), co1(c, d); Complex c = co, c1 = co1; c.add(c1); c.Print1(); co.sub(co1); co.Print0(); &#125; return 0;&#125; J. 分数运算（类+构造）: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;class num_fen&#123; int a, b;//a 为分子， b为分母public: num_fen();//无参构造，可以不用写这个 num_fen(int na, int nb);//有参构造 void get();//输入分子分母的值 num_fen add(num_fen &amp;num1);//分数加法 num_fen mul(num_fen &amp;num1); void Display();&#125;;num_fen::num_fen() &#123; a = 0, b = 1;&#125;num_fen::num_fen(int na, int nb) &#123; a = na, b = nb; if(b &lt; 0) b = -b, a = -a;&#125;void num_fen::get() &#123; cin &gt;&gt; a &gt;&gt; b;&#125;num_fen num_fen::add(num_fen &amp;num1) &#123; int a0 = a * num1.b + b * num1.a; int b0 = b * num1.b; num_fen num2(a0, b0); return num2;&#125;num_fen num_fen::mul(num_fen &amp;num1) &#123; int a0 = a * num1.a; int b0 = b * num1.b; num_fen num2(a0, b0); return num2;&#125;void num_fen::Display() &#123; printf(&quot;%d/%d&quot;, a, b);&#125;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; num_fen num0, num1; num0.get(), num1.get(); num0.Display(); cout &lt;&lt; &quot; &quot;; num1.Display(); cout &lt;&lt; endl; num_fen num2 = num0.add(num1); num_fen num3 = num0.mul(num1); num2.Display(); cout &lt;&lt; endl; num3.Display(); cout &lt;&lt; endl; &#125; return 0;&#125; K. 存折类定义（类与对象）: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;class Account&#123;public: string name, acc; double balance; Account() &#123; cin &gt;&gt; acc &gt;&gt; name &gt;&gt; balance; &#125; void check() &#123; cout &lt;&lt; name &lt;&lt; &quot;&#x27;s balance is &quot; &lt;&lt; balance &lt;&lt; endl; &#125; void deposit() &#123; double num; cin &gt;&gt; num; balance += num; cout &lt;&lt; &quot;saving ok!&quot; &lt;&lt; endl; &#125; void withdraw() &#123; double num; cin &gt;&gt; num; if(num &gt; balance) cout &lt;&lt; &quot;sorry! over limit!&quot; &lt;&lt; endl; else &#123; balance -= num; cout &lt;&lt; &quot;withdraw ok!&quot; &lt;&lt; endl; &#125; &#125;&#125;;int main()&#123; for(int i = 0; i &lt; 2; i ++ ) &#123; Account a; a.check(); a.deposit(); a.check(); a.withdraw(); a.check(); &#125; return 0;&#125; L. 五子棋简单实现（类和对象）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#include&lt;iostream&gt;using namespace std;const char black_chess = &#x27;#&#x27;, white_chess = &#x27;@&#x27;;const char black = &#x27;u&#x27;, white = &#x27;o&#x27;;class play_table&#123; bool over;//判断游戏是否结束 bool hefa; //判断操作是否合法 bool state;//判断下一轮的状态，0为黑子，1为白子 int winner; //判断赢家是谁,0为黑子， 1为白子public: char table[16][16]; play_table() &#123; over = false, hefa = true, state = 0; for(int i = 1; i &lt;= 15; i ++ ) for(int j = 1; j &lt;= 15; j ++ ) table[i][j] = &#x27;0&#x27;; &#125; bool getOver() &#123; return over; &#125; void check(char ch) &#123; bool flag = false; int cnt = 0; //横行判断 for(int i = 1; i &lt;= 15; i ++ ) for(int j = 1; j &lt;= 11; j ++ ) &#123; if(table[i][j] == ch &amp;&amp; table[i][j + 1] == ch &amp;&amp; table[i][j + 2] == ch &amp;&amp; table[i][j + 3] == ch &amp;&amp; table[i][j + 4] == ch) &#123; flag = true; break; &#125; &#125; //竖列判断 for(int i = 1; i &lt;= 11; i ++ ) for(int j = 1; j &lt;= 15; j ++ ) &#123; if(table[i][j] == ch &amp;&amp; table[i + 1][j] == ch &amp;&amp; table[i + 2][j] == ch &amp;&amp; table[i + 3][j] == ch &amp;&amp; table[i + 4][j] == ch) &#123; flag = true; break; &#125; &#125; //主对角线及平行 for(int i = 1; i &lt;= 11; i ++ ) for(int j = 1; j &lt;= 11; j ++ ) &#123; if(table[i][j] == ch &amp;&amp; table[i + 1][j + 1] == ch &amp;&amp; table[i + 2][j + 2] == ch &amp;&amp; table[i + 3][j + 3] == ch &amp;&amp; table[i + 4][j + 4] == ch) &#123; flag = true; break; &#125; &#125; //副对角线及平行 for(int i = 1; i &lt;= 11; i ++ ) for(int j = 5; j &lt;= 15; j ++ ) &#123; if(table[i][j] == ch &amp;&amp; table[i + 1][j - 1] == ch &amp;&amp; table[i + 2][j - 2] == ch &amp;&amp; table[i + 3][j - 3] == ch &amp;&amp; table[i + 4][j - 4] == ch) &#123; flag = true; break; &#125; &#125; if(flag) &#123; over = true; if(ch == black_chess) winner = 0; else winner = 1; &#125; &#125; void play(char ch,int x, int y) &#123; //是否落在棋盘内 if(x &lt;= 15 &amp;&amp; x &gt;= 1 &amp;&amp; y &lt;= 15 &amp;&amp; y &gt;= 1) &#123; if(table[x][y] != &#x27;0&#x27;)//操作不合法 &#123; hefa = false; if(ch == black) state = 0; else state = 1; &#125; else//操作合法 &#123; hefa = true; if (ch == black) &#123; state = 1; table[x][y] = black_chess; &#125; else &#123; state = 0; table[x][y] = white_chess; &#125; &#125; &#125; else &#123; hefa = false; if(ch == black) state = 0; else state = 1; &#125; check(black_chess), check(white_chess); &#125; void print() &#123; for(int i = 1; i &lt;= 15; i ++ ) &#123; for (int j = 1; j &lt;= 15; j++) cout &lt;&lt; table[i][j] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; &#125; if(!over) &#123; if(state == 0) cout &lt;&lt; &quot;黑子继续&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;白子继续&quot; &lt;&lt; endl; &#125; else &#123; if(winner == 0) cout &lt;&lt; &quot;黑子胜&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;白子胜&quot; &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; int n; play_table ta; cin &gt;&gt; n; while(n -- ) &#123; char ch; int x, y; cin &gt;&gt; ch &gt;&gt; x &gt;&gt; y; if(!ta.getOver()) &#123; ta.play(ch, x, y); &#125; &#125; ta.print(); &#125; return 0;&#125; M. 买彩游戏（类和对象）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;class Pride&#123;public: int **caipiao, zhongjiang[7]; int cnt[3] = &#123;0&#125;; int num; string name; Pride() &#123; cin &gt;&gt; num; cin &gt;&gt; name; caipiao = new int*[num]; for(int i = 0; i &lt; num; i ++ ) caipiao[i] = new int[7]; for(int i = 0; i &lt; num; i ++ ) for(int j = 0; j &lt; 7; j ++ ) cin &gt;&gt; caipiao[i][j]; for(int i = 0; i &lt; 7; i ++ ) cin &gt;&gt; zhongjiang[i]; &#125; void cmp() &#123; for(int i = 0; i &lt; num; i ++ ) &#123; int count = 0; for(int j = 0; j &lt; 7; j ++ ) if(caipiao[i][j] == zhongjiang[j]) count ++ ; if(count == 7) cnt[0] ++ ; else if(count &gt;= 5) cnt[1] ++ ; else if(count &gt;= 2) cnt[2] ++ ; &#125; &#125; void print() &#123; if(cnt[0] != 0) cout&lt;&lt;&quot;恭喜&quot;&lt;&lt; name &lt;&lt;&quot;中了&quot; &lt;&lt; cnt[0] &lt;&lt; &quot;注一等奖！&quot;&lt;&lt;endl; if(cnt[1] != 0) cout&lt;&lt;&quot;恭喜&quot;&lt;&lt; name &lt;&lt;&quot;中了&quot; &lt;&lt; cnt[1] &lt;&lt; &quot;注二等奖！&quot;&lt;&lt;endl; if(cnt[2] != 0) cout&lt;&lt;&quot;恭喜&quot;&lt;&lt; name &lt;&lt;&quot;中了&quot; &lt;&lt; cnt[2] &lt;&lt; &quot;注三等奖！&quot;&lt;&lt;endl; &#125;&#125;;int main()&#123; Pride p; p.cmp(); p.print(); return 0;&#125; O. Point_Array(类+构造+对象数组): 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;class Point&#123;public: double x, y; Point() &#123; cout &lt;&lt; &quot;Constructor.&quot; &lt;&lt; endl; x = 0, y = 0; &#125; Point(double nx, double ny) &#123; x = nx, y = ny; &#125; void SetP(double nx, double ny) &#123; x = nx, y = ny; &#125; double getDisTo(const Point &amp;p) &#123; double a = (p.x - x) * (p.x - x); double b = (p.y - y) * (p.y - y); double len = sqrt(a + b); return len; &#125; ~Point() &#123; cout &lt;&lt; &quot;Distructor.&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; int n; cin &gt;&gt; n; double a, b; Point p[n]; for(int i = 0; i &lt; n; i ++ ) &#123; cin &gt;&gt; a &gt;&gt; b; p[i].SetP(a, b); &#125; double Max = 0; int c = 0, d = 1; for(int i = 0; i &lt; n - 1; i ++ ) for(int j = i + 1; j &lt; n; j ++ ) &#123; if(p[i].getDisTo(p[j]) &gt; Max) &#123; Max = p[i].getDisTo(p[j]); c = i, d = j; &#125; &#125; printf(&quot;The longeset distance is %.2lf,between p[%d] and p[%d].\\n&quot;, Max, c, d); &#125; return 0;&#125; P. 分数类（类与构造）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;iostream&gt;using namespace std;int gcd(int a, int b)&#123; return b ? gcd(b, a % b) : a;&#125;class num&#123;private: int a, b;public: num() &#123; a = 0, b = 1; &#125; num(int na, int nb) &#123; a = na, b = nb; &#125; num add(num &amp;n2) &#123; num n3; n3.b = b * n2.b; n3.a = a * n2.b + b * n2.a; int g = gcd(n3.a, n3.b); n3.a /= g; n3.b /= g; return n3; &#125; num mul(num &amp;n2) &#123; num n3; n3.a = a * n2.a; n3.b = b * n2.b; int g = gcd(n3.a, n3.b); n3.a /= g; n3.b /= g; return n3; &#125; num sub(num &amp;n2) &#123; &#123; num n3; n3.b = b * n2.b; n3.a = a * n2.b - b * n2.a; int g = gcd(n3.a, n3.b); n3.a /= g; n3.b /= g; return n3; &#125; &#125; num div(num &amp;n2) &#123; num n3; n3.a = a * n2.b; n3.b = b * n2.a; int g = gcd(n3.a, n3.b); n3.a /= g; n3.b /= g; return n3; &#125; void print() &#123; if(b &lt; 0) b = -b, a = -a; printf(&quot;%d/%d\\n&quot;, a, b); &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; int a, b; scanf(&quot;%d/%d&quot;, &amp;a, &amp;b); num n0(a, b); scanf(&quot;%d/%d&quot;, &amp;a, &amp;b); num n1(a, b); num n2 = n0.add(n1); n2.print(); n2 = n0.sub(n1); n2.print(); n2 = n0.mul(n1); n2.print(); n2 = n0.div(n1); n2.print(); cout &lt;&lt; endl; &#125; return 0;&#125; Point_Array(类+构造+对象数组): 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;using namespace std;class Point &#123; double x, y;public: Point() &#123; cout &lt;&lt; &quot;Constructor.&quot; &lt;&lt; endl; x = 0, y = 0; &#125; Point(double xv, double yv) &#123; x = xv, y = yv; &#125; double getX() &#123; return x; &#125; double getY() &#123; return y; &#125; void setX(double xv) &#123; x = xv; &#125; void setY(double yv) &#123; y = yv; &#125; void setXY(double x1, double y1) &#123; x = x1, y = y1; &#125; double getdisto(Point &amp;P) &#123; double x1 = x - P.x; double y1 = y - P.y; double ans = x1 * x1 + y1 * y1; return sqrt(ans); &#125; ~Point() &#123; cout &lt;&lt; &quot;Distructor.&quot; &lt;&lt; endl; x = 0, y = 0; &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; int n; cin &gt;&gt; n; Point *p = new Point[n]; for(int i = 0; i &lt; n; i ++ ) &#123; double a, b; cin &gt;&gt; a &gt;&gt; b; p[i].setXY(a, b); &#125; double maxDis = 0; int a = 0, b = 0; for(int i = 0; i &lt; n - 1; i ++ ) for(int j = i + 1; j &lt; n; j ++ ) if(maxDis &lt; p[i].getdisto(p[j])) &#123; a = i, b = j; maxDis = p[i].getdisto(p[j]); &#125; printf(&quot;The longeset distance is %.2lf,between p[%d] and p[%d].\\n&quot;, maxDis, a, b); delete[] p; &#125; return 0;&#125; Q. 指针对象（类和对象）: 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;class Stu&#123;public: string Name, Sex, Id, Xueyuan, PhoneNum;&#125;;bool cmp(Stu A, Stu B)&#123; return A.Name &lt; B.Name;&#125;int main()&#123; int t; cin &gt;&gt; t; Stu *S = new Stu[t]; for(int i = 0; i &lt; t; i ++ ) &#123; cin &gt;&gt; S[i].Name &gt;&gt; S[i].Sex &gt;&gt; S[i].Id &gt;&gt; S[i].Xueyuan &gt;&gt; S[i].PhoneNum; &#125; sort(S, S + t, cmp); for(int i = 0; i &lt; t; i ++ ) cout &lt;&lt; S[i].Name &lt;&lt; endl; return 0;&#125; R. 对象数组（类和对象）: 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;class Stu&#123; string name, Id, sex, xue, phone;public: void get() &#123; cin &gt;&gt; name &gt;&gt; Id &gt;&gt; sex &gt;&gt; xue &gt;&gt; phone; &#125; string getName() &#123; return name; &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; Stu s[t]; for(int i = 0; i &lt; t; i ++ ) s[i].get(); for(int i = 0; i &lt; t; i ++ ) cout &lt;&lt; s[i].getName() &lt;&lt; endl; return 0;&#125; T. 单链表（类与构造）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include&lt;bits/stdc++.h&gt;using namespace std;class Node&#123;public: int data; Node *next; Node() &#123; next = NULL; data = 0; &#125; Node(int e) &#123; next = NULL; this -&gt; data = e; &#125;&#125;;class List&#123; Node *head; int len;public: List() &#123; len = 0; head = NULL; &#125; void createList(int *value, int n) &#123; len = n; head = new(Node); Node *p = head; for(int i = 0; i &lt; n; i ++ ) &#123; Node *q = new(Node); q -&gt; data = value[i]; p -&gt; next = q; p = p-&gt;next; &#125; &#125; void printList() &#123; Node *p = head; int cnt = 0; while(p -&gt; next) &#123; cnt ++ ; p = p -&gt;next; cout &lt;&lt; p-&gt;data; if(cnt != len) cout &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; bool insertNode(int pos, int value) &#123; int cnt = 0; Node *p = head; Node *q = new Node(value); while(p -&gt; next) &#123; cnt ++ ; p = p-&gt;next; if(cnt == pos) break; &#125; if(cnt == pos) &#123; q -&gt;next = p-&gt;next; p -&gt;next = q; len ++ ; return true; &#125; else &#123; cout &lt;&lt; &quot;error&quot; &lt;&lt; endl; return false; &#125; &#125; bool removeNode(int pos) &#123; if(pos == 1) &#123; head = head -&gt; next; len -- ; return true; &#125; else &#123; int cnt = 0; Node *p = head -&gt; next; while(p -&gt; next) &#123; cnt ++ ; if(cnt == pos - 1) break; p = p-&gt;next; &#125; if(cnt == pos - 1) &#123; len -- ; p -&gt; next = p -&gt; next -&gt; next; return true; &#125; else &#123; cout &lt;&lt; &quot;error&quot; &lt;&lt; endl; return false; &#125; &#125; &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; int *a, n; cin &gt;&gt; n; a = new int[n]; for(int i = 0; i &lt; n; i ++ ) cin &gt;&gt; a[i]; List l; l.createList(a, n); l.printList(); int m, pos, val; cin &gt;&gt; m; while(m -- ) &#123; cin &gt;&gt; pos &gt;&gt; val; bool flag = l.insertNode(pos, val); if(flag) l.printList(); &#125; cin &gt;&gt; m; while(m -- ) &#123; cin &gt;&gt; pos; bool flag = l.removeNode(pos); if(flag) l.printList(); &#125; &#125; return 0;&#125; U. 生日打折（复合类构造）: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;class Date&#123;public: int year, month, day; Date(int y, int m, int d) &#123; year = y, month = m, day = d; &#125; Date() &#123; year = 0, month = 0, day = 0; &#125;&#125;;class VIP&#123; int Id; Date birth; double Discount[2] = &#123;0.95, 0.5&#125;;public: VIP(int id, Date date) &#123; Id = id, birth = date; &#125; double dis(Date &amp;d) &#123; if(d.month == birth.month &amp;&amp; d.day == birth.day) return Discount[1]; else return Discount[0]; &#125;&#125;;int main()&#123; int y, m, d; cin &gt;&gt; y &gt;&gt; m &gt;&gt; d; Date today(y, m, d); int t; cin &gt;&gt; t; while(t -- ) &#123; int Id; cin &gt;&gt; Id &gt;&gt; y &gt;&gt; m &gt;&gt; d; Date birth(y, m, d); VIP cus(Id, birth); double price; cin &gt;&gt; price; int num = int(price * cus.dis(today)); cout &lt;&lt; Id &lt;&lt; &quot;&#x27;s consumption is &quot; &lt;&lt; num &lt;&lt; endl; &#125; return 0;&#125; V. 找出某个范围内的所有素数(构造与析构): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;class CSieve&#123;private: bool *p_sieve;//��������,��¼��Ӧ�±��������Ƿ�Ϊ���� //����Ŀ˵�Ĳ�һ��, �ҵ���0Ϊ������1Ϊ������ unsigned long num;//��Χ unsigned long cnt = 0;//����public: CSieve(unsigned long n)//����ɸ�� &#123; num = n; p_sieve = new bool[num + 1]; for(int i = 2; i &lt;= num; i ++) if(!p_sieve[i])//���i������ for(int j = i + i; j &lt;= num; j += i)//�ų������Χ������i�ı��� p_sieve[j] = true; for(int i = 2; i &lt;= num; i ++ ) if(!p_sieve[i]) cnt ++ ;//��¼�м������� &#125; void printPrime() &#123; //������� int count = 0; for(int i = 2; i &lt; num + 1; i ++ ) if(p_sieve[i] == false) &#123; cout &lt;&lt; i; count ++ ; if(count == cnt) cout &lt;&lt; endl; else cout &lt;&lt; &quot; &quot;; &#125; &#125; ~CSieve() &#123; num = 0; delete[] p_sieve; p_sieve = NULL; &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; int n; cin &gt;&gt; n; CSieve s(n); s.printPrime(); &#125; return 0;&#125; W. 任意鸡任意钱问题(构造与析构): 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;class chick&#123;public: int num0, num1, num2; chick(int n0, int n1, int n2) &#123; num0 = n0, num1 = n1, num2 = n2; &#125;&#125;;class problem&#123;public: int chi, money; vector&lt;chick&gt; Solution; void slove() &#123; for(int i = 1; i &lt;= chi; i ++ ) for(int j = 1; j &lt;= chi; j ++ ) for(int k = 1; k &lt;= chi; k ++ ) if(i * 5 + j * 3 + k / 3 == money &amp;&amp; i + j + k == chi &amp;&amp; k % 3 == 0) &#123; chick c(i, j , k); Solution.push_back(c); &#125; &#125; void print() &#123; cout &lt;&lt; Solution.size() &lt;&lt; endl; vector&lt;chick&gt;::iterator it; for(it = Solution.begin(); it != Solution.end(); it ++ ) &#123; cout &lt;&lt; it-&gt;num0 &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;num1 &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;num2 &lt;&lt; endl; &#125; &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; problem a; cin &gt;&gt; a.chi &gt;&gt; a.money; a.slove(); a.print(); &#125; return 0;&#125; X. Date(类与构造): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;class Date&#123;public: int year, month, day; int days[13] = &#123;31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 29&#125;; Date(int y, int m, int d) &#123; year = y; month = m; day = d; &#125; bool isRun() &#123; if((year % 4 == 0 &amp;&amp; year % 100 != 0) || (year % 400 == 0)) return true; return false; &#125; void ope() &#123; if(isRun() &amp;&amp; month == 2) days[1] = 29; if(day &gt; days[month - 1]) &#123; day %= days[month - 1]; month ++ ; &#125; if(month &gt; 12) &#123; month %= 12; year ++ ; &#125; &#125; void print() &#123; ope(); printf(&quot;Today is %04d/%02d/%02d\\n&quot;, year, month, day); day ++; ope(); printf(&quot;Tomorrow is %04d/%02d/%02d\\n&quot;, year, month, day); &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; Date date(a, b, c); date.print(); &#125; return 0;&#125; X的放大与缩小（运算符重载）: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;iostream&gt;using namespace std;class XGraph&#123; int n;public: XGraph(int n):n(n)&#123;&#125; friend ostream&amp; operator &lt;&lt; (ostream&amp; ot,const XGraph&amp; xGraph) &#123; for(int i = 0; i &lt; (xGraph.n + 1)/ 2; i ++ ) &#123; for(int j = 0; j &lt; xGraph.n - i; j ++ ) if(j &gt;= i) cout &lt;&lt; &quot;X&quot;; else cout &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; &#125; for(int i = (xGraph.n - 1)/ 2 - 1; i &gt;= 0; i -- ) &#123; for(int j = 0; j &lt; xGraph.n - i; j ++ ) if(j &gt;= i) cout &lt;&lt; &quot;X&quot;; else cout &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; &#125; return ot; &#125; friend XGraph&amp; operator ++(XGraph&amp; xGraph) &#123; if(xGraph.n != 21) xGraph.n += 2; return xGraph; &#125; friend XGraph operator ++(XGraph&amp; xGraph, int) &#123; XGraph x1(xGraph.n); if(xGraph.n != 21) xGraph.n += 2; return x1; &#125; friend XGraph operator --(XGraph&amp; xGraph) &#123; if(xGraph.n != 1) xGraph.n -= 2; return xGraph; &#125; friend XGraph operator --(XGraph&amp; xGraph, int) &#123; XGraph x1(xGraph.n); if(xGraph.n != 1) xGraph.n -= 2; return x1; &#125;&#125;;int main()&#123; int t, n; string cmd; cin &gt;&gt; n; XGraph xGraph(n); cin &gt;&gt; t; while(t -- ) &#123; cin &gt;&gt; cmd; if(cmd == &quot;show++&quot;) cout &lt;&lt; xGraph ++ &lt;&lt; endl; else if(cmd == &quot;++show&quot;) cout &lt;&lt; ++ xGraph &lt;&lt; endl; else if(cmd == &quot;show--&quot;) cout &lt;&lt; xGraph -- &lt;&lt; endl; else if(cmd == &quot;--show&quot;) cout &lt;&lt; -- xGraph &lt;&lt; endl; else if(cmd == &quot;show&quot;) cout &lt;&lt; xGraph &lt;&lt; endl; &#125; return 0;&#125; Y. Point(类与构造): 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;class Point&#123; double x, y;public: Point(double x1, double y1) &#123; x = x1, y = y1; &#125; double distance(Point &amp;p1) &#123; double a = (p1.x - x) * (p1.x - x); double b = (p1.y - y) * (p1.y - y); double len = sqrt(a + b); return len; &#125; double getX() &#123; return x; &#125; double getY() &#123; return y; &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; double a, b, c, d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; Point p1(a, b), p2(c, d); double len = p1.distance(p2); printf(&quot;Distance of Point(%.2lf,%.2lf) to Point&quot; &quot;(%.2lf,%.2lf) is %.2lf\\n&quot;, p1.getX(), p1.getY(), p2.getX(), p2.getY(), len); &#125; return 0;&#125; Z. 最长雪道计算(构造与析构）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;bits/stdc++.h&gt;using namespace std;int dx[4] = &#123;-1, 0, 1, 0&#125;;//偏移量int dy[4] = &#123;0, 1, 0, -1&#125;;//偏移量class Csnow&#123; int n; int **high;//记录高度 int **state;//记录从该点出发的最长路径 int path[100];//记录路径 int path_len;//记录最长路径长度 int now_len;//记录当前路径长度public: Csnow()//初始化 &#123; cin &gt;&gt; n; high = new int *[n + 1]; state = new int *[n + 1]; for(int i = 0; i &lt; n + 1; i ++ ) &#123; high[i] = new int[n + 1]; state[i] = new int[n + 1]; &#125; for(int i = 1; i &lt;= n; i ++ ) for(int j = 1; j &lt;= n; j ++ ) &#123; cin &gt;&gt; high[i][j]; state[i][j] = -1; &#125; memset(path, 0, sizeof path); &#125; int dp(int x, int y) &#123; int &amp;v = state[x][y]; if(v != -1) return v; v = 1; for(int i = 0; i &lt; 4; i ++ ) &#123; int a = x + dx[i], b = y + dy[i]; if(a &gt;= 1 &amp;&amp; a &lt;= n &amp;&amp; b &gt;= 1 &amp;&amp; b &lt;= n &amp;&amp; high[a][b] &lt; high[x][y]) v = max(v, dp(a, b) + 1); &#125; return v; &#125; void getPath(int x, int y) &#123; for(int i = 0; i &lt; 4; i ++ ) &#123; int a = x + dx[i], b = y + dy[i]; if(a &gt;= 1 &amp;&amp; a &lt;= n &amp;&amp; b &gt;= 1 &amp;&amp; b &lt;= n &amp;&amp; high[x][y] &gt; high[a][b] &amp;&amp; state[a][b] == path_len) &#123; now_len ++ ; path[now_len] = high[a][b]; path_len -- ; getPath(a, b); &#125; &#125; &#125; void get() &#123; for(int i = 1; i &lt;= n; i ++ ) for(int j = 1; j &lt;= n; j ++ ) state[i][j] = dp(i, j); int res = 0, x = 0, y = 0; for(int i = 1; i &lt;= n; i ++ ) for(int j = 1; j &lt;= n; j ++ ) if(res &lt; dp(i, j)) &#123; res = dp(i, j); x = i, y = j; &#125; printf(&quot;%d\\n&quot;, res); path[0] = high[x][y]; path_len = res - 1; now_len = 0; getPath(x, y); for(int i = 0; path[i] != 0; i ++ ) cout &lt;&lt; path[i] &lt;&lt; &quot;-&quot;; cout &lt;&lt; endl; &#125; ~Csnow() &#123; for(int i = 0; i &lt; n; i ++ ) &#123; delete[] high[i]; delete[] state[i]; &#125; delete[] high; delete[] state; &#125;&#125;;int main()&#123; Csnow snow; snow.get(); return 0;&#125; [. 那天是星期几(构造): 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;class CDate&#123; string we[7] = &#123; &quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot; &#125;;public: void get(); void print(); void getWeekofDay();private: int month; int day; int year; int week;&#125;;void CDate::print() &#123; printf(&quot;%d/%d/%d, &quot;, month, day, year); cout &lt;&lt; we[week]&lt;&lt; endl;&#125;void CDate::getWeekofDay() &#123; bool flag = 0; if(month == 1 || month == 2) &#123; flag = 1; month += 12, year -= 1; &#125; week = (day + 2*month + 3*(month+1)/5 + year + year/4 - year/100 + year/400) % 7 + 1; if(flag) &#123; month -= 12, year += 1; &#125;&#125;void CDate::get() &#123; cin &gt;&gt; year &gt;&gt; month &gt;&gt; day;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; CDate date; date.get(); date.getWeekofDay(); date.print(); &#125; return 0;&#125; 单链表(结构): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;iostream&gt;using namespace std;class Node&#123; int data; Node *next;public: Node():next(NULL)&#123;&#125; Node(int e):data(e), next(NULL)&#123;&#125; friend class List;&#125;;class List&#123; Node *head; int len;public: List() &#123; head = new Node; len = 0; &#125; void CreateList(int n, int *data) &#123; while(n -- ) &#123; Node *p = head; int i; for(i = 0; i &lt; len; i ++ ) p = p -&gt; next; Node *q = new Node(data[i]); p -&gt; next = q; len ++ ; &#125; &#125; bool Insert(int pos, int e) &#123; if(pos &lt; 1 || pos &gt; len + 1) return false; Node *p = head; for(int i = 1; i &lt; pos; i ++ ) p = p -&gt; next; Node *q = new Node(e); q -&gt; next = p -&gt; next; p -&gt; next = q; len ++ ; return true; &#125; bool Del(int pos) &#123; if(pos &lt; 1 || pos &gt; len) return false; Node *p = head; for(int i = 1; i &lt; pos; i ++ ) p = p -&gt; next; Node *q = p -&gt; next; p -&gt; next = q -&gt; next; delete q; len -- ; return true; &#125; void Display() &#123; Node *p = head -&gt; next; while(p) &#123; cout &lt;&lt; p -&gt; data; if(p -&gt; next) cout &lt;&lt; &quot; &quot;; else cout &lt;&lt; endl; p = p -&gt; next; &#125; &#125; ~List() &#123; Node *p = head -&gt; next; while(p -&gt; next) &#123; Node *q = p; p = p -&gt; next; delete q; &#125; head -&gt; next = NULL; len = 0; &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; int n; cin &gt;&gt; n; int data[n]; for(int i = 0; i &lt; n; i ++ ) cin &gt;&gt; data[i]; List list; list.CreateList(n, data); list.Display(); int m, e, pos; cin &gt;&gt; m; while(m -- ) &#123; cin &gt;&gt; pos &gt;&gt; e; if(list.Insert(pos, e)) list.Display(); else cout &lt;&lt; &quot;error&quot; &lt;&lt; endl; &#125; cin &gt;&gt; m; while(m -- ) &#123; cin &gt;&gt; pos; if(list.Del(pos)) list.Display(); else cout &lt;&lt; &quot;error&quot; &lt;&lt; endl; &#125; &#125;&#125; 点和圆(类与对象): 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;using namespace std;class Point&#123; int m_x; int m_y;public: void setPoint(int x, int y)&#123; this-&gt;m_x = x; this-&gt;m_y = y; &#125; int getX()&#123; return m_x; &#125; int getY()&#123; return m_y; &#125;&#125;;class Circle&#123; int m_x; int m_y; int m_r;public: void SetCenter(int x, int y)&#123; this-&gt;m_x = x; this-&gt;m_y = y; &#125; void SetRadius(int r)&#123; this -&gt; m_r =r; &#125; double getArea()&#123; return 3.14*m_r*m_r; &#125; double getLength()&#123; return 2*3.14*m_r; &#125; int getX()&#123; return m_x; &#125; int getY()&#123; return m_y; &#125; int getR()&#123; return m_r; &#125;&#125;;int main()&#123; int x1, y1, r, x2, y2; Circle ci; Point po; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; r; ci.SetCenter(x1,y1); ci.SetRadius(r); cin &gt;&gt; x2 &gt;&gt; y2; po.setPoint(x2,y2); cout &lt;&lt; ci.getArea() &lt;&lt; &quot; &quot; &lt;&lt; ci.getLength() &lt;&lt; endl; double len = (ci.getX()-po.getX())*(ci.getX()-po.getX())+ (ci.getY()-po.getY())*(ci.getY()-po.getY()); if( len&lt;= (ci.getR()*ci.getR()))&#123; cout &lt;&lt; &quot;yes&quot; &lt;&lt; endl; &#125;else&#123; cout &lt;&lt; &quot;no&quot; &lt;&lt; endl; &#125; return 0;&#125; 单词统计(string): 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int t; cin &gt;&gt; t; getchar(); while(t -- ) &#123; int cnt = 0; string line, word; getline(cin, line); stringstream ss(line); while(ss &gt;&gt; word) cnt ++ ; cout &lt;&lt; cnt &lt;&lt; endl; &#125;&#125; 时钟模拟(继承）: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;iostream&gt;using namespace std;class Counter&#123;protected: int value;public: void Incre() &#123; value += 1; &#125;&#125;;class Cycle_Counter : public Counter&#123;protected: int min_value, max_value;public: Cycle_Counter() &#123;&#125; Cycle_Counter(int Min, int Max, int va) &#123; min_value = Min; max_value = Max; value = va; &#125; bool Incre() &#123; bool flag;// value = (value + 1) % max_value + min_value; if(value == max_value - 1) &#123; value = (value + 1) % max_value + min_value; flag = true; &#125; else &#123; value += 1; flag = false; &#125; return flag; &#125; int getValue() &#123; return value; &#125;&#125;;class Bell&#123; Cycle_Counter *hour, *minute, *second;public: Bell(int h, int m, int s) &#123; hour = new Cycle_Counter(0, 24, h); minute = new Cycle_Counter(0, 60, m); second = new Cycle_Counter(0, 60, s); &#125; void Time() &#123; int add_num; cin &gt;&gt; add_num; while(add_num -- ) &#123; bool flag = second -&gt; Incre(); if(flag) flag = minute -&gt; Incre(); if(flag) hour -&gt; Incre(); &#125; printf(&quot;%d:%d:%d\\n&quot;, hour-&gt;getValue(), minute-&gt;getValue(), second-&gt;getValue()); &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; int hour, minute, second; cin &gt;&gt; hour &gt;&gt; minute &gt;&gt; second; Bell be(hour, minute, second); be.Time(); &#125; return 0;&#125; 线段相交----结构体: 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;using namespace std;struct point&#123; int x, y;&#125;;struct line&#123; point a, b; double k = 0, c = 0; int x1 = 0, x2 = 0; void ope() &#123; k = (a.y - b.y) / (a.x - b.x); c = a.y - (k * a.x); x1 = min(a.x, b.x); x2 = max(a.x, b.x); &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; line l1, l2; cin &gt;&gt; l1.a.x &gt;&gt; l1.a.y &gt;&gt; l1.b.x &gt;&gt; l1.b.y; cin &gt;&gt; l2.a.x &gt;&gt; l2.a.y &gt;&gt; l2.b.x &gt;&gt; l2.b.y; l1.ope(), l2.ope(); double x0 = (l2.c - l1.c) / (l1.k - l2.k); int x1 = max(l1.x1, l2.x1), x2 = min(l1.x2, l2.x2); if(l1.k != l2.k &amp;&amp; x0 &lt;= x2 &amp;&amp; x0 &gt;= x1) cout &lt;&lt; &quot;intersect&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;disjoint&quot; &lt;&lt; endl; &#125; return 0;&#125; 正话反说: 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; int t; cin &gt;&gt; t; getchar(); while(t -- ) &#123; int cnt = 0; string sentence; string str[1000]; getline(cin, sentence); stringstream word(sentence); string wor; while(word &gt;&gt; wor) str[cnt ++ ] = wor; while(cnt) &#123; cout &lt;&lt; str[ -- cnt]; if(cnt == 0) cout &lt;&lt; endl; else cout &lt;&lt; &quot; &quot;; &#125; &#125; return 0;&#125; 新旧身份证(继承): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Date&#123;protected: int year, month, day;public: Date(int y,int m,int d):year(y), month(m), day(d)&#123;&#125; bool check() //检验日期是否合法 &#123; int monthDay[] = &#123; 31,isLeap() ? 29 : 28,31,30,31,30,31,31,30,31,30,31 &#125;; if (day &lt; 0 || year &lt; 0 || month &lt; 0 || year &gt; 2015 || month &gt; 12 || day &gt; monthDay[month - 1]) return false; return true; &#125; bool isLeap() &#123; return (year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0); &#125; int getY()&#123; return year;&#125; int getM()&#123; return month;&#125; int getD()&#123; return day;&#125; void print() &#123; printf(&quot;%d年%d月%d日&quot;, year, month, day); &#125;&#125;;class OldID&#123;protected: string id15, name; //15位身份证号码，姓名 Date birthday; //出生日期public: OldID(string id, string na, int y, int m, int d):id15(id), name(na), birthday(y, m, d)&#123;&#125; bool check() //验证15位身份证是否合法 &#123; if(id15.size() != 15) return false; for(char i : id15) if(i &lt; &#x27;0&#x27; || i &gt; &#x27;9&#x27;) return false; if(!birthday.check()) return false; string d; for(int i = 6, j = 0; j &lt; 6; i ++ , j ++ ) d += id15[i]; int a = stoi(d); int b = birthday.getY() % 100 * 10000; b += birthday.getM() * 100 + birthday.getD(); if(a != b) return false; return true; &#125; void print() &#123; cout &lt;&lt; name &lt;&lt; endl; &#125;&#125;;class NewID:public OldID&#123;private: string id18; Date issueday; int validay;public: NewID(string name, int y1, int m1, int d1,string id1, string id2, int y2, int m2, int d2, int v):OldID(id1,name,y1,m1,d1), id18(id2),issueday(y2,m2,d2),validay(v)&#123;&#125; bool check() &#123; int a[17]=&#123;7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2&#125;; int sum = 0, mod; for(int j = 0; j &lt; 17; j ++ ) sum += (id18[j] - &#x27;0&#x27;) * a[j]; mod = sum % 11; char ch[] = &#123;&#x27;1&#x27;,&#x27;0&#x27;,&#x27;X&#x27;,&#x27;9&#x27;,&#x27;8&#x27;,&#x27;7&#x27;,&#x27;6&#x27;,&#x27;5&#x27;,&#x27;4&#x27;,&#x27;3&#x27;,&#x27;2&#x27;&#125;; if(id18[17] != ch[mod]) return false; int red, idd; string d; red = birthday.getY() * 10000 + birthday.getM() * 100 + birthday.getD(); for(int i = 6, j = 0; j &lt; 8; i ++ , j ++ ) d += id18[i]; idd = stoi(d); if(idd != red) return false; if(!issueday.check()) return false; if(birthday.getY() + validay &lt; issueday.getY()) return false; for(int j = 0; j &lt; 6; j ++ ) if(id15[j] != id18[j]) return false; for(int i = 14, j = 12; i &lt; 17; i ++ , j ++ ) if(id15[j] != id18[i]) return false; return true; &#125; void print() &#123; cout &lt;&lt; id18 &lt;&lt; &quot; &quot;; issueday.print(); if(validay != 100) cout &lt;&lt; &quot; &quot; &lt;&lt; validay &lt;&lt; &quot;年&quot; &lt;&lt; endl; else cout &lt;&lt; &quot; 长期&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; string name, id15, id18; int y1,m1,d1,y2,m2,d2,v; for(int i = 0; i &lt; t; i ++ ) &#123; cin &gt;&gt; name &gt;&gt; y1 &gt;&gt; m1 &gt;&gt; d1 &gt;&gt; id15 &gt;&gt; id18 &gt;&gt; y2 &gt;&gt; m2 &gt;&gt; d2 &gt;&gt; v; NewID nid(name, y1, m1, d1, id15, id18, y2, m2, d2, v); nid.OldID::print(); if(nid.OldID::check() &amp;&amp; nid.check()) nid.print(); else cout &lt;&lt; &quot;illegal id&quot; &lt;&lt; endl; &#125; return 0;&#125; 简单类模板(类模板): 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstring&gt;using namespace std;template&lt;class T&gt;class Num&#123; T data[100]; int len;public: Num():len(0) &#123; memset(data, -1, sizeof data); &#125; Num(int n, T *d):len(n) &#123; memset(data, -1, sizeof data); for(int i = 0; i &lt; len; i ++ ) data[i] = d[i]; &#125; void insert(int pos, T e) &#123; for(int i = len; i &gt; pos; i -- ) data[i] = data[i - 1]; data[pos] = e; len ++ ; &#125; void Del(int pos) &#123; for(int i = pos; i &lt; len; i ++ ) data[i] = data[i + 1]; len -- ; &#125; void Dis() &#123; for(int i = 0; i &lt; len; i ++ ) &#123; cout &lt;&lt; data[i]; if(i == len - 1) cout &lt;&lt; endl; else cout &lt;&lt; &quot; &quot;; &#125; &#125;&#125;;int main()&#123; int t, pos; int ie; cin &gt;&gt; t; int *datai = new int[t]; for(int i = 0; i &lt; t; i ++ ) cin &gt;&gt; datai[i]; Num&lt;int&gt; numi(t, datai); cin &gt;&gt; pos &gt;&gt; ie; numi.insert(pos, ie);// numi.Dis(); cin &gt;&gt; pos; numi.Del(pos); numi.Dis(); double de; cin &gt;&gt; t; double *datad = new double[t]; for(int i = 0; i &lt; t; i ++ ) cin &gt;&gt; datad[i]; Num&lt;double&gt; numd(t, datad); cin &gt;&gt; pos &gt;&gt; de; numd.insert(pos, de);// numd.Dis(); cin &gt;&gt; pos; numd.Del(pos); numd.Dis();&#125; 商旅信用卡(多重继承): 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;iostream&gt;using namespace std;class Member&#123;protected: string MID; int MInte;public: Member():MInte(0)&#123;&#125; Member(string id, int Inte):MID(id), MInte(Inte)&#123;&#125;&#125;;class CreCard&#123;protected: string CID, name; int Limit, CInte; float price;public: CreCard():Limit(0), CInte(0), price(0)&#123;&#125; CreCard(string id, string n, int m, int c, float p):CID(id), name(n), Limit(m), CInte(c), price(p)&#123;&#125;&#125;;class MemCard :virtual public CreCard,virtual public Member&#123; string ID;public: MemCard()&#123;&#125; MemCard(string MId, string CId, string name, float p):Member(MId, 0), CreCard(CId, name, p, 0, 0)&#123;&#125; void opeO(float n) &#123; price += n; MInte += n; CInte += n; &#125; void opeC(float p) &#123; if(p + price &gt; Limit) return; price += p; &#125; void opeQ(float p) &#123; if(price - p &lt; 0) price = 0; else price -= p; if(CInte - p &lt; 0) CInte = 0; else CInte -= p; &#125; void opeT(int m) &#123; MInte += m * 0.5; &#125; void Dis() &#123; cout &lt;&lt; MID &lt;&lt; &quot; &quot; &lt;&lt; MInte &lt;&lt; endl; cout &lt;&lt; CID &lt;&lt; &quot; &quot; &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; price &lt;&lt; &quot; &quot; &lt;&lt; CInte &lt;&lt; endl; &#125;&#125;;int main()&#123; string Cid, Mid, name; float price; cin &gt;&gt; Mid &gt;&gt; Cid &gt;&gt; name &gt;&gt; price; MemCard m1(Mid, Cid, name, price); int t; cin &gt;&gt; t; char ope; while(t -- ) &#123; cin &gt;&gt; ope; float b, a; switch (ope) &#123; case &#x27;o&#x27;: cin &gt;&gt; a; m1.opeO(a); break; case &#x27;c&#x27;: cin &gt;&gt; b; m1.opeC(b); break; case &#x27;q&#x27;: cin &gt;&gt; b; m1.opeQ(b); break; case &#x27;t&#x27;: cin &gt;&gt; a; m1.opeT(a); break; &#125; &#125; m1.Dis();&#125; 字符串合并(指针与函数）: 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;char *strAdd(char *s1, char *s2)&#123; int len1 = strlen(s1), len2 = strlen(s2); char *s3 = new char[len1 + len2 + 1]; for(int i = 0; i &lt; len1; i ++ ) *(s3 + i) = s1[i]; for(int i = len1, j = 0; i &lt; len1 + len2 + 1; j ++, i ++ ) *(s3 + i) = s2[j]; return s3;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; char ch1[100], ch2[100]; cin &gt;&gt; ch1; cin &gt;&gt; ch2; char *ch3 = strAdd(ch1, ch2); cout &lt;&lt; ch1 &lt;&lt; &quot; &quot; &lt;&lt; ch2 &lt;&lt; &quot; &quot; &lt;&lt; ch3 &lt;&lt; endl; &#125; return 0;&#125; 母牛生小牛(静态数据成员与静态成员函数): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;class Cow&#123; static int num[41]; static int year[41];public: static void Num(int n) &#123; year[1] = 1; for(int i = 1; i &lt; n; i ++ ) &#123; for(int j = 40; j &gt;= 1; j -- ) year[j] = year[j - 1]; for(int j = 4; j &lt;= 40; j ++ ) year[1] += year[j]; &#125; int sum = 0; for(int i = 1; i &lt;= 40; i ++ ) sum += year[i]; num[n] = sum; memset(year, 0, sizeof year); &#125; static int getNum(int n) &#123; return num[n]; &#125;&#125;;int Cow::num[41] = &#123;0&#125;;int Cow::year[41] = &#123;0&#125;;int main()&#123; int t; cin &gt;&gt; t; for(int i = 1; i &lt;= 30; i ++ ) Cow::Num(i); while(t -- ) &#123; int n; cin &gt;&gt; n; int num = Cow::getNum(n); cout &lt;&lt; num &lt;&lt; endl; &#125; return 0;&#125; 链表类模板: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include&lt;iostream&gt;using namespace std;template&lt;class T&gt;class Node&#123;public: T data; Node* next; Node():next(NULL)&#123;&#125; Node(T e):data(e), next(NULL)&#123;&#125;&#125;;template&lt;class T&gt;class List&#123; Node&lt;T&gt; *head; int len;public: List() &#123; head = new Node&lt;T&gt;; len = 0; &#125; void CreateList(int n, T* data) &#123; for(int k = 0; k &lt; n; k ++ ) &#123; Node&lt;T&gt;* p = head; for(int i = 0; i &lt; len; i ++ ) p = p -&gt; next; Node&lt;T&gt; *q = new Node&lt;T&gt;(data[k]); p -&gt; next = q; len ++ ; &#125; &#125; void append(T e) &#123; Node&lt;T&gt;* p = head; while(p -&gt; next) p = p -&gt; next; Node&lt;T&gt;* q = new Node&lt;T&gt;(e); p -&gt; next = q; &#125; bool remove(int n) &#123; if(n &lt; 0 || n &gt; len) return false; Node&lt;T&gt;* p = head; for(int i = 1; i &lt; n; i ++ ) p = p -&gt; next; p -&gt; next = p -&gt; next -&gt; next; return true; &#125; void insert(T a, int n) &#123; if(n &lt; 0 || n &gt; len + 1) return; Node&lt;T&gt;* p = head; for(int i = 0; i &lt; n; i ++ ) p = p -&gt; next; Node&lt;T&gt;* q = new Node&lt;T&gt;(a); q -&gt; next = p -&gt; next; p -&gt; next = q; &#125; void get(int n) &#123; if(n &lt; 1 || n &gt; len) &#123; cout &lt;&lt; &quot;error&quot; &lt;&lt; endl; return; &#125; Node&lt;T&gt;* p = head -&gt; next; for(int i = 1; i &lt; n; i ++ ) p = p -&gt; next; cout &lt;&lt; p -&gt; data &lt;&lt; endl; &#125; void reset(int pos, T e) &#123; Node&lt;T&gt;* p = head -&gt; next; for(int i = 1; i &lt; pos; i ++ ) p = p -&gt; next; p -&gt; data = e; &#125; void Dis() &#123; Node&lt;T&gt;* p = head -&gt; next; while(p) &#123; cout &lt;&lt; p -&gt; data; if(p -&gt; next) cout &lt;&lt; &quot; &quot;; else cout &lt;&lt; endl; p = p -&gt; next; &#125; &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; char type; int n; cin &gt;&gt; type &gt;&gt; n; if(type == &#x27;I&#x27;) &#123; int *b = new int[n]; for(int i = 0; i &lt; n; i ++ ) cin &gt;&gt; b[i]; List&lt;int&gt; list; list.CreateList(n, b); int e, pos; cin &gt;&gt; pos &gt;&gt; e; list.insert(e, pos); cin &gt;&gt; pos; list.get(pos); cin &gt;&gt; pos; list.remove(pos); cin &gt;&gt; pos &gt;&gt; e; list.reset(pos, e); list.Dis(); &#125; else if(type == &#x27;D&#x27;) &#123; double *b = new double[n]; for(int i = 0; i &lt; n; i ++ ) cin &gt;&gt; b[i]; List&lt;double&gt; list; list.CreateList(n, b); int pos; double e; cin &gt;&gt; pos &gt;&gt; e; list.insert(e, pos); cin &gt;&gt; pos; list.get(pos); cin &gt;&gt; pos; list.remove(pos); cin &gt;&gt; pos &gt;&gt; e; list.reset(pos, e); list.Dis(); &#125; else if(type == &#x27;S&#x27;) &#123; string *b = new string[n]; for(int i = 0; i &lt; n; i ++ ) cin &gt;&gt; b[i]; List&lt;string&gt; list; list.CreateList(n, b); int pos; string e; cin &gt;&gt; pos &gt;&gt; e; list.insert(e, pos); cin &gt;&gt; pos; list.get(pos); cin &gt;&gt; pos; list.remove(pos); cin &gt;&gt; pos &gt;&gt; e; list.reset(pos, e); list.Dis(); &#125; &#125;&#125; 分数四则运算(结构): 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;iostream&gt;using namespace std;int gcd(int a, int b)&#123; return b ? gcd(b, a % b) : a;&#125;struct num&#123; int a = 0, b = 0;&#125;;num add(num n1, num n2)&#123; num n3; n3.b = n1.b * n2.b; n3.a = n1.a * n2.b + n1.b * n2.a; int g = gcd(n3.a, n3.b); n3.a /= g; n3.b /= g; return n3;&#125;num sub(num n1, num n2)&#123; num n3; n3.b = n1.b * n2.b; n3.a = n1.a * n2.b - n1.b * n2.a; int g = gcd(n3.a, n3.b); n3.a /= g; n3.b /= g; return n3;&#125;num mul(num n1, num n2)&#123; num n3; n3.a = n1.a * n2.a; n3.b = n1.b * n2.b; int g = gcd(n3.a, n3.b); n3.a /= g; n3.b /= g; return n3;&#125;num div(num n1, num n2)&#123; num n3; n3.a = n1.a * n2.b; n3.b = n1.b * n2.a; int g = gcd(n3.a, n3.b); n3.a /= g; n3.b /= g; return n3;&#125;void print(num n)&#123; if(n.b &lt; 0) n.b = -n.b, n.a = -n.a; printf(&quot;%d/%d\\n&quot;, n.a, n.b);&#125;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; num n1, n2; scanf(&quot;%d/%d&quot;, &amp;n1.a, &amp;n1.b); scanf(&quot;%d/%d&quot;, &amp;n2.a, &amp;n2.b); print(add(n1, n2)); print(sub(n1, n2)); print(mul(n1, n2)); print(div(n1, n2)); puts(&quot;&quot;); &#125; return 0;&#125; 判断点线位置(结构): 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;struct point&#123; int x, y;&#125;;struct line&#123; int x, y;&#125;;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; point a, b, c; line l1, l2; cin &gt;&gt; a.x &gt;&gt; a.y; cin &gt;&gt; b.x &gt;&gt; b.y; cin &gt;&gt; c.x &gt;&gt; c.y; l1.x = b.x - a.x, l2.x = c.x - a.x; l1.y = b.y - a.y, l2.y = c.y - a.y; int res = l1.x * l2.y - l1.y * l2.x; if(res == 0) cout &lt;&lt; &quot;intersect&quot; &lt;&lt; endl; else if(res &lt; 0) cout &lt;&lt; &quot;clockwise&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;anti clockwise&quot; &lt;&lt; endl; &#125; return 0;&#125; 单链表的创建(结构体+链表): 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;iostream&gt;using namespace std;class Node&#123; int data; Node *next; Node():next(NULL)&#123;&#125; Node(int e):data(e), next(NULL)&#123;&#125; friend class List;&#125;;class List&#123; Node *head; int len;public: List() &#123; len = 0; head = new Node; &#125; void insert(int e) &#123; len ++ ; Node *p = head; while(p -&gt; next) &#123; p = p -&gt; next; &#125; Node *q = new Node(e); p -&gt; next = q; &#125; bool find(int e) &#123; Node *p = head -&gt; next; while(p) &#123; if(p -&gt; data == e) return true; p = p -&gt; next; &#125; return false; &#125; void Display() &#123; cout &lt;&lt; len &lt;&lt; &#x27; &#x27;; Node *p = head -&gt; next; while(p) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;; p = p -&gt; next; &#125; &#125; ~List() &#123; Node *p = head -&gt; next; if(p) &#123; Node *q = p; p = p -&gt; next; delete q; &#125; head -&gt; next = NULL; &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; List list; int e, n; cin &gt;&gt; n; cin &gt;&gt; e; list.insert(e); for(int i = 0; i &lt; n - 1; i ++ ) &#123; cin &gt;&gt; e; if(!list.find(e)) list.insert(e); &#125; list.Display(); &#125; return 0;&#125; 单链表的删除(结构体+链表): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;iostream&gt;using namespace std;class Node&#123; int data; Node *next; Node():next(NULL)&#123;&#125; Node(int e):data(e), next(NULL)&#123;&#125; friend class List;&#125;;class List&#123; Node *head; int len;public: List() &#123; len = 0; head = new Node; &#125; void insert(int e) &#123; len ++ ; Node *q = new Node(e); Node *p = head; while(p -&gt; next) &#123; p = p -&gt; next; &#125; p -&gt; next = q; &#125; bool del(int pos) &#123; if(pos &lt; 1 || pos &gt; len) return false; len -- ; Node *p = head; for(int i = 1; i &lt; pos; i ++ ) &#123; p = p -&gt; next; &#125; Node *q = p -&gt; next; p -&gt; next = q -&gt; next; delete q; return true; &#125; void Display() &#123; cout &lt;&lt; len &lt;&lt; &quot; &quot;; Node *p = head -&gt; next; while(p) &#123; cout &lt;&lt; p -&gt; data; if(p -&gt; next) cout &lt;&lt; &quot; &quot;; else cout &lt;&lt; endl; p = p -&gt; next; &#125; &#125; ~List() &#123; Node *p = head -&gt; next; while(p -&gt; next) &#123; Node *q = p; p = p -&gt; next; delete q; &#125; head -&gt; next = NULL; &#125;&#125;;int main()&#123; int n, e; List list; cin &gt;&gt; n; cin &gt;&gt; e; list.insert(e); for(int i = 0; i &lt; n - 1; i ++ ) &#123; cin &gt;&gt; e; list.insert(e); &#125; list.Display(); cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++ ) &#123; cin &gt;&gt; e; if(list.del(e)) list.Display(); else cout &lt;&lt; &quot;error&quot; &lt;&lt; endl; &#125; return 0;&#125; 单链表的插入(结构体+链表): 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;using namespace std;class Node&#123; int data; Node *next; Node():next(NULL)&#123;&#125; Node(int e):data(e), next(NULL)&#123;&#125; friend class List;&#125;;class List&#123; Node *head; int len;public: List() &#123; len = 0; head = new Node; &#125; bool insert(int pos, int e) &#123; if(pos &lt; 1 || pos &gt; len + 1) return false; len ++ ; Node *q = new Node(e); Node *p = head; for(int i = 1; i &lt; pos; i ++ ) p = p -&gt; next; q -&gt; next = p -&gt; next; p -&gt; next = q; return true; &#125; void Display() &#123; Node *p = head -&gt; next; while(p) &#123; cout &lt;&lt; p -&gt; data; if(p -&gt; next) cout &lt;&lt; &quot; &quot;; else cout &lt;&lt; endl; p = p -&gt; next; &#125; &#125; ~List() &#123; len = 0; Node *p = head -&gt; next; while(p -&gt; next) &#123; Node *q = p; p = p -&gt; next; delete q; &#125; head -&gt; next = NULL; &#125;&#125;;int main()&#123; List list; int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++ ) &#123; int pos, e; cin &gt;&gt; pos &gt;&gt; e; if(list.insert(pos, e)) list.Display(); else cout &lt;&lt; &quot;error&quot; &lt;&lt; endl; &#125; return 0;&#125; 单链表的查找(结构体+链表): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;iostream&gt;using namespace std;class Node&#123; int data; Node *next; Node():next(NULL)&#123;&#125; Node(int e):data(e),next(NULL)&#123;&#125; friend class List;public: void Output() &#123; cout &lt;&lt; data &lt;&lt; endl; &#125;&#125;;class List&#123; Node *head; int len;public: List() &#123; len = 0; head = new Node; &#125; Node *find(int pos) &#123; if(pos &lt; 1 || pos &gt; len) return NULL; Node *p = head; for(int i = 0; i &lt; pos; i ++ ) &#123; p = p -&gt; next; &#125; return p; &#125; void insert(int e) &#123; len ++ ; Node *q = new Node(e); Node *p = head; while(p -&gt; next) &#123; p = p -&gt; next; &#125; p -&gt; next = q; &#125; void Display() &#123; cout &lt;&lt; len &lt;&lt; &quot; &quot;; Node *p = head -&gt; next; while(p) &#123; cout &lt;&lt; p -&gt; data &lt;&lt; &quot; &quot;; p = p -&gt; next; &#125; cout &lt;&lt; endl; &#125; ~List() &#123; Node *p = head -&gt; next; while(p -&gt; next) &#123; Node *q = p; p = p -&gt; next; delete q; &#125; head -&gt; next = NULL; &#125;&#125;;int main()&#123; List list; int n, e; cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++ ) &#123; cin &gt;&gt; e; list.insert(e); &#125; list.Display(); cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++ ) &#123; cin &gt;&gt; e; Node *p = list.find(e); if(p) p -&gt; Output(); else cout &lt;&lt; &quot;error&quot; &lt;&lt; endl; &#125; return 0;&#125; 排序函数模板: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;iostream&gt;using namespace std;class Point&#123; double x, y, dis;public: Point()&#123;&#125; void getDis()&#123; dis = x * x + y * y;&#125; friend ostream&amp; operator &lt;&lt; (ostream&amp; ot, Point&amp; p) &#123; printf(&quot;(%.1lf, %.1lf)&quot;, p.x, p.y); return ot; &#125; friend istream&amp; operator &gt;&gt; (istream&amp; in, Point&amp; p) &#123; in &gt;&gt; p.x &gt;&gt; p.y; return in; &#125; friend bool operator &lt; (const Point&amp; p1, const Point&amp; p2) &#123; return p1.dis &lt; p2.dis; &#125;&#125;;template&lt;class T&gt;void mySort(T* a, int n)&#123; for(int i = 0; i &lt; n - 1; i ++ ) for(int j = n - 1; j &gt; i; j -- ) if(a[j] &lt; a[i]) swap(a[i], a[j]);&#125;template&lt;class T&gt;void Print(T* a, int n)&#123; for(int i = 0; i &lt; n; i ++ ) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; char type; int n; cin &gt;&gt; type &gt;&gt; n; if(type == &#x27;I&#x27;) &#123; int *b = new int[n]; for(int i = 0; i &lt; n; i ++ ) cin &gt;&gt; b[i]; mySort(b, n); Print(b, n); &#125; else if(type == &#x27;D&#x27;) &#123; double *b = new double[n]; for(int i = 0; i &lt; n; i ++ ) cin &gt;&gt; b[i]; mySort(b, n); Print(b, n); &#125; else if(type == &#x27;C&#x27;) &#123; char *b = new char[n]; for(int i = 0; i &lt; n; i ++ ) cin &gt;&gt; b[i]; mySort(b, n); Print(b, n); &#125; else if(type == &#x27;S&#x27;) &#123; string *b = new string[n]; for(int i = 0; i &lt; n; i ++ ) cin &gt;&gt; b[i]; mySort(b, n); Print(b, n); &#125; else &#123; Point *b = new Point[n]; for(int i = 0; i &lt; n; i ++ ) &#123; cin &gt;&gt; b[i]; b[i].getDis(); &#125; mySort(b, n); Print(b, n); &#125; &#125; return 0;&#125; 字符串操作（string）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;regex&gt;using namespace std;int n;string s[110];string itos(int x)&#123; if(!x) return &quot;0&quot;; string res; while(x) &#123; res.push_back(x % 10 + &#x27;0&#x27;); x /= 10; &#125; reverse(res.begin(), res.end()); return res;&#125;string cmd()&#123; string op; cin &gt;&gt; op; if(op == &quot;over&quot;) exit(0); else if(op == &quot;copy&quot;) &#123; int N = stoi(cmd()); int X = stoi(cmd()); int L = stoi(cmd()); return s[N].substr(X, L); &#125; else if(op == &quot;add&quot;) &#123; string S1 = cmd(),S2 = cmd(); regex rnum(&quot;[[:d:]]+&quot;); if(regex_match(S1,rnum) &amp;&amp; regex_match(S2,rnum)) &#123; int n1 = stoi(S1),n2 = stoi(S2); return itos(n1 + n2); &#125; else return S1 + S2; &#125; else if(op == &quot;find&quot;) &#123; string S = cmd(); int N = stoi(cmd()); if(s[N].find(S) == string::npos) return itos(S.size()); else return itos(s[N].find(S)); &#125; else if(op == &quot;rfind&quot;) &#123; string S = cmd(); int N = stoi(cmd()); if(s[N].rfind(S) == string::npos) return itos(S.size()); else return itos(s[N].rfind(S)); &#125; else if(op == &quot;insert&quot;) &#123; string S = cmd(); int N = stoi(cmd()); int X = stoi(cmd()); s[N].insert(X,S); return cmd(); &#125; else if(op == &quot;reset&quot;) &#123; string S = cmd(); int N = stoi(cmd()); s[N] = S; return cmd(); &#125; else if(op == &quot;print&quot;) &#123; int N = stoi(cmd()); cout &lt;&lt; s[N] &lt;&lt; endl; return cmd(); &#125; else if(op == &quot;printall&quot;) &#123; for(int i = 1;i &lt;= n;i ++) cout &lt;&lt; s[i] &lt;&lt; endl; return cmd(); &#125; return op;&#125;int main()&#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; s[i]; while(1) &#123; cmd(); &#125; return 0;&#125; 最贵的书（重载+友元+引用）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Book&#123; string name, auth, src; double price;public: Book()&#123;&#125; friend ostream&amp; operator &lt;&lt; (ostream&amp; ot, Book&amp; b) &#123; ot &lt;&lt; b.name &lt;&lt; endl; ot &lt;&lt; b.auth &lt;&lt; endl; printf(&quot;%.2lf\\n&quot;, b.price); ot &lt;&lt; b.src &lt;&lt; endl; return ot; &#125; friend istream&amp; operator &gt;&gt; (istream&amp; in, Book&amp; b) &#123; int pre, pos; string line; getline(in, line); pos = line.find(&quot;,&quot;); b.name = line.substr(0, pos); pre = ++ pos ; pos = line.find(&quot;,&quot;, pre); b.auth = line.substr(pre, pos - pre); pre = ++ pos ; pos = line.find(&quot;,&quot;, pre); string price; price = line.substr(pre, pos - pre); b.price = atof(price.c_str()); pre = ++ pos ; pos = line.find(&quot;,&quot;, pre); b.src = line.substr(pre, pos - pre); return in; &#125; friend void find(Book *book, int n, int &amp;max1,int &amp;max2);&#125;;void find(Book *book, int n, int &amp;max1,int &amp;max2)&#123; double mp1 = 0, mp2 = 0; for(int i = 0; i &lt; n; i ++ ) &#123; if(mp1 &lt; book[i].price) &#123; mp1 = book[i].price; max1 = i; &#125; &#125; for(int i = 0; i &lt; n; i ++ ) &#123; if(mp2 &lt; book[i].price &amp;&amp; i != max1) &#123; mp2 = book[i].price; max2 = i; &#125; &#125;&#125;int main()&#123; int t, n; cin &gt;&gt; t; while(t -- ) &#123; cin &gt;&gt; n; int a = 0, b = 0; getchar(); Book *book = new Book[n]; for(int i = 0; i &lt; n; i ++ ) cin &gt;&gt; book[i]; find(book, n, a, b); cout &lt;&lt; book[a] &lt;&lt; endl; cout &lt;&lt; book[b] &lt;&lt; endl; &#125;&#125; 判断矩形是否重叠(结构): 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;using namespace std;struct point&#123; int x = 0, y = 0;&#125;;struct rect&#123; point a, b; int x1 = 0, y1 = 0, x2 = 0, y2 = 0; void ope() &#123; x1 = min(a.x, b.x); x2 = max(a.x, b.x); y1 = min(a.y, b.y); y2 = max(a.y, b.y); &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; rect r1, r2; int flag = 1; cin &gt;&gt; r1.a.x &gt;&gt; r1.a.y &gt;&gt; r1.b.x &gt;&gt; r1.b.y; cin &gt;&gt; r2.a.x &gt;&gt; r2.a.y &gt;&gt; r2.b.x &gt;&gt; r2.b.y; r1.ope(), r2.ope(); if((r1.x1 &gt; r2.x2) || (r1.y1 &gt; r2.y2) || (r1.x1 &gt; r1.x2) || (r2.y1 &gt; r1.y2)) flag = 0; if(flag == 1) cout &lt;&lt; &quot;overlapped&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;not overlapped&quot; &lt;&lt; endl; &#125; return 0;&#125; 判断矩形是否重叠(复合类+友元): 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;using namespace std;class Point&#123;public: Point() &#123; x = 0, y = 0; &#125; int x, y;&#125;;class Rect&#123; Point a, b;public: Rect(Point A, Point B) &#123; a = A, b = B; &#125; int x1, x2, y1, y2; void ope() &#123; x1 = min(a.x, b.x); x2 = max(a.x, b.x); y1 = min(a.y, b.y); y2 = max(a.y, b.y); &#125; friend void cmp(Rect &amp;A, Rect &amp;B);&#125;;void cmp(Rect &amp;A, Rect &amp;B)&#123; if(A.x1 &gt; B.x2 || A.x2 &lt; B.x1 || A.y1 &gt; B.y2 || A.y2 &lt; B.y1) &#123; cout &lt;&lt; &quot;not overlapped&quot; &lt;&lt; endl; &#125;else cout &lt;&lt; &quot;overlapped&quot; &lt;&lt; endl;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; Point a, b, c, d; cin &gt;&gt; a.x &gt;&gt; a.y &gt;&gt; b.x &gt;&gt; b.y; cin &gt;&gt; c.x &gt;&gt; c.y &gt;&gt; d.x &gt;&gt; d.y; Rect r1(a, b), r2(c, d); r1.ope(), r2.ope(); cmp(r1, r2); &#125; return 0;&#125; 计算宝宝帐户收益(多重继承): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184#include&lt;iostream&gt;using namespace std;class CPeople&#123;protected: string name; string id;public: CPeople()&#123;&#125; CPeople(string n,string i) &#123; name = n; id = i; &#125;&#125;;class CInternetUser:virtual public CPeople&#123;protected: string password;public: void registerUser(string n,string i,string p) &#123; name = n; id = i; password = p; &#125;&#125;;class CBankCustomer:virtual public CPeople&#123;protected: double bank_balance; //银行余额 public: CBankCustomer()&#123;&#125; void openAccount(string n,string i) &#123; name = n; id = i; bank_balance=0; &#125; void deposit(double b) &#123; bank_balance += b; &#125; bool withdraw(double b) &#123; if(bank_balance - b &gt;= 0) &#123; bank_balance -= b; return 1; &#125;else return 0; &#125;&#125;;class CInternetBankCustomer:virtual public CBankCustomer,virtual public CInternetUser&#123;protected: double balance; //网上银行余额 double yesterday_balance; //昨日余额 double today_earnings; //今日收益 double today_interest; //今日万元收益率 double yesterday_interest; //昨日万元收益率 public: CInternetBankCustomer() &#123; balance = 0; yesterday_balance = 0; today_earnings = 0; today_interest = 0; yesterday_interest = 0; &#125; bool deposit(double b) &#123; if(bank_balance - b &gt;= 0) &#123; bank_balance -= b; balance += b; return 1; &#125; else return 0; &#125; bool withdraw(double b) &#123; if(balance-b&gt;=0) &#123; balance -= b; bank_balance += b; return 1; &#125; else return 0; &#125; void setInterest(double i) &#123; yesterday_interest = today_interest; today_interest = i; &#125; void calculateProfit() &#123; today_earnings = yesterday_balance * 0.0001 * yesterday_interest; balance += today_earnings; yesterday_balance = balance; &#125; void print() &#123; cout &lt;&lt; &quot;Name: &quot; &lt;&lt; CBankCustomer::name &lt;&lt; &quot; ID: &quot; &lt;&lt; CBankCustomer::id &lt;&lt; endl; cout &lt;&lt; &quot;Bank balance: &quot; &lt;&lt; bank_balance &lt;&lt; endl; cout &lt;&lt; &quot;Internet bank balance: &quot; &lt;&lt; balance &lt;&lt; endl; &#125; bool login(string i,string p) &#123; return (i == CInternetUser::id ) &amp;&amp; (p == CInternetUser::password) &amp;&amp; (CInternetUser::id == CBankCustomer::id) &amp;&amp; (CInternetUser::name == CBankCustomer::name); &#125;&#125;;int main()&#123; int t, no_of_days, i; string i_xm, i_id, i_mm, b_xm, b_id, ib_id, ib_mm; double money, interest; char op_code; cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; i_xm &gt;&gt; i_id &gt;&gt; i_mm; cin &gt;&gt; b_xm &gt;&gt; b_id; cin &gt;&gt; ib_id &gt;&gt; ib_mm; CInternetBankCustomer ib_user; ib_user.registerUser(i_xm, i_id, i_mm); ib_user.openAccount(b_xm, b_id); if (ib_user.login(ib_id, ib_mm) == 0) &#123; cout &lt;&lt; &quot;Password or ID incorrect&quot; &lt;&lt; endl; continue; &#125; cin &gt;&gt; no_of_days; for (i=0; i &lt; no_of_days; i++) &#123; //输入操作代码, 金额, 当日万元收益 cin &gt;&gt; op_code &gt;&gt; money &gt;&gt; interest; switch (op_code) &#123; case &#x27;S&#x27;: //从银行向互联网金融帐户存入 case &#x27;s&#x27;: if (ib_user.deposit(money) == 0) &#123; cout &lt;&lt; &quot;Bank balance not enough&quot; &lt;&lt; endl; continue; &#125; break; case &#x27;T&#x27;: //从互联网金融转入银行帐户 case &#x27;t&#x27;: if (ib_user.withdraw(money) == 0) &#123; cout &lt;&lt; &quot;Internet bank balance not enough&quot; &lt;&lt; endl; continue; &#125; break; case &#x27;D&#x27;: //直接向银行帐户存款 case &#x27;d&#x27;: ib_user.CBankCustomer::deposit(money); break; case &#x27;W&#x27;: //直接从银行帐户取款 case &#x27;w&#x27;: if (ib_user.CBankCustomer::withdraw(money) == 0) &#123; cout &lt;&lt; &quot;Bank balance not enough&quot; &lt;&lt; endl; continue; &#125; break; default: cout &lt;&lt; &quot;Illegal input&quot; &lt;&lt; endl; continue; &#125; ib_user.setInterest(interest); ib_user.calculateProfit(); ib_user.print(); cout&lt;&lt;endl; &#125; &#125; return 0;&#125; 图形输出（抽象类+多层继承）: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;using namespace std;class Shape&#123;protected: string name; double x, y;public: Shape(double x, double y):x(x), y(y)&#123;&#125; virtual double getX()&#123;return x;&#125; virtual double getY()&#123;return y;&#125; virtual string getN()&#123;return name;&#125; virtual double getA()&#123;return 0.0;&#125; virtual double getV()&#123;return 0.0;&#125; virtual void shapeName() = 0;&#125;;class Point:public Shape&#123;public: Point(double x, double y): Shape(x, y)&#123;&#125; void shapeName()&#123;name = &quot;Point&quot;;&#125;&#125;;class Circle:public Point&#123;protected: double r;public: Circle(double x, double y, double r): Point(x, y), r(r)&#123;&#125; void shapeName()&#123;name = &quot;Circle&quot;;&#125; double getA()&#123;return 3.14159 * r * r;&#125;&#125;;class Cylinder:public Circle&#123; double h;public: Cylinder(double x, double y, double r, double h): Circle(x, y, r), h(h)&#123;&#125; void shapeName()&#123;name = &quot;Cylinder&quot;;&#125; double getA()&#123;return 3.14159 * 2 * r * (h + r);&#125; double getV()&#123;return 3.14159 * r * r * h;&#125;&#125;;void Print(Shape* s)&#123; cout &lt;&lt; s-&gt;getN() &lt;&lt; &quot;--(&quot; &lt;&lt; s-&gt;getX() &lt;&lt; &quot;,&quot; &lt;&lt; s-&gt;getY() &lt;&lt; &quot;)--&quot; &lt;&lt; (int)s-&gt;getA() &lt;&lt; &quot;--&quot; &lt;&lt; (int)s-&gt;getV() &lt;&lt; endl;&#125;int main()&#123; Shape* p; double x, y, r, h; cin &gt;&gt; x &gt;&gt; y; p = new Point(x, y); p -&gt; shapeName(); Print(p); cin &gt;&gt; x &gt;&gt; y &gt;&gt; r; p = new Circle(x, y, r); p -&gt; shapeName(); Print(p); cin &gt;&gt; x &gt;&gt; y &gt;&gt; r &gt;&gt; h; p = new Cylinder(x, y, r, h); p -&gt; shapeName(); Print(p);&#125; 日程安排（多继承+友元函数）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;class Date&#123;protected: int year, month, day;&#125;;class Time&#123;protected: int hour, minute, second;&#125;;class Schedule : public Date, public Time&#123; int ID; friend bool before(const Schedule &amp; s1,const Schedule &amp; s2);public: Schedule()&#123;&#125; Schedule(int id, int y, int mo, int d, int h, int mi, int s) &#123; ID = id; year = y, month = mo, day = d; hour = h, minute = mi, second = s; &#125; void Display() &#123; printf(&quot;No.%d: &quot;, ID); printf(&quot;%04d/%02d/%02d %02d:%02d:%02d&quot;, year, month, day, hour, minute, second); &#125;&#125;;bool before(const Schedule &amp; s1,const Schedule &amp; s2)&#123; if(s1.year != s2.year) return s1.year &lt; s2.year; if(s1.month != s2.month) return s1.month &lt; s2.month; if(s1.day != s2.day) return s1.day &lt; s2.day; if(s1.hour != s2.hour) return s1.hour &lt; s2.hour; if(s1.minute != s2.minute) return s1.minute &lt; s2.minute; if(s1.second != s2.second) return s1.second &lt; s2.second;&#125;int main()&#123; int t, cnt = 0; vector&lt;Schedule&gt; table; while(cin &gt;&gt; t, t) &#123; int y, mo, d, h, mi, s; cin &gt;&gt; y &gt;&gt; mo &gt;&gt; d &gt;&gt; h &gt;&gt; mi &gt;&gt; s; Schedule schedule(t, y, mo, d, h, mi, s); table.push_back(schedule); &#125; sort(table.begin(), table.end(), before); printf(&quot;The urgent schedule is &quot;); table[0].Display();&#125; 约瑟夫环（结构体+循环链表）: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;iostream&gt;using namespace std;class Node&#123; int data; bool state; Node *next; Node() &#123; state = false; next = NULL; &#125; Node(int e) &#123; data = e; state = false; next = NULL; &#125; friend class List;&#125;;class List&#123; Node *head, *tail; int length;public: List() &#123; length = 0; head = new Node; tail = new Node; tail -&gt; next = head; &#125; void Init(int len) &#123; length = len; Node *p = head; head -&gt; data = 1; for(int i = 2; i &lt;= len; i ++ ) &#123; Node *q = new Node(i); p -&gt; next = q; p = q; &#125; tail = p; tail -&gt; next = head; &#125; void Play(int k , int m) &#123; int cnt = 1; Node *p = head; while(cnt != k) &#123; p = p -&gt; next; cnt ++ ; &#125; cnt = 0; while(cnt != length) &#123; int count = 1; while(count != m) &#123; p = p -&gt; next; if(p -&gt; state == false) count ++ ; &#125; p -&gt; state = true; cout &lt;&lt; p -&gt; data; while(p-&gt;state &amp;&amp; cnt != length - 1) p = p -&gt; next; if(cnt == length - 1) cout &lt;&lt; endl; else cout &lt;&lt; &quot; &quot;; cnt ++ ; &#125; &#125;&#125;;int main()&#123; int n, k, m; while(cin &gt;&gt; n &gt;&gt; k &gt;&gt; m) &#123; List list; list.Init(n); list.Play(k, m); &#125;&#125; 对象相加函数模板: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;using namespace std;class Clock&#123; int x, y, z;public: Clock(int x, int y, int z):x(x), y(y), z(z)&#123;&#125; int getx()&#123;return x;&#125; int gety()&#123;return y;&#125; int getz()&#123;return z;&#125; friend void operator &lt;&lt; (ostream&amp; ot, Clock&amp; c1) &#123; ot &lt;&lt; c1.x &lt;&lt; &quot; &quot; &lt;&lt; c1.y &lt;&lt; &quot; &quot; &lt;&lt; c1.z &lt;&lt; endl; &#125;// friend&#125;;class RMB&#123; int x, y, z;public: RMB(int x, int y, int z):x(x), y(y), z(z)&#123;&#125; int getx()&#123;return x;&#125; int gety()&#123;return y;&#125; int getz()&#123;return z;&#125; friend void operator &lt;&lt; (ostream&amp; ot, RMB&amp; r) &#123; ot &lt;&lt; r.x &lt;&lt; &quot; &quot; &lt;&lt; r.y &lt;&lt; &quot; &quot; &lt;&lt; r.z &lt;&lt; endl; &#125;&#125;;template&lt;class T&gt;T add(T&amp; t1, T&amp; t2, int t)&#123; int x = t1.getx() + t2.getx(); int y = t1.gety() + t2.gety(); int z = t1.getz() + t2.getz(); if(z &gt;= t) z %= t, y ++ ; if(y &gt;= t) y %= t, x ++ ; return T(x, y , z);&#125;int main()&#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; Clock c1(a, b, c); cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; Clock c2(a ,b, c); Clock cl = add(c1, c2, 60); cout &lt;&lt; cl; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; RMB r1(a, b, c); cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; RMB r2(a, b, c); RMB r = add(r1, r2, 10); cout &lt;&lt; r;&#125; 模拟时间（继承）: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;using namespace std;class Time&#123;protected: int hour, minute, second;public: Time()&#123;&#125; Time(int h, int m, int s) &#123; hour = h, minute = m, second = s; &#125; void Display() &#123; printf(&quot;%02d:%02d:%02d\\n&quot;, hour, minute, second); &#125;&#125;;class Time_12Hour : public Time&#123; string interval[2] = &#123;&quot;AM&quot;, &quot;PM&quot;&#125;; int inter;public: Time_12Hour(int h, int m, int s, int ter) &#123; hour = h, minute = m, second = s, inter = ter; &#125; void add() &#123; second ++ ; if(second &gt;= 60) &#123; second -= 60; minute ++ ; if(minute &gt;= 60) &#123; minute -= 60; hour ++ ; if(hour &gt;= 12) &#123; hour -= 12; inter = 1 - inter; &#125; &#125; &#125; &#125; void sub() &#123; second -- ; if(second &lt; 0) &#123; second += 60; minute -- ; if(minute &lt; 0) &#123; minute += 60; hour -- ; if(hour &lt; 0) &#123; hour += 12; inter = 1 - inter; &#125; &#125; &#125; &#125; void Display() &#123; cout &lt;&lt; interval[inter] &lt;&lt; &quot; &quot;; printf(&quot;%02d:%02d:%02d\\n&quot;, hour, minute, second); &#125;&#125;;int main()&#123; int t; while(cin &gt;&gt; t, t) &#123; string ope; int n = t % 10; n -- ; int h, m, s; cin &gt;&gt; h &gt;&gt; m &gt;&gt; s; Time_12Hour time12Hour(h, m, s, n); cin &gt;&gt; ope &gt;&gt; n; if(ope == &quot;+&quot;) while(n -- ) time12Hour.add(); else while(n -- ) time12Hour.sub(); time12Hour.Display(); &#125; return 0;&#125; 逆序输出函数模板: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;using namespace std;template&lt;class T&gt;string Reverse(T&amp; x)&#123; stringstream ss; string s; ss &lt;&lt; x; s = ss.str(); reverse(s.begin(), s.end()); return s;&#125;class Complex&#123; int r, i;public: Complex(int r, int i):r(r), i(i)&#123;&#125; operator string() &#123; string sr, si; if(r &gt; 0) sr = &quot;+&quot; + to_string(r); else sr = to_string(r); reverse(sr.begin(), sr.end()); si = to_string(i); reverse(si.begin(), si.end()); sr += si; return sr; &#125; friend ostream&amp; operator &lt;&lt; (ostream&amp; ot, Complex&amp; c) &#123; ot &lt;&lt; string(c); return ot; &#125;&#125;;int main()&#123; int t, x, r, i; string type, s, res; double d; cin &gt;&gt; t; while(t -- ) &#123; stringstream ss; cin &gt;&gt; type; if(type == &quot;I&quot;) &#123; cin &gt;&gt; x; if(x &lt; 0) cout &lt;&lt; &quot;-&quot;, x *= -1; res = Reverse(x), ss &lt;&lt; res, ss &gt;&gt; x; cout &lt;&lt; x &lt;&lt; endl; &#125; else if(type == &quot;S&quot;) &#123; cin &gt;&gt; s; cout &lt;&lt; Reverse(s) &lt;&lt; endl; &#125; else if(type == &quot;D&quot;) &#123; cin &gt;&gt; d; if(d &lt; 0) cout &lt;&lt; &quot;-&quot;, d *= -1; res = Reverse(d), ss &lt;&lt; res, ss &gt;&gt; d; cout &lt;&lt; d &lt;&lt; endl; &#125; else if(type == &quot;C&quot;) &#123; cin &gt;&gt; r &gt;&gt; i; Complex c(r, i); cout &lt;&lt; Reverse(c) &lt;&lt; endl; &#125; &#125; return 0;&#125; 链表原地反转（链表): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;iostream&gt;using namespace std;class Node&#123;public: int data; Node *next; Node() &#123; next = NULL; &#125; Node(int e) &#123; next = NULL; data = e; &#125; friend class List;&#125;;class List&#123; Node *head; int len;public: List() &#123; len = 0; head = new Node; &#125; void insert(int e) &#123; len ++ ; Node *q = new Node(e); Node *p = head; while(p -&gt; next) &#123; p = p -&gt; next; &#125; p -&gt; next = q; &#125; void resever() &#123; Node *tail = new Node; Node *t = tail; while(head -&gt; next) &#123; Node *p = head, *q = head -&gt; next; while(q -&gt; next) &#123; q = q -&gt; next; p = p -&gt; next; &#125; t -&gt; next = q; t = q; p -&gt; next = NULL; &#125; head = tail; &#125; void Display() &#123; Node *p = head -&gt; next; while(p) &#123; cout &lt;&lt; p -&gt; data &lt;&lt; &quot; &quot;; p = p -&gt; next; &#125; cout &lt;&lt; endl; &#125; ~List() &#123; Node *p = head -&gt; next; while(p -&gt; next) &#123; Node *q = p; p = p -&gt;next; delete q; &#125; head -&gt; next = NULL; &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; List list; int n, e; cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++ ) &#123; cin &gt;&gt; e; list.insert(e); &#125; list.resever(); list.Display(); &#125; return 0;&#125; 图书借阅（对象数组+构造）: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;using namespace std;#include&lt;unordered_map&gt;class Book&#123; string Id, Name; int Col_num, Ave_num;public: Book()&#123;&#125; Book(string id, string name, int col_num, int ave_num) &#123; Id = id, Name = name, Col_num = col_num, Ave_num = ave_num; &#125; void Set(string id, string name, int col_num, int ave_num) &#123; Id = id, Name = name, Col_num = col_num, Ave_num = ave_num; &#125; void get() &#123; cout &lt;&lt; Name &lt;&lt; &quot; &quot;; if(Ave_num == 0) cout &lt;&lt; &quot;该书已全部借出&quot; &lt;&lt; endl; else &#123; cout &lt;&lt; &quot;索取号: &quot; &lt;&lt; Id &lt;&lt; endl; Ave_num -- ; &#125; &#125; void Display() &#123; cout &lt;&lt; Id &lt;&lt; &quot; &quot; &lt;&lt; Name &lt;&lt; &quot; &quot; &lt;&lt; Col_num &lt;&lt; &quot; &quot; &lt;&lt; Ave_num &lt;&lt; endl; &#125; int getCol()&#123;return Col_num;&#125; int getAve()&#123;return Ave_num;&#125;&#125;;int main()&#123; int n, sum; cin &gt;&gt; n; sum = n; Book *book = new Book[n]; string Id, Name; int Col_num, Ave_num; unordered_map&lt;string, int&gt; books_idx; for(int i = 0; i &lt; n; i ++ ) &#123; cin &gt;&gt; Id &gt;&gt; Name &gt;&gt; Col_num &gt;&gt; Ave_num; book[i].Set(Id, Name, Col_num, Ave_num); books_idx.insert(&#123;Name, i&#125;); &#125; cin &gt;&gt; n; while(n -- ) &#123; cin &gt;&gt; Name; book[books_idx[Name]].get(); &#125; Col_num = 0, Ave_num = 0; for(int i = 0; i &lt; sum; i ++ ) &#123; book[i].Display(); Col_num += book[i].getCol(); Ave_num += book[i].getAve(); &#125; printf(&quot;借出图书: %d本 剩余馆藏图书: %d本\\n&quot;, Col_num - Ave_num, Ave_num); return 0;&#125; 身份证设定（复合类+拷贝构造）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;#include &lt;iomanip&gt;class cad;class bd &#123;protected: int y, m, d;public: bd() &#123;&#125;; bd(int y1, int m1, int d1) &#123; y = y1; m = m1; d = d1; &#125; void print() &#123; cout &lt;&lt; setfill(&#x27;0&#x27;); cout &lt;&lt; &quot;birth=&quot; &lt;&lt; y &lt;&lt; &quot;.&quot; &lt;&lt; setw(2) &lt;&lt; m &lt;&lt; &quot;.&quot; &lt;&lt; setw(2) &lt;&lt; d &lt;&lt; endl; &#125; friend cad;&#125;;class cad &#123;protected: int kd; string num; bd bh;public: cad(int kd, string num, bd b) : bh(b) &#123; this-&gt;kd = kd; this-&gt;num = num; &#125; void print() &#123; cout &lt;&lt; &quot;type=&quot; &lt;&lt; kd &lt;&lt; &quot; &quot;; bh.print(); cout &lt;&lt; &quot;ID=&quot; &lt;&lt; num &lt;&lt; endl; &#125; cad(const cad &amp;cad) &#123; kd = cad.kd; num = cad.num; bh = cad.bh; int cnt = num.length(); if (cnt == 15) &#123; this-&gt;kd = 2; num.insert(6, to_string(cad.bh.y), 0, 2); int n = 0, ad = 0; for (int i = 0; i &lt; 17; i++) &#123; n += num[i] - &#x27;0&#x27;; &#125; ad = n % 10; if (ad == 0) num.append(&quot;X&quot;); else num.append(to_string(ad)); &#125; &#125;&#125;;int main() &#123; int t, kd, y, m, d; string num; cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; kd &gt;&gt; num &gt;&gt; y &gt;&gt; m &gt;&gt; d; bd bh(y, m, d); cad pid1(kd, num, bh); cad pid2(pid1); pid2.print(); &#125; return 0;&#125; 三数论大小（引用）: 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;void Sort(int &amp;a, int &amp;b, int &amp;c)&#123; if(a &lt; b) swap(a, b); if(a &lt; c) swap(a, c); if(b &lt; c) swap(b, c);&#125;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; Sort(a, b, c); cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; c &lt;&lt; endl; &#125; return 0;&#125; 三数论大小（指针）: 1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; while(n --) &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; int *p = &amp;a; int *q = &amp;b; int *t = &amp;c; if (*p &lt; *q) swap(*p, *q); if (*p &lt; *t) swap(*p, *t); if (*q &lt; *t) swap(*q, *t); cout &lt;&lt; *p &lt;&lt; &quot; &quot; &lt;&lt; *q &lt;&lt; &quot; &quot; &lt;&lt; *t &lt;&lt; endl; &#125; return 0;&#125; 分数类（类与构造）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;iostream&gt;using namespace std;class Fraction&#123; int fz, fm;public: Fraction(int fz_val, int fm_val) &#123; fz = fz_val, fm = fm_val; int t = getGCD(); fz /= t; fm /= t; &#125; Fraction add(const Fraction &amp;r) &#123; int b = fm * r.fm; int a = fz * r.fm + r.fz * fm; Fraction F3(a, b); return F3; &#125; Fraction sub(const Fraction &amp;r) &#123; int b = fm * r.fm; int a = fz * r.fm - r.fz * fm; Fraction F3(a, b); return F3; &#125; Fraction mul(const Fraction &amp;r) &#123; int b = fm * r.fm; int a = fz * r.fz; Fraction F3(a, b); return F3; &#125; Fraction div(const Fraction &amp;r) &#123; int b = fm * r.fz; int a = fz * r.fm; Fraction F3(a, b); return F3; &#125; int getGCD() &#123; int a = fz; int b = fm; int c; while(b) &#123; c = a % b; a = b; b = c; &#125; return a; &#125; void print() &#123; if(fm &lt; 0) fm = -fm, fz = -fz; printf(&quot;%d/%d\\n&quot;, fz, fm); &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; int a, b, c, d; scanf(&quot;%d/%d&quot;, &amp;a, &amp;b); scanf(&quot;%d/%d&quot;, &amp;c, &amp;d); Fraction F1(a, b), F2(c, d); Fraction F3 = F1.add(F2); F3.print(); F3 = F1.sub(F2); F3.print(); F3 = F1.mul(F2); F3.print(); F3 = F1.div(F2); F3.print(); cout &lt;&lt; endl; &#125; return 0;&#125; 矩阵（运算符重载）: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;iostream&gt;using namespace std;class Array&#123; int n, m, t; int **data;public: Array()&#123;&#125; Array(int nv, int mv):n(nv), m(mv) &#123; data = new int*[n]; for(int i = 0; i &lt; n; i ++ ) data[i] = new int[m]; &#125; int* operator[] (int i) &#123; t = i; return *(data + i); &#125; int&amp; operator[] (int i) const &#123; return *(*(data + t) + i); &#125; int&amp; operator () (int i, int j) &#123; return data[i][j]; &#125; Array&amp; operator = (const Array&amp; a2) &#123; n = a2.n, m = a2.m; data = new int*[a2.n]; for(int i = 0; i &lt; a2.n; i ++ ) data[i] = new int[a2.m]; for(int i = 0; i &lt; n; i ++ ) for(int j = 0; j &lt; m; j ++ ) data[i][j] = a2.data[i][j]; return *this; &#125; ~Array() &#123; for(int i = 0; i &lt; n; i ++ ) delete[] data[i]; delete[] data; &#125;&#125;;int main()&#123; int t; int n, m; cin &gt;&gt; t; while(t -- ) &#123; cin &gt;&gt; n &gt;&gt; m; Array matA(n, m); for(int i = 0; i &lt; n; i ++ ) for(int j = 0; j &lt; m; j ++ ) cin &gt;&gt; matA[i][j]; cout &lt;&lt; &quot;MatrixA:&quot; &lt;&lt; endl; for(int i = 0; i &lt; n; i ++ ) &#123; for(int j = 0; j &lt; m; j ++ ) cout &lt;&lt; matA(i, j) &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; &#125; cout &lt;&lt; &quot;MatrixB:&quot; &lt;&lt; endl; Array matB; matB = matA; for(int i = 0; i &lt; n; i ++ ) &#123; for(int j = 0; j &lt; m; j ++ ) cout &lt;&lt; matB[i][j] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 集合（运算符重载）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;class Cset&#123; int len; vector&lt;int&gt; data;public: Cset()&#123;&#125; Cset(int n, int *e) &#123; len = n; for(int i = 0; i &lt; n; i ++ ) data.push_back(e[i]); &#125; friend ostream&amp; operator &lt;&lt; (ostream&amp; ot, Cset&amp; cset) &#123; for(int i = 0; i &lt; cset.len ; i ++ ) &#123; ot &lt;&lt; cset.data[i]; if(i == cset.len - 1) ot &lt;&lt; endl; else ot &lt;&lt; &quot; &quot;; &#125; &#125; friend Cset operator + (Cset&amp; c1, Cset&amp; c2) &#123; Cset c = c1; for(int i = 0; i &lt; c2.len; i ++ ) &#123; bool flag = 0; for(int j = 0; j &lt; c1.len; j ++ ) if(c1.data[j] == c2.data[i]) flag = 1; if(flag) continue; c.data.push_back(c2.data[i]); &#125; c.len = c.data.size(); return c; &#125; friend Cset operator * (Cset&amp; c1, Cset&amp; c2) &#123; Cset c; vector&lt;int&gt;::iterator it1, it2; it1 = c1.data.begin(); for(; it1 != c1.data.end(); it1 ++ ) &#123; for(it2 = c2.data.begin(); it2 != c2.data.end(); it2 ++ ) &#123; if(*it1 == *it2) c.data.push_back(*it1); &#125; &#125; c.len = c.data.size(); return c; &#125; friend Cset operator - (Cset&amp; c1, Cset&amp; c2) &#123; Cset c; vector&lt;int&gt;::iterator it1, it2; it1 = c1.data.begin(); for(; it1 != c1.data.end(); it1 ++ ) &#123; bool flag = 1; for(it2 = c2.data.begin(); it2 != c2.data.end(); it2 ++ ) if(*it1 == *it2) flag = 0; if(flag) c.data.push_back(*it1); &#125; c.len = c.data.size(); return c; &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; int len, *data; cin &gt;&gt; len; data = new int[len]; for(int i = 0; i &lt; len; i ++ ) cin &gt;&gt; data[i]; Cset cset1(len, data); cout &lt;&lt; &quot;A:&quot; &lt;&lt; cset1; cin &gt;&gt; len; data = new int[len]; for(int i = 0; i &lt; len; i ++ ) cin &gt;&gt; data[i]; Cset cset2(len, data); cout &lt;&lt; &quot;B:&quot; &lt;&lt; cset2; Cset add = cset1 + cset2; cout &lt;&lt; &quot;A+B:&quot; &lt;&lt; add; Cset sub = cset1 * cset2; cout &lt;&lt; &quot;A*B:&quot; &lt;&lt; sub; Cset bu1 = (cset1 - cset2); Cset bu2 = (cset2 - cset1); Cset bu = bu1 + bu2; cout &lt;&lt; &quot;(A-B)+(B-A):&quot; &lt;&lt; bu; cout &lt;&lt; endl; &#125; return 0;&#125; 删除重复元素（结构体+链表+类）: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;iostream&gt;using namespace std;class Node&#123; int data; Node *next;public: Node():next(NULL)&#123;&#125; Node(int e):next(NULL), data(e)&#123;&#125; friend class List;&#125;;class List&#123; Node *head; int len;public: List() &#123; len = 0; head = new Node; &#125; void insert(int e) &#123; len ++ ; Node *p = head; while(p -&gt; next) &#123; p = p -&gt; next; &#125; Node *q = new Node(e); p -&gt; next = q; &#125; bool find(int e) &#123; Node *p = head -&gt; next; for(int i = 0; i &lt; len; i ++ ) &#123; if(p -&gt; data == e) return true; p = p -&gt; next; &#125; return false; &#125; void Display() &#123; // cout &lt;&lt; len &lt;&lt; &quot; &quot;; Node *p = head -&gt; next; while(p) &#123; cout &lt;&lt; p -&gt; data; if(p -&gt; next) cout &lt;&lt; &quot; &quot;; else cout &lt;&lt; endl; p = p -&gt; next; &#125; // cout &lt;&lt; endl; &#125; ~List() &#123; Node *p = head -&gt; next; while(p) &#123; Node *q = p; p = q -&gt; next; delete q; &#125; len = 0; head -&gt; next = NULL; &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; int n, e; List list; cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++ ) &#123; cin &gt;&gt; e; if(!list.find(e)) list.insert(e); &#125; list.Display(); &#125; return 0;&#125; 三维空间的点（继承）: 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;class Point2&#123;protected: double x, y;public: Point2(double xx, double yy):x(xx), y(yy)&#123;&#125; double getDis() &#123; double res = x * x + y * y; return sqrt(res); &#125;&#125;;class Point3 : public Point2&#123; double z;public: Point3(double xx, double yy, double zz): Point2(xx, yy), z(zz)&#123;&#125; double getDis3() &#123; double res = x * x + y * y + z * z; return sqrt(res); &#125;&#125;;int main()&#123; int x, y, z; cin &gt;&gt; x &gt;&gt; y; Point2 p2(x, y); cout &lt;&lt; p2.getDis() &lt;&lt; endl; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; Point3 p3(x, y, z); cout &lt;&lt; p3.getDis3() &lt;&lt; endl; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; Point3 p4(x, y, z); cout &lt;&lt; p4.getDis3() &lt;&lt; endl; cout &lt;&lt; p4.getDis() &lt;&lt; endl; return 0;&#125; 交通工具（多重继承）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;class Vehicle&#123;protected: int max_speed, speed, weight;public: Vehicle():max_speed(0),speed(0),weight(0)&#123;&#125; Vehicle(int m, int s, int w) &#123; max_speed = m, speed = s, weight = w; &#125; void dis() &#123; printf(&quot;Vehicle:\\nmax_speed:%d\\nspeed:%d\\nweight:%d\\n\\n&quot;, max_speed, speed, weight); &#125;&#125;;class Bicycle :virtual public Vehicle&#123;protected: int height;public: Bicycle() : height(0) &#123;&#125; Bicycle(int m, int s, int w, int h) &#123; max_speed = m, speed = s, weight = w, height = h; &#125; void dis() &#123; printf(&quot;Bicycle:\\nmax_speed:%d\\nspeed:%d\\nweight:%d\\nheight:%d\\n\\n&quot;, max_speed, speed, weight, height); &#125;&#125;;class Motocar :virtual public Bicycle&#123;protected: int seat_num;public: Motocar():seat_num(0)&#123;&#125; Motocar(int m, int s, int w, int h, int sn) &#123; max_speed = m, speed = s, weight = w, height = h, seat_num = sn; &#125; void dis() const &#123; printf(&quot;Motocar:\\nmax_speed:%d\\nspeed:%d\\nweight:%d\\nseat_num:%d\\n\\n&quot;, max_speed, speed, weight, seat_num); &#125;&#125;;class Motocycle :virtual public Motocar,virtual public Bicycle&#123;public: Motocycle()&#123;&#125; Motocycle(int m, int s, int w, int h, int sn) &#123; max_speed = m, speed = s, weight = w, height = h, seat_num = sn; &#125; void dis() &#123; printf(&quot;Motocycle:\\nmax_speed:%d\\nspeed:%d\\nweight:%d\\nheight:%d\\nseat_num:%d&quot;, max_speed, speed, weight, height, seat_num); &#125;&#125;;int main()&#123; int m, s, w, h, sn; cin &gt;&gt; m &gt;&gt; s &gt;&gt; w &gt;&gt; h &gt;&gt; sn; Vehicle vehicle(m, s, w); vehicle.dis(); Bicycle bicycle(m, s, w, h); bicycle.dis(); Motocar motocar(m, s, w, h, sn); motocar.dis(); Motocycle motocycle(m, s, w, h, sn); motocycle.dis();&#125; 会员积分（期末模拟）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;using namespace std;class Mem&#123;protected: string id, name; int fen;public: Mem()&#123;&#125; Mem(string i, string n, int f):id(i), name(n), fen(f)&#123;&#125; virtual void add(int num) &#123; fen += num; &#125; virtual int Exchange(int num) &#123; int tmp = num / 100; fen -= (tmp * 100); return tmp; &#125; virtual void print() &#123; cout &lt;&lt; &quot;普通会员&quot; &lt;&lt; id &lt;&lt; &quot;--&quot; &lt;&lt; name &lt;&lt; &quot;--&quot; &lt;&lt; fen &lt;&lt; endl; &#125;&#125;;class VIP: public Mem&#123; int rate1, rate2;public: VIP(string i, string n, int f, int r1, int r2):Mem(i, n, f), rate1(r1), rate2(r2)&#123;&#125; virtual void add(int num) &#123; fen += num * rate1; &#125; virtual int Exchange(int num) &#123; int tmp = num / rate2; fen -= (tmp * rate2); return tmp; &#125; virtual void print() &#123; cout &lt;&lt; &quot;贵宾会员&quot; &lt;&lt; id &lt;&lt; &quot;--&quot; &lt;&lt; name &lt;&lt; &quot;--&quot; &lt;&lt; fen &lt;&lt; endl; &#125;&#125;;int main()&#123; string id, name; int r1, r2, f, n1, n2; cin &gt;&gt; id &gt;&gt; name &gt;&gt; f; Mem *pm; Mem mm(id, name, f); pm = &amp;mm; cin &gt;&gt; n1 &gt;&gt; n2; pm-&gt;add(n1); pm-&gt;Exchange(n2); pm-&gt;print(); cin &gt;&gt; id &gt;&gt; name &gt;&gt; f &gt;&gt; r1 &gt;&gt; r2; VIP vv(id, name, f, r1, r2); pm = &amp;vv; cin &gt;&gt; n1 &gt;&gt; n2; pm-&gt;add(n1); pm-&gt;Exchange(n2); pm-&gt;print();&#125; 元素查找（函数模板）: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;using namespace std;template&lt;typename T&gt;void myFind(T&amp; a, T *b, int n)&#123; for(int i = 0; i &lt; n; i ++ ) if(b[i] == a) &#123; cout &lt;&lt; i + 1 &lt;&lt; endl; return; &#125; cout &lt;&lt; 0 &lt;&lt; endl;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; int n; char type; cin &gt;&gt; type &gt;&gt; n; if(type == &#x27;I&#x27;) &#123; int *b = new int[n]; for(int i = 0; i &lt; n; i ++ ) cin &gt;&gt; b[i]; int a; cin &gt;&gt; a; myFind(a, b, n); &#125; else if(type == &#x27;D&#x27;) &#123; double *b = new double[n]; for(int i = 0; i &lt; n; i ++ ) cin &gt;&gt; b[i]; double a; cin &gt;&gt; a; myFind(a, b, n); &#125; else if(type == &#x27;C&#x27;) &#123; char *b = new char[n]; for(int i = 0; i &lt; n; i ++ ) cin &gt;&gt; b[i]; char a; cin &gt;&gt; a; myFind(a, b, n); &#125; else &#123; string *b = new string[n]; for(int i = 0; i &lt; n; i ++ ) cin &gt;&gt; b[i]; string a; cin &gt;&gt; a; myFind(a, b, n); &#125; &#125;&#125; 函数调用（函数指针）: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;int pingfang(int n)&#123; return n * n;&#125;double sq(double m)&#123; return sqrt(m);&#125;void toBig(char *p)&#123; int len; len = strlen(p); for(int i = 0; i &lt; len; i ++ ) &#123; if(p[i] &gt;= &#x27;a&#x27; &amp;&amp; p[i] &lt;= &#x27;z&#x27;) p[i] -= 32; &#125;&#125;int main()&#123; int (*INT)(int n); double (*DOUBLE)(double m); void (*CHAR)(char *p); int t; cin &gt;&gt; t; while(t -- ) &#123; char ch; cin &gt;&gt; ch; if(ch == &#x27;I&#x27;) &#123; INT = pingfang; int n; cin &gt;&gt; n; cout &lt;&lt; INT(n) &lt;&lt; endl; &#125; else if(ch == &#x27;F&#x27;) &#123; DOUBLE = sq; double n; cin &gt;&gt; n; cout &lt;&lt; DOUBLE(n) &lt;&lt; endl; &#125; else &#123; CHAR = toBig; char ch[100]; cin &gt;&gt; ch; CHAR(ch); cout &lt;&lt; ch &lt;&lt; endl; &#125; &#125; return 0;&#125; 加密模板（期末模拟）: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;template&lt;class T&gt;T Max(vector&lt;T&gt; data, int n)&#123; T maxx = data[0]; for(int i = 1; i &lt; n; i ++ ) if(maxx &lt; data[i]) maxx = data[i]; return maxx;&#125;template&lt;class T&gt;class password&#123; int len; vector&lt;T&gt; mingwen, miwen; T miyao;public: password(T miyao, int len, vector&lt;T&gt;ming):miyao(miyao), len(len) &#123; mingwen.resize(len); miwen.resize(len); mingwen = ming; &#125; void jiami() &#123; T m = Max(mingwen, len); for(int i = 0; i &lt; len; i ++ ) miwen[i] = m - mingwen[i] + miyao; &#125; void print() &#123; for(int i = 0; i &lt; len; i ++ ) &#123; cout &lt;&lt; miwen[i]; if(i == len - 1) cout &lt;&lt; endl; else cout &lt;&lt; &quot; &quot;; &#125; &#125;&#125;;int main()&#123; int len; vector&lt;int&gt; v1; int m1; cin &gt;&gt; m1 &gt;&gt; len; for(int i = 0; i &lt; len; i ++ ) &#123; int e; cin &gt;&gt; e; v1.push_back(e); &#125; password&lt;int&gt; p1(m1, len, v1); p1.jiami(); p1.print(); vector&lt;double&gt; v2; double m2; cin &gt;&gt; m2 &gt;&gt; len; for(int i = 0; i &lt; len; i ++ ) &#123; double e; cin &gt;&gt; e; v2.push_back(e); &#125; password&lt;double&gt; p2(m2, len, v2); p2.jiami(); p2.print(); vector&lt;char&gt; v3; char m3; cin &gt;&gt; m3 &gt;&gt; len; for(int i = 0; i &lt; len; i ++ ) &#123; char e; cin &gt;&gt; e; v3.push_back(e); &#125; password&lt;char&gt; p3(m3, len, v3); p3.jiami(); p3.print(); return 0;&#125; 加湿风扇（期末模拟）: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879 #include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class demo &#123;protected: int id, gl;public: demo(int ival, int gval) :id(ival), gl(gval) &#123;&#125;; void print() &#123; cout &lt;&lt; &quot;编号&quot; &lt;&lt; id &lt;&lt; &quot;--功率&quot; &lt;&lt; gl &lt;&lt; &#x27;W&#x27; &lt;&lt; endl; &#125;&#125;;class fan :virtual public demo &#123;protected: int fx, fl;public: fan(int ival, int gval, int fxval, int flval) :demo(ival, gval), fx(fxval), fl(flval) &#123;&#125;; void fxcontrol(int val) &#123; fx = val; &#125;; void flcontrol(int val) &#123; fl = val; &#125;; void print() &#123; cout &lt;&lt; (fx == 0 ? &quot;定向吹风&quot; : &quot;旋转吹风&quot;) &lt;&lt; &quot;--风力&quot; &lt;&lt; fl &lt;&lt; &quot;级&quot; &lt;&lt; endl; &#125;&#125;;class jsq :virtual public demo &#123;protected: float cur, max;public: jsq(int ival, int gval, float cval, float mval) :demo(ival, gval), cur(cval), max(mval) &#123;&#125;; int yujing() &#123; if (cur &gt;= max * 0.5) return 1; else if (cur &gt;= max * 0.1) return 2; else return 3; &#125; void print() &#123; int temp = yujing(); cout &lt;&lt; &quot;实际水容量&quot; &lt;&lt; cur &lt;&lt; &quot;升--&quot;; if (temp == 1) cout &lt;&lt; &quot;水量正常&quot; &lt;&lt; endl; else if (temp == 2) cout &lt;&lt; &quot;水量偏低&quot; &lt;&lt; endl; else if (temp == 3) cout &lt;&lt; &quot;水量不足&quot; &lt;&lt; endl; &#125;&#125;;class jsfan:public fan, public jsq &#123; int dangwei;public: jsfan(int ival, int gval, int fxval, int flval, float cval, float mval, int dval) :demo(ival,gval),fan(ival, gval, fxval, flval), jsq(ival, gval, cval, mval), dangwei(dval) &#123;&#125;; void dcontrol(int val) &#123; dangwei = val; if (dangwei == 0) return; else if (dangwei == 1) fan::fxcontrol(0), fan::flcontrol(1); else if (dangwei == 2) fan::fxcontrol(1), fan::flcontrol(2); else if (dangwei == 3) fan::fxcontrol(1), fan::flcontrol(3); &#125; void print() &#123; cout &lt;&lt; &quot;加湿风扇--档位&quot; &lt;&lt; dangwei &lt;&lt; endl; demo::print(), fan::print(), jsq::print(); &#125;&#125;;int main() &#123; int t; int ival, gval, fxval, flval, dval, val; float cval, mval; cin &gt;&gt; t; while (t--)&#123; cin &gt;&gt; ival &gt;&gt; gval &gt;&gt; fxval &gt;&gt; flval &gt;&gt; cval &gt;&gt; mval &gt;&gt; dval; jsfan s(ival, gval, fxval, flval, cval, mval, dval); cin &gt;&gt; val; s.dcontrol(val); s.print(); &#125; return 0;&#125; 复数运算（友元函数）: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;using namespace std;class complex&#123; double real; double imag;public: complex() &#123; real = 0, imag = 0; &#125; complex(double r, double i) &#123; real = r, imag = i; &#125; double getR()&#123;return real;&#125; double getI()&#123;return imag;&#125; friend complex addCom(complex c1, complex c2); friend void outCom(complex c);&#125;;complex addCom(complex c1, complex c2)&#123; double r = c1.getR() + c2.getR(); double i = c1.getI() + c2.getI(); complex c(r, i); return c;&#125;complex subCom(complex c1, complex c2)&#123; double r = c1.getR() - c2.getR(); double i = c1.getI() - c2.getI(); complex c(r, i); return c;&#125;void outCom(complex c)&#123; printf(&quot;(%.0lf,%.0lf)\\n&quot;, c.getR(), c.getI());&#125;int main()&#123; double r, i; cin &gt;&gt; r &gt;&gt; i; complex c(r, i); int t; cin &gt;&gt; t; while(t -- ) &#123; char ch; cin &gt;&gt; ch &gt;&gt; r &gt;&gt; i; complex c1(r, i); if(ch == &#x27;+&#x27;) c = addCom(c, c1); else c = subCom(c, c1); outCom(c); &#125; return 0;&#125; 存折与信用卡（继承）: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;using namespace std;class Account&#123;protected: string acc; string name; float balance;public: Account(string a, string n, float b) &#123; acc = a, name = n, balance = b; &#125; void Deposit(float num) &#123; balance += num; cout &lt;&lt; &quot;saving ok!&quot; &lt;&lt; endl; &#125; void Withdraw(float num) &#123; if(balance &lt; num) &#123; cout &lt;&lt; &quot;sorry! over balance!&quot; &lt;&lt; endl; return; &#125; balance -= num; cout &lt;&lt; &quot;withdraw ok!&quot; &lt;&lt; endl; &#125; void Display() &#123; cout &lt;&lt; &quot;balance is &quot; &lt;&lt; balance &lt;&lt; endl; &#125;&#125;;class Creadit : public Account&#123;protected: float limit;public: Creadit(string a, string n, float b, float l):Account(a, n, b), limit(l)&#123;&#125; void Withdraw(float num) &#123; if(balance + limit &gt;= num) &#123; balance -= num; cout &lt;&lt; &quot;withdraw ok!&quot; &lt;&lt; endl; &#125; else cout &lt;&lt; &quot;sorry! over limit!&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; string acc, name; float ba, li; cin &gt;&gt; acc &gt;&gt; name &gt;&gt; ba; Account Ac(acc, name, ba); Ac.Display(); cin &gt;&gt; ba; Ac.Deposit(ba); Ac.Display(); cin &gt;&gt; ba; Ac.Withdraw(ba); Ac.Display(); cin &gt;&gt; acc &gt;&gt; name &gt;&gt; ba &gt;&gt; li; Creadit Cr(acc, name, ba, li); Cr.Display(); cin &gt;&gt; ba; Cr.Deposit(ba); Cr.Display(); cin &gt;&gt; ba; Cr.Withdraw(ba); Cr.Display();&#125; 学生成绩计算（继承）: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;iostream&gt;using namespace std;class Person&#123;public: string name; int age; void Display() &#123; cout &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; age &lt;&lt; &quot; &quot;; &#125;&#125;;class Free : public Person&#123;public: Free() &#123; cin &gt;&gt; name &gt;&gt; age &gt;&gt; score; &#125; int score; char grade; void ope() &#123; if(score &gt;= 85) grade = &#x27;A&#x27;; else if(score &gt;= 75) grade = &#x27;B&#x27;; else if(score &gt;= 65) grade = &#x27;C&#x27;; else if(score &gt;= 60) grade = &#x27;D&#x27;; else grade = &#x27;F&#x27;; &#125; void Display() &#123; cout &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; age &lt;&lt; &quot; &quot; &lt;&lt; grade &lt;&lt; endl; &#125;&#125;;class Nonfree : public Person&#123;public: Nonfree() &#123; cin &gt;&gt; name &gt;&gt; age &gt;&gt; score1 &gt;&gt; score2; &#125; int sum, score1, score2; char grade; void ope() &#123; sum = score1 * 0.4 + score2 * 0.6; if(sum &gt;= 85) grade = &#x27;A&#x27;; else if(sum &gt;= 75) grade = &#x27;B&#x27;; else if(sum &gt;= 65) grade = &#x27;C&#x27;; else if(sum &gt;= 60) grade = &#x27;D&#x27;; else grade = &#x27;F&#x27;; &#125; void Display() &#123; cout &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; age &lt;&lt; &quot; &quot; &lt;&lt; grade &lt;&lt; endl; &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; char ch; cin &gt;&gt; ch; if(ch == &#x27;R&#x27;) &#123; Nonfree nf; nf.ope(); nf.Display(); &#125; else &#123; Free f; f.ope(); f.Display(); &#125; &#125;&#125; 成绩查询（指针运算）: 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;int main()&#123; int t; cin &gt;&gt; t; while( t-- )&#123; int n, score[1000], num; cin &gt;&gt; n; for( int i=0; i&lt;n; i++)&#123; cin &gt;&gt; score[i]; &#125; cin &gt;&gt; num; int *p, *q; p=score; if(n%2==0)&#123; q=p+n/2+1; &#125;else&#123; q=p+n/2; &#125; q--; cout &lt;&lt; *q &lt;&lt; &quot; &quot;; q++; q++; cout &lt;&lt; *q &lt;&lt; endl; cout &lt;&lt; *(p+num-1) &lt;&lt; endl; &#125; return 0;&#125; 扑克牌排序（结构体）: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;struct poke&#123; char str[10]; int weight; void getWeight() &#123; int q, w; if (strstr(str,&quot;大王&quot;)) q = 6; if (strstr(str,&quot;小王&quot;)) q = 5; if (strstr(str,&quot;黑桃&quot;)) q = 4; if (strstr(str,&quot;红桃&quot;)) q = 3; if (strstr(str,&quot;梅花&quot;)) q = 2; if (strstr(str,&quot;方块&quot;)) q = 1; if (str[6] == &#x27;A&#x27;) w = 14; else if (str[6] == &#x27;K&#x27;) w = 13; else if (str[6] == &#x27;Q&#x27;) w = 12; else if (str[6] == &#x27;J&#x27;) w = 11; else if (str[6] == &#x27;1&#x27;) w = 10; else if(str[6]) w = str[6] - &#x27;0&#x27;; weight = q * 14 + w; &#125; bool operator&lt; (const poke &amp;P)const &#123; return weight &gt; P.weight; &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; int n; cin &gt;&gt; n; poke *P = new poke[n]; for(int i = 0; i &lt; n; i ++ ) &#123; cin &gt;&gt; P[i].str; P[i].getWeight(); &#125; sort(P, P + n); for(int i = 0; i &lt; n; i ++ ) &#123; if(i == n - 1) cout &lt;&lt; P[i].str &lt;&lt; endl; else cout &lt;&lt; P[i].str &lt;&lt; &quot; &quot;; &#125; &#125;&#125; 指针对象（类和对象）: 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class student&#123;public: string name; string sex; string id; string college; string phoneNumber;&#125;;int main()&#123; int n; cin &gt;&gt; n; student *p = new student[n]; for( int i=0; i&lt;n; i++)&#123; cin &gt;&gt; (p+i)-&gt;name &gt;&gt; (p+i)-&gt;sex &gt;&gt; (p+i)-&gt;id &gt;&gt; (p+i)-&gt;college &gt;&gt; (p+i)-&gt;phoneNumber; &#125; for( int i=0; i&lt;n-1; i++)&#123; for( int j=n-1; j&gt;i; j--)&#123; if((p+j)-&gt;name.compare((p+j-1)-&gt;name)&lt;0)&#123; student temp; temp = *(p+j); *(p+j) = *(p+j-1); *(p+j-1) = temp; &#125; &#125; &#125; for( int i=0; i&lt;n; i++)&#123; cout &lt;&lt; (p+i)-&gt;name &lt;&lt; endl; &#125; return 0;&#125; 数据排序（函数模板）: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;using namespace std;template&lt;class T&gt;void mySort(T* a, int n)&#123; for(int i = 0; i &lt; n - 1; i ++ ) for(int j = n - 1; j &gt; i; j -- ) if(a[j] &lt; a[i]) swap(a[i], a[j]);&#125;template&lt;class T&gt;void Print(T* a, int n)&#123; for(int i = 0; i &lt; n; i ++ ) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; char type; int n; cin &gt;&gt; type &gt;&gt; n; if(type == &#x27;I&#x27;) &#123; int *b = new int[n]; for(int i = 0; i &lt; n; i ++ ) cin &gt;&gt; b[i]; mySort(b, n); Print(b, n); &#125; else if(type == &#x27;D&#x27;) &#123; double *b = new double[n]; for(int i = 0; i &lt; n; i ++ ) cin &gt;&gt; b[i]; mySort(b, n); Print(b, n); &#125; else if(type == &#x27;C&#x27;) &#123; char *b = new char[n]; for(int i = 0; i &lt; n; i ++ ) cin &gt;&gt; b[i]; mySort(b, n); Print(b, n); &#125; else &#123; string *b = new string[n]; for(int i = 0; i &lt; n; i ++ ) cin &gt;&gt; b[i]; mySort(b, n); Print(b, n); &#125; &#125;&#125; 最高成绩（静态成员）: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;using namespace std;class Stu&#123; int id; int score; static int maxScore; static int maxId;public: Stu(int ti = 0, int ts = 0): id(ti), score(ts)&#123;&#125; static void findMax(Stu &amp;st) &#123; if(maxScore &lt; st.score) &#123; maxScore = st.score; maxId = st.id; &#125; &#125; static int getMaxScore() &#123; return maxScore; &#125; static int getMaxId() &#123; return maxId; &#125;&#125;;int Stu::maxScore = 0;int Stu::maxId = 0;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; int id, score; cin &gt;&gt; id &gt;&gt; score; Stu st(id, score); Stu::findMax(st); &#125; cout &lt;&lt; Stu::getMaxId() &lt;&lt; &quot;--&quot; &lt;&lt; Stu::getMaxScore() &lt;&lt; endl; return 0;&#125; 月份查询（指针数组）: 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;using namespace std;int main()&#123; char*month[]=&#123; &quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot; &#125;; int t; cin &gt;&gt; t; while(t--)&#123; int n; cin &gt;&gt; n; if( n&gt;12 || n&lt;1 )&#123; cout &lt;&lt; &quot;error&quot; &lt;&lt; endl; &#125;else&#123; cout &lt;&lt; *(month+n-1) &lt;&lt; endl; &#125; &#125; return 0;&#125; 矩阵类模板（类模板）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;template&lt;class T&gt;class Mat&#123; vector&lt;vector&lt;T&gt;&gt; data; int n, m;public: Mat(int n, int m):n(n), m(m) &#123; data.resize(n); for(int i = 0; i &lt; n; i ++ ) data[i].resize(m); &#125; void transport() &#123; vector&lt;vector&lt;T&gt;&gt; d; d.resize(m); for(int i = 0; i &lt; n; i ++ ) for(int j = 0; j &lt; m; j ++ ) d[j].push_back(data[i][j]); data.resize(m); for(int i = 0; i &lt; m; i ++ ) data[i].resize(n); data = d; swap(n, m); &#125; friend istream&amp; operator &gt;&gt; (istream&amp; in, Mat&amp; m) &#123; for(int i = 0; i &lt; m.n; i ++ ) for(int j = 0; j &lt; m.m; j ++ ) in &gt;&gt; m.data[i][j]; return in; &#125; friend ostream&amp; operator &lt;&lt; (ostream&amp; ot, Mat&amp; m) &#123; for(int i = 0; i &lt; m.n; i ++ ) for(int j = 0; j &lt; m.m; j ++ ) &#123; cout &lt;&lt; m.data[i][j]; if(j == m.m - 1) cout &lt;&lt; endl; else cout &lt;&lt; &quot; &quot;; &#125; return ot; &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; char type; int n, m; cin &gt;&gt; type &gt;&gt; n &gt;&gt; m; if (type == &#x27;I&#x27;) &#123; Mat&lt;int&gt; mat(n, m); cin &gt;&gt; mat; mat.transport(); cout &lt;&lt; mat; &#125; else if (type == &#x27;D&#x27;) &#123; Mat&lt;double&gt; mat(n, m); cin &gt;&gt; mat; mat.transport(); cout &lt;&lt; mat; &#125; else if (type == &#x27;C&#x27;) &#123; Mat&lt;char&gt; mat(n, m); cin &gt;&gt; mat; mat.transport(); cout &lt;&lt; mat; &#125; &#125;&#125; 计重转换（期末模拟）: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;using namespace std;class CN; //提前声明class EN; //提前声明class Weight&#123; //抽象类protected: char kind[20]; //计重类型 int gram; //克public: Weight (char tk[] = &quot;no name&quot;, int tg=0) &#123; strcpy(kind, tk); gram = tg; &#125; virtual void Print(ostream &amp; out) = 0; //输出不同类型的计重信息&#125;;class CN: public Weight&#123; //中国计重 int j, l, q, k;public: CN(int j, int l, int q, int k, char ch[]) : j(j), l(l), q(q), k(k) &#123; strcpy(kind, ch); &#125; CN(int num, char ch[]) &#123; j = num / 500, num %= 500; l = num / 50, num %= 50; q = num / 5, num %= 5; k = num; strcpy(kind, ch); &#125; void Convert(int num) &#123; j = num / 500, num %= 500; l = num / 50, num %= 50; q = num / 5, num %= 5; k = num; &#125; void Print(ostream &amp; out) &#123; out &lt;&lt; kind &lt;&lt; &quot;:&quot; &lt;&lt; j &lt;&lt; &quot;斤&quot; &lt;&lt; l &lt;&lt; &quot;两&quot; &lt;&lt; q &lt;&lt; &quot;钱&quot; &lt;&lt; k &lt;&lt; &quot;克&quot; &lt;&lt; endl; &#125;&#125;;class EN: public Weight&#123; //英国计重 int b, z, d, k;public: EN(int b, int z, int d, int k, char ch[]) : b(b), z(z), d(d), k(k) &#123; strcpy(kind, ch); &#125; void Convert(int num) &#123; b = num / 512, num %= 512; z = num / 32, num %= 32; d = num / 2, num %= 2; k = num; &#125; void Print(ostream &amp; out) &#123; out &lt;&lt; kind &lt;&lt; &quot;:&quot; &lt;&lt; b &lt;&lt; &quot;磅&quot; &lt;&lt; z &lt;&lt; &quot;盎司&quot; &lt;&lt; d &lt;&lt; &quot;打兰&quot; &lt;&lt; k &lt;&lt; &quot;克&quot; &lt;&lt; endl; &#125; operator CN() &#123; int t = k + d * 2 + z * 32 + b * 512; return CN(t, &quot;中国计重&quot;); &#125;&#125;;ostream&amp; operator&lt;&lt;(ostream&amp; out, Weight&amp; c)&#123; c.Print(out); return out;&#125;int main()//主函数&#123; int tw; CN cn(0,0,0,0, &quot;中国计重&quot;); cin &gt;&gt; tw; cn.Convert(tw); //把输入的克数转成中国计重 cout &lt;&lt; cn; EN en(0,0,0,0,&quot;英国计重&quot;); cin&gt;&gt;tw; en.Convert(tw); //把输入的克数转成英国计重 cout &lt;&lt; en; cn = en; //把英国计重转成中国计重 cout &lt;&lt; cn; return 0;&#125; 访问数组元素（引用）: 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;using namespace std;#define N 1000int &amp;put(int *num, int i)&#123; return *(num + i);&#125;int main()&#123; int num[N]; int t, n, sum, i; cin &gt;&gt; t; while(t -- ) &#123; cin &gt;&gt; n; for(i = 0; i &lt; n; i ++ ) &#123; cin &gt;&gt; put(num, i); &#125; for(sum = 0, i = 0; i &lt; n; i ++ ) sum += num[i]; cout &lt;&lt; &quot;sum=&quot; &lt;&lt; sum &lt;&lt; endl; &#125; return 0;&#125; 距离计算（友元函数）: 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;class Point&#123; double x, y;public: Point(double xx, double yy) &#123; x = xx, y = yy; &#125; friend double Distance(Point &amp;a, Point &amp;b);&#125;;double Distance(Point &amp;a, Point &amp;b)&#123; double len = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y); return sqrt(len);&#125;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; double x1, y1, x2, y2; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2; Point p1(x1, y1), p2(x2, y2); cout &lt;&lt; (int)Distance(p1, p2) &lt;&lt; endl; &#125; return 0;&#125; 金属加工（期末模拟）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;using namespace std;class block&#123; int y, w, v;public: block()&#123;&#125; block(int y, int w, int v) : y(y), w(w), v(v) &#123;&#125; block(block&amp; b) &#123; y = b.y, w = b.w, v = b.v; &#125; friend block operator + (block&amp; b1, block&amp; b2) &#123; int y = b1.y + b2.y; int w = b1.w + b2.w; int v = b1.v + b2.v; block tmp(y, w, v); return tmp; &#125; friend block operator * (block&amp; b, int n) &#123; int y = b.y; int w = b.w; int v = b.v * n; block tmp(y, w, v); return tmp; &#125; bool operator ++ () &#123; w *= 1.1, v *= 1.1; y ++ ; &#125; block operator -- (int) &#123; block tmp(*this); w *= 0.9, v *= 0.9; y --; return tmp; &#125; void print() &#123; cout &lt;&lt; &quot;硬度&quot; &lt;&lt; y &lt;&lt; &quot;--重量&quot; &lt;&lt; w &lt;&lt; &quot;--体积&quot; &lt;&lt; v &lt;&lt; endl; &#125;&#125;;int main()&#123; int y, w, v, n; cin &gt;&gt; y &gt;&gt; w &gt;&gt; v; block b1(y, w, v); cin &gt;&gt; y &gt;&gt; w &gt;&gt; v; block b2(y, w, v); cin &gt;&gt; n; (b1 + b2).print(); (b1 * n).print(); (++ b1); b1.print(); b2 -- ; b2.print();&#125; 立方体碰撞检测（复合类+动态对象数组+析构）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;using namespace std;class Point&#123; int x, y, z;public: Point():x(0), y(0), z(0)&#123;&#125; Point(int a, int b, int c):x(a),y(b),z(c)&#123;&#125; int getX()&#123;return x;&#125; int getY()&#123;return y;&#125; int getZ()&#123;return z;&#125; ~Point() &#123; x = 0, y = 0, z = 0; &#125; friend class Cube;&#125;;class Cube&#123; Point *point; int minX, minY, minZ; int maxX, maxY, maxZ;public: Cube() &#123; point = new Point[2]; &#125; Cube(int x1, int y1, int z1, int x2, int y2, int z2) &#123; point = new Point[2]; Point p1(x1, y1, z1), p2(x2, y2, z2); point[0] = p1, point[1] = p2; &#125; void ope() &#123; minX = min(point[0].getX(), point[1].getX()); maxX = max(point[0].getX(), point[1].getX()); minY = min(point[0].getY(), point[1].getY()); maxY = max(point[0].getY(), point[1].getY()); minZ = min(point[0].getZ(), point[1].getZ()); maxZ = max(point[0].getZ(), point[1].getZ()); &#125; bool collide(Cube &amp;C) &#123; if(minX &gt; C.maxX || maxX &lt; C.minX || minY &gt; C.maxY || maxY &lt; C.minY || minZ &gt; C.maxZ || maxZ &lt; C.minZ) return false; return true; &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; int x1, x2, y1, y2, z1, z2; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; z1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; z2; Cube c1(x1, y1, z1, x2, y2, z2); cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; z1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; z2; Cube c2(x1, y1, z1, x2, y2, z2); c1.ope(), c2.ope(); if(c1.collide(c2)) cout &lt;&lt; &quot;collide&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;have distance&quot; &lt;&lt; endl; &#125; return 0;&#125; 倚天屠龙记（函数模板）: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;template &lt;class T&gt;void add(T* a, T* b, int n)&#123; for(int i = 0; i &lt; n; i ++ ) cout &lt;&lt; b[i]; for(int i = 0; i &lt; n; i ++ ) cout &lt;&lt; a[i]; cout &lt;&lt; endl;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; char type; int n; cin &gt;&gt; type &gt;&gt; n; if(type == &#x27;I&#x27;) &#123; int *a = new int[n]; int *b = new int[n]; for(int i = 0; i &lt; n; i ++ ) cin &gt;&gt; a[i]; for(int i = 0; i &lt; n; i ++ ) cin &gt;&gt; b[i]; add(a, b, n); &#125; else if(type == &#x27;D&#x27;) &#123; double *a = new double[n]; double *b = new double[n]; for(int i = 0; i &lt; n; i ++ ) cin &gt;&gt; a[i]; for(int i = 0; i &lt; n; i ++ ) cin &gt;&gt; b[i]; add(a, b, n); &#125; else if(type == &#x27;C&#x27;) &#123; char *a = new char[n]; char *b = new char[n]; for(int i = 0; i &lt; n; i ++ ) cin &gt;&gt; a[i]; for(int i = 0; i &lt; n; i ++ ) cin &gt;&gt; b[i]; add(a, b, n); &#125; &#125; return 0;&#125; 动态数组（指针与数组）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;using namespace std;int main()&#123; int t; cin &gt;&gt; t; while( t-- )&#123; char c; int n; cin &gt;&gt; c &gt;&gt; n; if( c==&#x27;I&#x27;)&#123; int item; int *p = new int[n]; for( int i=0; i&lt;n; i++)&#123; cin &gt;&gt; item; *(p+i) = item; &#125; int sum = 0; for( int i=0; i&lt;n; i++)&#123; sum += *(p+i); &#125; float ave = 0; ave = sum/n; cout &lt;&lt; ave &lt;&lt; endl; &#125;else if( c==&#x27;C&#x27; )&#123; char ch; char *q = new char[n]; for( int i=0; i&lt;n; i++)&#123; cin &gt;&gt; ch; *(q+i) = ch; &#125; char max = *q; for( int i=0; i&lt;n; i++)&#123; if( *(q+i)&gt;max )&#123; max = *(q+i); &#125; &#125; cout &lt;&lt; max &lt;&lt; endl; &#125;else if( c==&#x27;F&#x27; )&#123; float *r = new float[n]; float fl; for( int i=0; i&lt;n; i++)&#123; cin &gt;&gt; fl; *(r+i) = fl; &#125; float min = 99999999; for( int i=0; i&lt;n; i++)&#123; if( *(r+i)&lt;min )&#123; min = *(r+i); &#125; &#125; cout &lt;&lt; min &lt;&lt; endl; &#125; &#125; system(&quot;pause&quot;); return 0;&#125; 动物园（虚函数与多态）: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;iostream&gt;using namespace std;class Animal&#123;protected: string name; int age;public: Animal(string n, int a):name(n), age(a)&#123;&#125; virtual void Dis()&#123;&#125;;&#125;;class Tiger:public Animal&#123;public: Tiger(string n, int a): Animal(n, a)&#123;&#125; void Dis() &#123; cout &lt;&lt; &quot;Hello,I am &quot; &lt;&lt; name &lt;&lt; &quot;,AOOO.&quot; &lt;&lt; endl; &#125;&#125;;class Pig:public Animal&#123;public: Pig(string n, int a): Animal(n, a)&#123;&#125; void Dis() &#123; cout &lt;&lt; &quot;Hello,I am &quot; &lt;&lt; name &lt;&lt; &quot;,HENGHENG.&quot; &lt;&lt; endl; &#125;&#125;;class Duck:public Animal&#123;public: Duck(string n, int a): Animal(n, a)&#123;&#125; void Dis() &#123; cout &lt;&lt; &quot;Hello,I am &quot; &lt;&lt; name &lt;&lt; &quot;,GAGA.&quot; &lt;&lt; endl; &#125;&#125;;class Dog:public Animal&#123;public: Dog(string n, int a): Animal(n, a)&#123;&#125; void Dis() &#123; cout &lt;&lt; &quot;Hello,I am &quot; &lt;&lt; name &lt;&lt; &quot;,WangWang.&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; string name, ani; int age, t; Animal *a[100]; cin &gt;&gt; t; for(int i = 0; i &lt; t; i ++ ) &#123; cin &gt;&gt; ani &gt;&gt; name &gt;&gt; age; if(ani == &quot;Tiger&quot;) &#123; a[i] = new Tiger(name, age); a[i]-&gt;Dis(); &#125; else if(ani == &quot;Pig&quot;) &#123; a[i] = new Pig(name, age); a[i]-&gt;Dis(); &#125; else if(ani == &quot;Duck&quot;) &#123; a[i] = new Duck(name, age); a[i]-&gt;Dis(); &#125; else if(ani == &quot;Dog&quot;) &#123; a[i] = new Dog(name, age); a[i]-&gt;Dis(); &#125; else &#123; cout &lt;&lt; &quot;There is no &quot; &lt;&lt; ani &lt;&lt; &quot; in our Zoo.&quot; &lt;&lt; endl; &#125; &#125;&#125; 圆和圆柱体计算（继承）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;using namespace std;class Point&#123;protected: double x, y;public: int getX()&#123; return x; &#125; int getY()&#123; return y; &#125;&#125;;class Circle : public Point&#123;protected: double radius;public: Circle() &#123;&#125; Circle(double X, double Y, double r) &#123; x = X, y = Y, radius = r; &#125; int getR()&#123; return radius; &#125; double Area() &#123; return 3.14 * radius * radius; &#125; void DisplayCir() &#123; printf(&quot;Circle:(%d,%d),%d\\n&quot;, getX(),getY(),getR()); printf(&quot;Area:%.2lf\\n&quot;, Area()); &#125;&#125;;class Cylinder : public Circle&#123; double high;public: Cylinder(double X, double Y, double r, double h) &#123; x = X, y = Y, radius = r, high = h; &#125; int getH() &#123; return high; &#125; double Volume() &#123; return Area() * high; &#125; void DisplayCyl() &#123; printf(&quot;Cylinder:(%d,%d),%d,%d\\n&quot;, getX(),getY(),getR(), getH()); printf(&quot;Volume:%.2lf\\n&quot;, Volume()); &#125;&#125;;int main()&#123; double x, y, r, h; cin &gt;&gt; x &gt;&gt; y &gt;&gt; r; Circle c1(x, y, r); c1.DisplayCir(); cin &gt;&gt; x &gt;&gt; y &gt;&gt; r &gt;&gt; h; Cylinder cy(x, y, r, h); cy.DisplayCyl(); return 0;&#125; 在职研究生（多重继承）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;iostream&gt;using namespace std;class People&#123;protected: string name, sex; int age;public: People()&#123;&#125; People(string n, string s, int a):name(n), sex(s), age(a)&#123;&#125; void display() &#123; cout &lt;&lt; &quot;People:&quot; &lt;&lt; endl; cout &lt;&lt; &quot;Name: &quot; &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; &quot;Sex: &quot; &lt;&lt; sex &lt;&lt; endl; cout &lt;&lt; &quot;Age: &quot; &lt;&lt; age &lt;&lt; endl; cout &lt;&lt; endl; &#125;&#125;;class Stu:virtual public People&#123;protected: string id; double grade;public: Stu()&#123;&#125; Stu(string n, string s, int a, string ID, double g):People(n, s, a), id(ID), grade(g)&#123;&#125; void display() &#123; cout &lt;&lt; &quot;Student:&quot; &lt;&lt; endl; cout &lt;&lt; &quot;Name: &quot; &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; &quot;Sex: &quot; &lt;&lt; sex &lt;&lt; endl; cout &lt;&lt; &quot;Age: &quot; &lt;&lt; age &lt;&lt; endl; cout &lt;&lt; &quot;No.: &quot; &lt;&lt; id &lt;&lt; endl; cout &lt;&lt; &quot;Score: &quot; &lt;&lt; grade &lt;&lt; endl; cout &lt;&lt; endl; &#125;&#125;;class Tea:virtual public People&#123;protected: string work, dep;public: Tea()&#123;&#125; Tea(string n, string s, int a, string w, string d):People(n, s, a),work(w), dep(d)&#123;&#125; void display() &#123; cout &lt;&lt; &quot;Teacher:&quot; &lt;&lt; endl; cout &lt;&lt; &quot;Name: &quot; &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; &quot;Sex: &quot; &lt;&lt; sex &lt;&lt; endl; cout &lt;&lt; &quot;Age: &quot; &lt;&lt; age &lt;&lt; endl; cout &lt;&lt; &quot;Position: &quot; &lt;&lt; work &lt;&lt; endl; cout &lt;&lt; &quot;Department: &quot; &lt;&lt; dep &lt;&lt; endl; cout &lt;&lt; endl; &#125;&#125;;class Grad:public Tea, public Stu&#123; string tea, dire;public: Grad()&#123;&#125; Grad(string n, string s, int a, string ID, double g, string w, string d, string dir, string tea):People(n, s, a) &#123; this -&gt; id = ID, this -&gt;grade = g; work = w, dep = d, this -&gt; tea = tea, this -&gt; dire = dir; &#125; void display() &#123; cout &lt;&lt; &quot;GradOnWork:&quot; &lt;&lt; endl; cout &lt;&lt; &quot;Name: &quot; &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; &quot;Sex: &quot; &lt;&lt; sex &lt;&lt; endl; cout &lt;&lt; &quot;Age: &quot; &lt;&lt; age &lt;&lt; endl; cout &lt;&lt; &quot;No.: &quot; &lt;&lt; id &lt;&lt; endl; cout &lt;&lt; &quot;Score: &quot; &lt;&lt; grade &lt;&lt; endl; cout &lt;&lt; &quot;Position: &quot; &lt;&lt; work &lt;&lt; endl; cout &lt;&lt; &quot;Department: &quot; &lt;&lt; dep &lt;&lt; endl; cout &lt;&lt; &quot;Direction: &quot; &lt;&lt; dire &lt;&lt; endl; cout &lt;&lt; &quot;Tutor: &quot; &lt;&lt; tea &lt;&lt; endl; &#125;&#125;;int main()&#123; string name, sex, id, work, dep, dir, tea; int age; double gra; cin &gt;&gt; name &gt;&gt; sex &gt;&gt; age; cin &gt;&gt; id &gt;&gt; gra; cin &gt;&gt; work &gt;&gt; dep; cin &gt;&gt; dir &gt;&gt; tea; People p(name, sex, age); p.display(); Stu stu(name, sex, age, id, gra); stu.display(); Tea tea1(name, sex, age, work, dep); tea1.display(); Grad grad(name, sex, age, id, gra, work, dep, dir, tea); grad.display(); return 0;&#125; 学生类定义（类和对象）: 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;class student&#123;public: string name; string id; string college; string major; string xinBie; string address; string phoneNumber;&#125;;int main()&#123; int t; cin &gt;&gt; t; student stu[t]; for( int i=0; i&lt;t; i++)&#123; cin &gt;&gt; stu[i].name &gt;&gt; stu[i].id &gt;&gt; stu[i].college &gt;&gt; stu[i].major &gt;&gt; stu[i].xinBie &gt;&gt; stu[i].address &gt;&gt; stu[i].phoneNumber; &#125; for( int i=0; i&lt;t; i++)&#123; cout &lt;&lt; stu[i].name &lt;&lt; &quot; &quot; &lt;&lt; stu[i].id &lt;&lt; &quot; &quot; &lt;&lt; stu[i].college &lt;&lt; &quot; &quot; &lt;&lt; stu[i].major &lt;&lt; &quot; &quot; &lt;&lt; stu[i].xinBie &lt;&lt; &quot; &quot; &lt;&lt; stu[i].address &lt;&lt; &quot; &quot; &lt;&lt; stu[i].phoneNumber &lt;&lt; endl; &#125; return 0;&#125; 小票输入输出（结构体）: 123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;struct Pos&#123; string name, te, op, ci, cn, tr, co, va;&#125;;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; Pos pos; cin &gt;&gt; pos.name &gt;&gt; pos.te &gt;&gt; pos.op &gt;&gt; pos.ci &gt;&gt; pos.va &gt;&gt; pos.cn &gt;&gt; pos.tr &gt;&gt; pos.co; cout &lt;&lt; &quot;Name: &quot; &lt;&lt; pos.name &lt;&lt; endl &lt;&lt; &quot;Terminal: &quot; &lt;&lt; pos.te &lt;&lt; &quot; operator: &quot; &lt;&lt; pos.op &lt;&lt; endl &lt;&lt; &quot;Card Issuers: &quot; &lt;&lt; pos.ci &lt;&lt; &quot; Validity: &quot; &lt;&lt; pos.va &lt;&lt; endl &lt;&lt; &quot;CardNumber: &quot; &lt;&lt; pos.cn.substr(0,4) &lt;&lt; &quot;********&quot; &lt;&lt; pos.cn.substr(12,4) &lt;&lt; endl &lt;&lt; &quot;Traded: &quot; &lt;&lt; pos.tr &lt;&lt; endl &lt;&lt; &quot;Costs: $&quot; &lt;&lt; pos.co &lt;&lt; endl &lt;&lt; endl; &#125; return 0;&#125; 教师类定义（类和对象）: 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;class teacher&#123;public: string name; string sex; string college; string zhiChen; string zhiWu; string xueLi; string office; string phoneNumber;&#125;;int main()&#123; int t; cin &gt;&gt; t; teacher *tea = new teacher[t]; for( int i=0; i&lt;t; i++)&#123; cin &gt;&gt; tea[i].name &gt;&gt; tea[i].sex &gt;&gt; tea[i].college &gt;&gt; tea[i].zhiChen &gt;&gt; tea[i].zhiWu &gt;&gt; tea[i].xueLi &gt;&gt; tea[i].office &gt;&gt; tea[i].phoneNumber; &#125; for( int i=0; i&lt;t; i++)&#123; cout &lt;&lt; tea[i].name &lt;&lt; &quot; &quot; &lt;&lt; tea[i].sex &lt;&lt; &quot; &quot; &lt;&lt; tea[i].college &lt;&lt; &quot; &quot; &lt;&lt; tea[i].zhiChen &lt;&lt; &quot; &quot; &lt;&lt; tea[i].zhiWu &lt;&lt; &quot; &quot; &lt;&lt; tea[i].xueLi&lt;&lt; &quot; &quot; &lt;&lt; tea[i].office &lt;&lt; &quot; &quot; &lt;&lt; tea[i].phoneNumber &lt;&lt; endl; &#125; return 0;&#125; 求最大值最小值（引用）: 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;void find(int *num, int n, int &amp;MinIdx, int &amp;MaxIdx)&#123; int Min = 0x3f3f3f3f, Max = -Min; for(int i = 0; i &lt; n; i ++ ) &#123; if(Min &gt; num[i]) Min = num[i], MinIdx = i; if(Max &lt; num[i]) Max = num[i], MaxIdx = i; &#125;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; int *num, n, MinIdx, MaxIdx; cin &gt;&gt; n; num = new int[n]; for(int i = 0; i &lt; n; i ++ ) cin &gt;&gt; num[i]; find(num, n, MinIdx, MaxIdx); cout &lt;&lt; &quot;min=&quot; &lt;&lt; num[MinIdx] &lt;&lt; &quot; minindex=&quot; &lt;&lt; MinIdx &lt;&lt; endl; cout &lt;&lt; &quot;max=&quot; &lt;&lt; num[MaxIdx] &lt;&lt; &quot; maxindex=&quot; &lt;&lt; MaxIdx &lt;&lt; endl; cout &lt;&lt; endl; &#125;&#125; 点到原点的距离（继承）: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;class Podouble_1D&#123;public: double x; double Distance() &#123; return fabs(x); &#125;&#125;;class Podouble_2D: public Podouble_1D&#123;public: double y; double Distance() &#123; double dis = x * x + y * y; return sqrt(dis); &#125;&#125;;class Podouble_3D: public Podouble_2D&#123;public: double Distance() &#123; double dis = x * x + y * y + z * z; return sqrt(dis); &#125; void setZ(double Z) &#123; z = Z; &#125; double getZ()&#123; return z; &#125;protected: double z;&#125;;int main()&#123; int n; while(cin &gt;&gt; n, n) &#123; if(n == 1) &#123; Podouble_1D p1; cin &gt;&gt; p1.x; printf(&quot;Distance from Point (%.2lf) to original point is %.2lf\\n&quot;, p1.x, p1.Distance()); &#125; else if(n == 2) &#123; Podouble_2D p2; cin &gt;&gt; p2.x &gt;&gt; p2.y; printf(&quot;Distance from Point (%.2lf, %.2lf) to original point is %.2lf\\n&quot;, p2.x, p2.y, p2.Distance()); &#125; else if(n == 3) &#123; Podouble_3D p3; double z; cin &gt;&gt; p3.x &gt;&gt; p3.y &gt;&gt; z; p3.setZ(z); printf(&quot;Distance from Point (%.2lf, %.2lf, %.2lf) to original point is %.2lf\\n&quot;, p3.x, p3.y, p3.getZ(), p3.Distance()); &#125; &#125; return 0;&#125; 矩形关系（运算符重载）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;iostream&gt;using namespace std;class CPoint&#123; int x, y;public: CPoint(int x, int y):x(x), y(y)&#123;&#125; int getX()&#123;return x;&#125; int getY()&#123;return y;&#125;&#125;;bool cmp(CPoint&amp; p1, CPoint&amp; p2)&#123; if(p1.getY() == p2.getY() &amp;&amp; p1.getX() == p2.getX()) return true; return false;&#125;class CRectangle&#123; CPoint left, right;public: CRectangle(int x1, int y1, int x2, int y2): left(x1, y1), right(x2, y2)&#123;&#125; friend ostream&amp; operator &lt;&lt; (ostream&amp; ot, CRectangle&amp; r1) &#123; ot &lt;&lt; r1.left.getX() &lt;&lt; &quot; &quot; &lt;&lt; r1.left.getY() &lt;&lt; &quot; &quot;; ot &lt;&lt; r1.right.getX() &lt;&lt; &quot; &quot; &lt;&lt; r1.right.getY(); return ot; &#125; operator int() &#123; int a = right.getX() - left.getX(); int b = left.getY() - right.getY(); int area = abs(a * b); return area; &#125; friend bool operator &gt; (CPoint&amp; p, CRectangle&amp; r) &#123; int x = p.getX(), y = p.getY(); int x1 = r.left.getX(), y1 = r.left.getY(); int x2 = r.right.getX(), y2 = r.right.getY(); if(x &gt;= x1 &amp;&amp; x &lt;= x2 &amp;&amp; y &lt;= y1 &amp;&amp; y &gt;= y2) return true; return false; &#125; friend bool operator &gt; (CRectangle&amp; r1, CRectangle&amp; r2) &#123; CPoint p1 = r2.left, p2 = r2.right; if(p1 &gt; r1 &amp;&amp; p2 &gt; r1) return true; return false; &#125; friend bool operator == (CRectangle&amp; r1, CRectangle&amp; r2) &#123; CPoint p1 = r2.left, p2 = r2.right; CPoint p3 = r1.left, p4 = r1.right; if(cmp(p1, p3) &amp;&amp; cmp(p2, p4)) return true; return false; &#125; friend bool operator * (CRectangle&amp; r1, CRectangle&amp; r2) &#123; CPoint p1 = r2.left, p2 = r2.right; CPoint p3 = r1.left, p4 = r1.right; //A.x1 &gt; B.x2 || A.x2 &lt; B.x1 || A.y1 &gt; B.y2 || A.y2 &lt; B.y1 if(p1.getX() &gt; p4.getX() || p1.getY() &lt; p4.getY() || p2.getX() &lt; p3.getX() || p2.getY() &gt; p3.getY()) return false; return true; &#125;&#125;;int main()&#123; int t, x1, x2, y1, y2; cin &gt;&gt; t; while(t -- ) &#123; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2; CRectangle rect1(x1, y1, x2, y2); cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2; CRectangle rect2(x1, y1, x2, y2); cout &lt;&lt; &quot;矩形1:&quot; &lt;&lt; rect1 &lt;&lt; &quot; &quot; &lt;&lt; (int)rect1 &lt;&lt; endl; cout &lt;&lt; &quot;矩形2:&quot; &lt;&lt; rect2 &lt;&lt; &quot; &quot; &lt;&lt; (int)rect2 &lt;&lt; endl; if(rect1 == rect2) cout &lt;&lt; &quot;矩形1和矩形2相等&quot; &lt;&lt; endl; else if(rect2 &gt; rect1) cout &lt;&lt; &quot;矩形2包含矩形1&quot; &lt;&lt; endl; else if(rect1 &gt; rect2) cout &lt;&lt; &quot;矩形1包含矩形2&quot; &lt;&lt; endl; else if(rect1 * rect2) cout &lt;&lt; &quot;矩形1和矩形2相交&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;矩形1和矩形2不相交&quot; &lt;&lt;endl; cout &lt;&lt;endl; &#125; return 0;&#125; 矩阵左转（指针与数组）: 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;void rotate(int *matrix,int *changed_matrix)&#123; for(int i=0;i&lt;2;i++) &#123; for(int j=0;j&lt;3;j++) &#123; *(changed_matrix+(2-j)*2+i) =*(matrix+i*3+j); &#125; &#125;&#125;int main()&#123;int t; cin&gt;&gt;t; while (t--) &#123; int matrix[2][3],changed_matrix[3][2]; for(int i=0;i&lt;2;i++) for(int j=0;j&lt;3;j++) cin&gt;&gt;matrix[i][j]; rotate(*matrix,*changed_matrix); for(int i=0;i&lt;3;i++) &#123; for(int j=0;j&lt;2;j++) cout&lt;&lt;*(*(changed_matrix+i)+j)&lt;&lt;&#x27; &#x27;; cout&lt;&lt;endl; &#125; &#125; return 0;&#125; 矩阵相乘（运算符重载）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;class Mat&#123; vector&lt;vector&lt;int&gt;&gt; mat; int len;public: Mat(int n) &#123; len = n; mat.resize(n); for(int i = 0; i &lt; n; i ++ ) mat[i].resize(n); &#125; Mat(int n, int k) &#123; len = n; mat.resize(n); for(int i = 0; i &lt; n; i ++ ) mat[i].resize(n); for(int i = 0; i &lt; n; i ++ ) for(int j = 0; j &lt; n; j ++ ) if(i == j) mat[i][j] = 1; else mat[i][j] = 0; &#125; Mat(int n, vector&lt;vector&lt;int&gt;&gt; data) &#123; len = n; mat.resize(n); for(int i = 0; i &lt; n; i ++ ) mat[i].resize(n); for(int i = 0; i &lt; n; i ++ ) for(int j = 0; j &lt; n; j ++ ) mat[i][j] = data[i][j]; &#125; friend Mat operator * (Mat&amp; m1, Mat&amp; m2) &#123; int t = m1.len; Mat tmp(t); for(int k = 0; k &lt; t; k ++ ) for(int i = 0; i &lt; t; i ++ ) for(int j = 0; j &lt; t; j ++ ) tmp.mat[i][j] += m1.mat[i][k] * m2.mat[k][j]; return tmp; &#125; void Dis() &#123; for(int i = 0; i &lt; len; i ++ ) &#123; for(int j = 0; j &lt; len; j ++ ) &#123; cout &lt;&lt; mat[i][j]; if(j == len - 1) cout &lt;&lt; endl; else cout &lt;&lt; &quot; &quot;; &#125; &#125; &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; data; data.resize(n); for(int i = 0; i &lt; n; i ++ ) data[i].resize(n); Mat m(n, 1); while(t -- ) &#123; for(int i = 0; i &lt; n; i ++ ) for(int j = 0; j &lt; n; j ++ ) cin &gt;&gt; data[i][j]; Mat m1(n, data); m = m * m1; &#125; m.Dis();&#125; 矩阵相加（运算符重载）: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;iostream&gt;using namespace std;class Mat&#123; int n, m, **data;public: Mat(Mat&amp; mat) &#123; this -&gt; n = mat.n; this -&gt; m = mat.m; data = new int*[m]; for(int i = 0; i &lt; m; i ++ ) data[i] = new int[n]; for(int i = 0; i &lt; m; i ++ ) for(int j = 0; j &lt; n; j ++ ) data[i][j] = mat.data[i][j]; &#125; Mat(int mm, int nn, int **d) &#123; this -&gt; m = mm, this -&gt; n = nn; data = new int*[m]; for(int i = 0; i &lt; m; i ++ ) data[i] = new int[n]; for(int i = 0; i &lt; m; i ++ ) for(int j = 0; j &lt; n; j ++ ) data[i][j] = d[i][j]; &#125; friend Mat&amp; operator + (Mat&amp; m1, Mat&amp; m2) &#123; for(int i = 0; i &lt; m1.m; i ++ ) for(int j = 0; j &lt; m1.n; j ++ ) m1.data[i][j] += m2.data[i][j]; return m1; &#125; void Dis() &#123; for(int i = 0; i &lt; m; i ++ ) for(int j = 0; j &lt; n; j ++ ) &#123; cout &lt;&lt; data[i][j]; if(j == n - 1) cout &lt;&lt; endl; else cout &lt;&lt; &quot; &quot;; &#125; &#125; ~Mat() &#123; for(int i = 0; i &lt; m; i ++ ) delete data[i]; delete[] data; &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; int n, m; cin &gt;&gt; m &gt;&gt; n; int **d; d = new int*[m]; for(int i = 0; i &lt; m; i ++ ) d[i] = new int[n]; for(int i = 0; i &lt; m; i ++ ) for(int j = 0; j &lt; n; j ++ ) cin &gt;&gt; d[i][j]; Mat m1(m, n, d); for(int i = 0; i &lt; m; i ++ ) for(int j = 0; j &lt; n; j ++ ) cin &gt;&gt; d[i][j]; Mat m2(m, n, d); Mat m3(m1 + m2); m3.Dis(); &#125;&#125; 货币加减（运算符重载）: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;using namespace std;class Money&#123; int yuan, jiao, fen;public: Money(int i, int j, int k):yuan(i), jiao(j), fen(k)&#123;&#125; void Dis() &#123; printf(&quot;%d元%d角%d分\\n&quot;, yuan, jiao, fen); &#125; friend Money operator + (Money&amp; m1, Money&amp; m2) &#123; int i = m1.yuan + m2.yuan; int j = m1.jiao + m2.jiao; int k = m1.fen + m2.fen; if(k &gt; 10) k = k % 10, j ++ ; if(j &gt; 10) j = j % 10, i ++ ; return Money(i, j, k); &#125; friend Money operator - (Money&amp; m1, Money&amp; m2) &#123; int i = m1.yuan - m2.yuan; int j = m1.jiao - m2.jiao; int k = m1.fen - m2.fen; if(k &lt; 0) k = k + 10, j -- ; if(j &lt; 0) j = j + 10, i -- ; return Money(i, j, k); &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; int i, j, k; string ope; cin &gt;&gt; i &gt;&gt; j &gt;&gt; k; Money money(i, j, k); while(cin &gt;&gt; ope) &#123; if(ope == &quot;stop&quot;) break; cin &gt;&gt; i &gt;&gt; j &gt;&gt; k; Money money1(i, j, k); if(ope == &quot;add&quot;) money = money + money1; else money = money - money1; &#125; money.Dis(); &#125;&#125; 向量的加减（运算符重载）: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;class Vector&#123; int vec[10];public: Vector(int v[]) &#123; for(int i = 0; i &lt; 10; i ++ ) vec[i] = v[i]; &#125; Vector()&#123;&#125; Vector(const Vector&amp; obj) &#123; for(int i = 0; i &lt; 10; i ++ ) vec[i] = obj.vec[i]; &#125; Vector operator +(const Vector&amp; obj) &#123; int tmp[10]; for(int i = 0; i &lt; 10; i ++ ) tmp[i] = vec[i] + obj.vec[i]; return Vector(tmp); &#125; Vector operator -(const Vector&amp; obj) &#123; int tmp[10]; for(int i = 0; i &lt; 10; i ++ ) tmp[i] = vec[i] - obj.vec[i]; return Vector(tmp); &#125; void print() &#123; for(int i = 0; i &lt; 10; i ++ ) &#123; cout &lt;&lt; vec[i]; if(i == 9) cout &lt;&lt; endl; else cout &lt;&lt; &quot; &quot;; &#125; &#125;&#125;;int main()&#123; int t1[10], t2[10]; for(int i = 0; i &lt; 10; i ++ ) cin &gt;&gt; t1[i]; for(int i = 0; i &lt; 10; i ++ ) cin &gt;&gt; t2[i]; Vector v1(t1), v2(t2); (v1 + v2).print(); (v1 - v2).print(); return 0;&#125; 员工工资（虚函数与多态）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;iostream&gt;using namespace std;class Person&#123;protected: string name, zhi; int money, age, level;public: Person(string n, string z, int a, int l):name(n), zhi(z), age(a), level(l)&#123;&#125; void Dis() &#123; if(age &lt; 0 || level &lt; 0) &#123; cout &lt;&lt; &quot;error grade or year.&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; name &lt;&lt; &quot;:&quot; &lt;&lt; zhi &lt;&lt; &quot;,Salary:&quot; &lt;&lt; money &lt;&lt; endl; &#125; &#125; virtual void salary()&#123;&#125;&#125;;class Employee:public Person&#123;public: Employee(string n, string z, int a, int l): Person(n, z, a, l)&#123;&#125; void salary() &#123; money = 1000 + 500 * level + 50 * age; &#125;&#125;;class Teamleader:public Person&#123;public: Teamleader(string n, string z, int a, int l): Person(n, z, a, l)&#123;&#125; void salary() &#123; money = 3000 + 800 * level + 100 * age; &#125;&#125;;class Manager:public Person&#123;public: Manager(string n, string z, int a, int l): Person(n, z, a, l)&#123;&#125; void salary() &#123; money = 5000 + 1000 * (level + age); &#125;&#125;;int main()&#123; string name, zhi; int a, l, n; cin &gt;&gt; n; Person *p[100]; for(int i = 0; i &lt; n; i ++ ) &#123; cin &gt;&gt; name &gt;&gt; zhi &gt;&gt; l &gt;&gt; a; if(zhi == &quot;Employee&quot;) &#123; p[i] = new Employee(name, zhi, a, l); p[i]-&gt;salary(); p[i]-&gt;Dis(); &#125; else if(zhi == &quot;Teamleader&quot;) &#123; p[i] = new Teamleader(name, zhi, a, l); p[i]-&gt;salary(); p[i]-&gt;Dis(); &#125; else if(zhi == &quot;Manager&quot;) &#123; p[i] = new Manager(name, zhi, a, l); p[i]-&gt;salary(); p[i]-&gt;Dis(); &#125; else &#123; cout &lt;&lt; &quot;error position.&quot; &lt;&lt; endl; &#125; &#125;&#125; 四进制加法（运算符重载）: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;class Num&#123; vector&lt;int&gt; num;public: Num()&#123;&#125; Num(string e) &#123; for(int i = e.size() - 1; i &gt;= 0; i -- ) num.push_back(e[i] - &#x27;0&#x27;); &#125; Num(vector&lt;int&gt; e):num(e)&#123;&#125; friend Num operator+(const Num&amp; A, const Num&amp; B) &#123; vector&lt;int&gt; C; int t; for(int i = 0; i &lt; A.num.size() || i &lt; B.num.size(); i ++ ) &#123; if(i &lt; A.num.size()) t += A.num[i]; if(i &lt; B.num.size()) t += B.num[i]; C.push_back(t % 4); t /= 4; &#125; if(t) C.push_back(1); while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return Num(C); &#125; void Display() &#123; for(int i = num.size() - 1; i &gt;= 0; i -- ) cout &lt;&lt; num[i]; cout &lt;&lt; endl; &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; Num n; string num; while(t -- ) &#123; cin &gt;&gt; num; Num n1(num); n = n + n1; &#125; n.Display();&#125; 图形面积（虚函数与多态）: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;using namespace std;class Shape&#123;protected: double a, b, r; double area;public: Shape(double a, double b):a(a), b(b)&#123;&#125; Shape(double r):r(r)&#123;&#125; virtual void Area()&#123;&#125; virtual void Dis() &#123; printf(&quot;%.2lf\\n&quot;, area); &#125;&#125;;class Square:virtual public Shape&#123;public: Square(double a, double b): Shape(a, b)&#123;&#125; void Area() &#123; area = a * b; &#125;&#125;;class Rect:virtual public Shape&#123;public: Rect(double a, double b): Shape(a, b)&#123;&#125; void Area() &#123; area = a * b; &#125;&#125;;class Circle:public Shape&#123;public: Circle(double r): Shape(r)&#123;&#125; void Area() &#123; area = 3.14 * r * r; &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; Shape *s[3]; double a, b, r; cin &gt;&gt; r; s[0] = new Circle(r); s[0]-&gt;Area(); s[0]-&gt;Dis(); cin &gt;&gt; a; s[1] = new Square(a, a); s[1] -&gt;Area(); s[1]-&gt;Dis(); cin &gt;&gt; a &gt;&gt; b; s[2] = new Rect(a, b); s[2]-&gt;Area(); s[2]-&gt;Dis(); &#125;&#125; 大整数计算（运算符重载）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276#include&lt;iostream&gt;using namespace std;#include&lt;string.h&gt;#include&lt;math.h&gt;class CBigInteger&#123; char *p; public: CBigInteger(); CBigInteger(char *q); friend CBigInteger operator+(CBigInteger&amp;,CBigInteger&amp;); friend CBigInteger operator-(CBigInteger&amp;,CBigInteger&amp;); friend CBigInteger operator*(CBigInteger&amp;,CBigInteger&amp;); ~CBigInteger(); char* getp()&#123;return p;&#125;; friend ostream&amp;operator&lt;&lt;(ostream &amp;,CBigInteger&amp; ); friend istream&amp;operator&gt;&gt;(istream &amp;,CBigInteger&amp;);&#125;;ostream&amp;operator&lt;&lt;(ostream &amp;o,CBigInteger &amp;c)&#123; int i; if(c.p[0]==&#x27;-&#x27;)&#123; o&lt;&lt;&quot;(&quot;&lt;&lt;c.p[0]; for(i=1;i&lt;strlen(c.p);i++)&#123; if(c.p[i]!=&#x27;0&#x27;)&#123; break; &#125; &#125; for(i;i&lt;strlen(c.p);i++)&#123; o&lt;&lt;c.p[i]; &#125; cout&lt;&lt;&quot;)&quot;; &#125;else&#123; if(strlen(c.p)==1)&#123; o&lt;&lt;c.p; &#125;else&#123; for(i=0;i&lt;strlen(c.p);i++)&#123; if(c.p[i]!=&#x27;0&#x27;)&#123; break; &#125; &#125; for(i;i&lt;strlen(c.p);i++)&#123; o&lt;&lt;c.p[i]; &#125; &#125; &#125; return o;&#125;istream&amp;operator&gt;&gt;(istream &amp;i,CBigInteger&amp;c)&#123; /*for(int i=0;i&lt;strlen(c.p);i++)&#123; o&gt;&gt;c.p[i]&gt;&gt;endl; &#125;*/ i&gt;&gt;c.p; return i;&#125;CBigInteger::CBigInteger()&#123; p=new char[1001];&#125;CBigInteger::CBigInteger(char *q)&#123; p=new char[1001]; p=q;&#125;CBigInteger::~CBigInteger()&#123; delete[]p;&#125;CBigInteger operator+(CBigInteger &amp;c1,CBigInteger &amp;c2)&#123; CBigInteger c; int i,sum1=0,sum2=0,sum3=0; if(c1.p[0]!=&#x27;-&#x27;) i=0; else i=1; for(i;i&lt;strlen(c1.p);i++)&#123; sum1=sum1*10+c1.p[i]-&#x27;0&#x27;; &#125; // cout&lt;&lt;&quot;sum1&quot;&lt;&lt;sum1&lt;&lt;endl; if(c2.p[0]!=&#x27;-&#x27;) i=0; else i=1; for(i;i&lt;strlen(c2.p);i++)&#123; sum2=sum2*10+c2.p[i]-&#x27;0&#x27;; &#125; // cout&lt;&lt;&quot;sum2&quot;&lt;&lt;sum2&lt;&lt;endl; if(c1.p[0]!=&#x27;-&#x27;&amp;&amp;c2.p[0]!=&#x27;-&#x27;) sum3=sum1+sum2; else if(c1.p[0]==&#x27;-&#x27;&amp;&amp;c2.p[0]!=&#x27;-&#x27;) sum3=sum2-sum1; else if(c1.p[0]!=&#x27;-&#x27;&amp;&amp;c2.p[0]==&#x27;-&#x27;) sum3=sum1-sum2; else if(c1.p[0]==&#x27;-&#x27;&amp;&amp;c2.p[0]==&#x27;-&#x27;)&#123; sum3=-sum1-sum2; &#125; //cout&lt;&lt;sum3&lt;&lt;&quot;sum3 &quot;&lt;&lt;endl; int len=0; for(i=1;sum3/i!=0;i=i*10)&#123; len++; // cout&lt;&lt;len&lt;&lt;endl; &#125; i=0; int flag=1; int len1=len; if(sum3==0)&#123; c.p[0]=&#x27;0&#x27;; c.p[1]=&#x27;\\0&#x27;; return c; &#125; if(sum3&lt;0)&#123; sum3=-sum3; flag=0; &#125; if(flag==0)&#123; c.p[0]=&#x27;-&#x27;; i=1; len1=len+1; &#125; //cout&lt;&lt;&quot;len=&quot;&lt;&lt;len&lt;&lt;endl; for(i;i&lt;len1;i++)&#123; if(flag==1) c.p[i]=(int)(sum3/pow(10,len-i-1))%10+&#x27;0&#x27;; //cout&lt;&lt;c.p[i]&lt;&lt;endl; else&#123; c.p[i]=(int)(sum3/pow(10,len-i))%10+&#x27;0&#x27;; &#125; &#125; c.p[len1]=&#x27;\\0&#x27;; return c;&#125;;CBigInteger operator-(CBigInteger &amp;c1,CBigInteger &amp;c2)&#123; CBigInteger c; int i,sum1=0,sum2=0,sum3=0; if(c1.p[0]!=&#x27;-&#x27;) i=0; else i=1; for(i;i&lt;strlen(c1.p);i++)&#123; sum1=sum1*10+c1.p[i]-&#x27;0&#x27;; &#125; //cout&lt;&lt;&quot;sum1&quot;&lt;&lt;sum1&lt;&lt;endl; if(c2.p[0]!=&#x27;-&#x27;) i=0; else i=1; for(i;i&lt;strlen(c2.p);i++)&#123; sum2=sum2*10+c2.p[i]-&#x27;0&#x27;; &#125; if(c1.p[0]!=&#x27;-&#x27;&amp;&amp;c2.p[0]!=&#x27;-&#x27;) sum3=sum1-sum2; else if(c1.p[0]==&#x27;-&#x27;&amp;&amp;c2.p[0]!=&#x27;-&#x27;)&#123; sum3=sum2+sum1; sum3=-sum3; &#125; else if(c1.p[0]!=&#x27;-&#x27;&amp;&amp;c2.p[0]==&#x27;-&#x27;) sum3=sum1+sum2; //cout&lt;&lt;sum3&lt;&lt;&quot;sum3 &quot;&lt;&lt;endl; int len=0; for(i=1;sum3/i!=0;i=i*10)&#123; len++; // cout&lt;&lt;len&lt;&lt;endl; &#125; if(sum3==0)&#123; c.p[0]=&#x27;0&#x27;; c.p[1]=&#x27;\\0&#x27;; return c; &#125; i=0; int len1=len; int flag=1; if(sum3&lt;0)&#123; sum3=-sum3; flag=0; &#125; if(flag==0)&#123; c.p[0]=&#x27;-&#x27;; i=1; len1=len+1; &#125; //cout&lt;&lt;&quot;len=&quot;&lt;&lt;len&lt;&lt;endl; for(i;i&lt;len1;i++)&#123; if(flag==1) c.p[i]=(int)(sum3/pow(10,len-i-1))%10+&#x27;0&#x27;; else&#123; c.p[i]=(int)(sum3/pow(10,len-i))%10+&#x27;0&#x27;; &#125; &#125; c.p[len1]=&#x27;\\0&#x27;; return c;&#125;;CBigInteger operator*(CBigInteger &amp;c1,CBigInteger &amp;c2)&#123; CBigInteger c; long long i; long long sum1=0,sum2=0; long long sum3=0; if(c1.p[0]!=&#x27;-&#x27;) i=0; else i=1; for(i;i&lt;strlen(c1.p);i++)&#123; sum1=sum1*10+c1.p[i]-&#x27;0&#x27;; &#125; // cout&lt;&lt;&quot;sum1 &quot;&lt;&lt;sum1&lt;&lt;endl; if(c2.p[0]!=&#x27;-&#x27;) i=0; else i=1; for(i;i&lt;strlen(c2.p);i++)&#123; sum2=sum2*10+c2.p[i]-&#x27;0&#x27;; &#125;// cout&lt;&lt;&quot;sum2 &quot;&lt;&lt;sum2&lt;&lt;endl; sum3=sum1*sum2;// cout&lt;&lt;&quot;sum3 &quot;&lt;&lt;sum3&lt;&lt;endl; if((c1.p[0]!=&#x27;-&#x27;&amp;&amp;c2.p[0]==&#x27;-&#x27;)||(c2.p[0]!=&#x27;-&#x27;&amp;&amp;c1.p[0]==&#x27;-&#x27;))&#123; sum3=-sum3; &#125; //cout&lt;&lt;sum3&lt;&lt;&quot;sum3&quot;&lt;&lt;endl; int len=0; for(i=1;sum3/i!=0;i=i*10)&#123; len++; &#125; i=0; int flag=1; int len1=len; if(sum3==0)&#123; c.p[0]=&#x27;0&#x27;; c.p[1]=&#x27;\\0&#x27;; return c; &#125; if(sum3&lt;0)&#123; sum3=-sum3; flag=0; &#125; if(flag==0)&#123; //cout&lt;&lt;&quot;1&quot;&lt;&lt;endl; c.p[0]=&#x27;-&#x27;; i=1; len1=len+1; &#125; //cout&lt;&lt;&quot;i&quot;&lt;&lt;i&lt;&lt;endl; //cout&lt;&lt;&quot;len1=&quot;&lt;&lt;len1&lt;&lt;endl; //cout&lt;&lt;&quot;pow=&quot;&lt;&lt;(int)pow(10,0)&lt;&lt;endl; for(i;i&lt;len1;i++)&#123; if(flag==1) if(i==(len1-1))&#123; c.p[i]=sum3%10+&#x27;0&#x27;; &#125;else&#123; c.p[i]=(int)(sum3/pow(10,len-i-1))%10+&#x27;0&#x27;; &#125; else&#123; c.p[i]=(int)(sum3/pow(10,len-i))%10+&#x27;0&#x27;; &#125; //cout&lt;&lt;(int)(sum3/pow(10,len-i))&lt;&lt;endl; //cout&lt;&lt;c.p[i]&lt;&lt;&quot; 1&quot;&lt;&lt;endl; &#125; c.p[len1]=&#x27;\\0&#x27;; return c;&#125;;int main()&#123; int t; char op; CBigInteger bigNum1; CBigInteger bigNum2; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;bigNum1&gt;&gt;op&gt;&gt;bigNum2; cout&lt;&lt;bigNum1&lt;&lt;&quot; &quot;&lt;&lt;op&lt;&lt;&quot; &quot;&lt;&lt;bigNum2&lt;&lt;&quot; = &quot;; if(op==&#x27;+&#x27;)&#123; CBigInteger num = bigNum1+bigNum2; cout&lt;&lt;num&lt;&lt;endl; &#125;else if(op==&#x27;-&#x27;)&#123; CBigInteger num = bigNum1-bigNum2; cout&lt;&lt;num&lt;&lt;endl; &#125; else if(op==&#x27;*&#x27;)&#123; CBigInteger num = bigNum1*bigNum2; cout&lt;&lt;num&lt;&lt;endl; &#125; //cout&lt;&lt;bigNum1&lt;&lt;endl; &#125;&#125; 字符串比较（指针与字符）: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;iostream&gt;using namespace std;int compare(char *S, char *T)&#123; int len1=0, len2=0; while( *(S+len1)!=&#x27;\\0&#x27;)&#123; len1++; &#125; while( *(T+len2)!=&#x27;\\0&#x27;)&#123; len2++; &#125; if( len1 &gt; len2 )&#123; return 1; &#125;else if( len1 &lt; len2 )&#123; return -1; &#125;else&#123; int greater=0, weaker=0; for( int i=0; i&lt;len1; i++)&#123; if( *(S+i)&gt;*(T+i) )&#123; greater++; &#125;else if(*(S+i)&lt;*(T+i))&#123; weaker++; &#125; &#125; if( greater &gt; weaker )&#123; return 1; &#125;else if( greater &lt; weaker )&#123; return -1; &#125;else&#123; return 0; &#125; &#125;&#125;int main()&#123; int t; cin &gt;&gt; t; while( t-- )&#123; char str1[100], str2[100]; char *S, *T; cin &gt;&gt; str1; cin &gt;&gt; str2; S = str1; T = str2; int n = compare(S, T); cout &lt;&lt; n &lt;&lt; endl; &#125; return 0;&#125;/*#include&lt;iostream&gt;using namespace std;#include&lt;cstring&gt;int cmp(char *S, char *T)&#123; int lenS = strlen(S); int lenT = strlen(T); int cnt1 = 0, cnt2 = 0; if(lenS == lenT) &#123; for(int i = 0; i &lt; lenS; i ++ ) &#123; if(S[i] &gt; T[i]) cnt1 ++ ; else if(S[i] &lt; T[i]) cnt2 ++ ; &#125; if(cnt1 &gt; cnt2) return 1; else if(cnt1 &lt; cnt2) return -1; return 0; &#125; else if(lenS &gt; lenT) return 1; else return -1;&#125;int main()&#123; int t; cin &gt;&gt; t; char S[100], T[100]; while(t -- ) &#123; cin &gt;&gt; S; cin &gt;&gt; T; cout &lt;&lt; cmp(S, T) &lt;&lt; endl; &#125; return 0;&#125;*/ 字符串比较（运算符重载）: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;class str&#123; string s;public: str()&#123;&#125; str(string s):s(s)&#123;&#125; friend bool operator &gt; (str&amp; s1, str&amp; s2) &#123; return s1.s &gt; s2.s; &#125; friend bool operator &lt; (str&amp; s1, str&amp; s2) &#123; return s1.s &lt; s2.s; &#125; friend bool operator == (str&amp; s1, str&amp; s2) &#123; return s1.s == s2.s; &#125; void Dis() &#123; cout &lt;&lt; s &lt;&lt; endl; &#125;&#125;;int main()&#123; string a, b, c; getline(cin, a); getline(cin, b); getline(cin, c); str str1(a), str2(b), str3(c); if(str1 &gt; str2) str1.Dis(); else str2.Dis(); if(str1 &lt; str3) str1.Dis(); else str3.Dis(); if(str2 == str3) str2.Dis(); else str3.Dis(); return 0;&#125; 支票账户（虚函数与多态）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;iostream&gt;using namespace std;class BaseAccount&#123;protected: string name, account; int balance;public: BaseAccount()&#123;&#125; BaseAccount(string n, string a, int b):name(n), account(a), balance(b)&#123;&#125; void Deposit(int sum) &#123; balance += sum; &#125; virtual void Withdraw(int sum) &#123; if(sum &gt; balance) &#123; cout &lt;&lt; &quot;insufficient&quot; &lt;&lt; endl; return; &#125; balance -= sum; &#125; virtual void Display() &#123; cout &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; account &lt;&lt; &quot; Balance:&quot; &lt;&lt; balance &lt;&lt; endl; &#125;&#125;;class BasePlus : public BaseAccount&#123; int limit;public: BasePlus(string n, string a, int b, int l = 5000):BaseAccount(n, a,b), limit(l)&#123;&#125; void Withdraw(int sum) &#123; if(sum &gt; balance + limit) &#123; cout &lt;&lt; &quot;insufficient&quot; &lt;&lt; endl; return; &#125; balance -= sum; if(balance &lt; 0) &#123; limit += balance; balance = 0; &#125; &#125; void Display() &#123; cout &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; account &lt;&lt; &quot; Balance:&quot; &lt;&lt; balance &lt;&lt; &quot; limit:&quot; &lt;&lt; limit &lt;&lt; endl; &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; BaseAccount *Count[t]; string name, account; int balance, limit, num; for(int i = 0; i &lt; t; i ++ ) &#123; cin &gt;&gt; name &gt;&gt; account &gt;&gt; num; if(account[1] == &#x27;A&#x27;) Count[i] = new BaseAccount(name, account, num); else Count[i] = new BasePlus(name, account, num); cin &gt;&gt; num; Count[i]-&gt;Deposit(num); cin &gt;&gt; num; Count[i] -&gt;Withdraw(num); cin &gt;&gt; num; Count[i]-&gt;Deposit(num); cin &gt;&gt; num; Count[i] -&gt;Withdraw(num); Count[i] -&gt;Display(); &#125; return 0;&#125; 旅馆旅客管理（静态成员）: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;class Customer&#123;public: Customer(string name); static void changeYear(int r) &#123; Year = r; &#125; static void xigou() &#123; TotalCustNum = 0; Rent = 150; &#125; void Display();private: static int TotalCustNum; static int Rent; static int Year; int CustID; string CustName;&#125;;void Customer::Display()&#123; cout &lt;&lt; CustName; printf(&quot; %d%04d %d %d\\n&quot;, Year, CustID, CustID, CustID * Rent);&#125;int Customer::TotalCustNum = 0;int Customer::Rent = 150;int Customer::Year = 0;Customer::Customer(string name)&#123; CustName = name; CustID = ++ TotalCustNum;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; int year; cin &gt;&gt; year; Customer::changeYear(year); int cnt = 0; string name; while(cin &gt;&gt; name) &#123; if(name == &quot;0&quot;) break; Customer cu(name); cu.Display(); &#125; &#125;&#125; 有界数组模板类（类模板）: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;using namespace std;template&lt;class T&gt;void mySort(T* a, int n)&#123; for(int i = 0; i &lt; n - 1; i ++ ) for(int j = n - 1; j &gt; i; j -- ) if(a[j] &lt; a[i]) swap(a[i], a[j]);&#125;template&lt;class T&gt;void Print(T* a, int n)&#123; for(int i = 0; i &lt; n; i ++ ) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125;template&lt;class T&gt;void find(T* a, int n, T t)&#123; int k = -1; for(int i = 0; i &lt; n; i ++ ) &#123; if(a[i] == t) &#123; k = i; break; &#125; &#125; cout &lt;&lt; k &lt;&lt; endl;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; char type; int n; cin &gt;&gt; type &gt;&gt; n; if(type == &#x27;I&#x27;) &#123; int *a = new int[n]; for(int i = 0; i &lt; n; i ++ ) cin &gt;&gt; a[i]; int t; cin &gt;&gt; t; mySort(a, n); Print(a, n); find(a, n, t); &#125; else if(type == &#x27;D&#x27;) &#123; double *a = new double[n]; for(int i = 0; i &lt; n; i ++ ) cin &gt;&gt; a[i]; double t; cin &gt;&gt; t; mySort(a, n); Print(a, n); find(a, n, t); &#125; else if(type == &#x27;C&#x27;) &#123; char *a = new char[n]; for(int i = 0; i &lt; n; i ++ ) cin &gt;&gt; a[i]; char t; cin &gt;&gt; t; mySort(a, n); Print(a, n); find(a, n, t); &#125; &#125; return 0;&#125; 汽车收费（虚函数和多态）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;using namespace std;class Vehicle&#123;protected: string no; //编号public: Vehicle(string n):no(n)&#123;&#125; virtual void display() = 0; //应收费用&#125;;class Car : public Vehicle&#123; int weight, num;public: Car(string No, int n, int w):Vehicle(No), num(n), weight(w)&#123;&#125; void display() &#123; cout &lt;&lt; no &lt;&lt; &quot; &quot; &lt;&lt; num * 8 + weight * 2 &lt;&lt; endl; &#125;&#125;;class Truck : public Vehicle&#123; int weight;public: Truck(string No, int w):Vehicle(No), weight(w)&#123;&#125; void display() &#123; cout &lt;&lt; no &lt;&lt; &quot; &quot; &lt;&lt; weight * 5 &lt;&lt; endl; &#125;&#125;;class Bus : public Vehicle&#123; int num;public: Bus(string No, int n):Vehicle(No), num(n)&#123;&#125; void display() &#123; cout &lt;&lt; no &lt;&lt; &quot; &quot; &lt;&lt; num * 3 &lt;&lt; endl; &#125;&#125;;int main()&#123; Vehicle *pv[10]; int n, wei, num, cnt = 0; string no; cin &gt;&gt; n; while(n -- ) &#123; int type; cin &gt;&gt; type; switch (type) &#123; case 1: cin &gt;&gt; no &gt;&gt; num &gt;&gt; wei; pv[cnt] = new Car(no, num, wei); break; case 2: cin &gt;&gt; no &gt;&gt; wei; pv[cnt] = new Truck(no, wei); break; case 3: cin &gt;&gt; no &gt;&gt; num; pv[cnt] = new Bus(no, num); break; &#125; pv[cnt] -&gt; display(); cnt ++ ; &#125; return 0;&#125; 谁的票数最高（函数模板）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;template&lt;class T&gt;void count(T* a, int n)&#123; int max = 0, id = 0; vector&lt;int&gt; cnt; cnt.assign(n, 1); for(int i = 0; i &lt; n - 1; i ++ ) for(int j = i + 1; j &lt; n; j ++ ) if(a[i] == a[j]) cnt[i] ++ ; for(int i = 0; i &lt; n; i ++ ) if(cnt[i] &gt; max) &#123; max = cnt[i]; id = i; &#125; cout &lt;&lt; a[id] &lt;&lt; &quot; &quot; &lt;&lt; cnt[id] &lt;&lt; endl;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; char type; int n; cin &gt;&gt; type &gt;&gt; n; if(type == &#x27;I&#x27;) &#123; int *b = new int[n]; for(int i = 0; i &lt; n; i ++ ) cin &gt;&gt; b[i]; count(b, n); &#125; else if(type == &#x27;C&#x27;) &#123; char *b = new char[n]; for(int i = 0; i &lt; n; i ++ ) cin &gt;&gt; b[i]; count(b, n); &#125; else &#123; string *b = new string[n]; for(int i = 0; i &lt; n; i ++ ) cin &gt;&gt; b[i]; count(b, n); &#125; &#125; return 0;&#125; 三串合一（指针与字符数组）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;using namespace std;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; //读入字符串 char ch0[3][11]; for(int i = 0; i &lt; 3; i ++) &#123; cin &gt;&gt; ch0[i];// cout &lt;&lt; ch0[i] &lt;&lt; endl; &#125; //st数组记录开始的a， ed数组记录结束的b， // sub多余了，懒得删掉，len表示长度 int st[3], ed[3], len = 0; for(int i = 0; i &lt; 3; i ++ ) &#123; cin &gt;&gt; st[i] &gt;&gt; ed[i]; len += ed[i] - st[i] + 1; &#125;// cout &lt;&lt; len &lt;&lt; endl; char *ch = new char[len + 1]; int cnt = 0;//记录当前赋值到第几个字符了 //赋值 for(int i = 0; i &lt; 3; i ++ ) &#123; for(int j = st[i] - 1; j &lt; ed[i]; j ++ ) &#123;// ch0[i][j] *(ch + cnt) = *( *(ch0 + i) + j); cnt ++ ; &#125; &#125; *(ch + cnt) = &#x27;\\0&#x27;; cout &lt;&lt; ch &lt;&lt; endl; &#125; return 0;&#125; 复数（输入输出运算符重载）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;using namespace std;class CComplex&#123; int real, imag;public: CComplex() &#123; real = 0, imag = 0; &#125; friend istream&amp; operator &gt;&gt;(istream &amp;in, CComplex &amp;a) &#123; in &gt;&gt; a.real &gt;&gt; a.imag; return in; &#125; friend ostream&amp; operator &lt;&lt;(ostream &amp;out, CComplex &amp;a) &#123; if(a.imag != 0 &amp;&amp; a.real == 0) out &lt;&lt; a.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl; else if(a.imag == 0 &amp;&amp; a.real != 0) out &lt;&lt; a.real &lt;&lt; endl; else if(a.imag == 0 &amp;&amp; a.real == 0) out &lt;&lt; 0 &lt;&lt; endl; else &#123; if(a.imag &lt; 0) out &lt;&lt; a.real &lt;&lt; a.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl; else out &lt;&lt; a.real &lt;&lt; &quot;+&quot; &lt;&lt; a.imag &lt;&lt; &quot;i&quot; &lt;&lt; endl; &#125; return out; &#125;&#125;;int main()&#123; int n; double r, i; CComplex x; cin &gt;&gt; n; while(n -- ) &#123; cin &gt;&gt; x; cout &lt;&lt; x; &#125; return 0;&#125; 宠物的生长（虚函数和多态）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;iostream&gt;using namespace std;class Date&#123; int year, month, day;public: Date(int y,int m,int d):year(y), month(m), day(d)&#123;&#125; bool isLeap() &#123; return (year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0); &#125; bool check(Date&amp; d) &#123; if(d.year != year) return d.year &gt; year; if(d.month != month) return d.month &gt; month; if(d.day != day) return d.day &gt; day; return true; &#125; int abs(Date&amp; d) &#123; int monthDay[] = &#123; 31,isLeap() ? 29 : 28,31,30,31,30,31,31,30,31,30,31 &#125;; int s[13] = &#123;0&#125;; for(int i = 1; i &lt;= 12; i ++ ) s[i] = s[i - 1] + monthDay[i]; if(d.month == month &amp;&amp; d.year == year) return d.day - day; if(d.year == year) &#123; int a1 = s[d.month - 1] + d.day; int a2 = s[month - 1] + day; return a1 - a2 + 1; &#125; &#125;&#125;;class Pet&#123;protected: string name;//姓名 double length;//身长 double weight;//体 Date current;//开始记录时间public: Pet(string n, double l, double w, Date&amp; d):name(n), length(l), weight(w), current(d)&#123;&#125; virtual void display(Date day)=0;//输出目标日期时宠物的身长和体重&#125;;class Cat : public Pet&#123; double hrate, wrate;public: Cat(string n, double l, double w, Date&amp; d):Pet(n, l, w, d) &#123; hrate = 0.1, wrate = 0.2; &#125; void display(Date day) &#123; length += current.abs(day) * hrate; weight += current.abs(day) * wrate; cout &lt;&lt; name &lt;&lt; &quot; after &quot; &lt;&lt; current.abs(day); printf(&quot; day: length=%.2lf,weight=%.2lf\\n&quot;, length, weight); &#125;&#125;;class Dog : public Pet&#123; double hrate, wrate;public: Dog(string n, double l, double w, Date&amp; d):Pet(n, l, w, d) &#123; hrate = 0.2, wrate = 0.1; &#125; void display(Date day) &#123; length += current.abs(day) * hrate; weight += current.abs(day) * wrate; cout &lt;&lt; name &lt;&lt; &quot; after &quot; &lt;&lt; current.abs(day); printf(&quot; day: length=%.2lf,weight=%.2lf\\n&quot;, length, weight); &#125;&#125;;int main()&#123; int n; Pet *pet[10]; cin &gt;&gt; n; int y, m, d; double l, w; string name; cin &gt;&gt; y &gt;&gt; m &gt;&gt; d; Date begin(y, m, d); int cnt = 0; while(n -- ) &#123; int type; cin &gt;&gt; type; cin &gt;&gt; name &gt;&gt; l &gt;&gt; w &gt;&gt; y &gt;&gt; m &gt;&gt; d; Date date(y, m, d); if(type == 1) pet[cnt] = new Cat(name, l, w, begin); else pet[cnt] = new Dog(name, l, w, begin); if(!begin.check(date)) cout &lt;&lt; &quot;error&quot; &lt;&lt; endl; else pet[cnt] -&gt;display(date); cnt ++ ; &#125; return 0;&#125; 数字判断（指针为函数参数）: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;using namespace std;int isNumber(char *p, int len)&#123; int k, sum=0; for( int i = 0; i &lt; len; i ++ )&#123; if( *(p+i) &lt;= &#x27;9&#x27; &amp;&amp; *(p+i) &gt;= &#x27;0&#x27; )&#123; k = *(p+i) - &#x27;0&#x27;; sum = sum * 10 + k; &#125;else&#123; return -1; &#125; &#125; return sum;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t -- )&#123; char ch[100]; cin &gt;&gt; ch; int i=0; while(ch[i] != &#x27;\\0&#x27;)&#123; i++; &#125; char *p=ch; int n = isNumber(p, i); cout &lt;&lt; n &lt;&lt; endl; &#125; return 0;&#125;// #include&lt;iostream&gt;// #include&lt;cstring&gt;// #include&lt;stack&gt;// using namespace std;// int isNumber(char *str)// &#123;// stack&lt;int&gt; st;// int len = strlen(str);// for(int i = 0; i &lt; len; i ++ )// &#123;// if(str[i] &lt;= &#x27;9&#x27; &amp;&amp; str[i] &gt;= &#x27;0&#x27;)// st.push(str[i] - &#x27;0&#x27;);// else return -1;// &#125;// int res = 1, sum = 0;// while(!st.empty())// &#123;// sum += st.top() * res;// res *= 10;// st.pop();// &#125;// return sum;// &#125;// int main()// &#123;// char str[100];// int t;// cin &gt;&gt; t;// while(t -- )// &#123;// cin &gt;&gt; str;// cout &lt;&lt; isNumber(str) &lt;&lt; endl;// &#125;// return 0;// &#125; 时钟调整（运算符前后增量）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;using namespace std;class Time&#123; int h, m, s;public: Time(int h, int m, int s):h(h), m(m), s(s)&#123;&#125; friend Time operator ++ (Time&amp; t) &#123; t.s ++ ; if(t.s &gt;= 60) t.s %= 60, t.m ++ ; if(t.m &gt;= 60) t.m %= 60, t.h ++ ; if(t.h &gt;= 12) t.h %= 12; return t; &#125; friend Time operator -- (Time&amp; t, int) &#123; Time tmp(t); t.s -- ; if(t.s &lt; 0) &#123; t.s += 60; t.s %= 60; t.m -- ; &#125; if(t.m &lt; 0) &#123; t.m += 60; t.m %= 60; t.h -- ; &#125; if(t.h &lt; 0) &#123; t.h += 12; t.h %= 12; &#125; return tmp; &#125; void Dis() &#123; printf(&quot;%d:%d:%d\\n&quot;, h, m, s); &#125;&#125;;int main()&#123; int h, s, m, t; cin &gt;&gt; h &gt;&gt; m &gt;&gt; s &gt;&gt; t; Time time(h, m, s); while(t -- ) &#123; int n; cin &gt;&gt; n; if(n &gt; 0) while(n -- ) ++ time; else &#123; n *= -1; while(n -- ) time -- ; &#125; time.Dis(); &#125;&#125; 求最大面积（虚函数和多态）: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;using namespace std;class Geometry&#123;public: virtual double getArea() = 0; //计算面积，结果保留小数点后两位&#125;;class Rect:public Geometry&#123; double l, w;public: Rect(double ll, double ww):l(ll), w(ww)&#123;&#125; double getArea() &#123; return l * w; &#125;&#125;;class Circle:public Geometry&#123; double r;public: Circle(double rr):r(rr)&#123;&#125; double getArea() &#123; return r * r * 3.14; &#125;&#125;;class TotalArea&#123;public: static void computerTotalArea(Geometry** t, int n) &#123; double Max = 0; for(int i = 0; i &lt; n; i ++ ) &#123; Max = max(Max, t[i] -&gt; getArea()); &#125; printf(&quot;最大面积=%.2lf\\n&quot;, Max); &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; Geometry **g; g = new Geometry*[t]; for(int i = 0; i &lt; t; i ++ ) &#123; int type; double a, b; cin &gt;&gt; type; if(type == 1) &#123; cin &gt;&gt; a &gt;&gt; b; g[i] = new Rect(a, b); &#125; else &#123; cin &gt;&gt; a; g[i] = new Circle(a); &#125; &#125; TotalArea::computerTotalArea(g, t); return 0;&#125; 组链表与通讯录（期末模拟）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include&lt;iostream&gt;using namespace std;const int hmax = 26;class Info&#123; //联系人，用一个链表结点表示 string name; //姓名 int phoneNo; //电话public: Info* next; //指向下一个结点 Info(string tn = &quot;no name&quot;, int pno = 0) &#123; name = tn; phoneNo = pno; next = nullptr; &#125; void Print() &#123; cout &lt;&lt; name &lt;&lt; &quot;--&quot; &lt;&lt; phoneNo &lt;&lt; endl; &#125; //属性的get和set方法....自行定义 string getN()&#123;return name;&#125; int getP() const&#123;return phoneNo;&#125; void setP(int p)&#123;phoneNo = p;&#125;&#125;;class PhoneBook&#123; //组链表方式实现通讯录 //....自行增加一些操作 //提示：把插入和查找先写成内部函数，再被运算符重载调用，会更方便public: Info Table[hmax];//链表头结点数组，对应26个大写字母 //以下定义五个操作：输入Input、打印Print、插入、合并、查找 //具体操作看前面说明 void Input(); friend PhoneBook&amp; operator += (PhoneBook&amp;pb, Info&amp; Inf); friend PhoneBook&amp; operator + (PhoneBook&amp;pb, PhoneBook&amp;pc); Info* operator() (string name); void Print();&#125;;//...PhoneBook类成员函数，类外实现，自行编写Info* PhoneBook::operator () (string n)&#123; int idx = n[0] - &#x27;A&#x27;; Info *p = Table[idx].next; while(p) &#123; if(p-&gt;getN() == n) return p; p = p -&gt; next; &#125; return nullptr;&#125;void PhoneBook::Print()&#123; for(int i = 0; i &lt; hmax; i ++ ) &#123; if(Table[i].next == nullptr) continue; cout &lt;&lt; (char)(&#x27;A&#x27; + i) &lt;&lt; &quot;--&quot;; Info *p = Table[i].next; while(p) &#123; cout &lt;&lt; p-&gt;getN() &lt;&lt; &quot;.&quot; &lt;&lt; p-&gt;getP() &lt;&lt; &quot;--&quot;; p = p -&gt; next; &#125; cout &lt;&lt; endl; &#125;&#125;PhoneBook&amp; operator += (PhoneBook&amp;pb, Info &amp;Inf)&#123; string name = Inf.getN(); int idx = name[0] - &#x27;A&#x27;; Info *p = pb.Table[idx].next; bool flag = 0; while(p) &#123; if(p -&gt; getN() == name) &#123; flag = 1; p -&gt; setP(Inf.getP()); break; &#125; p = p -&gt; next; &#125; if(!flag) &#123; Inf.next = pb.Table[idx].next; pb.Table[idx].next = &amp;Inf; &#125; return pb;&#125;PhoneBook&amp; operator + (PhoneBook&amp;pb, PhoneBook&amp;pc)&#123; for(int i = 0; i &lt; hmax; i ++ ) &#123; Info *p = pc.Table[i].next; while(p) &#123; bool flag = false; Info *q = pb.Table[i].next; while(q) &#123; if(q-&gt;getN() == p-&gt;getN()) &#123; q-&gt;setP(p-&gt;getP()); flag = true; break; &#125; q = q -&gt; next; &#125; Info *tmp1 = p -&gt; next; if(!flag) &#123; Info *tmp = p; tmp -&gt; next = pb.Table[i].next; pb.Table[i].next = tmp; &#125; p = tmp1; &#125; &#125; return pb;&#125;void PhoneBook::Input()&#123; int n, phone; string name; cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++ ) &#123; cin &gt;&gt; name &gt;&gt; phone; Info *p = new Info(name, phone); int idx = name[0] - &#x27;A&#x27;; p -&gt;next = Table[idx].next; Table[idx].next = p; &#125;&#125;int main()&#123; string tname; int i, tno; Info *p; PhoneBook pb; pb.Input(); //接收输入数据，初始化第一个通讯录 //两次姓名查找 for (i = 0; i &lt; 2; i ++ ) &#123; cin &gt;&gt; tname; p = pb(tname); //调用()运算符，实现查找 if(p) p -&gt; Print(); //查找成功，输出联系人信息 else cout &lt;&lt; &quot;查找失败&quot; &lt;&lt; endl; //查`找失败，输出提示信息 &#125; //一次插入 cin &gt;&gt; tname &gt;&gt; tno; Info temp(tname, tno); pb += temp; //调用+=运算符，实现插入新联系人 //通讯录合并 PhoneBook pc; pc.Input(); //初始化第二个通讯录 pb = pb + pc; //调用+运算符，实现合并 pb.Print(); //输出所有操作后的通讯录 return 0;&#125; 进位与借位（虚函数和多态）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;vector&gt;#include&lt;iostream&gt;using namespace std;class Group&#123;public: virtual int add(int x, int y) = 0;//输出加法的运算结果 virtual int sub(int x, int y) = 0;//输出减法的运算结果&#125;;class GroupA : public Group&#123;public: int add(int x, int y) &#123; cout &lt;&lt; x + y &lt;&lt; endl; &#125; int sub(int x, int y) &#123; cout &lt;&lt; x - y &lt;&lt; endl; &#125;&#125;;class GroupB : public Group&#123;public: int add(int x, int y) &#123; cout &lt;&lt; x + y &lt;&lt; endl; &#125; int sub(int x, int y) &#123; vector&lt;int&gt; A, B, C; while(x) A.push_back(x % 10), x /= 10; while(y) B.push_back(y % 10), y /= 10; for(int i = 0; i &lt; A.size() || i &lt; B.size(); i ++ ) &#123; int abs = 0; abs = (A[i] - B[i] + 10) % 10; C.push_back(abs); &#125; for(int i = C.size() - 1; i &gt;= 0; i -- ) cout &lt;&lt; C[i]; cout &lt;&lt; endl; &#125;&#125;;class GroupC : public Group&#123;public: int add(int x, int y) &#123; vector&lt;int&gt; A, B, C; while(x) A.push_back(x % 10), x /= 10; while(y) B.push_back(y % 10), y /= 10; for(int i = 0; i &lt; A.size() || i &lt; B.size(); i ++ ) &#123; int sum = 0; if(A.size() &gt; i) sum += A[i]; if(B.size() &gt; i) sum += B[i]; sum %= 10; C.push_back(sum); &#125; for(int i = C.size() - 1; i &gt;= 0; i -- ) cout &lt;&lt; C[i]; cout &lt;&lt; endl; &#125; int sub(int x, int y) &#123; vector&lt;int&gt; A, B, C; while(x) A.push_back(x % 10), x /= 10; while(y) B.push_back(y % 10), y /= 10; for(int i = 0; i &lt; A.size() || i &lt; B.size(); i ++ ) &#123; int abs = 0; abs = (A[i] - B[i] + 10) % 10; C.push_back(abs); &#125; for(int i = C.size() - 1; i &gt;= 0; i -- ) cout &lt;&lt; C[i]; cout &lt;&lt; endl; &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; Group *group[t]; for(int i = 0; i &lt; t; i ++ ) &#123; int type, a, b; char ch; scanf(&quot;%d%d%c%d&quot;, &amp;type, &amp;a, &amp;ch, &amp;b); switch (type) &#123; case 1: group[i] = new GroupA; break; case 2: group[i] = new GroupB; break; case 3: group[i] = new GroupC; break; &#125; if(ch == &#x27;+&#x27;) group[i] -&gt; add(a, b); else group[i] -&gt; sub(a,b); &#125;&#125; 人民币输出（输出运算符重载）: 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;class Money&#123; double num; int y, j, f;public: Money()&#123;&#125; friend istream&amp; operator &gt;&gt; (istream&amp; in, Money&amp; m) &#123; in &gt;&gt; m.num; int k = m.num * 100; m.y = k / 100, m.j = k / 10 % 10; m.f = k % 10; &#125; friend ostream&amp; operator &lt;&lt; (ostream&amp; out, Money&amp; m) &#123; out &lt;&lt; &quot;yuan=&quot; &lt;&lt; m.y &lt;&lt; &quot; jiao=&quot; &lt;&lt; m.j &lt;&lt; &quot; fen=&quot; &lt;&lt; m.f &lt;&lt; endl; &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; Money money; while(t -- ) &#123; cin &gt;&gt; money; cout &lt;&lt; money; &#125;&#125; 动态矩阵（指针与堆内存分配）: 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; int Max = -0x3f3f3f3f; int Min = -Max; int n, m; cin &gt;&gt; n &gt;&gt; m; int **a = NULL; a = new int *[n]; for(int i = 0; i &lt; n; i ++ ) &#123; a[i] = new int[m]; &#125; for(int i = 0; i &lt; n; i ++ ) for(int j = 0; j &lt; m; j ++ ) &#123; cin &gt;&gt; a[i][j]; Min = min(Min, a[i][j]); Max = max(Max, a[i][j]); &#125; cout &lt;&lt; Min &lt;&lt; &quot; &quot; &lt;&lt; Max &lt;&lt; endl; &#125; return 0;&#125; 日期时间合并输出（友元函数）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;using namespace std;class Time;class Date&#123; friend void Display(Date &amp;D, Time &amp;T); int y, m, d;public: Date(int year, int month, int day) &#123; y = year, m = month, d = day; &#125;&#125;;class Time&#123; friend void Display(Date &amp;D, Time &amp;T); int h, m, s;public: Time(int hour, int minute, int second) &#123; h = hour, m = minute, s = second; &#125;&#125;;void Display(Date &amp;D, Time &amp;T)&#123; printf(&quot;%4d-%02d-%02d %02d:%02d:%02d\\n&quot;, D.y, D.m, D.d, T.h, T.m, T.s);&#125;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; int y, mo, d, h, mi, s; cin &gt;&gt; y &gt;&gt; mo &gt;&gt; d &gt;&gt; h &gt;&gt; mi &gt;&gt; s; Date date(y, mo, d); Time time(h, mi, s); Display(date, time); &#125; return 0;&#125; 复数的加减乘运算（运算符重载）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;using namespace std;class Com&#123; int real, imag;public: Com(int r, int i):real(r), imag(i)&#123;&#125; friend Com operator + (Com&amp; c1, Com&amp; c2) &#123; int r = c1.real + c2.real; int i = c1.imag + c2.imag; return Com(r, i); &#125; friend Com operator - (Com&amp; c1, Com&amp; c2) &#123; int r = c1.real - c2.real; int i = c1.imag - c2.imag; return Com(r, i); &#125; friend Com operator * (Com&amp; c1, Com&amp; c2) &#123; int r = c1.real * c2.real - c1.imag * c2.imag; int i = c1.imag * c2.real + c1.real * c2.imag; return Com(r, i); &#125; void Dis() &#123; cout &lt;&lt; &quot;Real=&quot; &lt;&lt; real &lt;&lt; &quot; Image=&quot; &lt;&lt; imag &lt;&lt; endl; &#125;&#125;;int main()&#123; int r, i; cin &gt;&gt; r &gt;&gt; i; Com c1(r, i); cin &gt;&gt; r &gt;&gt; i; Com c2(r, i); (c1 + c2).Dis(); (c1 - c2).Dis(); (c1 * c2).Dis();&#125; 学生生日差值计算（运算符重载）: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int month[13] = &#123;0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;;int day[13] = &#123;0&#125;;class Stu&#123; string name; int y, m, d;public: Stu()&#123;&#125; Stu(string n, int y, int m, int d):name(n), y(y), m(m), d(d)&#123;&#125; string getN()&#123;return name;&#125; friend int operator - (const Stu&amp; s1, const Stu&amp; s2) &#123; int tot1 = day[s1.m] + s1.d; int tot2 = day[s2.m] + s2.d + (s2.y - s1.y) * 365; return abs(tot2 - tot1); &#125; friend bool operator &lt; (Stu&amp; s1, Stu&amp; s2) &#123; if(s1.y != s2.y) return s1.y &lt; s2.y; if(s1.m != s2.m) return s1.m &lt; s2.m; if(s1.d != s2.m) return s1.d &lt; s2.d; &#125;&#125;;int main()&#123; for(int i = 1; i &lt;= 12; i ++ ) day[i] = day[i - 1] + month[i]; int n, y, m, d; string name; cin &gt;&gt; n; Stu stu[100]; for(int i = 0; i &lt; n; i ++ ) &#123; cin &gt;&gt; name &gt;&gt; y &gt;&gt; m &gt;&gt; d; stu[i] = Stu(name, y, m, d); &#125; sort(stu, stu + n); cout &lt;&lt; stu[0].getN() &lt;&lt; &quot;和&quot; &lt;&lt; stu[n - 1].getN(); cout &lt;&lt; &quot;年龄相差最大，为&quot; &lt;&lt; stu[n - 1] - stu[0] &lt;&lt; &quot;天。\\n&quot;;&#125; 蛇形矩阵（指针与动态内存分配）: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;using namespace std;void snake_mat(int n)&#123; int **mat = new int*[n]; for(int i = 0; i &lt; n; i ++ ) mat[i] = new int[n]; int left = 0, right = n - 1, top = 0, bottom = n - 1; int k = 1; while(left &lt;= right &amp;&amp; top &lt;= bottom) &#123; for(int i = left; i &lt;= right; i ++ ) mat[top][i] = k ++ ; for(int i = top + 1; i &lt;= bottom; i ++ ) mat[i][right] = k ++ ; for(int i = right - 1; i &gt;= left &amp;&amp; top &lt; bottom; i -- ) mat[bottom][i] = k ++ ; for(int i = bottom - 1; i &gt; top &amp;&amp; left &lt; right; i -- ) mat[i][left] = k ++ ; left ++ , right -- , top ++ , bottom -- ; &#125; for(int i = 0; i &lt; n; i ++ ) for(int j = 0; j &lt; n; j ++ ) &#123; cout &lt;&lt; mat[i][j]; if(j == n - 1) cout &lt;&lt; endl; else cout &lt;&lt; &quot; &quot;; &#125; for(int i = 0; i &lt; n; i ++ ) delete[] mat[i]; delete[] mat;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; int n; cin &gt;&gt; n; snake_mat(n); cout &lt;&lt; endl; &#125; return 0;&#125; 身份证号码升位（拷贝构造函数）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Date&#123;protected: int year, month, day;public: Date()&#123;&#125; Date(int y,int m,int d):year(y), month(m), day(d)&#123;&#125; bool check() //检验日期是否合法 &#123; int monthDay[] = &#123; 31,isLeap() ? 29 : 28,31,30,31,30,31,31,30,31,30,31 &#125;; if (day &lt; 0 || year &lt; 0 || month &lt; 0 || month &gt; 12 || day &gt; monthDay[month - 1]) return false; return true; &#125; bool isLeap() &#123; return ((year % 4 == 0 &amp;&amp; year % 100 != 0) || year % 400 == 0); &#125; int getY()&#123; return year;&#125; int getM()&#123; return month;&#125; int getD()&#123; return day;&#125; void print() &#123; printf(&quot;%d年%d月%d日&quot;, year, month, day); &#125;&#125;;class StuID&#123; string name, ID; Date birthday; int registered;public: StuID(string n, string id, Date d):name(n), ID(id), birthday(d)&#123;&#125; StuID(StuID&amp; stuid) &#123; this -&gt; name = stuid.name; this -&gt; birthday = stuid.birthday; this -&gt; registered = stuid.registered; this -&gt; ID = stuid.ID; if(ID.size() == 15) &#123; ID.insert(6, to_string(birthday.getY()), 0, 2); int a[17]=&#123;7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2&#125;; int sum = 0, mod; for(int j = 0; j &lt; 17; j ++ ) sum += (ID[j] - &#x27;0&#x27;) * a[j]; mod = sum % 11; int ch[] = &#123;1,0,0,9,8,7,6,5,4,3,2&#125;; if(mod == 2) ID.append(&quot;X&quot;); else ID.append(to_string(ch[mod])); &#125; &#125; bool check() &#123; if(!birthday.check()) return false; if(ID.size() == 15) &#123; for(char i : ID) if(i &lt; &#x27;0&#x27; || i &gt; &#x27;9&#x27;) return false; string d; for(int i = 6, j = 0; j &lt; 6; i ++ , j ++ ) d += ID[i]; int a = stoi(d); int b = birthday.getY() % 100 * 10000; b += birthday.getM() * 100 + birthday.getD(); if(a != b) return false; &#125; else if(ID.size() == 18) &#123; int a[17]=&#123;7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2&#125;; int sum = 0, mod; for(int j = 0; j &lt; 17; j ++ ) sum += (ID[j] - &#x27;0&#x27;) * a[j]; mod = sum % 11; char ch[] = &#123;&#x27;1&#x27;,&#x27;0&#x27;,&#x27;X&#x27;,&#x27;9&#x27;,&#x27;8&#x27;,&#x27;7&#x27;,&#x27;6&#x27;,&#x27;5&#x27;,&#x27;4&#x27;,&#x27;3&#x27;,&#x27;2&#x27;&#125;; if(ID[17] != ch[mod]) return false; int red, idd; string d; red = birthday.getY() * 10000 + birthday.getM() * 100 + birthday.getD(); for(int i = 6, j = 0; j &lt; 8; i ++ , j ++ ) d += ID[i]; idd = stoi(d); if(idd != red) return false; &#125; else return false; return true; &#125; void print() &#123; cout &lt;&lt; name &lt;&lt; &quot; &quot;; if(!check()) &#123; cout &lt;&lt; &quot;illegal id&quot; &lt;&lt; endl; return; &#125; birthday.print(); cout &lt;&lt; &quot; &quot; &lt;&lt; ID &lt;&lt; endl; &#125;&#125;;int main()&#123; int t; cin &gt;&gt; t; int y, m, d; string name, id; while(t -- ) &#123; cin &gt;&gt; y &gt;&gt; m &gt;&gt; d; Date day(y, m, d); cin &gt;&gt; name &gt;&gt; id; StuID stu(name, id, day); stu.print(); if(id.size() == 15 &amp;&amp; stu.check()) &#123; StuID stu1(stu); stu1.print(); &#125; &#125; return 0;&#125; 银行账户（静态成员与友元函数）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;#include&lt;string&gt;class Account&#123; static int count, balance_sum; static float Rate; string _accno, _accname; float _balance;public: friend void update(Account &amp;A, float amount1, float amount2); Account(); Account(string accno, string name, float balance) &#123; _accno = accno, _accname = name, _balance = balance; &#125; void Deposit(float amount) &#123; _balance += amount; cout &lt;&lt; GetBalance() &lt;&lt; &quot; &quot;; _balance *= (1 + Rate); &#125; void Withdraw(float amount) &#123; _balance -= amount; &#125; float GetBalance() &#123; return _balance; &#125; void Show() &#123; cout &lt;&lt; _accno &lt;&lt; &quot; &quot; &lt;&lt; _accname &lt;&lt; &quot; &quot;; &#125; static int GetCount() &#123; return count; &#125; static void SetCount(int n) &#123; count = n; &#125; static void GetRate(float r) &#123; Rate = r; &#125; static int GetSum() &#123; return balance_sum; &#125;&#125;;int Account::count = 0;int Account::balance_sum = 0;float Account::Rate = 0;void update(Account &amp;A, float amount1, float amount2)&#123; A.Deposit(amount1); cout &lt;&lt; A.GetBalance() &lt;&lt; &quot; &quot;; A.Withdraw(amount2); cout &lt;&lt; A.GetBalance() &lt;&lt; endl; Account::balance_sum += A.GetBalance();&#125;int main()&#123; float rat; int cnt; cin &gt;&gt; rat; cin &gt;&gt; cnt; Account::SetCount(cnt); Account::GetRate(rat); Account** acc = new Account*[cnt]; for(int i = 0; i &lt; cnt; i ++ ) &#123; string acco, accname; float balance, amount1, amount2; cin &gt;&gt; acco &gt;&gt; accname &gt;&gt; balance &gt;&gt; amount1 &gt;&gt; amount2; acc[i] = new Account(acco, accname, balance); acc[i]-&gt;Show(); update(*acc[i], amount1, amount2); &#125; cout &lt;&lt; Account::GetSum() &lt;&lt; endl; return 0;&#125; 日期比较（运算符重载之类型转换）: 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;using namespace std;class Date&#123; int y, m, d;public: Date()&#123;&#125; Date(int y, int m, int d):y(y), m(m), d(d)&#123;&#125; Date&amp; operator=(int t) &#123; y = t / 10000; m = t / 100 % 100; d = t % 100; &#125; void Dis() &#123; printf(&quot;%04d年%02d月%02d日\\n&quot;, y, m, d); &#125;&#125;;int main()&#123; int t, t1, t2; Date c1, c2; cin &gt;&gt; t; while(t -- ) &#123; cin &gt;&gt; t1 &gt;&gt; t2; c1 = t1; c2 = t2; if(t1 &gt; t2) c1.Dis(); else c2.Dis(); &#125; return 0;&#125; 计算学生成绩等级（虚函数和多态）: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;class Student&#123;protected: string name; int type; int courses[3]; string courseGrade;public: Student(string n,int t,int a1,int a2,int a3):name(n),type(t) &#123; courses[0] = a1,courses[1] = a2,courses[2] = a3; &#125; virtual void calculateGrade() = 0; virtual ~Student() = 0; void print() &#123; cout &lt;&lt; name &lt;&lt; &quot;,&quot;; if(type == 1) cout &lt;&lt; &quot;本科生,&quot;; else cout &lt;&lt; &quot;研究生,&quot;; cout &lt;&lt; courseGrade &lt;&lt; endl; &#125;&#125;;Student::~Student()&#123;&#125;class Undergraduate:public Student&#123;public: Undergraduate(string n,int t,int a1,int a2,int a3) : Student(n,t,a1,a2,a3)&#123;&#125; void calculateGrade() &#123; double sum = 0; for(int i = 0; i &lt; 3; i ++) sum += courses[i]; sum /= 3; if(sum &gt;= 80) courseGrade = &quot;优秀&quot;; else if(sum &gt;= 70 &amp;&amp; sum &lt; 80) courseGrade = &quot;良好&quot;; else if(sum &gt;= 60 &amp;&amp; sum &lt; 70) courseGrade = &quot;一般&quot;; else if(sum &gt;= 50 &amp;&amp; sum &lt; 60) courseGrade = &quot;及格&quot;; else if(sum &lt; 50) courseGrade = &quot;不及格&quot;; &#125;&#125;;class Postgraduate:public Student&#123;public: Postgraduate(string n,int t,int a1,int a2,int a3) : Student(n,t,a1,a2,a3)&#123;&#125; void calculateGrade() &#123; double sum = 0; for(int i = 0; i &lt; 3; i ++) sum += courses[i]; sum /= 3; if(sum &gt;= 90) courseGrade = &quot;优秀&quot;; else if(sum &gt;= 80 &amp;&amp; sum &lt; 90) courseGrade = &quot;良好&quot;; else if(sum &gt;= 70 &amp;&amp; sum &lt; 80) courseGrade = &quot;一般&quot;; else if(sum &gt;= 60 &amp;&amp; sum &lt; 70) courseGrade = &quot;及格&quot;; else if(sum &lt; 60) courseGrade = &quot;不及格&quot;; &#125;&#125;;int main()&#123; int t;cin &gt;&gt; t; Student* p[100]; for(int i = 0; i &lt; t; i ++ ) &#123; string name; int type; int a1 ,a2, a3; cin &gt;&gt; name &gt;&gt; type &gt;&gt; a1 &gt;&gt; a2 &gt;&gt; a3; if(type == 1) p[i] = new Undergraduate(name, type, a1, a2, a3); else p[i] = new Postgraduate(name, type, a1, a2, a3); &#125; for(int i = 0;i &lt; t;i ++) &#123; p[i]-&gt;calculateGrade(); p[i]-&gt;print(); &#125; for(int i = 0; i &lt; t; i ++) delete p[i]; return 0;&#125; 附加题、组链表与通讯录（期末模拟）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include&lt;unordered_map&gt;#include&lt;iostream&gt;using namespace std;const int hmax = 26;class Info&#123; string name; int phoneNo;public: Info* next; Info(string tn = &quot;no name&quot;, int pno = 0) &#123; name = tn; phoneNo = pno; next = nullptr; &#125; void Print() &#123; cout &lt;&lt; name &lt;&lt; &quot;--&quot; &lt;&lt; phoneNo &lt;&lt; endl; &#125; string getN()&#123;return name;&#125; int getP()&#123;return phoneNo;&#125; void setP(int p)&#123;phoneNo = p;&#125;&#125;;class PhoneBook&#123;public: unordered_map&lt;char, Info&gt; Table; void Input(); friend PhoneBook&amp; operator += (PhoneBook&amp;pb, Info&amp; Inf); friend PhoneBook&amp; operator + (PhoneBook&amp;pb, PhoneBook&amp;pc); Info* operator() (string name); void Print();&#125;;void PhoneBook::Input()&#123; int n, phone; string name; cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++ ) &#123; cin &gt;&gt; name &gt;&gt; phone; Info *p = new Info(name, phone); p -&gt;next = Table[name[0]].next; Table[name[0]].next = p; &#125;&#125;PhoneBook&amp; operator += (PhoneBook&amp;pb, Info &amp;Inf)&#123; string name = Inf.getN(); Info *p = pb.Table[name[0]].next; bool flag = 0; while(p) &#123; if(p -&gt; getN() == name) &#123; flag = 1; p -&gt; setP(Inf.getP()); break; &#125; p = p -&gt; next; &#125; if(!flag) &#123; Inf.next = pb.Table[name[0]].next; pb.Table[name[0]].next = &amp;Inf; &#125; return pb;&#125;PhoneBook&amp; operator + (PhoneBook&amp;pb, PhoneBook&amp;pc)&#123; for(int i = 0; i &lt; hmax; i ++ ) &#123; Info *p = pc.Table[i + &#x27;A&#x27;].next; while(p) &#123; bool flag = false; Info *q = pb.Table[i + &#x27;A&#x27;].next; while(q) &#123; if(q -&gt; getN() == p -&gt; getN()) &#123; q -&gt; setP(p -&gt; getP()); flag = true; break; &#125; q = q -&gt; next; &#125; Info *tmp1 = p -&gt; next; if(!flag) &#123; Info *tmp = p; tmp -&gt; next = pb.Table[i + &#x27;A&#x27;].next; pb.Table[i + &#x27;A&#x27;].next = tmp; &#125; p = tmp1; &#125; &#125; return pb;&#125;Info* PhoneBook::operator () (string n)&#123; Info *p = Table[n[0]].next; while(p) &#123; if(p-&gt;getN() == n) return p; p = p -&gt; next; &#125; return nullptr;&#125;void PhoneBook::Print()&#123; for(int i = 0; i &lt; hmax; i ++ ) &#123; if(Table[i + &#x27;A&#x27;].next == nullptr) continue; cout &lt;&lt; (char)(&#x27;A&#x27; + i) &lt;&lt; &quot;--&quot;; Info *p = Table[i + &#x27;A&#x27;].next; while(p) &#123; cout &lt;&lt; p-&gt;getN() &lt;&lt; &quot;.&quot; &lt;&lt; p-&gt;getP() &lt;&lt; &quot;--&quot;; p = p -&gt; next; &#125; cout &lt;&lt; endl; &#125;&#125;int main()&#123; string tname; int i, tno; Info *p; PhoneBook pb; pb.Input(); for (i = 0; i &lt; 2; i ++ ) &#123; cin &gt;&gt; tname; p = pb(tname); if(p) p -&gt; Print(); else cout &lt;&lt; &quot;查找失败&quot; &lt;&lt; endl; &#125; cin &gt;&gt; tname &gt;&gt; tno; Info temp(tname, tno); pb += temp; PhoneBook pc; pc.Input(); pb = pb + pc; pb.Print(); return 0;&#125;","categories":[],"tags":[]},{"title":"算法设计实验六","slug":"算法设计实验六","date":"2021-06-10T13:56:20.000Z","updated":"2023-02-22T13:07:14.706Z","comments":true,"path":"2021/06/10/算法设计实验六/","link":"","permalink":"http://www.misaka-9982.com/2021/06/10/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C%E5%85%AD/","excerpt":"","text":"一、实验目的： 掌握最大流算法思想。 学会用最大流算法求解应用问题。 二、内容： 有m篇论文和n个评审，每篇论文需要安排a个评审，每个评审最多评b篇论文。请设计一个论文分配方案。 要求应用最大流解决上述问题，画出m=10，n=3的流网络图并解释说明流网络图与论文评审问题的关系。 编程实现所设计算法，计算a和b取不同值情况下的分配方案，如果没有可行方案则输出无解。 三、实验要求 在blackboard提交电子版实验报告，注意实验报告的书写，整体排版。 实验报告的实验步骤部分需详细给出算法思想与实现代码之间的关系解释，不可直接粘贴代码（直接粘贴代码者视为该部分内容缺失）。 实验报告中要求证明该算法的关键定理，并说明这些定理所起的作用。 实验报告样式可从http://192.168.2.3/guide.aspx 表格下载－学生适用－在校生管理－实践教学－实验：深圳大学学生实验报告） 源代码作为实验报告附件上传。 在实验课需要现场运行验证并讲解PPT。 四、问题分析 1.二分图的构建 将每一篇论文、每一位评审都抽象成为一个点，就可以得到一个论文的点集和一个评审的点集。如下左图（图1），数字从0到9的十个点的集合表示论文所属的点集，x，y，z三个点表示三位评审。 图 1 二分图的表示 图2 解决方案对应的二分图 如果一位评审评阅了这篇论文，那么我们就在这位评审和这篇论文对应的点之间连接一条边。在这个二分图中一条边表示一篇论文和一个评审的匹配。 假定每篇论文需要一位评审，每个评审最多评审4篇论文,那么我们可以得到x评审0到3号四篇论文，y评审4到7号四篇论文，z评审8,9号论文这样一种解决方案，那么画出这个解决方案的二分图就可以得到上方右图（图2）这样的一个二分图。 2.流网络的搭建 ①虚拟源点和汇点 要使用最大流算法解决论文评审方案分配的问题，我们首先需要有一个流网络，目前已经有了一个二分图，搭建流网络我们还需要一个源点和一个汇点。 如下图，我们分别在论文点集的左边虚拟了一个源点S ，在评审点集的右边虚拟了一个汇点T。 图 3 虚拟源点、 汇点 ②容量设置 对于一篇论文，它需要安排a位评审，所以源点和每一个论文对应的点之间的边容量上限应该设置为a，如果小于这个值那么流网络无法输出解决方案。 对于一位评审，他最多能评b篇论文，所以评审对应的点连接到汇点的边容量上限应设置为b。 图 4 容量限制 论文和评审之间的边的容量应该都设置为1，一个评审不会多次评阅相同的一篇论文，而相同的一篇论文可以被所有的评审进行评阅，所以一个论文点会和所有的评审有边连接的关系，而这些边的容量为1，如果一条边的流量为1就说明这条边对应的评审评阅了这篇论文， 为0则没有评阅。 图 5 论文与评审之间边的容量限制。 对所有的论文和评审进行连接并设置容量限制，得到下图中的流网络。 图 6 完整的流网络图 ③正确性证明 要对一个二分图使用最大流算法，我们只需要证明对于二分图的解空间中的任意一个可行解一定可以在流网络中找到一个对应的可行流，在流网络中的任意一个可行流一定可以在二分图的解空间中找到一个对应的可行解，这样解空间中的最大匹配就对应于流网络中的最大流 （1）二分图中的任意匹配一定可以在流网络中找到一个对应的可行流。如下图，对于左边的二分图，其对应于右边的流网络，网络中的流量满足容量限制和流量守恒，所以这个流量是合法的可行流。 图 8 可行解对应于可行流 （2）流网络中的任意一个可行流一定可以在二分图中找到一个对应的匹配关系，流网络中的每一个流量的数值大小都是整数值，而对于两个点集之间有流量的边，单独拿出来就是对应二分图匹配关系。如下图，由于流量值都是整数，并且中间的边流量要么是零要么是一，只有这两个数可行，所以左边的流网络课以对应于右边的二分图。 图 9 可行流对应于可行解 由此，我们可以说明二分图解空间的最大解对应于流网络的最大流，所以我们可以使用最大流算法求解二分图的匹配方案。 3.是否存在可行的匹配方案 ①每篇论文需要的评审数量要少于或等于评审的人数即$a ≤ n$ ②论文需要的评审总次数小于等于评审们最多能评审的数量即 $a × m ≤ b × n$ 满足上面两条不等式则说明存在可行的匹配方案，否则不存在可行的匹配方案 五、算法原理描述 1.FF方法 （1）算法思想 只要有一条从源点（开始节点）到汇点（结束节点）的路径，在路径的所有边上都有可用容量，就沿着这条路径发送一个流，流量由路径上的最小容量限制。 然后再找到另一条路径，一直到网络中不存在这种路径为止。 一条有可用容量的路径被称为一条增广路径。 算法过程如下所示 ①路径$S -&gt; 1 -&gt; 3 -&gt; T$ 为一条增广路径，最小容量为2，向这条路径发送流量值为2的流量。 ②路径$S -&gt; 2 -&gt; 4 -&gt; T$ 为一条增广路径 ③ 增广路径$S -&gt; 2 -&gt; 3 -&gt; 1 -&gt; 4 -&gt; T$ ④再无增广路径，发送出去的流量值之和为最大流 （2）最坏情况分析 存在某些特殊的边可能会导致算法效率降低，如下图，有可能先找到增广路径$S-&gt;2-&gt;1-&gt;T$，然后找到增广路径$S-&gt;1-&gt;2-&gt;T$，接着增广$S-&gt;2-&gt;1-&gt;T$，依次重复增广两百万次才完成对这个流网络的增广。 （3）伪代码描述 （4）算法时间复杂度 找到一条增广路径的时间复杂度为$O(E)$，有上述最坏情况分析可得，算法整体的时间复杂度为$O( E |f*| )$，其中， $|f*|$为最大流，$E$为边数 2.EK算法 （1）算法思想 采用BFS的方式搜索增广路径来实现FF方法，可以确保每次找到的增广路径都是长度最短的路径，如上述FF方法的最坏情况，使用BFS的搜索方式则只需要搜索两条增广路径就能结束算法。如下图，算法增广完$S -&gt; 2 -&gt; 1 -&gt; T$和$S -&gt; 1 -&gt; 2-&gt;T$这两条路径就结束。 （2）伪代码描述 （3）算法时间复杂度 查阅资料得EK算法的时间复杂度为$O(V E^2)$，其中， $V$为点数，$E$为边数 3.Dinic算法 （1）算法思想 Dinic 算法 的过程是这样的：每次增广前，我们先用 BFS 来将图分层。设源点的层数为0，那么一个点的层数便是它离源点的最近距离。 图 17 通过BFS分层，我们可以寻找是否存在增广路径，并确保找到的增广路径是最短路径。 我们每次找增广路的时候，都只找比当前点层数多 1的点进行增广（这样就可以确保我们找到的增广路是最短的），即DFS搜索。 如下图，1、2、3三个点形成环，如果使用FF方法，那么就有可能会在这环上不断绕圈，而采用BFS分层，并严格按照层数多1的方式搜索路径，则会避免这种情况。 如图17，我们对流网络分层完之后可以找到如图18左侧的一条增广路径，对其进行增广，得到右侧的残留网络，很明显，这个分层图依旧存在增广路径。如果是EK算法，则在这个时候会重新遍历整个流网络搜索增广路径，而Dinic算法采用dfs的方式在这个基础之上搜索增广路径，如图19至图21所示，最后得到图21右侧没有增广路径的残留网络，才会重新使用BFS对流网络重新分层以寻找增广路径。 图 18 图 19 图 20 图 21 （2）算法优化 ①多路增广 每次找到一条增广路的时候，如果残余流量没有用完的话，我们就可以利用残余部分流量，再找出一条增广路。这样就可以在一次 DFS 中找出多条增广路，大大提高了算法的效率。 如下图22，对于S发送到1号点的流量50份单位流量，然后对路径$1 -&gt; 3 -&gt; T$进行增广，之后1号点还剩下24份流量，接着对路径$1 -&gt; 4 -&gt; T$进行增广，1号点还剩下9份流量，再将剩余的流量发送到$1 -&gt; 5 -&gt; T$这条路径上，这样一次DFS就实现了对多条路径的增广。 ②废点优化 对于一个点，如果所有流入他的边都已经饱和了，那么之后的增广过程中一定不会再用到这个点，将这个点废弃掉，层数设置为-1，就不会再次搜索到这个点了。 如下图，在多路增广的过程中，流入点1的所有边的流量都已经饱和了，将1号点的层数设置为-1，本次BFS构建出来的分层图不再搜索1号点。 ③当前弧优化 如果一条边已经被增广过并且达到饱和，那么它就没有可能被增广第二次。那么，我们下一次进行增广的时候，就可以不必再走那些已经被增广过的边。 如下图，假定这个网络首先增广路径2 ~ k – a 和2 ~ k – b并且k - a和k - b这两条边达到饱和，那么在增广路径1 ~ k 的时候，不再需要考虑k - a和k - b这两条边，只需要从k - c这条边开始增广。 （3）伪代码描述 （4）算法时间复杂度 每轮BFS搭建分层图找到的增广路的数量至少为1，增广路的数量每次都减少至少一条, 整个网络中最多有n - 1条增广路, n顶点数量。分层图可以在$O(E)$的时间复杂度内用BFS构建。一条增广路可以在$O(VE)$的复杂度内构建。Dinic算法整体的时间复杂度为$O(V^2E)$ 3.预流推进 上面提及的算法都是增广路算法，即按照增广路径不断压入少量的流量，直到满流，而预流推进算法则是一次性将巨额流量压入网络，如果能够流就让他流，即将流量转到下一个节点，否则就溢出，不管溢出的部分。可以推送流量就推送流量，最终汇点T有多少流量就是最大流。 基本概念 余流：每个点当前有多少水。 推流：把该点的余流推给周围点 高度：流网络中的每个点都有一个高度，水只会从高处往低处流，算法只会在$h（u）= h（v）+ 1$的边$（u，v）$执行推流 溢出：超额流$eu= (x,u)∈Efx,u- (u,y)∈Ef(u,y) &gt; 0,$则称结点u溢出 重贴标签（Relabel）：如果节点u溢出，且$∀(u,v)∈Ef, h(u)&lt;=h(v)$ 则u点适合使用relabel操作，将$h（u）$更新为 $minhv+1,(u,v)∈Ef$即可 （2）算法思想 1.先假装s有无限多的水(余流)，从s向周围点推流（把该点的余流推给周围点），并让周围点入队 2.不断地取队首元素，对队首元素推流 3.队列为空时结束算法，t点的余流即为最大流。 注意事项 ①在开始预流推进前要先把S的高度改为n（点数），避免一开始S推流过去的点就直接把余流倒流回S。 ②S和T不能进入队列 ③推的流量不能超过边的容量也不能超过该点余流 ④如果$（u，v）$在推流完之后满流，则将这条边在残留网络中删除。 （3）算法过程 对于下面的流网络，我们使用红色数字表示余流，蓝色数字表示高度。荧光底色标记着发生变化的数值 首先，网络中有六个点，先将源点S的高度设置为6，然后向与源点连接的点推送流量，源点的余流为-11，1号点的余流为5，3号点的余流为6，（S,1）和（S,2）的边权设置为0。 此时，1号点，3号点有余流，将他们的高度抬高。 对1号点执行推流操作 与1号点连接的边都达到饱和状态，不能继续执行推流操作，继续抬高1号点的高度 依此类推，不断地对流网络中的点执行推流，然后重新设置高度，直到整个网络中除了源点和汇点其他的点都没有余流，那么这个时候汇点中的流量值就是最大流的流量值 （4）算法优化 ① 堆优化 最高标号预流推进算法（High Level Preflow Push）简称HLPP 是基于预流推进算法的优先队列实现，该算法优先推送高度高的溢出的结点。 具体地说，HLPP 算法过程如下： 1.初始化（基于预流推进算法）； 2.选择溢出结点（除 S,T）中高度最高的结点u，并对它所有可以推送的边进行推送； 3.如果 u仍溢出，对它重贴标签，回到步骤 2； 4.如果没有溢出的结点，算法结束。 ②BFS优化 在初始化高度的时候进行优化。具体来说，我们初始化 h(u)为u到t的最短距离；特别的，h（s） = n（n为顶点数）。在 BFS 的同时我们可以顺带地检查图的连通性，排除无解的情况。 如下图，通过从汇点T 开始BFS整个流网络可以得到右边节点带有高度的流网络 ③GAP优化 HLPP 推送的条件是h（u）= h（v）+ 1，而如果在算法的某一时刻，h(u) = k的结点个数为0，那么对于h(u) &gt; k的结点就永远无法推送超额流到汇点T，因此只能送回源点S，那么我们就在这时直接让他们的高度变成n + 1，以尽快推送回源点S，减少重贴标签的操作。 如下图，算法在某个时刻将1号点的高度从2抬高到3，然后发现图中高度为2的节点数量为0，那么我们将0号点和1号点的高度设置为6，以使得它们的余流加快回流到源点S （5）伪代码描述 （3）算法时间复杂度 查阅资料得EK算法的时间复杂度为 $O（V^2E^{1/2}）$，其中， V为点数，E为边数 六、效率分析（时间单位：us） 由于最大流算法的时间复杂度上界比较宽松，并且本实验的流网络结构较为简单且层数固定，因此不作理论效率的比较，只通过不同参数的变化分析时间效率的变化； 1.其他值固定，改变a的值 时间单位：ms a EK Dinic HLPP 5 1308.17 5.0402 15.636 10 3794.81 3.145 27.5953 15 7434.1 4.1857 46.3086 20 12774.3 4.7355 74.1043 25 20119.8 5.168 96.5127 b = 25, n = 500, m = 500 a增大，EK和HLPP需要遍历的边和点数量增大，EK，HLPP 所需时间增多 对 Dinic 的效率影响不大 其他值固定，改变b的值 时间单位：ms b EK Dinic HLPP 5 4776.69 6.1278 100.655 10 2228.4 2.748 36.1762 15 1754.15 2.7448 22.0881 20 1471.36 2.2022 16.2429 25 1301.78 2.5006 14.6073 a = 5, n = 500, m = 500 b增大，增广路径随b的增大而增加，EK，HLPP 所需时间减少 对 Dinic 的效率影响不大 其他值固定，改变n的值 时间单位：ms n EK Dinic HLPP 100 599.6 2.4803 8.6507 200 765.851 1.5216 9.8194 300 945.658 1.6449 12.229 400 1081.43 2.2724 13.2294 500 1290.19 2.9115 14.4041 a = 5, b = 25, m = 500 n增大，增广路数量增大，EK，HLPP 所需时间增大 对 Dinic 的效率影响不大 \\4. 其他值固定，改变m的值 时间单位：ms m EK Dinic HLPP 100 43.856 1.7683 4.1706 200 160.41 1.1502 3.8335 300 407.002 1.2255 6.5871 400 783.97 1.7507 10.0239 500 1382.34 2.0253 13.4699 a = 25, b = 25, n = 500 m增大，增广路数量增大，EK，HLPP 所需时间增大 对 Dinic的效率影响不大 在上面的数据测试中，可以发现本实验的几种最大流算法中Dinic算法的表现最为优异，主要原因是Dinic算法的多路增广在这个实验构建的流网络效果最佳，以及Dinic实际上只需要在这个网络中使用一次BFS构建分层图就可以多次进行多路增广，所以即便Dinic的时间复杂度为$O(V^2E)$依旧表现优异。 EK算法则是由于每次寻找增广路都需要进行一次BFS搜索，并且论文点集和评审点集之间的边相对来说比较稠密，所以相同规模的图EK算法在这三个算法之中效率最低。 再看时间复杂度为$O（V^2E^{1/2}）$的HLPP算法，HLPP算法的时间复杂度在这个三个算法中最低，但是其他算法的时间复杂上界较为宽松，而HLPP算法实际运行是比较贴近它自身的时间复杂度的。由于本实验的流网络结构比较简单，而且层数只有四层，所以HLPP的各种优化在计算最大流的优势反而在这个实验之中体现不出来，并且对应的操作带来的时间消耗使得HLPP在这个流网络中的各项效率均差于Dinic算法。 七、实验心得 网络流算法的普遍化及专门化 我们可以利用网络流去找出最大流是最简单及最普通的问题，它提供了在一指定的图中由源点到汇点的最大可能总流量。还有很多其它问题可以利用最大流算法去解决，假设它们可以适当地塑造成流网络的模样，例如二分图匹配（Bipartite Matching）、任务分配问题（Assignment Problem）和运输问题（Transportation Problem）。 流网络的建立 如果我们能找到问题的解空间中可行解和流网络中可行流之间一一对应的关系，那我们就可以使用最大流算法来求解问题的最大可行解","categories":[{"name":"算法","slug":"算法","permalink":"http://www.misaka-9982.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.misaka-9982.com/tags/Algorithm/"}]},{"title":"算法设计实验五","slug":"算法设计实验五","date":"2021-05-20T13:56:20.000Z","updated":"2023-02-22T13:07:14.748Z","comments":true,"path":"2021/05/20/算法设计实验五/","link":"","permalink":"http://www.misaka-9982.com/2021/05/20/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C%E4%BA%94/","excerpt":"","text":"一、实验目的： 掌握图的连通性。 掌握并查集的基本原理和应用。 二、内容： 1. 桥的定义 在图论中，一条边被称为“桥”代表这条边一旦被删除，这张图的连通块数量会增加。等价地说，一条边是一座桥当且仅当这条边不在任何环上。一张图可以有零或多座桥。 图 1 没有桥的无向连通图 图 2 这是有16个顶点和6个桥的图（桥以红色线段标示） 2. 求解问题 找出一个无向图中所有的桥。 3. 算法 （1）基准算法 12345678For every edge (u, v), do followinga) Remove (u, v) from graphb) See if the graph remains connected (We can either use BFS or DFS)c) Add (u, v) back to the graph. （2）应用并查集设计一个比基准算法更高效的算法。不要使用Tarjan算法，如果使用Tarjan算法，仍然需要利用并查集设计一个比基准算法更高效的算法。 三、实验要求 实现上述基准算法。 设计的高效算法中必须使用并查集，如有需要，可以配合使用其他任何数据结构。 用图2的例子验证算法正确性。 使用文件 mediumG.txt和largeG.txt 中的无向图测试基准算法和高效算法的性能，记录两个算法的运行时间。 设计的高效算法的运行时间作为评分标准之一。 提交程序源代码。 实验报告中要详细描述算法设计的思想，核心步骤，使用的数据结构。 四、算法原理描述 1、基准算法 使用的数据结构：邻接表。 由于实际应用中大多为稀疏图，使用邻接矩阵则会有大量的空白数据，将造成较大的浪费，会导致dfs遍历的无效次数增多 基准法1 1）算法描述：首先用dfs 或者bfs 计算出图中共有几个连通块，如果当前搜索的连通块中节点都已经被被访问过，而整个图的节点还没有被完成访问过，则连通块的数量加一，并进入下一个连通块进行搜索，枚举完所有节点以计算出有几个连通块。 如下图，当访问完A点所在的连通块中所有的点，还有其他灰色的点没有被访问过，那么连通块的数量加一，并开始访问其他点所在的连通块，以此计算出这种图共有4个连通块。 计算出图中总共有几个连通块之后，开始计算图中共有多少条桥。一条边被称为“桥”代表这条边一旦被删除，这张图的连通块数量会增加。因此，只需要将图中任意一条边删除，再计算出图中共有几个连通块，与删除边之前的连通块数量作比较，如果连通块的数量增加，那么，被删除的这条边就是桥。 如下图，原本A,B两点之间连接有一条边，使得A,B两点处于同一个连通块之中，而删去AB这条边后可以发现此时，A，B两点位于不同的连通块之中，连通块的数量从4个变成了5个，说明AB这条边是桥。 按照这种思路依次枚举图中所有的边，就可以找出所有的桥。 2）伪代码描述： CountBlock( )函数用于在开始搜索之前计算不删除边时，这个图有几个连通块 3）算法时间复杂度： n为点数，m为边数，每次计算连通块的数量需要枚举图中的所有节点，单次计算连通块的数量的时间复杂度为 $O（n + m）$，共有m条边需要计算m次，因此总的时间复杂度为 $O（m n + m^2）$ 基准法2 1）算法描述： 从桥的定义出发，一条边是一座桥当且仅当这条边不在任何环上。对于图中的任意一条边，如果删去这条边，而这条边对应的两个点不再连通的话，说明除了这条边，没有其他路径可以使得这两个点连通，那么这条被删掉的边就是桥。而如果两点之间依旧连通的话，说明这条边处在一个环里面，存在其他路径使得这两个点连通，那么这条被删掉的边就不是桥。 两点之间的连通性可以通过对其中一个点进行一次深度优先搜索进行判断，如果在深度优先搜索的过程访问到了另外一个节点，那么就说明两点是连通的，停止搜索。 如下图，A,B两点之间原本是相互连通的，删去AB这条边，对A进行深度优先搜索，搜索结束时，依旧没有访问过B点，说明除了AB这条边之外，A点和B点再也没有其他连通的路径，那么AB这条边就是桥，依次枚举图中的每一条边，即可找出所有的桥。 2）伪代码描述： 3）算法时间复杂度： n为点数，m为边数，每次查看两点的连通性在最坏情况下要枚举n个点，时间复杂度为$O(n + m)$，共有m条边需要计算m次，总的时间复杂度为$O（m n + m^2）$ 2、优化 在图论中，无向图 G 的生成树（英语：Spanning Tree）是具有 G 的全部顶点，但边数最少的连通子图。换句话说，树会使得所有的顶点连通，并且不会形成环。那么桥一定会出现在树边上，而不会出现在非树边上。 如下图，对于子图A 和 子图B 他们之间有唯一的一条边使得他们之间保持连通，那么在这个图的生成树一定会包含这条边，否则子图A子图B之间不连通。 而对于下图，假设黄色的边为树边，而灰色的边为非树边，那么当删去灰色边时，连通块的数量不会增加，说明这条灰色的边不是桥，对于一张图中的生成树来说，它的树边已经能保证所有的节点之间相互连通，而这个时候再往树中添加任意一条非树边就一定会和其他的树边形成环，非树边一定不是桥。 这个时候就可以使用基准法来枚举这些树边以找出所有的桥。需要枚举的边从整张图的m条边降低为生成树的$n – 1$ 条边，而对于非连通图来说，需要枚举的就是生成森林的树边。 如下左图，对它进行生成树的生成，就会得到右图中的森林，对于森林中树的树边进行枚举即可 对于稠密图来说，枚举树边会使效率得到大幅度的提升。 2）伪代码描述： 生成生成树的伪代码： 使用生成树的树边进行枚举： 3）算法时间复杂度： n为点数，m为边数，一棵树有n – 1 条边，基准法原来需要枚举m条边，现在只需要枚举树边，时间复杂度从 $O（m n + m^2）$降低为$O（m n + n^2）$ 3、并查集 并查集是一种树形的数据结构，用于处理一些不交集（一系列没有重复元素的集合）的合并及查询问题。 并查集支持如下操作： 查询：查询某个元素属于哪个集合，通常是返回集合内的一个“代表元素”。这个操作是为了判断两个元素是否在同一个集合之中。 合并：将两个集合合并为一个。 并查集的初始化伪代码 查找 通俗地讲一个故事：几个家族进行宴会，但是家族普遍长寿，所以人数众多。由于长时间的分离以及年龄的增长，这些人逐渐忘掉了自己的亲人，只记得自己的爸爸是谁了，而最长者（称为「祖先」）的父亲已经去世，他只知道自己是祖先。为了确定自己是哪个家族，他们想出了一个办法，只要问自己的爸爸是不是祖先，一层一层的向上问，直到问到祖先。如果要判断两人是否在同一家族，只要看两人的祖先是不是同一人就可以了。 在这样的思想下，并查集的查找算法诞生了。 如下图，要查找绿色节点的祖先节点，就需要先找出绿色节点的父亲节点，如果他的父亲节点不是祖先节点，那就接着找父亲节点的父亲节点，知道找出祖先节点为止。 查找函数的伪代码 路径压缩 这样一层一层地查找的确可以达成目的，但是显然效率实在太低。因为使用了大量没用的信息，一个节点的祖先是谁与他的父亲是谁没什么关系，这样一层一层找太浪费时间，不如直接让这个节点当祖先的儿子，问一次就可以出结果了。甚至祖先是谁都无所谓，只要这个人可以代表我们家族就能得到想要的效果。 把在路径上的每个节点都直接连接到根上，这就是路径压缩。 如下图，原本要查找绿色节点的祖先需要向上查询3次，而在查询过程中将查询路径上的节点的父亲节点都设置为祖先节点，在此查询时就只需要查询一次，效率明显提高了。 路径压缩的伪代码 时间复杂度：使用了路径压缩的并查集查询时间复杂度仅为$O(1)$ 合并 宴会上，一个家族的祖先突然对另一个家族说：我们两个家族交情这么好，不如合成一家好了。另一个家族也欣然接受了。 上文说过，祖先是谁并不重要，所以只要其中一个祖先变成另一个祖先的父亲节点就可以了。 如下左图，将右边集合的祖先节点设置为左边集合的祖先节点的父亲节点，两个集合就合并成为一个集合。而右图将左边集合的祖先节点设置为右边集合的祖先节点的父亲节点，两个集合也是合并成为一个集合。 合并操作的伪代码 按秩合并 合并后可能会导致集合树的不平衡，增大树的深度，从而增加查询的耗时。一个控制树的深度的办法是，在合并时，比较两棵树的大小，较大的一棵树的根节点成为合并后的树的根节点，较小的一棵树的根节点则成为前者的子节点。 判断树的大小有两种常用的方法，一个是以树中元素的数量作为树的大小，这被称为按大小合并。伪代码如下： 需要注意的是，上面的代码中，只有根节点的size有意义，非根节点的size是没有意义的。 另一种做法则是使用“秩”来比较树的大小。“秩”的定义如下： 只有根节点的树（即只有一个元素的集合），秩为0； 当两棵秩不同的树合并后，新的树的秩为原来两棵树的秩的较大者； 当两棵秩相同的树合并后，新的树的秩为原来的树的秩加一。 在没有路径压缩优化时，树的秩等于树的深度减一。在有路径压缩优化时，树的秩仍然能反映出树的深度和大小。在合并时根据两棵树的秩的大小，决定新的根节点，这被称作按秩合并。用伪代码表示如下： 同样，上面的代码中，只有根节点的rank有意义，非根节点的rank是没有意义的。 由伪代码分析可得，使用了路径压缩的单次Union操作时间复杂度可以近似地认为是$O(1)$。由《算法导论》一书中定理21.1的证明可知，一个有n个点的集合，每个点的祖先节点最多被更新$⌈log n⌉$ 次，最多需要执行$n – 1$ 次Union操作，因此Union操作总的时间复杂度为$O(nlogn)$ 并查集求桥 1）算法描述:对于给定的图，先将图中各个顶点初始化为属于各自顶点的集合，然后依次输入图的边，如果边对应的两个顶点属于不同的集合，则将这两个点进行合并，如果两点属于同一个集合则不进行操作，依次对所有的边操作完，计算图中共有几个祖宗节点，有几个祖宗节点就有几个连通块。记录下这个连通块的数量，然后生成一个生成树，初始化各点所属的集合，删除其中一条生成树的树边，按照其他边对应的两个点的关系合并集合，合并完成之后计算连通块的数量，如果连通块的数量比删除边之前的连通块数量多，那么删除的边就是桥。依次枚举完所有的树边，就可以找出所有的桥。** 2）伪代码描述： 3）算法时间复杂度：每次查询一条边的两个点所属集合的时间复杂度为$O(1)$，合并两个点所在的集合的时间复杂度为$O(1)$，共有m 条边，查询这些边对应的点所属集合的时间复杂度为$O(m)$。生成树的树边共有 $n – 1$ 条树边，初始化集合并删去其中一条树边后重新合并这些点，需要重复 $n – 1$ 次，算法总体的时间复杂度为$O(n m)$。 边双连通分量 在一张连通的无向图中，对于两个点 u 和 v，如果无论删去哪条边（只能删去一条）都不能使它们不连通，我们就说 u和v 边双连通。 若一个无向图中的去掉任意一条边都不会改变此图的连通性，即不存在桥，则称作边双连通图，边双连通图的任意一条边都至少在一个简单环中。一个无向图中的每一个极大边双连通子图称作此无向图的边双连通分量。 如下图，对于图①，删除图中任意一条边，图①中各点依旧保持连通。而如果同时删去（0,3）和（0,1）这两条边，那么节点0和其他节点将不再连通，那么图①则称为边双连通图。 对于下图，只需要删除（0,3）这一条边（也就是桥），节点0就不再和其他节点连通，这样的图就不是边双连通图。图中节点2,4,5则构成了这个图的边双连通分量。 可以看出，桥将一个图中的边双连通分量划分开来。如果我们将每个边双连通分量都压缩成一个顶点，并且只将桥边作为边留在压缩后的图中，那么我们将得到一个无环图，即树。 如下图，将左图中的所有边双连通分量找出来之后进行压缩操作即可得到右图中的树。如果该图有多个连通分量，则得到森林。 当还没开始往图里添加边时时，它包含n个双连通的分量，这些分量之间本身是不连通的。（n为点数） 如右图，图中没有任何边，每个点都是一个双连通分量 每次往图中添加下一条边时，可能会出现三种情况： 1.边对应的两个点属于同一个双连通分量。 这条边会使得所在的双连通分量添加一条环边，不会改变森林的其他结构。在这种情况下，桥的数量不会发生变化。 如下图，桥的数量原本有编号的四条边，添加了黄色边之后，黄色边所在的双连通分量多了一条环边，而桥依旧是原本编号的四条边，并且没有发生连通分量或者双连通分量的合并。 2.两点属于两个不同的连通分量 这条边对应的两个点原本属于两棵不同的树，加上这条边之后，会使的两个连通分量合并成一个，而这条边则成为连通这两个分量的唯一路径，也就是桥。在这种情况下，桥的数量加一，原有的旧桥依旧是桥，不受影响。 如下图，点①与点②原本属于两棵不同的树，连接点①和点②之后，他们所属的连通分量发生合并，现在他们都属于同一个连通分量，并且黄色边会成为新的桥，桥的数量加一。 3.两点属于同一个连通分量，不同的双连通分量 在这种情况下，这条边与一些旧桥一起形成了环，由此产生的环需要被压缩成一个新的双连通分量。在这种情况下，新加入的边会被当作桥来处理，桥的数量会加一，紧接着把与这条边形成环的旧桥以及这条新桥给减掉，因此桥的数量会减少两条或者更多。 如下图，原本边（①，③）是一条桥，加入边（①，②）之后，桥（①，③）与边（①，②）形成环。先把边（①，②）当作桥处理，将桥的数量加一，然后把形成环的桥边（①，③）和（①，②）给去掉，这种情况下，桥的数量就减少了两条。 对于下图原本边（①，②），（①，③），（②，④）都是桥，加入边（③，④）之后，边（①，②），（①，③），（②，④）与（③，④）形成一个环，把（③，④）当作桥来处理，桥的数量加一，然后处理旧桥与这条新桥，在这种情况下，桥的数量减少四条。 分析完上述三种情况后，我们可以发现求桥的数量可以被简化为维护图中双连通分量形成的森林以及这些双连通分量的有效压缩。 高效算法使用的数据结构 两个并查集，一个并查集用于维护图中的连通分量，另外一个并查集用于图中的双连通分量。同时两个并查集都采用路径压缩和按秩合并。 最小公共祖先 最小公共祖先简称 LCA（Lowest Common Ancestor）。两个节点的最小公共祖先，就是这两个点的公共祖先里面，离根最远的那个。 如下图，点1和点2的公共祖先节点有5，6,7,8，而离根节点最远的节点为5号点，点1和点2的最小公共祖先就是5号点。同理，3号点和4号点的LCA为6号点，2号点和5号点的LCA为5号点，因为5号点本身就是2号点的祖先节点。 压缩操作 在树中添加一条新的边（a，b），如果这条边对应的两点属于同一个连通分量，不同的双连通分量，那么就会形成一个新的环，a, b两点已经被（a，b）这条边连接，通过在树中寻找这两个点的LCA，我们就能找到这个新形成的环，这个环由边（a，b），a点在树上到LCA的路径，LCA到b点的路径这几个部分组成。 如下左图，在树中添加（①，②）这条边，①②⑤这三个点就会形成一个环，通过找到①，②两点的LCA 即⑤号点，我们就可以将他们在维护双连通分量的并查集中合并成一个集合。 同理，⑤号所属集合中的一个点与⑦号点连一条线会与⑥号点形成一个新的环，通过⑦号点是这条新的边两点对应的LCA，⑤号点寻找LCA的路径为⑤ -&gt; ⑥ -&gt; ⑦，将五号点寻找LCA路径中经过的点合并到⑦号点所属的双连通分量集合中去。 伪代码描述 算法时间复杂度 每次往图里添加一条新的边要查询两个点所属的连通分量集合及双连通分量的集合，一条边需要4次查询，共有m条边，一共需要查询$4 * m$ 次， 使用了路径压缩的并查集查询时间复杂度为$O(m)$。 每次合并集合的时间复杂度为$O(1)$，每个点的祖先节点最多被更新$⌈log n⌉$ 次，最多需要执行$n – 1$ 次合并操作，因此合并操作总的时间复杂度为$O(n log n)$。 算法整体的时间复杂度为$O(m + n log n)$。由于边数一般比点数多很多，因此整体复杂度主要取决于边数。 五、效率分析（时间单位：us） 注：下列表格中的DSU代表使用双连通分量压缩计算桥数量的算法 附件数据集的运行时间： 算法 中图 大图 DSU 77.9us 0.2944s Tarjan 7.9us 0.7173s 桥的数量 0 8 在规模较小时，DSU算法的运行时间要大于Tarjan算法的运行时间，而当数据规模较大时，由于Tarjan算法的具体代码实现采用了递归的实现方式，会增加与算法效率本身无关的开销，所以运行时间要大于DSU算法的运行时间 O（m）复杂度时间理论值推导 $t_1 = m_1 * t$, t1表示规模为m1的数据用时 $t_2 = m_2 * t$, t2表示规模为m2的数据用时 $t2=（m2/m1） * t1$ O（n log（n））复杂度时间推导 $t_1=n_1*log(2，n_1)*t$, t1表示规模为n1的数据用时 $t_2=n_2*log(2，n_2)*t$, t2表示规模为n2的数据用时 $t_2=n_2/n_1*（log（2，n_2）/1og（2，n_1））* t_1$ 基准法1 + 生成树优化随机数据测试 边数固定，点数从一千个点增加到五千个点 算法 点数 边数 基准法(us) O(nm)参考值(us) BaseTree 1000 50000 3.15E+06 3.28E+06 BaseTree 2000 50000 6.79E+06 6.56E+06 BaseTree 3000 50000 1.02E+07 9.84E+06 BaseTree 4000 50000 1.33E+07 1.31E+07 BaseTree 5000 50000 1.64E+07 1.64E+07 由上图可以看出，当点数远少于边数的时候基准法使用生成树优化的时间复杂度$O（m n + n^2）$中的$n^2$ 一项可以忽略不计，实际运行时间和参考值的曲线基本贴合在一起，拟合程度较好。 边数和点数相等，从一万个点到五万个点 算法 点数 边数 基准法(us) O(n * n)参考值(us) BaseTree 10000.00 10000.00 2286580.00 2304804.00 BaseTree 20000.00 20000.00 10493700.00 9219216.00 BaseTree 30000.00 30000.00 22397300.00 20743236.00 BaseTree 40000.00 40000.00 38891000.00 36876864.00 BaseTree 50000.00 50000.00 57620100.00 57620100.00 由上图可以看出，当点数和边数相接近时，算法的时间复杂度 $O（m n + n^2）$中的$m n$相当于$n^2$使得算法整体的时间复杂符合$O(n^2)$的增长趋势，实际运行时间和$O(n^2)$的曲线相接近，拟合程度较好。 DSU算法随机数据测试 点数固定，边数从两百万增加到一千二百万 时间单位：us 点数 边数 DSU处理(us) DSU理论值(us) Tarjan 5000 5000 569.3666667 24.11381667 311.5667 5000 2000000 11284.18 9645.526667 48975.98 5000 4000000 20081.04 19291.05333 98991.43 5000 6000000 30077.9 28936.58 150016.8 5000 8000000 39319.14 38582.10667 200799.7 5000 10000000 48158.5 48227.63333 254684.9 5000 12000000 57873.16 57873.16 302656.7 上表数据中理论值忽略了实际算法复杂$O(m + n log n)$中的$n log n$以一千两百万条边的处理时间作为基准值推导出其他数据规模的理论值，需要注意的是当边数和点数数量级接近时，$m$与 $n log n$的数量级相接近，算法实际运行时间受点数影响较大，所以五千个点，五千条边的实际处理时间和理论时间相差了二十多倍 从图中可以看出当边数的数量远远大于点数时，理论值和实际值的拟合程度较高，算法的实际运行时间主要取决于边数。 稀疏图的算法效率分析 点数固定，边数增加： 十万个点的数据规模： 点数 边数 DSU处理(us) O(m)参考值(us) O(nlogn)参考值 100000 100000 9466.95 9466.95 9466.95 100000 200000 10585.18 18933.9 20073.83 100000 300000 12031.1 28400.85 31110.98 100000 400000 11682.15 37867.8 42427.54 100000 500000 12317.5 47334.75 53951.86 一百万个点的随机数据： 点数 边数 DSU处理(us) O(m)参考值(us) O(n log n)参考值 1000000 1000000 15014 1.50E+04 15014.00 1000000 2000000 25135.1 3.00E+04 31534.55 1000000 3000000 27167.46667 4.50E+04 48623.75 1000000 4000000 30746 6.01E+04 66082.22 1000000 5000000 39939.8 7.51E+04 83815.28 1000000 6000000 50295 9.01E+04 101767.16 1000000 7000000 48344.23333 1.05E+05 119901.02 从上两张图中可以发现，当点数和边数相接近时，算法的实际运行时间和$O(m)$的参考值曲线拟合程度极差，说明当边数和点数相接近时，算法运行时间和边数关系不大。 还可以发现当边数提高到七百万条边时，与附件中的数据集规模相当，而算法的平均运行时间为四十多毫秒，而数据集中的文件需要接近三百毫秒的处理时间。可能的原因是附件中的数据集在算法运行中的合并次数比较多，最终数据集中的图只剩下一个连通分量，九个双连通分量，并且数据集中含有部分重边，跳过重边需要一部分时间，而随机图的生成是有进行去重的操作，所以花费的时间要远大于测试的随机数据平均值。 边数固定，点数增加： 点数 边数 DSU处理(us) O(n log n)参考值 100000 500000 12773.04 12773.04 200000 500000 13605.66 27084.11 300000 500000 13251.54 41975.69 400000 500000 13278.98 57244.27 500000 500000 13564.68 72793.17 从上图可以发现，实际运行时间和$O(n log n)$的参考值并不拟合，事实上，只有在极端的情况下合并操作的时间复杂度才会达到 $O(n log n)$，在随机图数据测试中一般不会产生这种极端情况。 与Tarjan算法的效率对比： 稀疏图：边数 = 点数 时间单位：us 算法 点数 边数 dsu tar DSU 1000000 1000000 31327.22 52194.2 DSU 2000000 2000000 40378.46 93568.31667 DSU 3000000 3000000 48704.74 135942.35 DSU 4000000 4000000 56922.36 176652.6833 DSU 5000000 5000000 65829.04 210706.2667 稠密图：$边数 = (点数 * 点数 ) / 2 * 0.96， m = n * n * 0.48$ 算法 点数 边数 处理时间(us) tarjan DSU 1000 480000 2571.66 8945.967 DSU 2000 1920000 9718.6 44108.47 DSU 3000 4320000 22239.98 106044 DSU 4000 7680000 37450.12 193829.9 DSU 5000 12000000 57873.16 356946.8 观察图表可得，DSU与Tarjan都为线性效率，但是tarjan的代码实现采用了递归的方式，无关的开销较多，实际运行时间要比DSU算法大 六、实验心得 在 Tarjan 的论文中，证明了不使用启发式合并、只使用路径压缩的最坏时间复杂度是$O(m log n)$。 在姚期智的论文中，证明了不使用启发式合并、只使用路径压缩，在平均情况下，时间复杂度依然是 $O(mα（m，n）)$。由于路径压缩单次合并可能造成大量修改，有时路径压缩会破坏按秩合并的准确性，并不适合使用。在实际应用中，不一定总是需要两种优化一起使用。 有些人可能有一个误解，以为路径压缩优化后，并查集始终都是一个菊花图（只有两层的树的俗称）。但其实，由于路径压缩只在查询时进行，也只压缩一条路径，所以并查集最终的结构仍然可能是比较复杂的。 图算法的意义：图形通常用来描述某些事物之间的某种特定关系。顶点用于代表事物，连接两顶点的边则用于表示两个事物间具有这种关系","categories":[{"name":"算法","slug":"算法","permalink":"http://www.misaka-9982.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.misaka-9982.com/tags/Algorithm/"}]},{"title":"算法设计实验四","slug":"算法设计实验四","date":"2021-05-03T13:56:20.000Z","updated":"2023-02-22T13:07:14.708Z","comments":true,"path":"2021/05/03/算法设计实验四/","link":"","permalink":"http://www.misaka-9982.com/2021/05/03/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C%E5%9B%9B/","excerpt":"","text":"一、实验目的： 掌握动态规划算法设计思想。 掌握流水线问题的动态规划解法。 二、内容： 汽车厂有两条流水线，每条流水线有n个处理环节（station）: S1,1，…，S1,n 和 S2,1，…，S2,n，其中下标的第一个字母表示流水线编号（流水线1和流水线2）。其中S1, j 和 S2, j 完成相同的功能，但是花费的时间不同，分别是a1, j , a2, j 。两条流水线的输入时间分别为e1 和 e2, 输出时间是x1 和 x2。 每个安装步骤完成后，有两个选择： 1）停在同一条安装线上，没有转移代价； 2）转到另一条安装线上，转移代价： Si,j 的代价是ti,j , j = 1，…，n - 1 问题: 如何选择安装线1和安装线2的节点组合，从而最小化安装一台车的总时间？ 三、实验要求 1、给出解决问题的动态规划方程； 2、随机产生S2, j 、ti,j的值，对小数据模型利用蛮力法测试算法的正确性； 3、随机产生S2, j 、ti,j的值，对不同数据规模（n的值）测试算法效率，并与理论效率进行比对，请提供能处理的数据最大规模，注意要在有限时间内处理完； 4、该算法是否有效率提高的空间？包括空间效率和时间效率。 四、算法原理描述 1、回溯剪枝（暴力枚举） 1）算法描述：利用回溯法遍历计算所有解对应的代价，找出其中的最小值。 搜索树定义： 解空间：$n$个变量，每个变量有两种取值所以总共有$O(2^n)$ 种解 节点定义：$(x1,x2,…,x7)$，xi取值范围{0,1}$ 状态树的构造：在两条流水线中选择其中一条以进入下一层的搜索。 树最多有$n + 1$层（根是第0层） 每个叶子节点就是一种解，遍历所有叶子节点找出代价最小的解 如下图，四个叶子节点中的最小值为12，枚举这个四个叶子节点，找出12这个最小值。 在进行回溯的过程中还可以进行一些比较简单的剪枝。在进行搜索的过程中，如果来到当前节点所需要的代价已经大于或等于当前记录下来的最小代价时，由于到下一个节点进行处理的代价是正值，那么总的代价也会呈现递增的趋势，这个时候就直接回溯。 如下图，当搜索到③号节点时，当前需要的代价为14，已经大于当前搜索出来的最小值12，那么就直接回溯。 2）伪代码描述： 3）算法时间复杂度：设每条流水线有n个处理节点，每个节点都有两个方向可以选择，那么解空间就有$2^n$ 个节点，枚举每一种方案的时间复杂度为$O(2^n)$ 2、动态规划 1）状态表示： 流水线问题要求的是总的耗时最短的路线组合，我们可以将$f_i[j]$设为最快通过处理站 $S_{i,j}$的时间，即$f_i[j]$为所有到达站点 $S_{i,j}$的路线总时间中的最小值。设$f$为通过整个流水线的最短时间 2）边界条件 $j=1, i=1, 2$ 时，底盘送入流水线，第一步的时间为输入时间加上工序时间，故边界条件为： $f_1[1] = e_1+a_{1,1}$ $f_2[1] = e_2+ a_{2,1}$ 3）阶段划分 观察下面两张图可以发现，要到达 $S_{1,2}$的最短时间 $f_{1,2}$由需要从 $S_{1,1}$或者 $S_{2,1}$出发 要到达 $S_{1,3}$的最短时间 $f_{1,3}$由需要从 $S_{1,2}$或者 $S_{2,2}$出发 可以看出问题fi[j]是在上一个阶段的基础上构成，所以可以推测该问题具有最优子结构 证明: 假设$fi[j]$为最优，而其子问题 $h1[j - 1]$不是最优,那么存在子问题的最短时间 $f1_j - 1 &lt; h1[j - 1]$ 为最优，交换$ f1[j - 1]与 h1[j - 1]$得出 $f’i[j] &lt; fi[j]$为最优，那么 $fi[j] $不是最优解，矛盾。 该问题符合最优子结构的性质，同理可证其他情况。证毕。 所以我们可以将阶段划分如下： $f1j - 1， f2j - 1$是前一阶段 求 $f1j、 f2$j为后一阶段 4）状态计算 由阶段划分的分析，我们不难发现到达 $S1,j$的路线可以分为从站点 $S1,j-1$而来和从站点 $S2,j-1$而来，又由于该问题具有最优子结构，那么求$f1[j]$可以转化为求$f1[j-1]$和$f2j-1+t2[j-1]$二者之间的最小值，得出最小值后再加上站点 $S1,j$需要的时间 $a1 j$，同理可求$f2[j]$ 通过整个流水线的最短时间$f_*$则由$f1[n]+x1$ 和 $f2[n]+x2$ 二者之间的较小值得出 至此，我们可以写出状态转移方程为 $f_*=min(f1[n]+x1,f2[n]+x2)$ 2）伪代码描述 求解最短时间 3）算法复杂度分析： 时间复杂度：每次计算需要计算两个站点，每个站点计算前面两个站点到本站点时间的最小值，可以得出时间复杂度为$O(n)$ 空间复杂度：$O(n)$，但存储信息为中间过程的时间最小值，每个站点的处理时间，每个站点的转移代价，流水线转移路径，常数较大，可进一步优化 4）优化方案 由于每次的状态计算只与上一阶段的状态有关，所以可以不记录中间结果，只记录流水线转移路径, 每个站点的处理时间，每个站点的转移代价都可以不存储。 在计算机中，一个char类型字符占用一个字节的存储空间，而一个int类型占用4个字节，所以使用char类型数组代替int类型数组存储路径可以提高测试的最大规模。 在Windows系统下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。栈的大小受限于编译器。如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 而堆是向高地址扩展的数据结构，是不连续的内存区域。系统是用链表来存储的空闲内存地址的。堆的大小受限于计算机系统中有效的虚拟内存。因此堆能获得的空间比栈的空间要大。 将数组开辟到堆区可以进一步提高测试数据的最大规模。 状态转移方程： $h1= f1 ,h2= f2$ $f1 = e1+a_{1,1}, if - j=1$ $f1 = min(h1, h2+t2,j -1)+a_{1,j} , if - j≥2$ $f2 = e2+a_{2,1}, if - j=1$ $f2 = min(h2, h1+t1,j -1)+a_{2,j }, if - j≥2$ $f_*=min(f1+x1,f2+x2)$ 伪代码描述 5）路径输出函数 思路：逆序输出后面的节点是由前面哪一个节点转移而来 时间复杂度：$O(n)$，空间复杂度：$O(n)$ 五、效率分析（时间单位：us） O（n）复杂度时间理论值推导 $tl=n1 * t$, t1表示规模为n1的数据用时 $t2=n2 * t$ t2表示规模为n2的数据用时 $t2=（n2/n1） * t1$ 记录了所有中间结果以及转移代价和处理时间的算法效率： 时间单位：us Input dp1 理论值 10000000 57065.9 56099.17 20000000 112016 112198.3 30000000 168418 168297.5 40000000 225884 224396.7 50000000 281895 280495.8 60000000 336595 336595 能达到的最大测试规模为六千万 观察图表可得，实测效率曲线与理论效率曲线拟合较好，实测效率满足理论分析，实际时间复杂度为$O(n)$ 不记录最小处理时间中间结果但记录各种代价以及路径的时间效率： 时间单位：us Input dp2 理论值 10000000 44304.3 44142.38 20000000 88556.1 88284.75 30000000 133542 132427.1 40000000 177171 176569.5 50000000 221502 220711.9 60000000 264927 264854.3 70000000 308989 308996.6 80000000 353139 353139 能达到的最大测试规模为八千万 观察图表可得，实测效率曲线与理论效率曲线拟合较好，实测效率满足理论分析，实际时间复杂度为$O(n)$ 二者六千万规模部分的对比： 比值的平均值为1.27204 记录最小处理时间中间结果的算法时间复杂度的常数较大，这因为访问数组的代价要比访问单个变量的代价开销要大 只记录路径的算法时间效率 Input dp2 理论值 随机数时间 差值 理论值2 30000000 1.59E+06 1578925 1.47E+06 1.22E+05 109804.8 60000000 3.16E+06 3157850 2.94E+06 2.23E+05 219124.7 90000000 4.74E+06 4736775 4.41E+06 3.33E+05 328929.4 1.2E+08 6.33E+06 6315700 5.87E+06 4.54E+05 438209.8 1.5E+08 7.90E+06 7894625 7.34E+06 5.61E+05 547602.1 1.8E+08 9.49E+06 9473550 8.83E+06 6.61E+05 658633.1 2.1E+08 1.11E+07 11052475 1.03E+07 7.65E+05 768634 2.4E+08 1.26E+07 12631400 1.18E+07 8.77E+05 876800 由于在dp函数内部生成随机数，所以总的时间也包含了随机数生成的时间。记录同等规模的随机数所需的时间与总的时间作差得出实际在计算所用的时间。 观察图表可得，实测效率曲线与理论效率曲线拟合较好，实测效率满足理论分析，实际时间复杂度为$O(n)$ 测试数据的最大规模 Int类型数组记录路径（只记录路径） 最大数据规模：$2.4E+08$（两亿四千万） 处理时间：8.77E+05（us）（0.877秒） Char类型数组记录路径（只记录路径） 最大数据规模：$9.9E+08$（九亿九千万） 处理时间：6.07E+06（us）（6.07秒） 分析：char类型占一个字节，而int类型占四个字节，所以数据规模大概为int类型的四倍。使用char类型变量赋值时，会发生隐式类型转换这部分的开销较大，所以处理时间比int类型的处理时间的四倍要高 将char类型数据开辟到堆区（只记录路径） 最大数据规模：$21.4E+08$（二十一亿四千万） 处理时间：1.54E+07（us）（15.4秒） 分析：堆区处理时间/栈区处理时间 = 1.54E+07 / 6.07E+06 ≈ 2.54 堆区数据规模/栈区数据规模 = 21.4E+08 / 9.9E+08 ≈ 2.16 堆区处理速度：堆区数据规模/堆区处理时间=9.9/6.07≈1.3896(亿/s) 栈区处理速度：栈区数据规模/栈区处理时间=21.4/15.4≈ 1.6309(亿/s) 可见堆区的处理速度要慢于栈区的处理速度 堆区内存使用的是链表存储，而栈区内存使用连续的空间存储，所以访问堆区的内存要慢于访问栈区的内存，但优点在于可利用的空间更大。 六、实验心得 DP问题的难点主要在于找出状态转移方程。 很多算法都是问题的可划分性以及子问题之间的相似性来进行归纳，降低求解的复杂度。动态规划也不例外。 动态规划的艺术在于状态设计和子结构的发掘，如何把问题形式化为状态空间，进一步抽象出DP的状态表示和阶段划分，是一件值得探究的事。","categories":[{"name":"算法","slug":"算法","permalink":"http://www.misaka-9982.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.misaka-9982.com/tags/Algorithm/"}]},{"title":"算法设计实验三","slug":"算法设计实验三","date":"2021-04-20T13:56:20.000Z","updated":"2023-02-22T13:07:14.708Z","comments":true,"path":"2021/04/20/算法设计实验三/","link":"","permalink":"http://www.misaka-9982.com/2021/04/20/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C%E4%B8%89/","excerpt":"","text":"一、实验目的： 掌握回溯法算法设计思想。 掌握地图填色问题的回溯法解法。 二、内容： 背景知识： 为地图或其他由不同区域组成的图形着色时，相邻国家/地区不能使用相同的颜色。 我们可能还想使用尽可能少的不同颜色进行填涂。一些简单的“地图”（例如棋盘）仅需要两种颜色（黑白），但是大多数复杂的地图需要更多颜色。 每张地图包含四个相互连接的国家时，它们至少需要四种颜色。1852年，植物学专业的学生弗朗西斯·古思里（Francis Guthrie）于1852年首次提出“四色问题”。他观察到四种颜色似乎足以满足他尝试的任何地图填色问题，但他无法找到适用于所有地图的证明。这个问题被称为四色问题。长期以来，数学家无法证明四种颜色就够了，或者无法找到需要四种以上颜色的地图。直到1976年德国数学家沃尔夫冈·哈肯（Wolfgang Haken）（生于1928年）和肯尼斯·阿佩尔（Kenneth Appel，1932年-2013年）使用计算机证明了四色定理，他们将无数种可能的地图缩减为1936种特殊情况，每种情况都由一台计算机进行了总计超过1000个小时的检查。 他们因此工作获得了美国数学学会富尔克森奖。在1990年，哈肯（Haken）成为伊利诺伊大学（University of Illinois）高级研究中心的成员，他现在是该大学的名誉教授。 四色定理是第一个使用计算机证明的著名数学定理，此后变得越来越普遍，争议也越来越小 更快的计算机和更高效的算法意味着今天您可以在几个小时内在笔记本电脑上证明四种颜色定理。 问题描述： 我们可以将地图转换为平面图，每个地区变成一个节点，相邻地区用边连接，我们要为这个图形的顶点着色，并且两个顶点通过边连接时必须具有不同的颜色。附件是给出的地图数据，请针对三个地图数据尝试分别使用5个（le450_5a），15个（le450_15b），25个（le450_25a）颜色为地图着色。 三、实验要求 1、对下面这个小规模数据，利用四色填色测试算法的正确性； 2、对附件中给定的地图数据填涂； 3、随机产生不同规模的图，分析算法效率与图规模的关系（四色）。 四、算法原理描述 1、朴素回溯 1）算法描述:每次对当前需要染色的节点选择一种它可以使用的颜色进行染色，然后进行下一个节点的染色，直到所有节点染完颜色，染色方案的数量就会加一。然后回到上一个节点继续枚举它可以使用的颜色进行染色。直到将所有的染色方案找出为止。 如下图，如果只有四个节点，四种颜色，当左侧的图染完颜色之后就将3号点和4号点的颜色删除，往下枚举3号点可以使用的颜色，接着对该图进行染色，就可以得到右侧另外一种染色方案，这样枚举下去，直到找出所有方案。 2）伪代码描述： 12345678910dfs(t) if t &gt; point_num then ans_num ++ return for i from 1 to color_num if check(t, i) then color[t] = i dfs(t + 1) color[t] = 0 3）算法时间复杂度：设节点数为n， 颜色数为c，每个节点都有c种颜色可以选择，那么解空间就有$cn$ 个节点，而朴素回溯是枚举每一种方案所以时间复杂度为$O(Cn)$ 时间复杂度为指数级，需要采用合适的剪枝策略进行优化 2、剪枝策略 1.优化搜索顺序：在染色的过程中，按照不同的顺序对节点进行染色其对应的搜索树的各个层次，各个分支之间的顺序不是固定的，不同的搜索顺序会产生不同的搜索树形态，它们的规模大小也相差甚远。 如下图中的两棵搜索树，它们的叶子节点对应的是相同解决方案，左图的搜索树一开始就选分支数量较多的节点搜索，有可能直到搜索深度较深的时候才会将不合法的的方案排除，而右图中的搜索树则选择从分支数量较少的节点开始搜索，有可能在搜索深度较浅的时候就就不合法的方案排除。所以在搜索的时候应该尽量选择分支较少的搜索顺序进行搜索（即DH准则）和优先搜索分支较少的节点（即MRV准则） 在刚开始染色的时候选择度数最大的节点对其周围的节点产生的约束条件最强，使得最多的节点减少一种可使用的颜色，使得整棵搜索树的分支较少，所以第一个染色的节点应选择度数最大的节点（即DH准则）。 如下图，如果优先对SA节点染色，那么其他的节点可用的颜色就全部减少一种，其对应搜索树的宽度大大减小。 在搜索过程中，优先选择可填颜色最少的节点（MRV准则），也即优先选择分支最少的节点可以减少搜索次数，尽早排除不合法的方案。 如下图，染色顺序的第三步中未染色的节点分别有1、2、3、3种颜色可以使用，如果选择剩下三种颜色的节点先染色的话，那么对应的就会产生三条分支，而选择剩下一种颜色的节点进行染色的话对应就只产生一条分支，大大减少了搜索次数。 3.可行性剪枝:在染色的过程中，及时对当前的状态进行检查，如果发现当前分支已经完成所有节点的染色，那么就执行回溯。 如下图，如果可以使用的颜色只有四种，左图中间节点的周围节点都已经染上颜色，那么就会发现中间这个节点没有剩余的颜色可填，那么就执行回溯，回到4号节点使用下一种颜色，那么中间节点就有可以使用的颜色，并完成当前整个图的染色。 上述过程只是检查当前节点的染色状态并执行剪枝，而向前探查则在当前节点染色完毕后对其相邻节点进行检查，如果其相邻节点并未染色并且没有剩余颜色可以使用那么当前状态不合法，执行回溯。使用向前探查的方法可以减小搜索过程中搜索不合法分支的深度。 4．排除等效冗余:在搜索过程中，如果我们能够判定从搜索树的当前节点上沿着某几条不同分支到达的子树是等效的，那么只需要对其中的一条分支执行搜索。 对应的，在染色的过程当中，如果当前需要染色的点有 x 种从未被其他点使用过的颜色可以使用，则这 x 种颜色可以视为等价的颜色，直接使用其中一种颜色后，计算其他点的染色方案数，令方案数乘以 x 即可。 例如，对于下面的图，假设有四种颜色可以使用，那么利用排列组合的原理，可以计算出下图有 $4！= 24$ 种染色方案 类似的，对于下图，假设有三种颜色可以使用，那么下图将会有$2！+2！+2！+3！= 12$种染色方案 由于n种颜色对应的全排列有 $n!$ 种，所以该方法可以极大的提高搜索效率。 2）伪代码描述： 1234567891011121314151617dfs(pt, level)` `if(level &gt; point\\_num) return 1` `for(int i = 1; i &lt;= color\\_num; i ++ )` `if 颜色i不应使用 then continue` `color[pt] = i //染色` `对本次染色点的邻点进行操作并寻找下一节点染色` `if 该颜色第一次使用 then` `tmp\\_unuse = unuse` `unuse -- , used[i] ++ ` `ans += dfs(nextpt, level + 1) \\* tmp\\_unuse` `unuse ++ , used[i] -- ` `else if 该颜色不是第一次使用 then` `used[i] ++ ` `ans += dfs(nextpt, level + 1)` `used[i] -- ` `回溯，恢复原有状态` `return ans 五、效率分析 注：下面的列表中Prune代表没有使用等效冗余的剪枝算法，而MathP则代表使用了排除等效冗余的剪枝算法 1.附件数据分析 小规模 五色 十六色 二十五色 方案数量(MathP) 480 3840 2.09E+13 1.55E+25 耗时/ms 0.052352 202 2.721264 2.944414 方案数量(Prune) 480 3840 1.00E+10 1.00E+10 耗时/ms 0.057918 3806 145408 90217 耗时比 1.106319 18.8 53433.99 30640.05 由于$16! = 20922789888000$，$25! = 15511210043330985984000000$ 所以使用排除等效冗余的剪枝算只需要搜索出一组解，即可等效出其颜色数量对应的阶乘组解，因此十六色和二十五色对应的数据集只需要几毫秒的时间就搜索出十几位数大小的染色方案数量。而当解空间较小时，如上表中的小规模数据，排除等效冗余的算法尽管比没有排除的算法快，但优势体现得不明显，图越稠密，颜色数量越多，其优势 2.随机图效率分析 1）点数固定为二十个点，边数由稀疏增加到稠密 点数 边数 颜色数 Prune时间(ms) MathP时间（ms） 时间比值取对数 20 20 4 42482 6496 0.815558938 20 40 4 76 11 0.839420907 20 60 5 120 6 1.301029996 20 80 6 955 10 1.980003372 20 100 7 6769 9 2.876282005 20 120 10 49362 4 4.091332756 20 140 12 88909.66339 4.270977 4.318421733 20 160 13 115045.9889 0.039866 6.460268819 20 180 16 295174.936 0.026392 7.048607175 上表中对应的额染色方案数量列表 点数 边数 Prune MathP 20 20 3501133308 3501133308 20 40 6336288 6336288 20 60 11043720 11043720 20 80 83416320 83416320 20 100 629712720 629712720 20 120 10000000000 2.85626E+11 20 140 9999999996 2.15129E+13 20 160 9999999997 1.09596E+12 20 180 10000000000 4.81224E+14 由上图可以看出，点的数量一定时，图越稠密，使用的测试数据需要使用的颜色数量越多 由图像可得，当图极其稀疏时，随着边数的增加，算法运行的时间会逐步减少，而当图逐渐稠密时，算法运行的时间也逐渐开始变长 (注：边数为20时，使用该算法得到的运行时间为6496ms，与其他边数差值过大，故未在图中画出) 由图像可得，当图越稠密，颜色数量越多，排除等效冗余的算法效率也会相应的提高，算法总体运行时间的趋势是往下降的，中间的运行时间有部分往上升的，这主要取决于点与点之间的约束关系，即图本身的复杂程度 上图为没有使用等效冗余的算法运行时间与使用等效冗余的算法运行时间的比值取对数的图，可以看出比值的对数与边数呈现正相关的关系，120条边之后曾长速度略有下降，主要是因为没有使用等效冗余的算法搜索完100亿组解之后就退出不再进行搜索 2）边数固定为四十五条边，逐渐增加点数 点数 边数 颜色数 Prune时间(ms) MathP时间（ms） 时间比值取对数 10 45 10 79.89145 0.003464 4.36292242 15 45 5 7.442274 0.351904 1.325281452 20 45 5 21022.43152 727.384756 1.460918751 25 45 4 49676.92409 7451.619834 0.823904007 上表中对应的额染色方案数量列表 点数 边数 Prune MathP 10 45 3628800 3628800 15 45 384960 384960 20 45 1378805760 1378805760 25 45 2233151424 2233151424 由上图可得边数固定时，点数越多，即图越稀疏，使用的测试数据需要用到的颜色数量呈现减少的趋势 综合上面三个图像可以得出，无论是排除等效冗余还是不排除，在边数固定的情况下，点数越多，即图越稀疏，需要用到的颜色数量越少，算法运行需要的时间越长，而且排除等效冗余的效率也开始逐渐下降，与不排除等效冗余的运行时间比值呈现下降的趋势。 以上数据分析只能说明使用的测试数据情况如此，不能代表所有的随机图都是这样，要得出所有图自身的边数点数颜色数与算法效率之间的关系还要取决于图本身的复杂程度，即图本身点与点之间的约束关系 六、实验心得 回溯法是将所有的解（问题的解空间）按照一定结构排列，再进行搜索的一种解决问题的方法，其本质就是枚举，时间复杂指数级的，当问题的规模较大时，使用朴素回溯就不太合适了 剪枝算法对于提高回溯搜索的效率具有重要的意义，一个好的剪枝算法可以极大地提高回溯的搜索效率 不同的问题有不同的剪枝策略，需要具体问题具体分析，结合实际做出不同的剪枝策略","categories":[{"name":"算法","slug":"算法","permalink":"http://www.misaka-9982.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.misaka-9982.com/tags/Algorithm/"}]},{"title":"算法设计实验二","slug":"算法设计实验二","date":"2021-04-10T13:56:20.000Z","updated":"2023-02-22T13:07:14.708Z","comments":true,"path":"2021/04/10/算法设计实验二/","link":"","permalink":"http://www.misaka-9982.com/2021/04/10/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C%E4%BA%8C/","excerpt":"","text":"一．实验目的 对于平面上给定的N个点，给出所有点对的最短距离，即，输入是平面上的N个点，输出是N点中具有最短距离的两点。 要求随机生成N个点的平面坐标，应用蛮力法编程计算出所有点对的最短距离。 要求随机生成N个点的平面坐标，应用分治法编程计算出所有点对的最短距离。 分别对N=100,1000,10000,100000，统计算法运行时间，比较理论效率与实测效率的差异，同时对蛮力法和分治法的算法效率进行分析和比较。 如果能将算法执行过程利用图形界面输出，可获加分。 二、算法原理描述 1、蛮力法 1）算法描述：已知集合S中有n个点，一共可以组成$n(n-1)/2$对点对，蛮力法就是对这$n(n-1)/2$对点对逐对进行距离计算，通过循环求得点集中的最近点对： 2）伪代码描述： 1234enumerate(const Point *test, int N) for i from 0 to N - 1 for j from i + 1 to N ans = min(ans, dis(test[i], test[j])) 3）算法时间复杂度：算法一共要执行 $n(n-1)/2$次循环，因此算法复杂度为$O(n^2)$ 2、分治法 1）算法描述：已知集合S中有n个点，分治法的思想就是将S进行拆分，分为两部分求最近点对。每次选择一条垂线L，将S拆分左右两部分为SL和SR，L一般取点集S中所有点的中间点的x坐标来划分，这样可以保证SL和SR中的点数目各为n/2 （否则以其他方式划分S，极端情况下可能会导致SL和SR中点数目一个为1，一个为n-1，不利于算法效率的准确性） 将左右两部分继续分解为更小的两部分，直到不能继续分解为止，用P1,P2来表示这两个部分，此时最终要求的最近距离可能在左边即P1中或者在右边即P2中，还有可能这个点对一个点在左边，一个点在右边 找出这两部分中的最小点对距离：d1和d2，记P1和P2中最小点对距离$d=min(d1，d2)$ 此时，P1中所有点与P2中所有点构成的点对均为最接近点对的候选者。在最坏情况下有$n/2$这样的候选者。 P1中任意一点p,它若与P2中的点q构成最接近点对的候选者，则必有$d(p,q)&lt;d$。满足这个条件的P2中的点一定落在一个$d×2d$的矩形R中 由d的意义可知P2中任何2个S中的点的距离都不小于d，由此可以推出矩形R中最多只有6个S中的点。 将矩形R的长为$2δ$的边3等分，将它的长为$δ$的边2等分，由此导出6个$（d/2）×（2d/3）$的矩形。 若矩形R中有多于6个S中的点，则由抽屉原理易知至少有一个$d×2d$的小矩形中有2个以上S中的点。设u,v是这样2个点，它们位于同一小矩形中，则这个小矩形中两点的最大距离即对角线的长度$sqrt((d/2)^2 + (2d/3)^2) = 5d/6 &lt; d$ $d(u,v)≤5d/6 &lt; d$。这与d的意义相矛盾。由反证法可以得出这个矩形R最多有6个点。 因此，在分治法的合并步骤中，我们最多只需要检查$6×n/2=3n$对候选者，而不是$n /2$个候选者。若将P1和P2中所有S的点按其y坐标排好序，则对P1中所有点p，对排好序的点列作一次扫描，就可以找出所有最接近点对的候选者，对P1中每一点最多只要检查P2中排好序的相继6个点。 由于分治算法的结构和归并排序的结构相类似，所以在合并的过程中采用归并排序的合并操作对候选点的y值进行排序，相当于一边递归一边排序，每次合并的排序开销为$O(n)$，因此算法整体的时间复杂度为$T(n)= 2T(n/2) + O(n)$，$T(n)= O(nlogn)$ 2）伪代码描述： 1234567merge(left, right) dist = INF; if(left == right) return dist; if(left + 1 == right) return 两点距离 mid = (left + right) / 2; dist1 = merge(left, mid), dist2 = merge(mid + 1, right); dist = min(dist1, dist2); 找出距离中点x坐标小于dist的点存入tmp数组 对tmp数组按y值进行归并排序的合并操作 对tmp数组中每个点遍历与它之后的6个点的距离更新最短距离 3）算法时间复杂度： 在分解前按照x值进行排序，时间复杂度为$O(n log n)$，合并阶段的开销时间复杂度为$O(n)$，递推式为 计算得出算法整体的时间复杂度为$O(n log n)$ 三、算法测试结果及效率分析； 1.蛮力法 输入规模 处理时间 理论值 10000 0.57515 0.5751500 20000 2.30136 2.3006000 30000 5.19265 5.1763500 40000 9.21931 9.2024000 50000 14.8461 14.3787500 60000 21.5779 21.5779000 70000 29.0257 29.3699194 80000 38.1453 38.3607111 90000 48.4883 48.5502750 100000 59.7885 59.9386111 先选取输入规模n=10000的实际时间t1作为理论时间的基准。 当n=20000时，$t2=t1*(2/1)2$、 当n=30000时，$t3=t1*(3/1)2$， 以此类推做出表格数值，得出的理论值曲线基本与实际值曲线基本贴合。 2.分治法 100规模 输入规模 处理时间 理论值 100 7.06E-06 7.06E-06 200 1.77E-05 1.62E-05 300 2.68E-05 2.62E-05 400 3.57E-05 3.67E-05 500 4.65E-05 4.76E-05 1000规模 输入规模 处理时间 理论值 1000 7.40E-05 7.40E-05 2000 0.00017 0.000163 3000 0.000267 0.000257 4000 0.000346 0.000355 5000 0.000436 0.000456 1w输入规模 输入规模 处理时间 理论值 10000 0.00089 8.90E-04 20000 0.001855 0.001913958 30000 0.002935 0.002988478 40000 0.003985 0.004095833 50000 0.0051 0.005227604 10w规模 输入规模 处理时间 理论值 100000 0.011 0.011 200000 0.0232 0.023324532 300000 0.0351 0.036149 400000 0.0494 0.049298128 500000 0.0615 0.06268867 600000 0.0753 0.076271597 700000 0.0887 0.09001451 800000 0.1012 0.103894384 900000 0.1154 0.117894002 1000000 0.1306 0.132 注：在代码实现的过程中采用了$O_3$优化，故算法运行时间稍快 O（nlog（n））复杂度时间推导 $tl=n1*log（2，n1）*t$， t1表示规模为n1的数据用时 $t2=n2*log（2，n2）*t$，t2表示规模为n2的数据用时 $t2=n2/n1*（log（2，n2）/1og（2，n1））*t1$ 实际运行时间基本符合上述推导，每次合并的点都限制在$d*2d$的矩形之中，合并的开销稳定在$O(n)$，时间曲线较为稳定 误差分析：规模较小时，分治算法运行速度较快，而实现算法的代码采用的是time.h头文件的clock（）函数进行时间测量，会导致精度的丢失，所以在较小规模的测试中误差体现比较明显，只能将测试次数提高以降低误差，测试规模增大，算法运行时间明显趋于稳定 四．对求解这个问题的经验总结 在设计分治算法的过程中要尽可能地降低合并过程的开销，如果在以上设计的分治算法中对y值的排序直接采用快速排序进行排序的话，那么实际的合并代价为$O(n log n)$，而算法整体的时间复杂度则会退化成为$O（n log_2 n）$，并不是真正意义上的$O(n log n)$ 在设计算法的过程中，可以利用蛮力求解的方式在小规模的数据验证算法的正确性 利用计算机的时钟作为种子产生的随机数来生成点的坐标会产生大量的重复，可以利用STL库中的set容器自己设置去重的规则进行去重，还可以获取cpu运行周期作为随机数产生的种子使得生成的随机数较为随机 灵活应用数学定理以辅助设计算法可以使得算法的时间复杂度获得极大的提升，如上面合并过程只需枚举6个点的证明过程，就使合并代价大大降低，数学工具是设计算法的利器","categories":[{"name":"算法","slug":"算法","permalink":"http://www.misaka-9982.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.misaka-9982.com/tags/Algorithm/"}]},{"title":"DS-OJ","slug":"DS-OJ","date":"2021-02-12T05:25:38.000Z","updated":"2023-01-24T03:15:40.575Z","comments":true,"path":"2021/02/12/DS-OJ/","link":"","permalink":"http://www.misaka-9982.com/2021/02/12/DS-OJ/","excerpt":"","text":"题目源自某高校数据结构的OJ 郑重声明 代码仅供参考，请勿直接抄袭，~(嗯，我自己学的时候也抄了好多)~本文字数过多，请善用Ctrl + F进行检索 DS–图非0面积: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;#define x first#define y secondtypedef pair&lt;int, int&gt; PII;const int N = 1010;bool g[N][N], st[N][N];int n, m, t;int cnt;int dx[4] = &#123;0, -1, 0, 1&#125;;int dy[4] = &#123;1, 0, -1, 0&#125;;void bfs()&#123; memset(st, false, sizeof st); queue&lt;PII&gt; q; for(int i = 0; i &lt; n; i ++ ) &#123; if(!g[i][0]) &#123; q.push(&#123;i, 0&#125;); st[i][0] = true; &#125; if(!g[i][m - 1]) &#123; q.push(&#123;i, m - 1&#125;); st[i][0] = true; &#125; &#125; for(int i = 0; i &lt; m; i ++ ) &#123; if(!g[0][i]) &#123; q.push(&#123;0, i&#125;); st[0][i] = true; &#125; if(!g[n - 1][i]) &#123; q.push(&#123;n - 1, i&#125;); st[n - 1][i] = true; &#125; &#125; while(!q.empty()) &#123; auto t = q.front(); q.pop(); g[t.x][t.y] = 1; for(int i = 0; i &lt; 4; i ++ ) &#123; int a = t.x + dx[i], b = t.y + dy[i]; if(a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= m) continue; if(!st[a][b] &amp;&amp; !g[a][b]) q.push(&#123;a, b&#125;); &#125; &#125;&#125;void count()&#123; cnt = 0; for(int i = 0; i &lt; n; i ++ ) for(int j = 0; j &lt; m; j ++ ) if(!g[i][j]) cnt ++ ;&#125;int main()&#123; cin &gt;&gt; t; while(t -- ) &#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i ++ ) for(int j = 0; j &lt; m; j ++ ) cin &gt;&gt; g[i][j]; bfs(); count(); cout &lt;&lt; cnt &lt;&lt; endl; &#125; return 0;&#125; DS栈–Web导航: 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;int main()&#123; stack&lt;string&gt; back; stack&lt;string&gt; forward; string ope; string temp = &quot;http://www.acm.org/&quot;; while( cin &gt;&gt; ope )&#123; if( ope==&quot;QUIT&quot; )&#123; break; &#125;else if( ope==&quot;VISIT&quot; )&#123; back.push(temp); cin &gt;&gt; temp; cout &lt;&lt; temp &lt;&lt; endl; while( !forward.empty() )&#123; forward.pop(); &#125; &#125;else if( ope==&quot;BACK&quot; )&#123; if(back.empty())&#123; cout &lt;&lt; &quot;Ignored&quot; &lt;&lt; endl; continue; &#125; forward.push(temp); temp = back.top(); back.pop(); cout &lt;&lt; temp &lt;&lt; endl; &#125;else if( ope==&quot;FORWARD&quot;)&#123; if(forward.empty())&#123; cout &lt;&lt; &quot;Ignored&quot; &lt;&lt; endl; continue; &#125; back.push(temp); temp = forward.top(); forward.pop(); cout &lt;&lt; temp &lt;&lt; endl; &#125; &#125; return 0;&#125; DS树–二叉树高度: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;iostream&gt;using namespace std;class BiNode&#123; char data; BiNode *lChild; BiNode *rChild;public: BiNode():lChild(NULL),rChild(NULL)&#123;&#125; BiNode(char e):data(e),lChild(NULL),rChild(NULL)&#123;&#125; ~BiNode()&#123; delete lChild; delete rChild; &#125; friend class BiTree;&#125;;class BiTree&#123; BiNode *root; void CreateTree(BiNode *&amp;t); void LeafNum(BiNode *t, int deep);public: int maxx; BiTree():root(NULL)&#123; maxx = 0; &#125; ~BiTree()&#123; delete root; &#125; void CreateTree(); void LeafNum();&#125;;void BiTree::CreateTree(BiNode *&amp;t)&#123; char c; cin &gt;&gt; c; if( c!=&#x27;0&#x27; ) &#123; t = new BiNode(c); CreateTree(t-&gt;lChild); CreateTree(t-&gt;rChild); &#125;else&#123; t=NULL; &#125;&#125;void BiTree::CreateTree()&#123; CreateTree(root);&#125;void BiTree::LeafNum(BiNode *t, int deep)&#123; if(t)&#123; deep++; if( !t-&gt;rChild &amp;&amp; !t-&gt;lChild)&#123; if(maxx &lt; deep)&#123; maxx = deep; &#125; &#125; LeafNum(t-&gt;lChild, deep); LeafNum(t-&gt;rChild, deep); &#125;&#125;void BiTree::LeafNum()&#123; LeafNum(root, 0); cout &lt;&lt; maxx &lt;&lt; endl;&#125;int main()&#123; int t; cin &gt;&gt; t; while( t-- )&#123; string str; BiTree tree; tree.CreateTree(); tree.LeafNum(); &#125; return 0;&#125; DS树–带权路径和: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;class BiNode&#123; char data; BiNode *lChild; BiNode *rChild; int road;public: BiNode():lChild(NULL),rChild(NULL)&#123;&#125; BiNode(char e):data(e),lChild(NULL),rChild(NULL)&#123;&#125; ~BiNode()&#123;delete lChild; delete rChild;&#125; friend class BiTree;&#125;;class BiTree&#123; BiNode *root; int count; queue&lt;int&gt; weight; void CreateTree(BiNode *&amp;t, int layer); void preOrder(BiNode *t);public: BiTree():root(NULL),count(0)&#123;&#125; void CreateTree(); void preOrder(); void getWeight();&#125;;void BiTree::CreateTree(BiNode *&amp;t,int layer) &#123; char c; cin&gt;&gt;c; if(c!=&#x27;0&#x27;) &#123; t = new BiNode(c); t-&gt;road = layer; CreateTree(t-&gt;lChild,layer+1); CreateTree(t-&gt;rChild,layer+1); &#125;&#125;void BiTree::CreateTree() &#123; CreateTree(root,0);&#125;void BiTree::preOrder(BiNode *t) &#123; if(t) &#123; if(!t-&gt;lChild &amp;&amp; !t-&gt;rChild) &#123; count += weight.front() * t-&gt;road; weight.pop(); &#125; preOrder(t-&gt;lChild); preOrder(t-&gt;rChild); &#125;&#125;void BiTree::preOrder() &#123; preOrder(root); cout&lt;&lt;count&lt;&lt;endl;&#125;void BiTree::getWeight() &#123; int n; cin&gt;&gt;n; while (n--) &#123; int w; cin&gt;&gt;w; weight.push(w); &#125;&#125;int main()&#123; int t; cin&gt;&gt;t; while (t--) &#123; BiTree myTree; myTree.CreateTree(); myTree.getWeight(); myTree.preOrder(); &#125; return 0;&#125; DS树–二叉树之最大路径: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;class BiNode&#123; char data; BiNode *lChild; BiNode *rChild; int weight;public: BiNode():lChild(NULL),rChild(NULL)&#123;&#125; BiNode(char e):data(e),lChild(NULL),rChild(NULL)&#123;&#125; ~BiNode()&#123;delete lChild;delete rChild;&#125; friend class BiTree;&#125;;class BiTree&#123; BiNode *root; queue&lt;int&gt; weights; int maxRoad; void CreateTree(BiNode *&amp;t); void getRoad(BiNode *t,int road);public: BiTree():root(NULL),maxRoad(0)&#123;&#125;; ~BiTree()&#123;&#125;; void CreateTree(); void getRoad();&#125;;void BiTree::CreateTree(BiNode *&amp;t) &#123; char c; cin&gt;&gt;c; if(c!=&#x27;0&#x27;) &#123; t = new BiNode(c); CreateTree(t-&gt;lChild); CreateTree(t-&gt;rChild); &#125; else t = NULL;&#125;void BiTree::CreateTree() &#123; CreateTree(root);&#125;void BiTree::getRoad(BiNode *t, int road) &#123; if(t) &#123; t-&gt;weight = weights.front()+road; weights.pop(); getRoad(t-&gt;lChild,t-&gt;weight); getRoad(t-&gt;rChild,t-&gt;weight); if(!t-&gt;lChild &amp;&amp; !t-&gt;rChild) if(t-&gt;weight&gt;maxRoad) maxRoad = t-&gt;weight; &#125;&#125;void BiTree::getRoad() &#123; int n; cin&gt;&gt;n; while (n--) &#123; int e; cin&gt;&gt;e; weights.push(e); &#125; getRoad(root,0); cout&lt;&lt;maxRoad&lt;&lt;endl;&#125;int main()&#123; int t; cin&gt;&gt;t; while (t--) &#123; BiTree myTree; myTree.CreateTree(); myTree.getRoad(); &#125; return 0;&#125; DS队列+堆栈–数制转换: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;int main()&#123; int t; cin &gt;&gt; t; while( t-- ) &#123; double n; int k, nint; cin &gt;&gt; n &gt;&gt; k; nint = int(n); double ndouble = n-nint; stack&lt;int&gt; numint; queue&lt;int&gt; numdouble; while(nint/k!=0) &#123; numint.push(nint%k); nint/=k; &#125; numint.push(nint%k); int i=0; while( i&lt;3 ) &#123; ndouble*=k; numdouble.push(int(ndouble)); ndouble=ndouble-int(ndouble); i++; &#125; char output[6]=&#123;&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;&#125;; while( !numint.empty())&#123; if(numint.top()&lt;10) cout &lt;&lt; numint.top(); else cout &lt;&lt; output[numint.top()-10]; numint.pop(); &#125; cout &lt;&lt; &quot;.&quot;; while(!numdouble.empty()) &#123; if(numdouble.front()&lt;10) cout &lt;&lt; numdouble.front(); else cout &lt;&lt; output[numdouble.front()-10]; numdouble.pop(); &#125; cout &lt;&lt; endl; &#125; system(&quot;pause&quot;); return 0;&#125; DS堆栈–行编辑: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;int main()&#123; int t; cin &gt;&gt; t; while( t-- ) &#123; stack&lt;char&gt; s; string str; cin &gt;&gt; str; int len = str.length(); for( int i=0; i&lt;len; i++) &#123; if( str[i]==&#x27;#&#x27; &amp;&amp; !s.empty()) &#123; s.pop(); &#125;else if( str[i]!=&#x27;#&#x27;) &#123; s.push(str[i]); &#125; &#125; if(s.empty()) &#123; cout &lt;&lt; &quot;NULL&quot; &lt;&lt; endl; &#125;else&#123; stack&lt;char&gt; s1; while( !s.empty()) &#123; s1.push(s.top()); s.pop(); &#125; while( !s1.empty()) &#123; cout &lt;&lt; s1.top(); s1.pop(); &#125; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; DS队列–组队列: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;string&gt;#include&lt;queue&gt;using namespace std;int main()&#123; int t, j; int value; map&lt;int, int&gt; mem; cin &gt;&gt; t; queue&lt;int&gt; que[10]; for( int i=0; i&lt;t; i++) &#123; cin &gt;&gt; j; while( j-- ) &#123; cin &gt;&gt; value; mem[value] = i; &#125; &#125; string tag; int flag = 1; while(1) &#123; cin &gt;&gt; tag; if(tag==&quot;ENQUEUE&quot;)&#123; cin &gt;&gt; value; for( int i=0; i&lt;10; i++) &#123; if(que[i].empty() || mem[que[i].front()] == mem[value]) &#123; que[i].push(value); break; &#125; &#125; &#125;else if(tag==&quot;DEQUEUE&quot;)&#123; for( int i=0; i&lt;10; i++)&#123; if(!que[i].empty())&#123; cout &lt;&lt; que[i].front() &lt;&lt; endl; que[i].pop(); break; &#125; &#125; &#125;else&#123; break; &#125; &#125; return 0;&#125; DS堆栈–括号匹配: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;string&gt;using namespace std;int main()&#123; int t; cin &gt;&gt; t; while( t-- ) &#123; stack&lt;char&gt; s; string str; cin &gt;&gt; str; int len = str.length(); int flag=1; for( int i=0; i&lt;len; i++) &#123; if( str[i]==&#x27;(&#x27; || str[i]==&#x27;[&#x27; || str[i]==&#x27;&#123;&#x27;) s.push(str[i]); if( str[i]==&#x27;)&#x27;) &#123; if( s.top()==&#x27;(&#x27;) &#123; s.pop(); &#125; else &#123; flag=0; &#125; &#125; if( str[i]==&#x27;]&#x27;) &#123; if( s.top()==&#x27;[&#x27;) &#123; s.pop(); &#125; else &#123; flag=0; &#125; &#125; if( str[i]==&#x27;&#125;&#x27;) &#123; if( s.top()==&#x27;&#123;&#x27;) &#123; s.pop(); &#125; else &#123; flag=0; &#125; &#125; &#125; if( flag==1 &amp;&amp; s.empty()) &#123; cout &lt;&lt; &quot;ok&quot; &lt;&lt; endl; &#125;else&#123; cout &lt;&lt; &quot;error&quot; &lt;&lt; endl; &#125; &#125; return 0;&#125; DS堆栈–迷宫求解: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;struct position &#123; int x; int y;&#125;;class Maze &#123; int **maze; int size; stack&lt;position&gt; path;public: Maze(int n); ~Maze(); void Go();&#125;;Maze::Maze(int n) &#123; size = n; maze = new int *[n]; for (int i = 0; i &lt; n; i++) maze[i] = new int[n]; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) cin &gt;&gt; maze[i][j];&#125;Maze::~Maze() &#123; for (int i = 0; i &lt; size; i++) delete[]maze[i]; delete[]maze;&#125;void Maze::Go() &#123; // 进入迷宫 path.push(&#123;0, 0&#125;); maze[0][0] = 1; int i = 0, j = 0; // 迷宫按照右下左上走 while (true) &#123; if (j + 1 &lt; size &amp;&amp; maze[i][j + 1] == 0) //向右 &#123; maze[i][j + 1] = 1; //代表走过 path.push(&#123;i, ++j&#125;); //走到 i,j+1位置，入栈 &#125; else if (i + 1 &lt; size &amp;&amp; maze[i + 1][j] == 0) //向下 &#123; maze[i + 1][j] = 1; path.push(&#123;++i, j&#125;); &#125; else if (j - 1 &gt;= 0 &amp;&amp; maze[i][j - 1] == 0) //向左 &#123; maze[i][j - 1] = 1; path.push(&#123;i, --j&#125;); &#125; else if (i - 1 &gt;= 0 &amp;&amp; maze[i - 1][j] == 0) //向上 &#123; maze[i - 1][j] = 1; path.push(&#123;--i, j&#125;); &#125; else //无路可走 &#123; //回退 i = path.top().x; j = path.top().y; //判断回退之后是否还有可以走的路 if(!((j + 1 &lt; size &amp;&amp; maze[i][j + 1] == 0) || (i + 1 &lt; size &amp;&amp; maze[i + 1][j] == 0) || (j - 1 &gt;= 0 &amp;&amp; maze[i][j - 1] == 0) || (i - 1 &gt;= 0 &amp;&amp; maze[i - 1][j] == 0))) path.pop(); //出栈 &#125; if (path.empty() || (i == size - 1 &amp;&amp; j == size - 1)) //如果回退到起点或者到达终点就结束循环 break; &#125; //输出路径 if (path.empty()) cout &lt;&lt; &quot;no path&quot; &lt;&lt; endl; else &#123; stack&lt;position&gt; path1; while (!path.empty()) //将path倒序 &#123; path1.push(path.top()); path.pop(); &#125; i = 0; while (!path1.empty()) &#123; if ((++i) % 4 == 0) cout &lt;&lt; &#x27;[&#x27; &lt;&lt; path1.top().x &lt;&lt; &#x27;,&#x27; &lt;&lt; path1.top().y &lt;&lt; &#x27;]&#x27; &lt;&lt; &quot;--&quot; &lt;&lt; endl; else cout &lt;&lt; &#x27;[&#x27; &lt;&lt; path1.top().x &lt;&lt; &#x27;,&#x27; &lt;&lt; path1.top().y &lt;&lt; &#x27;]&#x27; &lt;&lt; &quot;--&quot;; path1.pop(); &#125; cout &lt;&lt; &quot;END&quot; &lt;&lt; endl; &#125;&#125;int main() &#123; int t; cin &gt;&gt; t; while (t--) &#123; int n; cin &gt;&gt; n; Maze myMaze(n); myMaze.Go(); &#125; return 0;&#125; DS排序–希尔排序: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;using namespace std;class Array&#123; int *array; int len;public: Array(int n); ~Array(); void outPut(); void ShellInsert(int gap); void ShellSort();&#125;;Array::Array(int n) &#123; len = n; array = new int[n]; for(int i=0;i&lt;n;i++) cin&gt;&gt;array[i];&#125;Array::~Array() &#123; delete []array;&#125;void Array::outPut() &#123; for(int i=0;i&lt;len;i++) &#123; cout &lt;&lt; array[i]; if(i!=len-1) cout&lt;&lt;&#x27; &#x27;; &#125; cout&lt;&lt;endl;&#125;void Array::ShellInsert(int gap) &#123; int k,i,j,temp; for(k=0;k&lt;gap;k++) &#123; for (i = k; i &lt; len; i+=gap )&#123; temp = array[i]; for (j = i; j &gt; k; j-=gap) &#123; if (temp &gt; array[j - gap]) array[j] = array[j - gap]; else break; &#125; array[j] = temp; &#125; &#125;&#125;void Array::ShellSort() &#123; int gap=len/2; while (true) &#123; ShellInsert(gap); outPut(); if(gap==1) break; gap/=2; &#125;&#125;int main() &#123; int t; cin&gt;&gt;t; while (t--) &#123; int n; cin &gt;&gt; n; Array myArray(n); myArray.ShellSort(); cout&lt;&lt;endl; &#125; return 0;&#125; DS排序–快速排序: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;iostream&gt;using namespace std;class Array&#123; int len; int *array;public: Array(int n); ~Array(); void Display(); int Partition(int low, int high); void QuickSort(int low, int high); void QuickSort(); void swap(int a, int b);&#125;;void Array::swap(int a, int b) &#123; int temp = array[a]; array[a] = array[b]; array[b] = temp;&#125;int Array::Partition(int low, int high) &#123; int PivotKey = array[low]; while( low &lt; high )&#123; while( low&lt;high &amp;&amp; array[high] &gt;= PivotKey )&#123; high--; &#125; swap(low, high); while( low &lt; high &amp;&amp; array[low] &lt;= PivotKey)&#123; low++; &#125; swap(low, high); &#125; Display(); return low;&#125;void Array::QuickSort(int low, int high) &#123; int pivot; if(low &lt; high)&#123; pivot = Partition(low, high); QuickSort(low, pivot-1); QuickSort(pivot+1, high); &#125;&#125;void Array::QuickSort() &#123; QuickSort(0, len-1); cout &lt;&lt; endl;&#125;void Array::Display() &#123; for( int i=0; i&lt;len; i++)&#123; cout &lt;&lt; array[i]; if( i==len-1 )&#123; cout &lt;&lt; endl; &#125;else&#123; cout &lt;&lt; &quot; &quot;; &#125; &#125;&#125;Array::~Array() &#123; delete[] array; len = 0;&#125;Array::Array(int n) &#123; len = n; array = new int[len]; for(int i=0; i&lt;len; i++)&#123; cin &gt;&gt; array[i]; &#125;&#125;int main()&#123; int t; cin &gt;&gt; t; while( t-- )&#123; int n; cin &gt;&gt; n; Array myArray(n); myArray.QuickSort(); &#125;&#125; DS堆栈–逆序输出（STL栈使用）: 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stack&gt;using namespace std;int main()&#123; int t; cin &gt;&gt; t; while( t-- ) &#123; string str; cin &gt;&gt; str; stack&lt;char&gt; s; int len = str.length(); for( int i=0; i&lt;len; i++) &#123; s.push(str[i]); &#125; while( !s.empty()) &#123; cout &lt;&lt; s.top(); s.pop(); &#125; cout &lt;&lt; endl; &#125; return 0;&#125; DS串应用- 计算一个串的最长的真前后缀: 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int *getNext(string str)&#123; int j, k; int len = (int)str.size(); int *next = new int[len + 1]; j = 0, k = -1; next[j] = k; while(j &lt; len) &#123; if(k == -1 || str[k] == str[j]) next[ ++ j] = ++ k; else k = next[k]; &#125; return next;&#125;string match(string str)&#123; int *next = getNext(str); int ans = next[(int)str.size()]; delete[] next; if(ans &lt;= 0) return &quot;empty&quot;; else return str.substr(0, ans);&#125;int main()&#123; int t; string s; cin &gt;&gt; t; while(t -- ) &#123; cin &gt;&gt; s; cout &lt;&lt; match(s) &lt;&lt; endl; &#125; return 0;&#125; DS串应用–KMP算法: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class String&#123; string S; string T; string C; int *next; void getNext(); int KMP();public: void Init(string a, string b, string c); ~String(); void Display();&#125;;void String::getNext()&#123; int i = 0, j = -1; next[i] = j; while(i &lt; (int)T.size()) &#123; if(j == -1 || T[i] == T[j]) next[ ++ i] = ++ j; else j = next[j]; &#125;&#125;int String::KMP()&#123; int i, j; for(i = 0, j = 0; i &lt; (int)S.size() &amp;&amp; j &lt; (int)T.size();) &#123; if(j == -1 || S[i] == T[j]) i ++ , j ++ ; else j = next[j]; &#125; if(j == (int)T.size()) return i - j + 1; return 0;&#125;void String::Init(string a, string b, string c)&#123; S = a, T = b, C = c; next = new int[(int)T.size()];&#125;String::~String()&#123; delete[] next;&#125;void String::Display()&#123; getNext(); for(int i = 0; i &lt; (int)T.size(); i ++ ) cout &lt;&lt; next[i] &lt;&lt; &#x27; &#x27;; cout &lt;&lt; endl; cout &lt;&lt; KMP() &lt;&lt; endl;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; String str; string a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; str.Init(a, b, c); str.Display(); &#125; return 0;&#125; DS单链表–合并: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;iostream&gt;using namespace std;class ListNode&#123; int data; ListNode *next; ListNode()&#123; next = NULL; &#125; friend class LinkList;&#125;;class LinkList&#123; ListNode *head; int len;public: LinkList(); ~LinkList(); void CreateInTail(int n); void OutPut(); LinkList merge(LinkList &amp;li);&#125;;LinkList::LinkList()&#123; head = new ListNode;&#125;LinkList::~LinkList()&#123; ListNode *p = head; ListNode *q; while(p)&#123; q=p; p=p-&gt;next; delete q; &#125; len = 0; head = NULL;&#125;void LinkList::CreateInTail(int n)&#123; len = n; ListNode *tail = head; while( n-- ) &#123; int item; cin &gt;&gt; item; ListNode *s = new ListNode; s-&gt;data = item; tail-&gt;next = s; tail = s; &#125;&#125;void LinkList::OutPut()&#123; ListNode *p=head-&gt;next; while(p)&#123; cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;; p=p-&gt;next; &#125; cout &lt;&lt; endl;&#125;LinkList LinkList::merge(LinkList &amp;li)&#123; LinkList temp; temp.len = len +li.len; ListNode *p = head-&gt;next; ListNode *q = li.head-&gt;next; ListNode *r = temp.head; while( p &amp;&amp; q) &#123; ListNode *s = new ListNode; if( p-&gt;data &lt; q-&gt;data ) &#123; s-&gt;data = p-&gt;data; p=p-&gt;next; &#125;else&#123; s-&gt;data = q-&gt;data; q=q-&gt;next; &#125; r-&gt;next = s; r=r-&gt;next; &#125; while(p) &#123; ListNode *s = new ListNode; s-&gt;data = p-&gt;data; r-&gt;next = s; r=r-&gt;next; p=p-&gt;next; &#125; while(q) &#123; ListNode *s = new ListNode; s-&gt;data = q-&gt;data; r-&gt;next = s; r=r-&gt;next; q=q-&gt;next; &#125; return temp;&#125;int main()&#123; int n, m; cin &gt;&gt; n; LinkList list1; list1.CreateInTail(n); list1.OutPut(); cin &gt;&gt; m; LinkList list2; list2.CreateInTail(m); list2.OutPut(); LinkList list3= list1.merge(list2); list3.OutPut(); return 0;&#125; DS串应用–串替换: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class String&#123; string S; string T; string C; int *next; void getNext(); int KMP();public: void Init(string a, string b, string c); ~String(); void Display();&#125;;void String::getNext()&#123; int i = 0, j = -1; next[i] = j; while(i &lt; (int)T.size()) &#123; if(j == -1 || T[i] == T[j]) next[ ++ i] = ++ j; else j = next[j]; &#125;&#125;int String::KMP()&#123; int i, j; for(i = 0, j = 0; i &lt; (int)S.size() &amp;&amp; j &lt; (int)T.size();) &#123; if(j == -1 || S[i] == T[j]) i ++ , j ++ ; else j = next[j]; &#125; if(j == (int)T.size()) return i - j; return -1;&#125;void String::Init(string a, string b, string c)&#123; S = a, T = b, C = c; next = new int[(int)T.size()];&#125;String::~String()&#123; delete[] next;&#125;void String::Display()&#123; getNext(); int pos = KMP(); cout &lt;&lt; S &lt;&lt; endl; if(pos == -1) cout &lt;&lt; S &lt;&lt; endl; else cout &lt;&lt; S.replace(pos, (int)T.size(), C) &lt;&lt; endl;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; String str; string a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; str.Init(a, b, c); str.Display(); &#125; return 0;&#125; DS单链表–类实现: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include&lt;iostream&gt;using namespace std;#define ok 0#define error -1class ListNode&#123;public: int data; ListNode *next; ListNode()&#123; next = NULL; &#125;&#125;;class LinkList&#123;public: ListNode *head; int len; LinkList(); ~LinkList(); ListNode *LL_index(int i); int LL_get(int i); int LL_insert(int i, int item); int LL_del(int i); void LL_display();&#125;;LinkList::LinkList()&#123; head = new ListNode(); len = 0;&#125;LinkList::~LinkList()&#123; ListNode *p, *q; p = head; while(p!=NULL)&#123; q=p; p=p-&gt;next; delete q; &#125; len = 0; head = NULL;&#125;void LinkList::LL_display()&#123; ListNode *p; p=head-&gt;next; while(p)&#123; cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;; p=p-&gt;next; &#125; cout &lt;&lt; endl;&#125;ListNode *LinkList::LL_index( int i)&#123; int j=0; ListNode *p = head; while( p &amp;&amp; j&lt;i ) &#123; p=p-&gt;next; j++; &#125; if( !p ) &#123; return NULL; &#125;else&#123; return p; &#125;&#125;int LinkList::LL_get(int i)&#123; if( i&lt;=0 || i&gt;len ) &#123; return error; &#125; int j=0; ListNode *p = head; while( p &amp;&amp; j&lt;i ) &#123; p = p-&gt;next; j++; &#125; if( !p ) &#123; return error; &#125;else&#123; return p-&gt;data; &#125;&#125;int LinkList::LL_insert( int i, int item)&#123; if( i&lt;=0 || i&gt;len+1 ) &#123; return error; &#125; ListNode *p, *s; p = LL_index(i-1); s=new ListNode(); s-&gt;data = item; s-&gt;next = p-&gt;next; p-&gt;next = s; len++; return ok;&#125;int LinkList::LL_del( int i)&#123; if( i&lt;0 || i&gt;len ) &#123; return error; &#125; ListNode *p, *s; p=LL_index(i-1); s=p-&gt;next; p-&gt;next=s-&gt;next; delete s; len--; return ok;&#125;int main()&#123; int n, i, m; LinkList list; cin &gt;&gt; n; for( i=1; i&lt;=n; i++) &#123; cin &gt;&gt; m; list.LL_insert(i, m); &#125; list.LL_display(); for( int j=0; j&lt;2; j++) &#123; cin &gt;&gt; i &gt;&gt; m; if( list.LL_insert(i, m)!=-1) &#123; list.LL_display(); &#125;else&#123; cout &lt;&lt; &quot;error&quot; &lt;&lt; endl; &#125; &#125; for( int j=0; j&lt;2; j++) &#123; cin &gt;&gt; n; if( list.LL_del(n)!=-1) &#123; list.LL_display(); &#125;else&#123; cout &lt;&lt; &quot;error&quot; &lt;&lt; endl; &#125; &#125; for( int j=0; j&lt;2; j++) &#123; cin &gt;&gt; i; if( list.LL_get(i)!=-1 ) &#123; cout &lt;&lt; list.LL_get(i) &lt;&lt; endl; &#125;else&#123; cout &lt;&lt; &quot;error&quot; &lt;&lt; endl; &#125; &#125; return 0;&#125; DS顺序表–类实现: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;iostream&gt;using namespace std;#define ok 0#define error -1class SeqList&#123; int *list; int maxsize; int size;public: SeqList(int n); ~SeqList(); int list_size(); int list_insert(int i, int item); int list_del(int i); int list_get(int i); void list_display();&#125;;SeqList::SeqList(int n) &#123; maxsize = 1000; size = n; list = new int[maxsize]; for( int i=0; i&lt;size; i++)&#123; cin &gt;&gt; list[i]; &#125;&#125;SeqList::~SeqList() &#123; delete[] list;&#125;int SeqList::list_size()&#123; return size;&#125;int SeqList::list_insert(int i, int item)&#123; if( i&lt;1 || i&gt;size+1)&#123; return error; &#125; int j; for( j=size-1; j&gt;=i-1; j--)&#123; list[j+1] = list[j]; &#125; list[i-1] = item; size++; return ok;&#125;int SeqList::list_del(int i)&#123; if( i&lt;1 || i&gt;size )&#123; return error; &#125; for( int j=i-1; j&lt;size-1; j++)&#123; list[j] = list[j+1]; &#125; size--; return ok;&#125;int SeqList::list_get(int i)&#123; if( i&lt;1 || i&gt;size )&#123; return error; &#125; return list[i-1];&#125;void SeqList::list_display() &#123; cout &lt;&lt; size &lt;&lt; &quot; &quot;; for( int i=0; i&lt;size; i++)&#123; cout &lt;&lt; list[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;int main()&#123; int n, k, flag; cin &gt;&gt; n; SeqList myList(n); myList.list_display(); cin &gt;&gt; n &gt;&gt; k; flag = myList.list_insert(n, k); if( flag==0 )&#123; myList.list_display(); &#125;else&#123; cout &lt;&lt; &quot;error&quot; &lt;&lt; endl; &#125; cin &gt;&gt; n &gt;&gt; k; flag = myList.list_insert(n, k); if( flag==0 )&#123; myList.list_display(); &#125;else&#123; cout &lt;&lt; &quot;error&quot; &lt;&lt; endl; &#125; cin &gt;&gt; n; flag = myList.list_del(n); if( flag==0 )&#123; myList.list_display(); &#125;else&#123; cout &lt;&lt; &quot;error&quot; &lt;&lt; endl; &#125; cin &gt;&gt; n; flag = myList.list_del(n); if( flag==0 )&#123; myList.list_display(); &#125;else&#123; cout &lt;&lt; &quot;error&quot; &lt;&lt; endl; &#125; cin &gt;&gt; n; flag = myList.list_get(n); if( flag!=-1 )&#123; cout &lt;&lt; flag &lt;&lt; endl; &#125;else&#123; cout &lt;&lt; &quot;error&quot; &lt;&lt; endl; &#125; cin &gt;&gt; n; flag = myList.list_get(n); if( flag!=-1 )&#123; cout &lt;&lt; flag &lt;&lt; endl; &#125;else&#123; cout &lt;&lt; &quot;error&quot; &lt;&lt; endl; &#125; return 0;&#125; DS二叉树–叶子数量: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;using namespace std;class BiNode&#123; char data; BiNode *lchild; BiNode *rchild;public: BiNode():lchild(NULL),rchild(NULL)&#123;&#125; BiNode(char e):data(e), lchild(NULL), rchild(NULL)&#123;&#125; ~BiNode()&#123;delete lchild; delete rchild;&#125; friend class BiTree;&#125;;class BiTree&#123; BiNode *root; int leafNum; void CreateTree(BiNode *&amp;t); void PreOrder(BiNode *t);public: BiTree():root(NULL), leafNum(0)&#123;&#125;; void CreateTree(); void PreOrder();&#125;;void BiTree::CreateTree(BiNode *&amp;t)&#123; char c; cin &gt;&gt; c; if( c!=&#x27;0&#x27; ) &#123; t = new BiNode(c); CreateTree(t-&gt;lchild); CreateTree(t-&gt;rchild); &#125;else&#123; t = NULL; &#125;&#125;void BiTree::CreateTree()&#123; CreateTree(root);&#125;void BiTree::PreOrder(BiNode *t)&#123; if(t)&#123; if(!t-&gt;lchild &amp;&amp; !t-&gt;rchild) leafNum++; PreOrder(t-&gt;lchild); PreOrder(t-&gt;rchild); &#125;&#125;void BiTree::PreOrder()&#123; PreOrder(root); cout &lt;&lt; leafNum &lt;&lt; endl;&#125;int main()&#123; int t; cin &gt;&gt; t; while( t-- ) &#123; BiTree tree; tree.CreateTree(); tree.PreOrder(); &#125; return 0;&#125; DS二叉树–层次遍历: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;class BiNode&#123; char data; BiNode *lchild; BiNode *rchild;public: BiNode():lchild(NULL),rchild(NULL)&#123;&#125; BiNode(char e):data(e), lchild(NULL),rchild(NULL)&#123;&#125; friend class BiTree;&#125;;class BiTree&#123; BiNode *root; queue&lt;BiNode*&gt; tq; void Create(BiNode *&amp;t); void LevOrder(BiNode *t);public: BiTree():root(NULL)&#123;&#125; void Create(); void LevOrder();&#125;;void BiTree::Create(BiNode*&amp;t)&#123; char c; cin &gt;&gt; c; if( c!=&#x27;0&#x27; )&#123; t = new BiNode(c); Create(t-&gt;lchild); Create(t-&gt;rchild); &#125;else&#123; t=NULL; &#125;&#125;void BiTree::Create()&#123; Create(root);&#125;void BiTree::LevOrder(BiNode *t)&#123; BiNode *p = t; if (p) tq.push(p); while (!tq.empty()) &#123; p = tq.front(); tq.pop(); cout &lt;&lt; p-&gt;data; if (p-&gt;lchild) tq.push(p-&gt;lchild); if (p-&gt;rchild) tq.push(p-&gt;rchild); &#125;&#125;void BiTree::LevOrder()&#123; LevOrder(root);&#125;int main()&#123; int t; cin &gt;&gt; t; while( t-- )&#123; BiTree tree; tree.Create(); tree.LevOrder(); cout &lt;&lt; endl; &#125; return 0;&#125; DS单链表–结点交换: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;iostream&gt;using namespace std;class ListNode&#123;public: int data; ListNode *next; ListNode()&#123; next = NULL; &#125;&#125;;class LinkList&#123;public: ListNode *head; int len; LinkList(); ~LinkList(); void CreateInTail( int n); void outPut(); bool swap( int pa, int pb); ListNode *Index(int i);&#125;;LinkList::LinkList()&#123; head = new ListNode; len = 0;&#125;LinkList::~LinkList()&#123; ListNode *p=head, *q; while(p)&#123; q=p; p=p-&gt;next; delete q; &#125; head = NULL; len = 0;&#125;void LinkList::CreateInTail(int n)&#123; len = n; ListNode *tail = head; while( n-- ) &#123; int item; cin &gt;&gt; item; ListNode *s = new ListNode; s-&gt;data = item; tail-&gt;next = s; tail = s; &#125;&#125;void LinkList::outPut()&#123; ListNode *p = head-&gt;next; while( p ) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;; p=p-&gt;next; &#125; cout &lt;&lt; endl;&#125;bool LinkList::swap(int pa, int pb)&#123; if( pa&lt;1 || pb&lt;1 || pa&gt;len || pb&gt;len ) &#123; return false; &#125; ListNode *p = Index(pa-1), *q = Index(pb-1); ListNode *t = p-&gt;next; p-&gt;next = q-&gt;next; q-&gt;next = t; t=p-&gt;next-&gt;next; p-&gt;next-&gt;next=q-&gt;next-&gt;next; q-&gt;next-&gt;next=t; return true;&#125;ListNode *LinkList::Index(int i)&#123; if( i&lt;0 || i&gt;len ) &#123; return NULL; &#125; ListNode *p = head; for( int j=0; j&lt;i; j++) &#123; p=p-&gt;next; &#125; return p;&#125;int main()&#123; int n; cin &gt;&gt; n; LinkList list; list.CreateInTail(n); list.outPut(); int pa, pb; cin &gt;&gt; pa &gt;&gt; pb; if( list.swap(pa,pb)) &#123; list.outPut(); &#125;else&#123; cout &lt;&lt; &quot;error&quot; &lt;&lt; endl; &#125; cin &gt;&gt; pa &gt;&gt; pb; if( list.swap(pa,pb)) &#123; list.outPut(); &#125;else&#123; cout &lt;&lt; &quot;error&quot; &lt;&lt; endl; &#125; return 0;&#125; DS顺序表–合并操作: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;iostream&gt;using namespace std;class SeqList&#123; int *list; int maxsize; int size;public: SeqList(int n); ~SeqList(); void Init(); SeqList combineList(SeqList &amp;li); void outPut();&#125;;SeqList::SeqList( int n)&#123; size = n; maxsize = 1000; list = new int[maxsize];&#125;SeqList::~SeqList()&#123; delete []list;&#125;SeqList SeqList::combineList(SeqList &amp;li)&#123; SeqList combine( size+li.size); int i=0, j=0, k=0; while ( i&lt;size &amp;&amp; j&lt;li.size) &#123; if( list[i]&lt;li.list[j]) &#123; combine.list[k] = list[i]; i++; &#125;else&#123; combine.list[k] = list[j]; j++; &#125; k++; &#125; while( i&lt;size ) &#123; combine.list[k] = list[i]; k++; i++; &#125; while( j&lt;li.size) &#123; combine.list[k] = li.list[j]; k++; j++; &#125; return combine;&#125;void SeqList::Init()&#123; for( int i=0; i&lt;size; i++) &#123; cin &gt;&gt; list[i]; &#125;&#125;void SeqList::outPut()&#123; cout &lt;&lt; size &lt;&lt; &quot; &quot;; for( int i=0; i&lt;size; i++) &#123; cout &lt;&lt; list[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;int main()&#123; int n, m; cin &gt;&gt; n; SeqList list1(n); list1.Init(); cin &gt;&gt; m; SeqList list2(m); list2.Init(); SeqList list3 = list1.combineList(list2); list3.outPut(); return 0;&#125; DS顺序表–连续操作: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;using namespace std;class SeqList&#123; int size; int maxsize; int *list;public: SeqList()&#123; maxsize = 1000; cin &gt;&gt; size; list = new int[maxsize]; for( int i=0; i&lt;size; i++)&#123; cin &gt;&gt; list[i]; &#125; Display(); &#125; void Display()&#123; cout &lt;&lt; size &lt;&lt; &quot; &quot;; for(int i=0; i&lt;size; i++)&#123; cout &lt;&lt; list[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; ~SeqList()&#123; delete[] list; size = 0; &#125; void multiInsert(int begin, int len, int item[])&#123; if( begin&lt;1 || size+len&gt;maxsize || begin&gt;size+1)&#123; return; &#125; for(int i=begin-1, j=0; i&lt;size; i++, j++)&#123; list[size+len-1-j] = list[size-1-j]; &#125; for( int j=begin-1, i=0; i&lt;len; i++, j++)&#123; list[j] = item[i]; &#125; size += len; Display(); &#125; void multiDel(int begin, int len)&#123; for(int i=begin-1, j=0; j&lt;len; j++)&#123; list[i] = list[i+len]; &#125; size -= len; Display(); &#125;&#125;;int main()&#123; SeqList list; int begin, len; cin &gt;&gt; begin &gt;&gt; len; int array[len]; for( int i=0; i&lt;len; i++)&#123; cin &gt;&gt; array[i]; &#125; list.multiInsert(begin, len, array); cin &gt;&gt; begin &gt;&gt; len; list.multiDel(begin, len); return 0;&#125; DS二叉树–左叶子数量: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class BitreeNode &#123;public: char data; BitreeNode *left; BitreeNode *right; BitreeNode():left(NULL),right(NULL)&#123;&#125; ~BitreeNode()&#123;&#125;&#125;;class Bitree&#123;private: BitreeNode *Root; int pos,count; string strtree; BitreeNode *CreateBitree(); void countleaves(BitreeNode *t);public: Bitree() &#123; count = 0; &#125;; ~Bitree() &#123;&#125;; void CreateTree(string TreeArray); void countleaves();&#125;;void Bitree::CreateTree(string treearray)&#123; pos = 0; strtree.assign(treearray); Root = CreateBitree();&#125;BitreeNode *Bitree::CreateBitree()&#123; BitreeNode *T; char ch; ch = strtree[pos++]; if (ch == &#x27;0&#x27;) T = NULL; else &#123; T = new BitreeNode(); T-&gt;data = ch; T-&gt;left = CreateBitree(); T-&gt;right = CreateBitree(); &#125; return T;&#125;void Bitree::countleaves()&#123; countleaves(Root); cout &lt;&lt; count &lt;&lt; endl;&#125;void Bitree::countleaves(BitreeNode *t)&#123; if (t) &#123; if (t-&gt;left) &#123; if (!t-&gt;left-&gt;left &amp;&amp; !t-&gt;left-&gt;right) count++; &#125; countleaves(t-&gt;left); countleaves(t-&gt;right); &#125;&#125;int main()&#123; int t; cin &gt;&gt; t; while (t--) &#123; string str; cin &gt;&gt; str; Bitree *tree; tree = new Bitree(); tree-&gt;CreateTree(str); tree-&gt;countleaves(); &#125;&#125; DS二叉树–赫夫曼树解码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include&lt;iostream&gt;#include&lt;string&gt;#define ok 1#define error -1using namespace std;const int maxW = 9999;class HuffNode&#123;public: int weight; int parent; int lChild; int rChild; char value;&#125;;class HuffMan&#123; void MakeTree(); void SelectMin(int pos, int *s1, int *s2);public: int len; int lNum; HuffNode *huffTree; string *huffCode; void MakeTree(int n, int *wt, char *str); void Coding(); int Decode(const string codestr, char txtStr[]); void Destroy();&#125;;void HuffMan::MakeTree(int n, int *wt, char *str)&#123; int i; lNum = n; len = 2*n-1; huffTree = new HuffNode[2*n]; huffCode = new string[lNum+1]; for( i=1; i&lt;=n; i++)&#123; huffTree[i].weight = wt[i-1]; huffTree[i].value = str[i-1]; &#125; for( i=1; i&lt;=len; i++)&#123; if( i&gt;n )&#123; huffTree[i].weight = 0; &#125; huffTree[i].parent = 0; huffTree[i].lChild = 0; huffTree[i].rChild = 0; &#125; MakeTree();&#125;void HuffMan::MakeTree() &#123; int i, s1, s2; for( i=lNum+1; i&lt;=len; i++)&#123; SelectMin(i-1, &amp;s1, &amp;s2); huffTree[s1].parent = i; huffTree[s2].parent = i; huffTree[i].lChild = s1; huffTree[i].rChild = s2; huffTree[i].weight = huffTree[s1].weight + huffTree[s2].weight; &#125;&#125;void HuffMan::SelectMin(int pos, int *s1, int *s2) &#123; int w1, w2, i; w1 = w2 = maxW; *s1 = *s2 = 0; for( i=1; i&lt;=pos; i++)&#123; if( w1&gt;huffTree[i].weight &amp;&amp; huffTree[i].parent==0 )&#123; w2 = w1; *s2 = *s1; w1 = huffTree[i].weight; *s1 = i; &#125;else if( w2&gt;huffTree[i].weight &amp;&amp; huffTree[i].parent==0 )&#123; w2 = huffTree[i].weight; *s2 = i; &#125; &#125;&#125;void HuffMan::Coding() &#123; char *cd; int i,c,f,start; cd = new char[lNum]; cd[lNum-1] = &#x27;\\0&#x27;; for( i=1; i&lt;=lNum; i++)&#123; start = lNum - 1; for( c=i, f=huffTree[i].parent; f!=0; f=huffTree[f].parent)&#123; if(huffTree[f].lChild == c)&#123; cd[--start] = &#x27;0&#x27;; &#125;else&#123; cd[--start] = &#x27;1&#x27;; &#125; &#125; huffCode[i].assign(&amp;cd[start]); &#125; delete []cd;&#125;int HuffMan::Decode(const string codestr, char *txtStr) &#123; int i, k, c; char ch; c = len; k = 0; for(i=0; i&lt;codestr.length(); i++)&#123; ch = codestr[i]; if( ch==&#x27;0&#x27; )&#123; c=huffTree[c].lChild; &#125;else if( ch==&#x27;1&#x27; )&#123; c=huffTree[c].rChild; &#125;else&#123; return error; &#125; if( !huffTree[c].lChild &amp;&amp; !huffTree[c].rChild )&#123; txtStr[k] = huffTree[c].value; k++; c=len; &#125;else&#123; ch = &#x27;\\0&#x27;; &#125; &#125; if( ch==&#x27;\\0&#x27; )&#123; return error; &#125;else&#123; txtStr[k] = &#x27;\\0&#x27;; &#125; return ok;&#125;void HuffMan::Destroy() &#123; len = 0; lNum = 0; delete []huffTree; delete []huffCode;&#125;int main()&#123; int t,n,i,j; int wt[800]; char ch[800]; HuffMan myHuff; cin &gt;&gt; t; for( i=0; i&lt;t; i++)&#123; cin &gt;&gt; n; for( j=0; j&lt;n; j++)&#123; cin &gt;&gt; wt[j]; &#125; for( j=0; j&lt;n; j++)&#123; cin &gt;&gt; ch[j]; &#125; myHuff.MakeTree(n,wt, ch); int k; cin &gt;&gt; k; while( k-- )&#123; string str; char txt[800]; cin &gt;&gt; str; if( myHuff.Decode(str,txt)!=-1)&#123; cout &lt;&lt; txt &lt;&lt; endl; &#125;else&#123; cout &lt;&lt; &quot;error&quot; &lt;&lt; endl; &#125; &#125; myHuff.Destroy(); &#125; return 0;&#125; DS图遍历–广度优先搜索: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;class Graph&#123; int vexNum; int **array; bool *visit; queue&lt;int&gt; Q; void BFS(int v);public: Graph(); ~Graph(); void BFS();&#125;;Graph::Graph() &#123; cin&gt;&gt;vexNum; array = new int*[vexNum]; visit = new bool[vexNum]; for(int i=0;i&lt;vexNum;i++) &#123; visit[i] = false; array[i]=new int[vexNum]; for(int j=0;j&lt;vexNum;j++) cin&gt;&gt;array[i][j]; &#125;&#125;Graph::~Graph() &#123; delete visit; for(int i=0;i&lt;vexNum;i++) delete array[i]; delete []array;&#125;void Graph::BFS(int v) &#123; if(!visit[v]) &#123; cout&lt;&lt;v&lt;&lt;&#x27; &#x27;; visit[v] = true; for(int i=0;i&lt;vexNum;i++) &#123; if(array[v][i]==1) Q.push(i); &#125; while (!Q.empty()) &#123; BFS(Q.front()); if(!Q.empty()) Q.pop(); &#125; &#125;&#125;void Graph::BFS() &#123; for(int i=0;i&lt;vexNum;i++) BFS(i); cout&lt;&lt;endl;&#125;int main()&#123; int t; cin&gt;&gt;t; while (t--) &#123; Graph myGraph; myGraph.BFS(); &#125; return 0;&#125; DS图遍历–深度优先搜索: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;using namespace std;class Graph&#123; int vexNum; int **array; bool *visit; void DFS(int v);public: Graph(); ~Graph(); void DFS();&#125;;Graph::Graph()&#123; cin &gt;&gt; vexNum; array = new int*[vexNum]; visit = new bool[vexNum]; for( int i=0; i&lt;vexNum; i++)&#123; visit[i] = false; array[i] = new int[vexNum]; for( int j=0; j&lt;vexNum; j++)&#123; cin &gt;&gt; array[i][j]; &#125; &#125;&#125;Graph::~Graph()&#123; delete []visit; for( int i=0; i&lt;vexNum; i++)&#123; delete array[i]; &#125; delete array;&#125;void Graph::DFS(int v)&#123; if(!visit[v])&#123; visit[v] = true; cout &lt;&lt; v &lt;&lt; &quot; &quot;; for( int i=0; i&lt;vexNum; i++)&#123; if( array[v][i]==1)&#123; DFS(i); &#125; &#125; &#125;&#125;void Graph::DFS()&#123; for( int i=0; i&lt;vexNum; i++)&#123; DFS(i); &#125; cout &lt;&lt; endl;&#125;int main()&#123; int t; cin &gt;&gt; t; while( t-- )&#123; Graph myGraph; myGraph.DFS(); &#125; return 0;&#125; DS二叉树–后序遍历非递归算法: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;class BiNode&#123; char data; int tag; BiNode *lChild; BiNode *rChild; BiNode():lChild(NULL),rChild(NULL)&#123;&#125; BiNode(char e):data(e),lChild(NULL),rChild(NULL)&#123;&#125; friend class BiTree;&#125;;class BiTree&#123; BiNode *root; void createTree(BiNode *&amp;r);public: BiTree():root(NULL)&#123;&#125; void createTree(); void postOrder();&#125;;void BiTree::createTree(BiNode *&amp;r) &#123; char ch; cin&gt;&gt;ch; if(ch != &#x27;0&#x27;) &#123; r = new BiNode(ch); createTree(r-&gt;lChild); createTree(r-&gt;rChild); &#125; else r = NULL;&#125;void BiTree::createTree() &#123; createTree(root);&#125;void BiTree::postOrder() &#123; stack&lt;BiNode*&gt; s1; stack&lt;int&gt; s2; if(!root) return; BiNode *p=root; do&#123; while (p) &#123; s1.push(p); s2.push(p-&gt;tag); p = p-&gt;lChild; if(s1.empty()) break; &#125; if(!p) &#123; int tag=s2.top(); if(tag == 0) &#123; s2.top()=1; p=s1.top()-&gt;rChild; &#125; else if(tag==1) &#123; p=s1.top(); s1.pop(); s2.pop(); cout&lt;&lt;p-&gt;data; p=NULL; &#125; &#125; &#125;while (!s1.empty()); cout&lt;&lt;endl;&#125;int main()&#123; int t; cin&gt;&gt;t; while (t--) &#123; BiTree myTree; myTree.createTree(); myTree.postOrder(); &#125; system(&quot;pause&quot;); return 0;&#125; DS二叉树–赫夫曼树的构建与编码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;const int maxW = 9999;class HuffNode&#123;public: int weight; int parent; int leftChild; int rightChild;&#125;;class HuffMan&#123; void MakeTree(); void SelectMin(int pos, int *s1, int *s2);public: int len; int lnum; HuffNode *huffTree; string *huffCode; void MakeTree(int n, int *wt); void Coding(); void Destroy();&#125;;void HuffMan::MakeTree(int n, int *wt)&#123; int i; lnum = n; len = 2*n-1; huffTree = new HuffNode[2*n]; huffCode = new string[lnum+1]; for( i=1; i&lt;=n; i++)&#123; huffTree[i].weight = wt[i-1]; &#125; for( i=1; i&lt;=len; i++)&#123; if( i&gt;n )&#123; huffTree[i].weight = 0; &#125; huffTree[i].parent = 0; huffTree[i].leftChild = 0; huffTree[i].rightChild = 0; &#125; MakeTree();&#125;void HuffMan::SelectMin(int pos, int *s1, int *s2) &#123; int w1, w2, i; w1 = w2 = maxW; *s1 = *s2 = 0; for( i=1; i&lt;=pos; i++)&#123; if( w1&gt;huffTree[i].weight &amp;&amp; !huffTree[i].parent )&#123; w2 = w1; *s2 = *s1; w1 = huffTree[i].weight; *s1 = i; &#125;else if( w2&gt;huffTree[i].weight &amp;&amp; !huffTree[i].parent )&#123; w2 = huffTree[i].weight; *s2 = i; &#125; &#125;&#125;void HuffMan::MakeTree() &#123; int i, s1, s2; for( i=lnum+1; i&lt;=len; i++)&#123; SelectMin(i-1, &amp;s1, &amp;s2); huffTree[s1].parent = huffTree[s2].parent=i; huffTree[i].leftChild = s1; huffTree[i].rightChild = s2; huffTree[i].weight = huffTree[s1].weight + huffTree[s2].weight; &#125;&#125;void HuffMan::Coding() &#123; char *cd; int i,c,f,start; cd = new char[lnum]; cd[lnum-1]=&#x27;\\0&#x27;; for(i=1; i&lt;=lnum;++i)&#123; start = lnum-1; for(c=i, f=huffTree[i].parent; f!=0; c=f, f=huffTree[f].parent)&#123; if( huffTree[f].leftChild == c)&#123; cd[--start] = &#x27;0&#x27;; &#125;else&#123; cd[--start] = &#x27;1&#x27;; &#125; &#125; huffCode[i].assign(&amp;cd[start]); &#125; delete []cd;&#125;void HuffMan::Destroy() &#123; len = 0; lnum = 0; delete []huffTree; delete []huffCode;&#125;int main()&#123; int t, i, j, n; int wt[800]; HuffMan myHuff; cin &gt;&gt; t; for( i=0; i&lt;t; i++)&#123; cin &gt;&gt; n; for( j=0; j&lt;n; j++)&#123; cin &gt;&gt; wt[j]; &#125; myHuff.MakeTree(n, wt); myHuff.Coding(); for( j=1; j&lt;=n; j++)&#123; cout &lt;&lt; myHuff.huffTree[j].weight &lt;&lt; &quot;-&quot;; cout &lt;&lt; myHuff.huffCode[j] &lt;&lt; endl; &#125; myHuff.Destroy(); &#125; return 0;&#125; DS图应用–最短路径（含代码框架）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;iostream&gt;using namespace std;#define inf 65535class Graph&#123; int vexNum; int **array;public: Graph(); ~Graph(); void Dijkstra(int v);&#125;;Graph::Graph() &#123; cin&gt;&gt;vexNum; array = new int*[vexNum]; for(int i=0;i&lt;vexNum;i++) &#123; array[i] = new int[vexNum]; for(int j=0;j&lt;vexNum;j++) &#123; int e; cin&gt;&gt;e; if(e==0) array[i][j] = inf; else array[i][j] = e; &#125; &#125;&#125;Graph::~Graph() &#123; for(int i=0;i&lt;vexNum;i++) delete []array[i]; delete []array;&#125;void Graph::Dijkstra(int v) &#123; int D[vexNum]; bool final[vexNum]; int pathLen[vexNum]; int **path = new int*[vexNum]; int start = v; for(int i=0;i&lt;vexNum;i++) &#123; D[i] = array[v][i]; final[i] = false; pathLen[i] = 2; //初始时，两个顶点直接到达 path[i] = new int[vexNum]; &#125; for(int i =0;i&lt;vexNum;i++) &#123; path[i][0] = v; path[i][1] = i; &#125; final[v] = true; D[v] = 0; for(int i=0;i&lt;vexNum;i++) //找最小 &#123; int min=inf; for(int j=0;j&lt;vexNum;j++) &#123; if(!final[j] &amp;&amp; D[j]&lt;min) &#123; min = D[j]; v = j; &#125; &#125; if(min == inf) break; final[v] = true; for(int j=0;j&lt;vexNum;j++) //更新 &#123; if(!final[j] &amp;&amp; array[v][j]+min &lt; D[j])&#123; D[j] = array[v][j] + min; for(int k=0;k&lt;pathLen[v];k++) path[j][k] = path[v][k]; pathLen[j] = pathLen[v]+1; path[j][pathLen[j]-1] = j; &#125; &#125; &#125; for(int i=0;i&lt;vexNum;i++) &#123; if(i==start) continue; cout&lt;&lt;start&lt;&lt;&#x27;-&#x27;&lt;&lt;i&lt;&lt;&#x27;-&#x27;&lt;&lt;D[i]&lt;&lt;&quot;----[&quot;; for(int j=0;j&lt;pathLen[i];j++) &#123; cout&lt;&lt;path[i][j]&lt;&lt;&#x27; &#x27;; &#125; cout&lt;&lt;&#x27;]&#x27;&lt;&lt;endl; &#125;&#125;int main()&#123; int t; cin&gt;&gt;t; while (t--) &#123; Graph myGraph; int v; cin&gt;&gt;v; myGraph.Dijkstra(v); &#125; return 0;&#125; DS内排—2-路归并排序: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class MergeSort&#123; string *strArray; string *str; int len;public: MergeSort(int n); ~MergeSort(); void Sort(); void Merge(int i,int j,int gap); void update(); void outPut();&#125;;MergeSort::MergeSort(int n) &#123; len=n; strArray = new string[n]; str = new string[n]; for(int i=0;i&lt;n;i++) &#123; cin &gt;&gt; strArray[i]; str[i]=strArray[i]; &#125;&#125;MergeSort::~MergeSort() &#123; delete []strArray; delete []str;&#125;void MergeSort::Sort() &#123; int gap=1,num=len; int i,j; while (num&gt;1) &#123; i=0; j=gap; while (j&lt;len) &#123; Merge(i,j,gap); num--; i+=gap*2; j+=gap*2; &#125; gap=gap*2; outPut(); &#125;&#125;void MergeSort::Merge(int i, int j, int gap) &#123; int m,n,k; for(m=i,n=j,k=i;m&lt;i+gap &amp;&amp; n&lt;j+gap&amp;&amp;n&lt;len;k++) &#123; if(strArray[m]&gt;strArray[n]) str[k] = strArray[m++]; else str[k] = strArray[n++]; &#125; while (m&lt;i+gap) str[k++] = strArray[m++]; while (n&lt;j+gap&amp;&amp;n&lt;len) str[k++]=strArray[n++]; update();&#125;void MergeSort::update() &#123; for(int i=0;i&lt;len;i++) strArray[i]=str[i];&#125;void MergeSort::outPut() &#123; for(int i=0;i&lt;len;i++) &#123; cout&lt;&lt;str[i]; if(i!=len-1) cout&lt;&lt;&#x27; &#x27;; &#125; cout&lt;&lt;endl;&#125;int main()&#123; int t; cin&gt;&gt;t; while (t--) &#123; int n; cin&gt;&gt;n; MergeSort myMerge(n); myMerge.Sort(); cout&lt;&lt;endl; &#125;&#125; DS哈希查找–链地址法: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;iostream&gt;using namespace std;class ListNode&#123;public: ListNode()&#123; next = NULL; &#125; int data; ListNode *next;&#125;;class HashTable&#123; int HashNum; ListNode *array[11]; int Hash(int key);public: HashTable(int n); void Search(int key);&#125;;int HashTable::Hash(int key) &#123; return key%11;&#125;HashTable::HashTable(int n) &#123; int e; for( int i=0; i&lt;11; i++)&#123; array[i] = new ListNode; array[i]-&gt;data = i; &#125; while( n-- )&#123; cin &gt;&gt; e; HashNum = Hash(e); ListNode *p = new ListNode; p-&gt;data = e; if( array[HashNum]-&gt;next==NULL )&#123; p-&gt;next = NULL; array[HashNum]-&gt;next = p; &#125;else&#123; p-&gt;next = array[HashNum]-&gt;next; array[HashNum]-&gt;next = p; &#125; &#125;&#125;void HashTable::Search(int key) &#123; int cnt=0; bool flag = false; HashNum = Hash(key); ListNode *p=array[HashNum]; while( p-&gt;next )&#123; cnt++; p=p-&gt;next; if( key==p-&gt;data )&#123; flag = true; break; &#125; &#125; if( flag== true )&#123; cout &lt;&lt; HashNum &lt;&lt; &quot; &quot; &lt;&lt; cnt &lt;&lt; endl; &#125;else&#123; ListNode *q = new ListNode; q-&gt;data=key; q-&gt;next = array[HashNum]-&gt;next; array[HashNum]-&gt;next = q; cout &lt;&lt; &quot;error&quot; &lt;&lt; endl; &#125;&#125;int main()&#123; int t; cin &gt;&gt; t; HashTable myHash(t); int n, key; cin &gt;&gt; n; while(n--)&#123; cin &gt;&gt; key; myHash.Search(key); &#125; return 0;&#125; DS基数排序: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cmath&gt;using namespace std;class RadixSort&#123; int *array; int max; queue&lt;int&gt; radix[10]; int len;public: RadixSort(int n); ~RadixSort(); void Max(); void Sort(); void Distribute(int wei); void Collect();&#125;;RadixSort::RadixSort(int n) &#123; len=n; array = new int[n]; for(int i=0;i&lt;n;i++) cin&gt;&gt;array[i]; Max();&#125;RadixSort::~RadixSort() &#123; delete []array;&#125;void RadixSort::Max() &#123; max=0; for(int i=0;i&lt;len;i++) &#123; int count=1,temp=array[i]; while (temp/10!=0) &#123; temp/=10; count++; &#125; if(count&gt;max) max=count; &#125;&#125;void RadixSort::Sort() &#123; for(int i=1;i&lt;=max;i++) &#123; Distribute(i); Collect(); &#125; cout&lt;&lt;endl;&#125;void RadixSort::Distribute(int wei) &#123; int j; for(int i=0;i&lt;len;i++) &#123; j=array[i]/pow(10,wei-1); j=j%10; radix[j].push(array[i]); &#125;&#125;void RadixSort::Collect() &#123; int num=0; for(int i=0;i&lt;10;i++) &#123; cout&lt;&lt;i&lt;&lt;&quot;:&quot;; if(radix[i].empty()) cout&lt;&lt;&quot;NULL&quot;&lt;&lt;endl; else &#123; while(!radix[i].empty()) &#123; cout&lt;&lt;&quot;-&gt;&quot;&lt;&lt;radix[i].front(); array[num++]=radix[i].front(); radix[i].pop(); &#125; cout&lt;&lt;&quot;-&gt;^&quot;&lt;&lt;endl; &#125; &#125; for(int i=0;i&lt;len;i++) &#123; cout&lt;&lt;array[i]; if(i!=len-1) cout&lt;&lt;&#x27; &#x27;; &#125; cout&lt;&lt;endl;&#125;int main()&#123; int t; cin&gt;&gt;t; while (t--) &#123; int n; cin&gt;&gt;n; RadixSort mySort(n); mySort.Sort(); &#125; return 0;&#125; DS二叉树判断–同一棵二叉树: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;iostream&gt;using namespace std;#include&lt;queue&gt;class BiNode&#123; BiNode *lChild; BiNode *rChild; char data;public: BiNode():lChild(NULL),rChild(NULL)&#123;&#125; BiNode(char e):data(e),lChild(NULL),rChild(NULL)&#123;&#125; friend class BiTree;&#125;;class BiTree&#123; BiNode *root; int len; queue&lt;BiNode*&gt; que; void CreateTree(BiNode *&amp;t); string str;public: BiTree(); ~BiTree(); void CreateTree(); void BFS();&#125;;void BiTree::BFS()&#123; BiNode *p; int i=0; que.push(root); while(i!=len)&#123; p = que.front(); que.pop(); if(p)&#123; if(p-&gt;data!=str[i])&#123; cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; return; &#125; que.push(p-&gt;lChild); que.push(p-&gt;rChild); &#125; i++; &#125; cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;&#125;BiTree::BiTree() &#123; cin &gt;&gt; str; len = str.length();&#125;BiTree::~BiTree() &#123; delete root; len = 0; while(!que.empty())&#123; que.pop(); &#125;&#125;void BiTree::CreateTree(BiNode *&amp;t) &#123; char e; cin &gt;&gt; e; if( e!=&#x27;#&#x27; )&#123; t = new BiNode(e); CreateTree(t-&gt;lChild); CreateTree(t-&gt;rChild); &#125;else&#123; t = new BiNode(&#x27;#&#x27;); &#125;&#125;void BiTree::CreateTree() &#123; CreateTree(root);&#125;int main()&#123; int t; cin &gt;&gt; t; while(t--)&#123; BiTree myTree; myTree.CreateTree(); myTree.BFS(); &#125;&#125; DS二叉树——Huffman编码与解码（不含代码框架）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class HuffmanNode&#123; int lChild; int rChild; int parents; int weight;public: HuffmanNode():lChild(0),rChild(0),parents(0),weight(0)&#123;&#125; friend class HuffmanTree;&#125;;class HuffmanTree&#123; int leafNum; HuffmanNode *tree; char *strs; string *code; void selectMin(int pos,int *min1,int *min2); int Index(char c);public: HuffmanTree(); void createTree(); void encode(string str); void decode(string str);&#125;;HuffmanTree::HuffmanTree() &#123; cin&gt;&gt;leafNum; tree = new HuffmanNode[2*leafNum]; strs = new char[leafNum]; code = new string[leafNum]; for(int i=0;i&lt;leafNum;i++) cin&gt;&gt;strs[i]; for(int i=1;i&lt;=leafNum;i++) cin&gt;&gt;tree[i].weight;&#125;void HuffmanTree::selectMin(int pos, int *min1, int *min2) &#123; int w1=99999,w2=99999; for(int i=1;i&lt;pos;i++) &#123; if(w1&gt;tree[i].weight &amp;&amp; tree[i].parents == 0) &#123; w2=w1; *min2 = *min1; w1 = tree[i].weight; *min1 = i; &#125; else if(w2&gt;tree[i].weight &amp;&amp; tree[i].parents == 0) &#123; w2 = tree[i].weight; *min2 = i; &#125; &#125;&#125;void HuffmanTree::createTree() &#123; for(int i =leafNum+1;i&lt;2*leafNum;i++) &#123; int min1=0,min2=0; selectMin(i,&amp;min1,&amp;min2); tree[i].weight = tree[min1].weight+tree[min2].weight; tree[i].lChild = min1; tree[i].rChild = min2; tree[min1].parents = i; tree[min2].parents = i; &#125;&#125;void HuffmanTree::encode(string str) &#123; for(int i=0;i&lt;leafNum;i++) &#123; int m=i+1; int n = tree[m].parents; while (n!=0) &#123; if (tree[n].lChild == m) code[i] = &quot;0&quot; + code[i]; else if (tree[n].rChild == m) code[i] = &quot;1&quot; + code[i]; m = n; n = tree[m].parents; &#125; cout&lt;&lt;strs[i]&lt;&lt;&quot; :&quot;&lt;&lt;code[i]&lt;&lt;endl; &#125; int len = str.size(); for(int i=0;i&lt;len;i++) &#123; int pos = Index(str[i]); cout&lt;&lt;code[pos]; &#125; cout&lt;&lt;endl;&#125;int HuffmanTree::Index(char c) &#123; for(int i=0;i&lt;leafNum;i++) if(c==strs[i]) return i; return -1;&#125;void HuffmanTree::decode(string str) &#123; int p= 2*leafNum-1; string msg; for(int i=0;i&lt;str.size();i++) &#123; if(str[i]==&#x27;0&#x27; &amp;&amp; tree[p].lChild!=0) p=tree[p].lChild; else if(str[i]==&#x27;1&#x27; &amp;&amp; tree[p].rChild!=0) p=tree[p].rChild; if(tree[p].lChild==0 &amp;&amp; tree[p].rChild==0) &#123; msg += strs[p-1]; p= 2*leafNum-1; &#125; &#125; if(p==2*leafNum-1) cout&lt;&lt;msg&lt;&lt;endl; else cout&lt;&lt;&quot;error!&quot;&lt;&lt;endl;&#125;int main()&#123; int t; cin&gt;&gt;t; while (t--) &#123; HuffmanTree myTree; myTree.createTree(); string str1; cin&gt;&gt;str1; myTree.encode(str1); string str2; cin&gt;&gt;str2; myTree.decode(str2); &#125; return 0;&#125; DS内排—堆排序: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;using namespace std;class heapSort&#123; int *array; int len;public: heapSort(int n); ~heapSort(); void Sift(int pos,int length); void Sort(); void outPut();&#125;;heapSort::heapSort(int n) &#123; len=n; array = new int[n]; for(int i=0;i&lt;n;i++) cin&gt;&gt;array[i]; for(int i=n/2;i&gt;=0;i--) Sift(i,len); //输出堆初始化 outPut();&#125;heapSort::~heapSort() &#123; delete []array;&#125;void heapSort::Sift(int pos, int length) &#123; int lChild=2*pos+1,rChild=2*pos+2; if(lChild&lt;length) //左孩子不超过最大值 &#123; if(rChild&lt;length) //存在右孩子 &#123; if(array[lChild]&lt;array[rChild]) &#123; if(array[lChild]&lt;array[pos]) &#123; int temp=array[pos]; array[pos]=array[lChild]; array[lChild]=temp; Sift(lChild,length); //和左孩子交换之后,筛选左孩子 &#125; &#125; else&#123; if(array[rChild]&lt;array[pos]) &#123; int temp=array[pos]; array[pos]=array[rChild]; array[rChild]=temp; Sift(rChild,length); //和右孩子交换之后,筛选右孩子 &#125; &#125; &#125; else //只有左孩子，没右孩子 &#123; if(array[lChild]&lt;array[pos]) &#123; int temp=array[pos]; array[pos]=array[lChild]; array[lChild]=temp; Sift(lChild,length); //和左孩子交换之后,筛选左孩子 &#125; &#125; &#125;&#125;void heapSort::Sort() &#123; for(int i=len-1;i&gt;0;i--) //从最后一个结点开始筛选,每次减一 &#123; int temp=array[i]; array[i]=array[0]; array[0]=temp; Sift(0,i); outPut(); &#125;&#125;void heapSort::outPut() &#123; cout&lt;&lt;len&lt;&lt;&#x27; &#x27;; for(int i=0;i&lt;len;i++) &#123; cout &lt;&lt; array[i]; if(i!=len-1) cout&lt;&lt;&#x27; &#x27;; &#125; cout&lt;&lt;endl;&#125;int main()&#123; int n; cin&gt;&gt;n; heapSort myHeap(n); myHeap.Sort(); return 0;&#125; DS内排—直插排序: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;using namespace std;class Array&#123; int *array; int len;public: Array(int n); ~Array(); void outPut(); void InsertSort();&#125;;Array::Array(int n)&#123; len = n; array = new int[n]; for( int i=0; i&lt;n; i++)&#123; cin &gt;&gt; array[i]; &#125;&#125;Array::~Array()&#123; delete[] array; len = 0;&#125;void Array::outPut()&#123; for( int i=0; i&lt;len; i++)&#123; cout &lt;&lt; array[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;void Array::InsertSort()&#123; int i,j,temp; for(i=1; i&lt;len; i++)&#123; temp = array[i]; for( j=i; j&gt;0; j--)&#123; if(temp&lt;array[j-1])&#123; array[j] = array[j-1]; &#125;else break; &#125; array[j] = temp; outPut(); &#125;&#125;int main()&#123; int n; cin &gt;&gt; n; Array myArray(n); myArray.InsertSort(); return 0;&#125; DS哈希查找与增补: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;iostream&gt;using namespace std;class ListNode&#123;public: ListNode()&#123; next = NULL; &#125; int data; ListNode *next;&#125;;class HashTable&#123; int HashNum; ListNode *array[11]; int Hash(int key);public: HashTable(int n); void Search(int key);&#125;;int HashTable::Hash(int key) &#123; return key%11;&#125;HashTable::HashTable(int n) &#123; int e; for( int i=0; i&lt;11; i++)&#123; array[i] = new ListNode; array[i]-&gt;data = i; &#125; while( n-- )&#123; cin &gt;&gt; e; HashNum = Hash(e); ListNode *p = new ListNode; p-&gt;data = e; if( array[HashNum]-&gt;next==NULL )&#123; p-&gt;next = NULL; array[HashNum]-&gt;next = p; &#125;else&#123; p-&gt;next = NULL; ListNode *q = new ListNode; q = array[HashNum]; while(q-&gt;next)&#123; q=q-&gt;next; &#125; q-&gt;next=p; &#125; &#125;&#125;void HashTable::Search(int key) &#123; int cnt=0; bool flag = false; HashNum = Hash(key); ListNode *p=array[HashNum]; while( p-&gt;next )&#123; cnt++; p=p-&gt;next; if( key==p-&gt;data )&#123; flag = true; break; &#125; &#125; if( flag== true )&#123; cout &lt;&lt; HashNum &lt;&lt; &quot; &quot; &lt;&lt; cnt &lt;&lt; endl; &#125;else&#123; ListNode *q = new ListNode; q-&gt;data=key; q-&gt;next = NULL; ListNode *k = new ListNode; k = array[HashNum]; while(k-&gt;next)&#123; k=k-&gt;next; &#125; k-&gt;next=q; cout &lt;&lt; &quot;error&quot; &lt;&lt; endl; &#125;&#125;int main()&#123; int t; cin &gt;&gt; t; HashTable myHash(t); int n, key; cin &gt;&gt; n; while(n--)&#123; cin &gt;&gt; key; myHash.Search(key); &#125; return 0;&#125; DS图—最小生成树: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;queue&gt;using namespace std;class Graph&#123; int vexNum; int arcNum; int **array; string *vex; bool *visit; int Index(string str); bool isOver();public: Graph(); ~Graph(); void Prim(string Vex); void Kruskal();&#125;;Graph::Graph()&#123; cin&gt;&gt;vexNum; vex = new string[vexNum]; for(int i=0;i&lt;vexNum;i++) cin&gt;&gt;vex[i]; array = new int*[vexNum]; visit = new bool[vexNum]; for(int i=0;i&lt;vexNum;i++) &#123; visit[i] = false; array[i] = new int[vexNum]; for(int j=0;j&lt;vexNum;j++) array[i][j] = 99999; &#125; cin&gt;&gt;arcNum; for(int i=0;i&lt;arcNum;i++) &#123; string str1,str2; int weight; cin&gt;&gt;str1&gt;&gt;str2&gt;&gt;weight; int num1=Index(str1),num2=Index(str2); array[num1][num2] = weight; array[num2][num1] = weight; &#125;&#125;int Graph::Index(string str) &#123; for(int i=0;i&lt;vexNum;i++) if(vex[i]==str) return i; return -1;&#125;void Graph::Prim(string Vex) &#123; int v = Index(Vex); visit[v] = true; int minWeight=0; queue&lt;string&gt; start; queue&lt;string&gt; end; queue&lt;int&gt; weights; while (!isOver()) &#123; int min=99999,startVex=-1,endVex=-1; for(int i=0;i&lt;vexNum;i++) &#123; if(visit[i]) &#123; for(int j=0;j&lt;vexNum;j++) &#123; if(!visit[j] &amp;&amp; array[i][j]&lt;min) &#123; min = array[i][j]; startVex = i; endVex = j; &#125; &#125; &#125; &#125; visit[endVex] = true; minWeight+=min; start.push(vex[startVex]); end.push(vex[endVex]); weights.push(min); &#125; cout&lt;&lt;minWeight&lt;&lt;endl; cout&lt;&lt;&quot;prim:&quot;&lt;&lt;endl; while (!start.empty()) &#123; cout&lt;&lt;start.front()&lt;&lt;&#x27; &#x27;&lt;&lt;end.front()&lt;&lt;&#x27; &#x27;&lt;&lt;weights.front()&lt;&lt;endl; start.pop(); end.pop(); weights.pop(); &#125;&#125;bool Graph::isOver() &#123; for(int i=0;i&lt;vexNum;i++) if(!visit[i]) return false; return true;&#125;void Graph::Kruskal() &#123; cout&lt;&lt;&quot;kruskal:&quot;&lt;&lt;endl; int father[vexNum]; //每个点的阵营 for(int i=0;i&lt;vexNum;i++) father[i] = i; bool isExist[vexNum][vexNum]; for(int i=0;i&lt;vexNum;i++) for(int j=0;j&lt;vexNum;j++) isExist[i][j]= false; for(int k=0;k&lt;vexNum-1;k++) //vexNum个结点，有vexNum-1条边 &#123; //找最小权值边 int min=99999,pos1=0,pos2=0; for(int i=0;i&lt;vexNum;i++) &#123; for(int j=0;j&lt;vexNum;j++) &#123; if(father[i] == father[j]) //如果同一阵营，则不找其边，防止构成环 continue; if(array[i][j]&lt;min &amp;&amp; !isExist[i][j]) &#123; min = array[i][j]; pos1 = i; pos2 = j; &#125; &#125; &#125; isExist[pos1][pos2] = true; isExist[pos2][pos1] = true; //编入阵营 if(pos1&lt;pos2) &#123; cout&lt;&lt;vex[pos1]&lt;&lt;&#x27; &#x27;&lt;&lt;vex[pos2]&lt;&lt;&#x27; &#x27;&lt;&lt;min&lt;&lt;endl; for(int i=0;i&lt;vexNum;i++) if(father[i] == father[pos2] &amp;&amp; i!=pos2) father[i] = father[pos1]; father[pos2] = father[pos1]; &#125; else &#123; cout&lt;&lt;vex[pos2]&lt;&lt;&#x27; &#x27;&lt;&lt;vex[pos1]&lt;&lt;&#x27; &#x27;&lt;&lt;min&lt;&lt;endl; for(int i=0;i&lt;vexNum;i++) if(father[i] == father[pos1] &amp;&amp; i!=pos1) father[i] = father[pos2]; father[pos1] = father[pos2]; &#125; &#125;&#125;int main()&#123; Graph myGraph; string v; cin&gt;&gt;v; myGraph.Prim(v); myGraph.Kruskal(); return 0;&#125; DS队列之银行排队: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int main()&#123; int t; cin &gt;&gt; t; int n=t; queue&lt;char&gt; Q; queue&lt;int&gt; T; while(n--) &#123; char s; cin &gt;&gt; s; Q.push(s); &#125; n=t; while(n--) &#123; int a; cin &gt;&gt; a; T.push(a); &#125; int num[3]=&#123;0&#125;; int num1[3]=&#123;0&#125;; n=t; while( n-- ) &#123; char s; s=Q.front(); if( s==&#x27;A&#x27; ) &#123; num[0]+=T.front(); num1[0]++; &#125;else if( s==&#x27;B&#x27; ) &#123; num[1]+=T.front(); num1[1]++; &#125;else&#123; num[2]+=T.front(); num1[2]++; &#125; Q.pop(); T.pop(); &#125; cout &lt;&lt; num[0]/num1[0] &lt;&lt; endl; cout &lt;&lt; num[1]/num1[1] &lt;&lt; endl; cout &lt;&lt; num[2]/num1[2] &lt;&lt; endl; return 0;&#125; DS二叉排序树之删除: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;iostream&gt;using namespace std;class BiNode&#123; int data; BiNode *lChild; BiNode *rChild; BiNode *parents;public: BiNode():lChild(NULL),rChild(NULL),parents(NULL)&#123;&#125; BiNode(int e):data(e),lChild(NULL),rChild(NULL),parents(NULL)&#123;&#125; friend class BiTree;&#125;;class BiTree&#123; BiNode *root; void InsertNode(int data,BiNode *&amp;r); void MidOrder(BiNode *t); void Delete(int key,BiNode *&amp;t); BiNode* getBefore(BiNode *s);public: BiTree(int data)&#123;root = new BiNode(data);&#125; void Insert(int key); void MidOrder(); void Delete(int key);&#125;;void BiTree::InsertNode(int data,BiNode *&amp;r) &#123; if(data&gt;r-&gt;data &amp;&amp; r-&gt;rChild) InsertNode(data,r-&gt;rChild); else if(data &lt; r-&gt;data &amp;&amp; r-&gt;lChild) InsertNode(data,r-&gt;lChild); else if(data&gt; r-&gt;data &amp;&amp; !r-&gt;rChild)&#123; BiNode *s = new BiNode(data); r-&gt;rChild = s; s-&gt;parents = r; &#125;else if(data&lt;r-&gt;data &amp;&amp; !r-&gt;lChild)&#123; BiNode *s = new BiNode(data); r-&gt;lChild = s; s-&gt;parents = r; &#125;&#125;void BiTree::Insert(int key) &#123; InsertNode(key,root);&#125;void BiTree::MidOrder(BiNode *t) &#123; if(t)&#123; MidOrder(t-&gt;lChild); cout&lt;&lt;t-&gt;data&lt;&lt;&#x27; &#x27;; MidOrder(t-&gt;rChild); &#125;&#125;void BiTree::MidOrder() &#123; MidOrder(root); cout&lt;&lt;endl;&#125;void BiTree::Delete(int key, BiNode *&amp;t) &#123; if(key &gt; t-&gt;data &amp;&amp; t-&gt;rChild)&#123; Delete(key,t-&gt;rChild); &#125;else if(key &lt;t-&gt;data &amp;&amp; t-&gt;lChild)&#123; Delete(key,t-&gt;lChild); &#125;else if(key == t-&gt;data)&#123; if(!t-&gt;lChild &amp;&amp; !t-&gt;rChild)&#123; delete t; t = NULL; &#125;else if(t-&gt;lChild &amp;&amp; !t-&gt;rChild)&#123; BiNode *p = t; t = t-&gt;lChild; delete p; &#125;else if(t-&gt;rChild &amp;&amp; !t-&gt;lChild)&#123; BiNode *p = t; t = t-&gt;rChild; delete p; &#125;else if(t-&gt;lChild &amp;&amp; t-&gt;rChild)&#123; BiNode *p = getBefore(t); t-&gt;data = p-&gt;data; if(p-&gt;lChild) p-&gt;parents-&gt;rChild = p-&gt;lChild; if(t-&gt;lChild == p) //当直接前驱就是他的左孩子时候，要把该节点左孩子设为NULL t-&gt;lChild = NULL; delete p; &#125; &#125;&#125;void BiTree::Delete(int key) &#123; Delete(key,root);&#125;BiNode *BiTree::getBefore(BiNode *s) &#123; //获取s的中序遍历直接前驱 BiNode *p = s-&gt;lChild; while (p-&gt;rChild) p= p-&gt;rChild; return p;&#125;int main()&#123; int t; cin&gt;&gt;t; while (t--) &#123; int n; cin&gt;&gt;n; int data; cin&gt;&gt;data; BiTree myTree(data); for(int i=1;i&lt;n;i++)&#123; cin&gt;&gt;data; myTree.Insert(data); &#125; myTree.MidOrder(); int m; cin&gt;&gt;m; while (m--)&#123; int key; cin&gt;&gt;key; myTree.Delete(key); myTree.MidOrder(); &#125; &#125;&#125; DS二叉排序树之查找: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;iostream&gt;using namespace std;class BiNode&#123; int data; BiNode *lChild; BiNode *rChild;public: BiNode():lChild(NULL),rChild(NULL)&#123;&#125; BiNode(int e):data(e),lChild(NULL), rChild(NULL)&#123;&#125; friend class BiTree;&#125;;class BiTree&#123; BiNode *root; int count; void InsertNode(int data, BiNode *&amp;r); void MidOrder(BiNode *t); bool Search(int key, BiNode *t);public: BiTree(int data)&#123; root = new BiNode(data); &#125; void Insert(int key); void MidOrder(); void Search(int key);&#125;;void BiTree::InsertNode(int data, BiNode *&amp;r)&#123; if(data&gt;r-&gt;data &amp;&amp; r-&gt;rChild)&#123; InsertNode(data, r-&gt;rChild); &#125;else if( data &gt; r-&gt;data &amp;&amp; !r-&gt;rChild)&#123; BiNode *s = new BiNode(data); r-&gt;rChild = s; &#125;else if( data &lt; r-&gt;data &amp;&amp; r-&gt;lChild )&#123; InsertNode(data, r-&gt;lChild); &#125;else if( data &lt; r-&gt;data &amp;&amp; !r-&gt;lChild)&#123; BiNode *s = new BiNode(data); r-&gt;lChild = s; &#125;&#125;void BiTree::Insert(int key)&#123; InsertNode(key, root);&#125;void BiTree::MidOrder(BiNode *t)&#123; if( t )&#123; MidOrder(t-&gt;lChild); cout &lt;&lt; t-&gt;data &lt;&lt; &quot; &quot;; MidOrder(t-&gt;rChild); &#125;&#125;void BiTree::MidOrder()&#123; MidOrder(root); cout &lt;&lt; endl;&#125;bool BiTree::Search( int key, BiNode *t)&#123; count++; if( key &gt; t-&gt;data &amp;&amp; t-&gt;rChild )&#123; return Search(key, t-&gt;rChild); &#125;else if( key &lt; t-&gt;data &amp;&amp; t-&gt;lChild )&#123; return Search(key,t-&gt;lChild); &#125;else if( key==t-&gt;data)&#123; return true; &#125; count++; return false;&#125;void BiTree::Search(int key)&#123; count = 0; if(Search(key, root))&#123; cout &lt;&lt; count &lt;&lt; endl; &#125;else&#123; cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl; &#125;&#125;int main()&#123; int t; cin &gt;&gt; t; while( t-- )&#123; int n; cin &gt;&gt; n; int data; cin &gt;&gt; data; BiTree myTree(data); for( int i=1; i&lt;n; i++)&#123; cin &gt;&gt; data; myTree.Insert(data); &#125; myTree.MidOrder(); int m; cin &gt;&gt; m; while( m-- )&#123; int key; cin&gt;&gt;key; myTree.Search(key); &#125; &#125; return 0;&#125; DS图—图的连通分量: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Graph&#123; int vexNum; int arcNum; string *vex; int **array; bool *visit; int count; void DFS(int v); int Index(string str);public: Graph(); ~Graph(); void getConnect(); void outPut();&#125;;Graph::Graph():count(0) &#123; cin&gt;&gt;vexNum; vex = new string[vexNum]; for(int i=0;i&lt;vexNum;i++) cin&gt;&gt;vex[i]; array = new int*[vexNum]; visit = new bool[vexNum]; for(int i=0;i&lt;vexNum;i++) &#123; visit[i] = false; array[i] = new int[vexNum]; for(int j=0;j&lt;vexNum;j++) array[i][j] = 0; &#125; cin&gt;&gt;arcNum; for(int i=0;i&lt;arcNum;i++) &#123; string str1,str2; cin&gt;&gt;str1&gt;&gt;str2; int num1=Index(str1),num2=Index(str2); array[num1][num2] = 1; array[num2][num1] = 1; &#125;&#125;Graph::~Graph() &#123; delete []visit; delete []vex; for(int i=0;i&lt;vexNum;i++) delete []array[i]; delete []array;&#125;void Graph::DFS(int v) &#123; if(!visit[v]) &#123; visit[v] = true; for(int j=0;j&lt;vexNum;j++) if(array[v][j]==1) DFS(j); &#125;&#125;void Graph::getConnect() &#123; for(int i=0;i&lt;vexNum;i++) if(!visit[i]) &#123; DFS(i); count++; &#125;&#125;int Graph::Index(string str) &#123; for(int i=0;i&lt;vexNum;i++) if(vex[i] == str) return i; return -1;&#125;void Graph::outPut() &#123; for(int i=0;i&lt;vexNum;i++) if(i!=vexNum-1) cout&lt;&lt;vex[i]&lt;&lt;&#x27; &#x27;; else cout&lt;&lt;vex[i]&lt;&lt;endl; for(int i=0;i&lt;vexNum;i++) for(int j=0;j&lt;vexNum;j++) if(j!=vexNum-1) cout&lt;&lt;array[i][j]&lt;&lt;&#x27; &#x27;; else cout&lt;&lt;array[i][j]&lt;&lt;endl; cout&lt;&lt;count&lt;&lt;endl&lt;&lt;endl;&#125;int main()&#123; int t; cin&gt;&gt;t; while (t--) &#123; Graph myGraph; myGraph.getConnect(); myGraph.outPut(); &#125; return 0;&#125; DS顺序表之循环移位: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;using namespace std;class SeqList&#123; int *list; int len; int maxLen;public: SeqList( int n); ~SeqList(); void move(); void outPut();&#125;;SeqList::SeqList(int n)&#123; len = n; maxLen = 100; list = new int[maxLen]; for( int i=0; i&lt;n; i++)&#123; cin &gt;&gt; list[i]; &#125;&#125;SeqList::~SeqList()&#123; delete []list;&#125;void SeqList::move()&#123; int direction, step; cin &gt;&gt; direction &gt;&gt; step; while( step &gt;= len )&#123; step-=len; &#125; int temp[step]; if( direction == 0)&#123; for( int i=0; i&lt;step; i++)&#123; temp[i] = list[i]; &#125; for( int i=step; i&lt;len; i++)&#123; list[i-step] = list[i]; &#125; for( int i=step+1; i&lt;len; i++)&#123; list[i] = temp[i-step-1]; &#125; &#125;else&#123; for( int i=len -step; i&lt;len; i++)&#123; temp[i-len+step] = list[i]; &#125; for( int i=len-step-1; i&gt;=0; i--)&#123; list[i+step] = list[i]; &#125; for( int i=0; i&lt;step; i++) &#123; list[i]=temp[i]; &#125; &#125;&#125;void SeqList::outPut()&#123; for( int i=0; i&lt;len; i++) &#123; cout &lt;&lt; list[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;int main()&#123; int n; cin &gt;&gt; n; SeqList list(n); list.outPut(); list.move(); list.outPut(); list.move(); list.outPut(); return 0;&#125; DS线性结构—火车问题: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; int n; string s1, s2; stack&lt;char&gt; st; queue&lt;string&gt; order; cin &gt;&gt; n &gt;&gt; s1 &gt;&gt; s2; int j = 0; for(int i = 0; i &lt; n; ) &#123; order.push(&quot;in&quot;); st.push(s1[i]); i ++ ; while(!st.empty()) &#123; if(st.top() == s2[j]) &#123; j ++ ; st.pop(); order.push(&quot;out&quot;); &#125;else break; &#125; &#125; if(st.empty() &amp;&amp; j == s2.length()) &#123; cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; while(!order.empty()) &#123; cout &lt;&lt; order.front() &lt;&lt; endl; order.pop(); &#125; &#125;else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; cout &lt;&lt; &quot;FINISH&quot; &lt;&lt; endl; &#125;&#125; DS线性表—多项式相加: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include&lt;iostream&gt;using namespace std;class ListNode&#123;public: int data1, data2; ListNode *next; ListNode() &#123; next = NULL; &#125;&#125;;class LinkList&#123;public: ListNode *head; int len; LinkList()&#123; head = new ListNode; len = 0; &#125; ~LinkList()&#123; ListNode *p, *q; p = head; while(p) &#123; q=p; p=p-&gt;next; delete q; &#125; len = 0; head = NULL; &#125; void CreateList( int n) &#123; int i; ListNode *q = head; int d1, d2; for( i=0; i&lt;n; i++) &#123; cin &gt;&gt; d1 &gt;&gt; d2; ListNode *p = new ListNode; p-&gt;data1 = d1; p-&gt;data2 = d2; q-&gt;next = p; p-&gt;next = NULL; q = p; &#125; len = n; &#125; void Display() &#123; int i; ListNode *p = head-&gt;next; for( i=0; i&lt;len; i++) &#123; if( p-&gt;data1 == 0) &#123; p=p-&gt;next; continue; &#125;else if( p-&gt;data2 == 0) &#123; if( p-&gt;data1 &lt; 0) &#123; cout &lt;&lt; &quot;(&quot; &lt;&lt; p-&gt;data1 &lt;&lt; &quot;)&quot;; &#125;else&#123; cout &lt;&lt; p-&gt;data1; &#125; p=p-&gt;next; &#125;else&#123; if( p-&gt;data1 &lt; 0 ) &#123; cout &lt;&lt; &quot;(&quot; &lt;&lt; p-&gt;data1 &lt;&lt; &quot;)x^&quot;; &#125;else&#123; cout &lt;&lt; p-&gt;data1 &lt;&lt; &quot;x^&quot;; &#125; if( p-&gt;data2 &lt; 0 ) &#123; cout &lt;&lt; &quot;(&quot; &lt;&lt; p-&gt;data2 &lt;&lt; &quot;)&quot;; &#125;else&#123; cout &lt;&lt; p-&gt;data2; &#125; p=p-&gt;next; &#125; if( i!=len-1 ) &#123; cout &lt;&lt; &quot; + &quot;; &#125; &#125; cout &lt;&lt; endl; &#125; void add(LinkList *q) &#123; ListNode *pre = head; ListNode *s = pre-&gt;next; ListNode *r = q-&gt;head-&gt;next; while( s!=NULL &amp;&amp; r!=NULL ) &#123; if( s-&gt;data2 &lt; r-&gt;data2) &#123; s = s-&gt;next; pre = pre-&gt;next; &#125;else if(s-&gt;data2 == r-&gt;data2) &#123; s-&gt;data1 = s-&gt;data1+r-&gt;data1; s = s-&gt;next; pre = pre-&gt;next; r = r-&gt;next; q-&gt;len--; &#125;else&#123; ListNode *m = new ListNode; m-&gt;data1 = r-&gt;data1; m-&gt;data2 = r-&gt;data2; m-&gt;next = s; pre-&gt;next = m; r = r-&gt;next; pre = pre-&gt;next; q-&gt;len--; &#125; &#125; if(r) &#123; pre-&gt;next = r; len = len+q-&gt;len; &#125; &#125; ListNode *index(int i) &#123; int k; ListNode *p = head; if( i!=0 ) &#123; for( k=1; k&lt;i; k++) &#123; p=p-&gt;next; &#125; return p-&gt;next; &#125;else&#123; return head; &#125; &#125;&#125;;int main()&#123; int T, n, m; cin &gt;&gt; T; while( T-- ) &#123; LinkList *list1 = new LinkList, *list2 = new LinkList; cin &gt;&gt; n; list1-&gt;CreateList(n); cin &gt;&gt; m; list2-&gt;CreateList(m); list1-&gt;Display(); list2-&gt;Display(); list1-&gt;add(list2); list1-&gt;Display(); delete list1, list2; &#125; return 0;&#125; DS链表—学生宿舍管理: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define ok 0#define error -1using namespace std; void outint(int n)&#123;cout&lt;&lt;n&lt;&lt;&quot; &quot;;&#125;int main()&#123; list&lt;int&gt; L1,L2; list&lt;string&gt; L3; list&lt;int&gt;::iterator p1=L1.begin(),p2=L2.begin(); list&lt;string&gt;::iterator p3=L3.begin(); for(int i=0;i&lt;20;i++) &#123; L1.insert(p1,101+i); p1++; &#125; L1.sort(); int n,k; string temp; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;temp; cin&gt;&gt;k; for(p1=L1.begin();p1!=L1.end();p1++) &#123; if(*p1==k) &#123; L1.erase(p1); L2.insert(L2.begin(),k); L2.sort(); for(p2=L2.begin(),p3=L3.begin();p2!=L2.end();p2++,p3++) &#123; if(*p2==k) L3.insert(p3,temp); &#125; break; &#125; &#125; &#125; string c1,c2; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;c1; if(c1==&quot;assign&quot;) &#123; cin&gt;&gt;c2; k=*L1.begin(); L2.insert(L2.begin(),k); L2.sort(); for(p2=L2.begin(),p3=L3.begin();p2!=L2.end();p2++,p3++) &#123; if(*p2==k)&#123; L3.insert(p3,c2); break; &#125; &#125; L1.erase(L1.begin()); &#125; if(c1==&quot;return&quot;) &#123; cin&gt;&gt;k; for(p2=L2.begin(),p3=L3.begin();p2!=L2.end();p2++,p3++) &#123; if(*p2==k) &#123; L1.insert(L1.end(),k); L2.erase(p2); L3.erase(p3); break; &#125; &#125; &#125; int flag=1; if(c1==&quot;display_used&quot;) &#123; flag=1; for(p2=L2.begin(),p3=L3.begin();p2!=L2.end();p2++,p3++) &#123; if(flag==1) &#123; cout&lt;&lt;*p3&lt;&lt;&quot;(&quot;&lt;&lt;*p2&lt;&lt;&quot;)&quot;; flag=0; &#125; else cout&lt;&lt;&quot;-&quot;&lt;&lt;*p3&lt;&lt;&quot;(&quot;&lt;&lt;*p2&lt;&lt;&quot;)&quot;; &#125; cout&lt;&lt;endl; &#125; if(c1==&quot;display_free&quot;) &#123; flag=1; for(p1=L1.begin();p1!=L1.end();p1++) &#123; if(flag==1) &#123; cout&lt;&lt;*p1; flag=0; &#125; else cout&lt;&lt;&quot;-&quot;&lt;&lt;*p1; &#125; cout&lt;&lt;endl; &#125; &#125;&#125; DS静态查找之折半查找: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;using namespace std;class BinSearch&#123; int len; int *array;public: BinSearch(); ~BinSearch(); int search(int key);&#125;;BinSearch::BinSearch() &#123; cin&gt;&gt;len; array = new int[len+1]; for(int i=1;i&lt;=len;i++) cin&gt;&gt;array[i];&#125;BinSearch::~BinSearch() &#123; delete []array;&#125;int BinSearch::search(int key) &#123; int low=1,high=len,mid; while (low&lt;=high) &#123; mid = (high+low)/2; if(array[mid] == key) return mid; else if(array[mid] &gt; key) high = mid-1; else if(array[mid] &lt; key) low = mid+1; &#125; return 0;&#125;int main()&#123; BinSearch myArray; int t; cin&gt;&gt;t; while (t--) &#123; int key; cin&gt;&gt;key; int res = myArray.search(key); if(res != 0) cout&lt;&lt;res&lt;&lt;endl; else cout&lt;&lt;&quot;error&quot;&lt;&lt;endl; &#125;&#125; DS静态查找之顺序查找: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;using namespace std;class Table&#123; int len; int *elem;public: Table(int n); ~Table(); int Search(int key);&#125;;Table::Table(int n)&#123; len = n; elem = new int[n+1]; for( int i=1; i&lt;=n; i++)&#123; cin &gt;&gt; elem[i]; &#125;&#125;Table::~Table()&#123; len = 0; delete[] elem;&#125;int Table::Search(int key)&#123; elem[0] = key; for( int i = len; i&gt;=0; i--)&#123; if(elem[i]==key)&#123; return i; &#125; &#125;&#125;int main()&#123; int n; cin &gt;&gt; n; Table myTable(n); int t; cin &gt;&gt; t; while( t-- )&#123; int key; cin &gt;&gt; key; int res=myTable.Search(key); if(res==0)&#123; cout &lt;&lt; &quot;error&quot; &lt;&lt; endl; &#125;else&#123; cout &lt;&lt; res &lt;&lt; endl; &#125; &#125; return 0;&#125; DS串应用—最长重复子串: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;void getNext(string p, int *next)&#123; next[0] = -1; int i = 0, j = -1; while(i &lt; (int)p.length()) &#123; if(j == -1 || p[i] == p[j]) next[ ++ i] = ++ j; else j = next[j]; &#125;&#125;int main()&#123; int n; cin &gt;&gt; n; string s, re; int i, j = -1, k; int Max = 0; while(n -- ) &#123; int next[100] = &#123;0&#125;; Max = -1; cin &gt;&gt; s; re = s; for(i = 0, k = (int)s.length() - 1; k &gt;= 0; i ++ , k -- ) re[i] = s[k]; getNext(s, next); for(i = 0; i &lt;= (int)s.length(); ++ i) if(next[i] &gt; Max &amp;&amp; next[i] &lt;= (int)s.length() / 2) Max = next[i]; getNext(re, next); for(i = 0; i &lt;= (int)re.length(); ++ i) if(next[i] &gt; Max &amp;&amp; next[i] &lt;= (int)re.length() / 2) Max = next[i]; if(Max == 0) cout &lt;&lt; j &lt;&lt; endl; else cout &lt;&lt; Max &lt;&lt; endl; &#125; return 0;&#125; DS二叉排序树之创建和插入: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;iostream&gt;using namespace std;class BiNode&#123; int data; BiNode *lChild; BiNode *rChild;public: BiNode():lChild(NULL),rChild(NULL)&#123;&#125; BiNode(int e):data(e),lChild(NULL), rChild(NULL)&#123;&#125; friend class BiTree;&#125;;class BiTree&#123; BiNode *root; void InsertNode(int data, BiNode *&amp;r); void MidOrder(BiNode *t);public: BiTree(int data)&#123; root = new BiNode(data); &#125; void Insert(int key); void MidOrder();&#125;;void BiTree::InsertNode(int data, BiNode *&amp;r)&#123; if(data&gt;r-&gt;data &amp;&amp; r-&gt;rChild)&#123; InsertNode(data, r-&gt;rChild); &#125;else if( data &gt; r-&gt;data &amp;&amp; !r-&gt;rChild)&#123; BiNode *s = new BiNode(data); r-&gt;rChild = s; &#125;else if( data &lt; r-&gt;data &amp;&amp; r-&gt;lChild )&#123; InsertNode(data, r-&gt;lChild); &#125;else if( data &lt; r-&gt;data &amp;&amp; !r-&gt;lChild)&#123; BiNode *s = new BiNode(data); r-&gt;lChild = s; &#125;&#125;void BiTree::Insert(int key)&#123; InsertNode(key, root);&#125;void BiTree::MidOrder(BiNode *t)&#123; if( t )&#123; MidOrder(t-&gt;lChild); cout &lt;&lt; t-&gt;data &lt;&lt; &quot; &quot;; MidOrder(t-&gt;rChild); &#125;&#125;void BiTree::MidOrder()&#123; MidOrder(root); cout &lt;&lt; endl;&#125;int main()&#123; int t; cin &gt;&gt; t; while( t-- )&#123; int n; cin &gt;&gt; n; int data; cin &gt;&gt; data; BiTree myTree(data); for( int i=1; i&lt;n; i++)&#123; cin &gt;&gt; data; myTree.Insert(data); &#125; myTree.MidOrder(); int m; cin &gt;&gt; m; while( m-- )&#123; cin &gt;&gt; data; myTree.Insert(data); myTree.MidOrder(); &#125; &#125; return 0;&#125; DS静态查找之顺序索引查找: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;string&gt;using namespace std;class Sequential_index_table&#123;public: int length; //顺序表长度 int index_length; //索引表长度 int *elem; //顺序表 int *index; //索引表最大关键字 int *index_loc; //索引表最大关键字的起始地址public: Sequential_index_table()&#123;&#125;; Sequential_index_table(int t)&#123; length = t; elem = new int[length]; for(int i = 0; i &lt; length; i++) //初始化顺序表 cin&gt;&gt;elem[i]; cin&gt;&gt;index_length; //初始化索引表最大关键字 index = new int[index_length]; for(int i = 0; i &lt; index_length; i++) cin&gt;&gt;index[i]; index_loc = new int [index_length]; index_loc[0]=0; for(int i=0;i&lt;index_length-1;i++) //根据索引表最大关键字初始化最大关键字起始地址 &#123; for(int j=index_loc[i];j&lt;length;j++) &#123; if(elem[j]&gt;index[i]) &#123; index_loc[i+1]=j; break; &#125; &#125; &#125; &#125; ~Sequential_index_table()&#123;&#125;; void Index_search(int key)&#123; int compare_time=0; for(int i=0;i&lt;index_length;i++) &#123; compare_time++; if(key &lt;= index[i] || i==index_length-1) //先和索引表最大关键字比较 &#123; int start_loc = index_loc[i]; int end_loc = i+1&gt;=index_length ? length:index_loc[i+1]; for(int j=start_loc;j&lt;end_loc;j++) //再从索引表最大关键字对应的下标开始比较 &#123; compare_time++; if(elem[j]==key) &#123; cout&lt;&lt;j+1&lt;&lt;&#x27;-&#x27;&lt;&lt;compare_time&lt;&lt;endl; return; &#125; &#125; cout&lt;&lt;&quot;error&quot;&lt;&lt;endl; return; &#125; &#125; &#125;&#125;;int main()&#123; int t,p,key; while(cin&gt;&gt;t) &#123; Sequential_index_table test(t); cin&gt;&gt;p; while(p--) &#123; cin&gt;&gt;key; test.Index_search(key); &#125; &#125;&#125; DS哈希查找—线性探测再散列: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;iostream&gt;using namespace std;class HashTable&#123; int len; int keyNum; int *array; int HashNum; int Hash(int key);public: HashTable(); ~HashTable(); void Search(int key); void Display();&#125;;HashTable::HashTable() &#123; cin &gt;&gt; len &gt;&gt; keyNum; array = new int[len]; for(int i=0; i&lt;len; i++)&#123; array[i]=0; &#125; for( int i=0; i&lt;keyNum; i++)&#123; int key; cin &gt;&gt; key; HashNum = Hash(key); for( int j=0; j&lt;keyNum; j++)&#123; if( array[(HashNum+j)%len]==0 )&#123; array[(HashNum+j)%len] = key; break; &#125; &#125; &#125;&#125;HashTable::~HashTable() &#123; delete[] array; len = 0;&#125;int HashTable::Hash(int key) &#123; return key%11;&#125;void HashTable::Display() &#123; for( int i=0; i&lt;len; i++)&#123; if( array[i]==0 )&#123; cout &lt;&lt; &quot;NULL&quot;; &#125;else&#123; cout &lt;&lt; array[i]; &#125; if( i==len-1 )&#123; cout &lt;&lt; endl; &#125;else&#123; cout &lt;&lt; &quot; &quot;; &#125; &#125;&#125;void HashTable::Search(int key) &#123; HashNum = Hash(key); int i; for( i=0; i&lt;len; i++)&#123; if( array[(HashNum+i)%len]==key || array[(HashNum+i)%len]==0)&#123; break; &#125; &#125; if( array[(HashNum+i)%len]==key )&#123; cout &lt;&lt; &quot;1 &quot; &lt;&lt; i+1 &lt;&lt; &quot; &quot; &lt;&lt; (HashNum+i)%len+1 &lt;&lt; endl; &#125;else&#123; cout &lt;&lt; &quot;0 &quot; &lt;&lt; i+1 &lt;&lt; endl; &#125;&#125;int main()&#123; int t; cin &gt;&gt; t; while( t-- )&#123; HashTable myHash; myHash.Display(); int n; cin &gt;&gt; n; while( n-- )&#123; int key; cin &gt;&gt; key; myHash.Search(key); &#125; &#125; return 0;&#125; DS二叉树——二叉树之数组存储: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;using namespace std;class BiTree&#123; int len; int *tree; void PreOrder(int i);public: BiTree(); ~BiTree(); void PreOrder();&#125;;BiTree::BiTree() &#123; cin&gt;&gt;len; tree = new int[len]; for(int i=0;i&lt;len;i++) cin&gt;&gt;tree[i];&#125;BiTree::~BiTree() &#123; delete []tree;&#125;void BiTree::PreOrder() &#123; PreOrder(0); cout&lt;&lt;endl;&#125;void BiTree::PreOrder(int i) &#123; if(tree[i]!=0 &amp;&amp; i&lt;len) &#123; cout &lt;&lt; tree[i]&lt;&lt;&#x27; &#x27;; PreOrder(2 * i + 1); PreOrder(2 * i + 2); &#125;&#125;int main()&#123; int t; cin&gt;&gt;t; while (t--) &#123; BiTree myTree; myTree.PreOrder(); &#125; return 0;&#125; DS二叉树——二叉树之父子结点: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;class BiNode&#123; char data; BiNode *lchild; BiNode *rchild; BiNode *parents;public: BiNode():lchild(NULL),rchild(NULL),parents(NULL)&#123;&#125; BiNode(char e):data(e),lchild(NULL),rchild(NULL),parents(NULL)&#123;&#125; friend class BiTree;&#125;;class BiTree&#123; BiNode *root; queue&lt;BiNode*&gt; leaf; queue&lt;BiNode*&gt; parents; void CreateTree(BiNode *&amp;t, BiNode *p); void PreOrder(BiNode *t);public: BiTree():root(NULL)&#123;&#125; void CreateTree(); void PreOrder();&#125;;void BiTree::CreateTree(BiNode *&amp;t, BiNode *p)&#123; char c; cin &gt;&gt; c; if( c!=&#x27;0&#x27; ) &#123; t=new BiNode(c); t-&gt;parents = p; CreateTree(t-&gt;lchild, t); CreateTree(t-&gt;rchild, t); &#125;else&#123; t=NULL; &#125;&#125;void BiTree::CreateTree()&#123; CreateTree(root, NULL);&#125;void BiTree::PreOrder(BiNode *t)&#123; if(t) &#123; if(!t-&gt;lchild &amp;&amp; !t-&gt;rchild) &#123; leaf.push(t); parents.push(t-&gt;parents); &#125; PreOrder(t-&gt;lchild); PreOrder(t-&gt;rchild); &#125; &#125;void BiTree::PreOrder()&#123; PreOrder(root); while( !leaf.empty())&#123; cout &lt;&lt; leaf.front()-&gt;data &lt;&lt; &quot; &quot;; leaf.pop(); &#125; cout &lt;&lt; endl; while( !parents.empty()) &#123; cout &lt;&lt; parents.front()-&gt;data &lt;&lt; &quot; &quot;; parents.pop(); &#125; cout &lt;&lt; endl;&#125;int main()&#123; int t; cin &gt;&gt; t; while( t-- ) &#123; BiTree tree; tree.CreateTree(); tree.PreOrder(); &#125; return 0;&#125; DS图—图的邻接矩阵存储及度计算: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;iostream&gt;using namespace std;class Graph&#123; char type; int vexNum; int arcNum; string *vex; int **array; int *in; int *out;public: Graph(); ~Graph(); int Index(string str); void countDegree(); void outPut();&#125;;Graph::Graph()&#123; cin &gt;&gt; type &gt;&gt; vexNum; vex = new string[vexNum]; for( int i=0; i&lt;vexNum; i++)&#123; cin &gt;&gt; vex[i]; &#125; array = new int*[vexNum]; for(int i=0; i&lt;vexNum; i++)&#123; array[i] = new int[vexNum]; for( int j=0; j&lt;vexNum; j++)&#123; array[i][j] = 0; &#125; &#125; in = new int[vexNum]; out = new int[vexNum]; for( int i=0; i&lt;vexNum; i++)&#123; in[i]=0; out[i]=0; &#125; cin &gt;&gt; arcNum; for( int i=0; i&lt;arcNum; i++)&#123; string str1, str2; cin &gt;&gt; str1 &gt;&gt; str2; int pos1 = Index(str1), pos2 = Index(str2); if( type == &#x27;U&#x27;)&#123; array[pos1][pos2] = 1; array[pos2][pos1] = 1; &#125;else if( type == &#x27;D&#x27;)&#123; array[pos1][pos2] = 1; &#125; &#125;&#125;Graph::~Graph()&#123; for( int i=0; i&lt;vexNum; i++)&#123; delete array[i]; &#125; delete array; delete in; delete out;&#125;int Graph::Index(string str)&#123; for( int i=0; i&lt;vexNum; i++)&#123; if( vex[i]==str)&#123; return i; &#125; &#125; return -1;&#125;void Graph::countDegree()&#123; for(int i=0; i&lt;vexNum; i++)&#123; for( int j=0; j&lt;vexNum; j++)&#123; if( array[i][j]==1)&#123; out[i]++; in[j]++; &#125; &#125; &#125;&#125;void Graph::outPut()&#123; for( int i=0; i&lt;vexNum; i++)&#123; for( int j=0; j&lt;vexNum; j++)&#123; if( j!=vexNum-1)&#123; cout &lt;&lt; array[i][j] &lt;&lt; &quot; &quot;; &#125;else&#123; cout &lt;&lt; array[i][j] &lt;&lt; endl; &#125; &#125; &#125; for( int i=0; i&lt;vexNum; i++)&#123; cout &lt;&lt; vex[i]; if( type==&#x27;D&#x27;)&#123; if( out[i]!=0 || in[i]!=0)&#123; cout &lt;&lt; &quot;: &quot; &lt;&lt; out[i] &lt;&lt; &quot; &quot; &lt;&lt; in[i] &lt;&lt; &quot; &quot; &lt;&lt; out[i] + in[i] &lt;&lt; endl; &#125;else&#123; cout &lt;&lt; endl; &#125; &#125;else if( type==&#x27;U&#x27; )&#123; if(out[i]!=0)&#123; cout &lt;&lt; &quot;: &quot; &lt;&lt; in[i] &lt;&lt; endl; &#125;else&#123; cout &lt;&lt; endl; &#125; &#125; &#125;&#125;int main()&#123; int t; cin &gt;&gt; t; while( t-- )&#123; Graph myGraph; myGraph.countDegree(); myGraph.outPut(); &#125; return 0;&#125; DS图—图的最短路径（不含代码框架）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;using namespace std;const int maxn = 105;const int INF = 0x3f3f3f3f;int Graph[maxn][maxn];int n;map&lt;string, int&gt; name;bool vis[maxn];int dis[maxn];int from[maxn];void init()&#123; for(int i = 0; i &lt; maxn; i++) &#123; vis[i] = false; dis[i] = INF; from[i] = i; for(int j = 0; j &lt; maxn; j++) Graph[i][j] = INF; &#125; name.clear();&#125;string getname(int i)&#123; for(map&lt;string, int&gt;::iterator it = name.begin(); it != name.end(); it++) if(it -&gt; second == i) return it -&gt; first;&#125;void dijkstra(int s)&#123; vis[s] = true; for(int i = 0; i &lt; n; i++) if(Graph[s][i] != INF) dis[i] = Graph[s][i], from[i] = s; for(int N = 1; N &lt; n; N++) &#123; int minn = INF, mini = -1; for(int i = 0; i &lt; n; i++) if(!vis[i] &amp;&amp; dis[i] &lt; minn) minn = dis[i], mini = i; if(mini != -1) &#123; vis[mini] = true; for(int i = 0; i &lt; n; i++) if(!vis[i] &amp;&amp; dis[i] &gt; Graph[mini][i] + dis[mini]) dis[i] = Graph[mini][i] + dis[mini], from[i] = mini; &#125; &#125; for(int i = 0; i &lt; n; i++) &#123; if(s == i) continue; cout &lt;&lt; getname(s) &lt;&lt; &quot;-&quot; &lt;&lt; getname(i); if(dis[i] == INF) cout &lt;&lt; &quot;--1&quot;; else &#123; int now = i; stack&lt;int&gt; ss; while(now != from[now]) &#123; ss.push(now); now = from[now]; &#125; cout &lt;&lt; &quot;-&quot; &lt;&lt; dis[i] &lt;&lt; &quot;----[&quot; &lt;&lt; getname(s) &lt;&lt; &#x27; &#x27;; while(!ss.empty()) &#123; cout &lt;&lt; getname(ss.top()) &lt;&lt; &#x27; &#x27;; ss.pop(); &#125; cout &lt;&lt;&quot;]&quot; ; &#125; cout &lt;&lt; endl; &#125;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t--) &#123; init(); cin &gt;&gt; n; string s; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; s; name[s] = i; &#125; for(int i = 0; i &lt; n; i++) for(int j = 0, x; j &lt; n; j++) &#123; cin &gt;&gt; x; if(x) Graph[i][j] = x; &#125; cin &gt;&gt; s; dijkstra(name[s]); &#125;&#125; DS二叉树—二叉树构建与遍历（不含框架）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;iostream&gt;using namespace std;class BiNode&#123; char data; BiNode *lchild; BiNode *rchild;public: BiNode():lchild(NULL),rchild(NULL)&#123;&#125; BiNode(char e):data(e),lchild(NULL), rchild(NULL)&#123;&#125; ~BiNode()&#123; delete lchild; delete rchild; &#125; friend class BiTree;&#125;;class BiTree&#123; BiNode *root; void CreateTree(BiNode *&amp;t); void PreOrder(BiNode *t); void MidOrder(BiNode *t); void PostOrder(BiNode *t);public: BiTree():root(NULL)&#123;&#125; ~BiTree()&#123;delete root;&#125; void CreateTree(); void PreOrder(); void MidOrder(); void PostOrder();&#125;;void BiTree::CreateTree(BiNode *&amp;t)&#123; char c; cin &gt;&gt; c; if( c!=&#x27;#&#x27; ) &#123; t = new BiNode(c); CreateTree(t-&gt;lchild); CreateTree(t-&gt;rchild); &#125;else&#123; t=NULL; &#125;&#125;void BiTree::CreateTree()&#123; CreateTree(root);&#125;void BiTree::PreOrder(BiNode *t)&#123; if(t) &#123; cout &lt;&lt; t-&gt;data; PreOrder(t-&gt;lchild); PreOrder(t-&gt;rchild); &#125;&#125;void BiTree::PreOrder()&#123; PreOrder(root); cout &lt;&lt; endl;&#125;void BiTree::MidOrder(BiNode *t)&#123; if(t) &#123; MidOrder(t-&gt;lchild); cout &lt;&lt; t-&gt;data; MidOrder(t-&gt;rchild); &#125;&#125;void BiTree::MidOrder()&#123; MidOrder(root); cout &lt;&lt; endl;&#125;void BiTree::PostOrder(BiNode *t)&#123; if(t) &#123; PostOrder(t-&gt;lchild); PostOrder(t-&gt;rchild); cout &lt;&lt; t-&gt;data; &#125;&#125;void BiTree::PostOrder()&#123; PostOrder(root); cout &lt;&lt; endl;&#125;int main()&#123; int t; cin &gt;&gt; t; while( t-- ) &#123; BiTree tree; tree.CreateTree(); tree.PreOrder(); tree.MidOrder(); tree.PostOrder(); &#125; return 0;&#125; TrieTree: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;queue&gt;using namespace std;class Node &#123;public: char data; Node* childs[26];&#125;;class TrieTree &#123;public: Node* root; TrieTree() &#123; root = new Node(); &#125; void createTree(int num, string* strs) &#123; for (int j = 0; j &lt; num; j++) &#123; string str = strs[j]; int len = str.length(); Node* q = root; for (int i = 0; i &lt; len; i++) &#123; if (q-&gt;childs[str[i] - 97] == NULL) &#123; Node* node = new Node(); node-&gt;data = str.at(i); q-&gt;childs[str[i] - 97] = node; q = node; &#125; else &#123; q = q-&gt;childs[str[i] - 97]; &#125; &#125; &#125; &#125; void BFSTraverse() &#123; Node* q = root; queue&lt;Node*&gt; que; que.push(q); while (que.empty() == false) &#123; Node* p = que.front(); que.pop(); for (int i = 0; i &lt; 26; i++) &#123; if (p-&gt;childs[i]) &#123; cout &lt;&lt; p-&gt;childs[i]-&gt;data; que.push(p-&gt;childs[i]); &#125; &#125; &#125; cout &lt;&lt; endl; &#125; void find() &#123; int n; cin &gt;&gt; n; for (int j = 0; j &lt; n; j++) &#123; string str; cin &gt;&gt; str; Node* q = root; int len = str.length(); int i = 0; for (; i &lt; len; i++) &#123; if (q-&gt;childs[str[i] - 97]) &#123; q = q-&gt;childs[str[i] - 97]; &#125; else &#123; break; &#125; &#125; int count = 0; if (i == len) &#123; queue&lt;Node*&gt; que; que.push(q); while (que.empty() == false) &#123; Node* p = que.front(); que.pop(); int flag = 0; for (int k = 0; k &lt; 26; k++) &#123; if (p-&gt;childs[k]) &#123; que.push(p-&gt;childs[k]); flag = 1; &#125; &#125; if (flag == 0) &#123; count++; &#125; &#125; &#125; cout &lt;&lt; count &lt;&lt; endl; &#125; &#125;&#125;;int main() &#123; char ch; int num = 0; string strs[1000]; while ((ch = getchar()) != EOF) &#123; if (ch == &#x27;\\n&#x27;) &#123; num++; TrieTree tree; tree.createTree(num, strs); tree.BFSTraverse(); tree.find(); for (int i = 0; i &lt; num; i++) &#123; strs[i] = &quot;\\0&quot;; &#125; num = 0; &#125; else if (ch == &#x27; &#x27;) &#123; num++; &#125; else &#123; strs[num] += ch; &#125; &#125;&#125; dancing party: 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; queue&lt;string&gt; m, f; cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++ ) &#123; string name, s; cin &gt;&gt; name &gt;&gt; s; if(s == &quot;F&quot;) f.push(name); else m.push(name); &#125; while(!m.empty() &amp;&amp; !f.empty()) &#123; cout &lt;&lt; f.front() &lt;&lt; &quot; &quot; &lt;&lt; m.front() &lt;&lt; endl; f.pop(), m.pop(); &#125; if(!m.empty()) cout &lt;&lt; &quot;M:&quot; &lt;&lt; m.size() &lt;&lt; endl; else if(!f.empty()) cout &lt;&lt; &quot;F:&quot; &lt;&lt; f.size() &lt;&lt; endl;&#125; 追星: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;iostream&gt;using namespace std; int MaxLen;const int MaxDist=9999;class Map&#123;private: int **Matrix; int Vexnum;public: void SetMatrix(int vnum,int **mx); void ShortestPath_DIJ(int v0); void refree() &#123; for(int i=0;i&lt;Vexnum;i++) delete [] Matrix[i]; delete []Matrix; &#125;&#125;;void Map::SetMatrix(int vnum,int **mx)&#123; int i,j; Vexnum = vnum; Matrix=new int* [MaxLen]; for(i=0;i&lt;MaxLen;i++) &#123; Matrix[i]=new int[MaxLen]; for(j=0;j&lt;MaxLen;j++) Matrix[i][j]=MaxDist; &#125; for(i=0;i&lt;Vexnum;i++) for(j=0;j&lt;Vexnum;j++) if(mx[i][j]) Matrix[i][j]=mx[i][j];&#125;void Map::ShortestPath_DIJ(int v0)&#123; int i,j,v,w,mmin; int *dist = new int[Vexnum]; bool *final = new bool[Vexnum]; int path[Vexnum][Vexnum]; int len[Vexnum]; for(int i = 0; i &lt; Vexnum; i++) &#123; final[i]=false; dist[i]=Matrix[v0][i]; &#125; for(int i=0;i&lt;Vexnum;i++) &#123; path[i][0]=v0; path[i][1]=i; &#125; for(int i = 0;i&lt;Vexnum;i++) &#123; len[i]=2; &#125; dist[v0]=0; final[v0]=true; for(int i=0;i&lt;Vexnum;i++) &#123; mmin=MaxDist; for(int j=0;j&lt;Vexnum;j++) &#123; if(!final[j] &amp;&amp; mmin &gt; dist[j]) &#123; mmin=dist[j]; v=j; &#125; &#125; if(mmin==MaxDist || v==Vexnum-1) //一旦v0到vN的最短路径取到，就可以停止 break; else &#123; final[v]=true; for(int j=0;j&lt;Vexnum;j++) &#123; if(!final[j] &amp;&amp; Matrix[v][j]+mmin&lt;dist[j]) &#123; dist[j]=Matrix[v][j]+mmin; for(int p=0;p&lt;len[v];p++) &#123; path[j][p]=path[v][p]; &#125; len[j]=len[v]+1; path[j][len[j]-1]=j; &#125; &#125; &#125; &#125; cout&lt;&lt;dist[Vexnum-1]&lt;&lt;endl; delete []dist; delete []final;&#125;int main()&#123; int t,k,v1,v2,distan; int vnum,v0; int **mx; Map test; while(cin&gt;&gt;vnum) &#123; MaxLen=vnum; mx=new int* [MaxLen]; for(int i=0;i&lt;MaxLen;i++) &#123; mx[i]=new int[MaxLen]; &#125; cin&gt;&gt;t; for(int i=0;i&lt;vnum;i++) for(int j=0;j&lt;vnum;j++) mx[i][j]=MaxDist; while(t--) &#123; cin&gt;&gt;v1&gt;&gt;v2&gt;&gt;distan; mx[v1-1][v2-1]=mx[v1-1][v2-1]&lt;distan?mx[v1-1][v2-1]:distan; //转换成邻接矩阵要取小的那个 mx[v2-1][v1-1]=mx[v2-1][v1-1]&lt;distan?mx[v2-1][v1-1]:distan; &#125; test.SetMatrix(vnum,mx); test.ShortestPath_DIJ(0); test.refree(); for(int i=0;i&lt;vnum;i++) delete [] mx[i]; delete []mx; &#125; return 0;&#125; 拯救公主 (Ver. I): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;class Box&#123; int x; int y; int di; int step;//用来记录该格位于广度遍历的第几层public: Box(); friend class Maze;&#125;;class Maze&#123;private: int n, m; int **maze; int directx[4], directy[4];public: Maze(int n1, int m1); ~Maze(); int FindPath();&#125;;Box::Box()&#123; x = 1; y = 1; di = 0; step = 0;&#125;Maze::Maze(int n1, int m1)&#123; n = n1+2; m = m1+2; maze = new int*[n]; for(int i=0; i&lt;n; i++) &#123; maze[i] = new int[m]; for(int j=0; j&lt;m; j++) &#123; char ch; if(0&lt;i &amp;&amp; i&lt;n-1 &amp;&amp; 0&lt;j &amp;&amp; j&lt;m-1) &#123; cin&gt;&gt;ch; if(ch==&#x27;.&#x27;) maze[i][j] = 0; else maze[i][j] = 1; &#125; else maze[i][j] = 1; &#125; &#125; directx[0] = 0, directx[1] = 1, directx[2] = 0, directx[3] = -1; directy[0] = 1, directy[1] = 0, directy[2] = -1, directy[3] = 0;&#125;Maze::~Maze()&#123; for(int i=0; i&lt;n; i++) delete []maze[i]; delete []maze;&#125;int Maze::FindPath()&#123; Box temp; queue&lt;Box&gt; q; q.push(temp); maze[1][1] = 1; while(!q.empty()) &#123; temp = q.front(); q.pop(); int line = temp.x; int col = temp.y; int di = temp.di; int step = temp.step; while(di&lt;4) &#123; int x = line+directx[di]; int y = col+directy[di]; if(!maze[x][y]) &#123; temp.x = x; temp.y = y; temp.di = 0; temp.step = step+1; q.push(temp); maze[x][y] = 1; if(x==n-2 &amp;&amp; y==m-2) &#123;//一旦有某一条到达了终点，则说明其是所有通路中最短的，将其step输出即可 cout&lt;&lt;&quot;It takes &quot;&lt;&lt;temp.step&lt;&lt;&quot; seconds to reach the target position.&quot;&lt;&lt;endl; return 1; &#125; &#125; di++; &#125; &#125; cout&lt;&lt;&quot;God please help our poor hero.&quot;&lt;&lt;endl; return 0;&#125;int main(void)&#123; int n, m; while(cin&gt;&gt;n&gt;&gt;m) &#123; Maze myMaze(n, m); myMaze.FindPath(); &#125; return 0;&#125; 关键路径-STL版: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;queue&gt;using namespace std;class Vertex&#123;public: int indexNo; bool hasEnterQueue; int early; int later; Vertex(int indexNo) &#123; this-&gt;indexNo = indexNo; hasEnterQueue = false; early = -1; later = 0x7ffff; &#125; void updateEarly(int parentEarly,int edgeValue) &#123; int newEarly = parentEarly + edgeValue; if(newEarly &gt; this-&gt;early) this-&gt;early = newEarly; &#125; void updateLater(int childLater,int edgeValue) &#123; int newLater = childLater - edgeValue; if(newLater &lt; this-&gt;later) this-&gt;later = newLater; &#125;&#125;;class Graph&#123;public: vector&lt;Vertex&gt; vertexes; vector&lt;vector&lt;int&gt; &gt; adjMat; int n; void readVertexes() &#123; cin&gt;&gt;n; //将顶点数读入成员变量n int i = 0; for(; i &lt; n; ++i) //初始化vertexes数组 &#123; Vertex v(i); vertexes.push_back(v); &#125; for(i = 0; i &lt; n; i++) //初始化adjMat数组 &#123; vector&lt;int&gt; row; int j = 0; for(; j &lt; n; ++j) &#123; row.push_back(0); &#125; adjMat.push_back(row); &#125; &#125; void readAdjMatrix() &#123; int edges; cin&gt;&gt;edges; int i = 0; int s,t,w; for(; i &lt; edges; ++i) //读入s,t,w，并将adjMat的第s行、第t列的值改为w. &#123; cin&gt;&gt;s&gt;&gt;t&gt;&gt;w; adjMat[s][t] = w; &#125; &#125; void updateEarly(int parentNo,queue&lt;int&gt; &amp;earlyQue) //更新最早开始时间 &#123; int parentEarly = vertexes[parentNo].early; //读入父结点early值 int j = 0; for(; j &lt; n; ++j) &#123; int edgeValue = adjMat[parentNo][j]; if(edgeValue == 0) //若父结点与结点j没有边相连，pass continue; Vertex &amp;child = vertexes[j]; child.updateEarly(parentEarly,edgeValue); //更新子结点j的early信息 if(!child.hasEnterQueue) &#123; child.hasEnterQueue = true; earlyQue.push(j); //将子结点加入队列 &#125; &#125; &#125; void updateLater(int childNo,queue&lt;int&gt; &amp;laterQue) //更新最晚开始时间 &#123; int parentLater = vertexes[childNo].later; //同理 int j = 0; for(; j &lt; n; ++j) &#123; int edgeValue = adjMat[j][childNo]; if(edgeValue == 0) continue; Vertex &amp;parent = vertexes[j]; parent.updateLater(parentLater,edgeValue); if(!parent.hasEnterQueue) &#123; parent.hasEnterQueue = true; laterQue.push(j); &#125; &#125; &#125; int getRoot() //获取入度为0的顶点 &#123; int j = 0; for(; j &lt; n; ++j) &#123; int i=0; for(; i &lt; n &amp;&amp; adjMat[i][j] == 0; ++i); if(i &gt;= n) return j; &#125; return -1; &#125; int getLeaf() //获取出度为0的顶点 &#123; int j = 0; for(; j &lt; n; ++j) &#123; int i = 0; for(; i &lt; n &amp;&amp; adjMat[j][i] == 0; ++i); if(i &gt;= n) return j; &#125; return -1; &#125; void printEarlyLater(bool isEarly) //输出，参数是1表示输出最早，参数是0表示输出最晚 &#123; int i = 0; for(; i &lt; n; ++i) &#123; Vertex &amp;v = vertexes[i]; if(isEarly) cout&lt;&lt;v.early&lt;&lt;&#x27; &#x27;; else cout&lt;&lt;v.later&lt;&lt;&#x27; &#x27;; &#125; cout&lt;&lt;endl; &#125; void findEarly() //执行关键路径算法，求每个顶点的最早开始时间。 &#123; int r = getRoot(); Vertex &amp;root = vertexes[r]; root.hasEnterQueue = true; root.early = 0; queue&lt;int&gt; que; que.push(r); while(!que.empty()) &#123; int p = que.front(); que.pop(); updateEarly(p,que); &#125; printEarlyLater(true); &#125; void clearEnterQueue() //重置各顶点标志的信息 &#123; for(int i = 0; i &lt; n; ++i) vertexes[i].hasEnterQueue = false; &#125; void findLater() //执行关键路径算法，求每个顶点的最玩开始时间。 &#123; clearEnterQueue(); int r = getLeaf(); Vertex &amp;parent = vertexes[r]; parent.hasEnterQueue = true; parent.later = parent.early; queue&lt;int&gt; que; que.push(r); while(!que.empty()) &#123; int p = que.front(); que.pop(); updateLater(p,que); &#125; printEarlyLater(false); &#125; void start() //开始函数：依次执行初始化、求最早、求最晚 &#123; readVertexes(); readAdjMatrix(); findEarly(); findLater(); &#125;&#125;;int main()&#123; int t=1; while(t--) &#123; Graph g; g.start(); &#125; return 0;&#125; 冒泡排序: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;using namespace std;class Array&#123; int *array; int len;public: Array(int n); ~Array(); void BubbleSort();&#125;;Array::Array(int n)&#123; len = n; array = new int[n]; for(int i=0; i&lt;n; i++)&#123; cin &gt;&gt; array[i]; &#125;&#125;Array::~Array()&#123; delete[] array; len = 0;&#125;void Array::BubbleSort()&#123; int i, j, temp, count = 0; for(i=0; i&lt;len-1; i++)&#123; for( j=len-1; j&gt;i; j--)&#123; if( array[j]&lt;array[j-1] )&#123; temp = array[j]; array[j] = array[j-1]; array[j-1] = temp; count ++ ; &#125; &#125; &#125; cout &lt;&lt; count &lt;&lt; endl;&#125;int main()&#123; int n; while( cin &gt;&gt; n)&#123; Array myArray(n); myArray.BubbleSort(); &#125; return 0;&#125; 前驱后继（DS线性结构）: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;using namespace std;class ListNode&#123; int data; ListNode *next; ListNode *pre; ListNode():next(NULL),pre(NULL)&#123;&#125; ListNode(int e):data(e),next(NULL),pre(NULL)&#123;&#125; friend class LinkList;&#125;;class LinkList&#123; ListNode *head; ListNode *tail;public: LinkList(); void Init(int n); void Search(int key);&#125;;LinkList::LinkList() &#123; head = new ListNode; tail = new ListNode; tail-&gt;pre = head; head-&gt;next = tail;&#125;void LinkList::Init(int n) &#123; int value; ListNode *p; cin &gt;&gt; value; p = new ListNode(value); p-&gt;next = tail; tail-&gt;pre = p; head-&gt;next = p; p-&gt;pre = head; for( int i=1; i&lt;n; i++)&#123; ListNode *q; cin &gt;&gt; value; q = new ListNode(value); q-&gt;next = tail; q-&gt;pre = tail-&gt;pre; tail-&gt;pre-&gt;next = q; tail-&gt;pre = q; &#125;&#125;void LinkList::Search(int key) &#123; ListNode *p; p = head-&gt;next; while(p-&gt;next &amp;&amp; p-&gt;data!=key)&#123; p=p-&gt;next; &#125; if(p)&#123; if( p-&gt;next==tail)&#123; cout &lt;&lt; p-&gt;pre-&gt;data &lt;&lt; endl; &#125;else if(p-&gt;pre!=head &amp;&amp; p-&gt;next!=tail)&#123; cout &lt;&lt; p-&gt;pre-&gt;data &lt;&lt; &quot; &quot; &lt;&lt; p-&gt;next-&gt;data &lt;&lt; endl; &#125;else if(p-&gt;pre==head)&#123; cout &lt;&lt; p-&gt;next-&gt;data &lt;&lt; endl; &#125; &#125;&#125;int main()&#123; int n, k, key; cin &gt;&gt; n &gt;&gt; k; LinkList myList; myList.Init(n); while(k--)&#123; cin &gt;&gt; key; myList.Search(key); &#125; return 0;&#125; 键盘坏了（DS线性结构）: 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;list&gt;using namespace std;string str;list&lt;char&gt; myList;list&lt;char&gt;::iterator it;int main()&#123; while(cin &gt;&gt; str)&#123; int len = str.length(); it = myList.begin(); for( int i=0; i&lt;len; i++)&#123; if(str[i] == &#x27;[&#x27;)&#123; it = myList.begin(); &#125;else if(str[i] == &#x27;]&#x27;)&#123; it = myList.end(); &#125;else&#123; myList.insert(it, str[i]); &#125; &#125; while(!myList.empty())&#123; cout &lt;&lt; myList.front(); myList.pop_front(); &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 六度空间（queue): 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1010;int g[N][N];bool st[N];int dist[N];int n, x, y;int bfs()&#123; queue&lt;int&gt; q; q.push(x - 1); int flag = -1; while(!q.empty()) &#123; int t = q.front(); q.pop(); for(int i = 0; i &lt; n; i ++ ) &#123; if(st[i]) continue; if(g[t][i] == 1) &#123;// cout &lt;&lt; t &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; endl; q.push(i); st[i] = true; dist[i] = dist[t] + 1; if(i == y - 1) flag = i; &#125; &#125; &#125; return flag;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t -- ) &#123; memset(st, 0, sizeof st); memset(g, 0, sizeof g); memset(dist, 0, sizeof dist); cin &gt;&gt; n &gt;&gt; x &gt;&gt; y; for(int i = 0; i &lt; n; i ++ ) for(int j = 0; j &lt; n; j ++ ) cin &gt;&gt; g[i][j]; int flag = bfs(); if(flag == -1) cout &lt;&lt; &quot;no&quot; &lt;&lt; endl; else cout &lt;&lt; dist[flag] - 1 &lt;&lt; endl; &#125; return 0;&#125; 线性表操作（list): 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;iostream&gt;#include&lt;list&gt;using namespace std;void Display(list&lt;int&gt; &amp;li)&#123; cout &lt;&lt; li.size() &lt;&lt; &quot; &quot;; for(list&lt;int&gt;::iterator it = li.begin(); it != li.end(); it++)&#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;int main()&#123; int n; cin &gt;&gt; n; list&lt;int&gt; *lists = new list&lt;int&gt;[n]; int num, e; for(int i=0; i&lt;n; i++)&#123; cin &gt;&gt; num; for( int j=0; j&lt;num; j++)&#123; cin &gt;&gt; e; lists[i].push_back(e); &#125; &#125; cin &gt;&gt; num; string ope; for(int i=0; i&lt;num; i++)&#123; cin &gt;&gt; ope; if(ope == &quot;insert&quot;)&#123; int no, index, ele; cin &gt;&gt; no &gt;&gt; index &gt;&gt; ele; list&lt;int&gt; li = lists[no-1]; if(index &gt;= 1 &amp;&amp; index &lt;= li.size()+1)&#123; list&lt;int&gt;::iterator it = li.begin(); for(int k=0; k&lt;index-1; k++)&#123; it++; &#125; li.insert(it,ele); &#125; lists[no-1] = li; Display(lists[no-1]); &#125;else if(ope == &quot;delete&quot;)&#123; int no, index; cin &gt;&gt; no &gt;&gt; index; list&lt;int&gt; li = lists[no-1]; if( index&gt;=1 &amp;&amp; index &lt;= li.size() )&#123; list&lt;int&gt;::iterator it = li.begin(); for(int k=0; k&lt;index-1; k++)&#123; it++; &#125; li.erase(it); &#125; lists[no-1] = li; Display(lists[no-1]); &#125;else if(ope==&quot;merge&quot;)&#123; int no1, no2; cin &gt;&gt; no1 &gt;&gt; no2; list&lt;int&gt; li1 = lists[no1-1]; list&lt;int&gt; li2 = lists[no2-1]; li1.sort(); li2.sort(); li1.merge(li2); lists[no1-1] = li1; li2.clear(); lists[no2-1] = li2; Display(lists[no1-1]); &#125;else if(ope==&quot;unique&quot;)&#123; int no; cin &gt;&gt; no; list&lt;int&gt; li = lists[no-1]; li.sort(); li.reverse(); li.unique(); lists[no-1] = li; Display(lists[no-1]); &#125;else if(ope == &quot;display&quot;)&#123; int no; cin &gt;&gt; no; Display(lists[no-1]); &#125; &#125;&#125; 堆的后序遍历（DS排序）: 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;void heapSort(int i, int n, int* a) &#123; int j = 2 * i; while (j &lt;= n) &#123; if (j &lt; n &amp;&amp; a[j] &gt; a[j + 1]) &#123; j++; &#125; if (a[j] &lt; a[i]) &#123; a[0] = a[i]; a[i] = a[j]; a[j] = a[0]; &#125; i = j; j = 2 * i; &#125;&#125;void postOrder(int i, int n, int* a) &#123; if (i &lt;= n) &#123; postOrder(2 * i, n, a); postOrder(2 * i + 1, n, a); cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; int* a = new int[n + 1]; for (int i = 1; i &lt; n + 1; i++) &#123; cin &gt;&gt; a[i]; &#125; for (int i = n / 2; i &gt;= 0; i--) &#123; heapSort(i, n, a); &#125; postOrder(1, n, a);&#125; 多项式运算（链表): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241#include &lt;iostream&gt;using namespace std;#define ok 0class ListNode &#123;public: int data; // 系数 int index; //指数 ListNode *next; ListNode() &#123; next = NULL; &#125;&#125;;class LinkList &#123;private: ListNode *head; // 代码规范 int len;public: LinkList() &#123; head = new ListNode; len = 0; &#125; ~LinkList() &#123; ListNode *p,*q; p=head; while(p != NULL) &#123; q = p; p = p-&gt;next; delete q; &#125; len = 0; head = NULL; &#125; ListNode createList(int n) &#123; len = n; ListNode* pnew = NULL; ListNode* tail = NULL; head-&gt;data = 0; head-&gt;next = NULL; tail = head; for ( int i = 1; i &lt; len + 1; i++) &#123; pnew = new ListNode(); cin &gt;&gt; pnew-&gt;data &gt;&gt; pnew-&gt;index; pnew-&gt;next = NULL; tail-&gt;next = pnew; tail = pnew; &#125; return *head; &#125; void LL_display() &#123; ListNode *p = head-&gt;next; if(head-&gt;next == NULL) &#123; cout&lt;&lt;&quot;0&quot;&lt;&lt;endl; return; &#125; while(p) &#123; if(p-&gt;index == 0 ) &#123; cout&lt;&lt;p-&gt;data; &#125; else if(p-&gt;index == 1) &#123; if(p-&gt;data &gt; 1) &#123; cout&lt;&lt;&quot;+&quot;&lt;&lt;p-&gt;data&lt;&lt;&quot;x&quot;; &#125; else if(p-&gt;data &lt; -1) &#123; cout&lt;&lt;p-&gt;data&lt;&lt;&quot;x&quot;; &#125; else if(p-&gt;data == -1)&#123; cout&lt;&lt;&quot;-x&quot;; &#125;else&#123; cout&lt;&lt;&quot;+x&quot;; &#125; &#125; if(p-&gt;index &gt; 1) &#123; if(p-&gt;data &gt; 1) &#123; cout&lt;&lt;&quot;+&quot;&lt;&lt;p-&gt;data&lt;&lt;&quot;x^&quot;&lt;&lt;p-&gt;index; &#125; else if(p-&gt;data &lt; -1) &#123; cout&lt;&lt;p-&gt;data&lt;&lt;&quot;x^&quot;&lt;&lt;p-&gt;index; &#125; else if(p-&gt;data == -1)&#123; cout&lt;&lt;&quot;-x^&quot;&lt;&lt;p-&gt;index; &#125; else &#123; cout&lt;&lt;&quot;+x^&quot;&lt;&lt;p-&gt;index; &#125; &#125; p = p-&gt;next; &#125; cout&lt;&lt;endl; return; &#125; LinkList *add(LinkList *b) &#123; LinkList *temp = new LinkList(); ListNode *t = (*temp).head; //(*temp) ListNode *p = head-&gt;next; ListNode *q = b-&gt;head-&gt;next; while(p &amp;&amp; q) &#123; ListNode *m = new ListNode; if(p-&gt;index == q-&gt;index) &#123; //如果指数相同则相加 m-&gt;data = p-&gt;data + q-&gt;data; if(m-&gt;data != 0) &#123; m-&gt;index = p-&gt;index; t-&gt;next = m; t = m; m-&gt;next = NULL; temp-&gt;len++; // 链表长度+1 &#125; p = p-&gt;next; q = q-&gt;next; continue; //直接进入下一个循环，避免浪费时间运行下面的判断语句 &#125; if(p-&gt;index &lt; q-&gt;index) &#123; //谁的指数小谁在前面加入链表 m-&gt;data = p-&gt;data; m-&gt;index = p-&gt;index; t-&gt;next = m; t = m; p = p-&gt;next; temp-&gt;len++; continue; &#125; if(p-&gt;index &gt; q-&gt;index) &#123; m-&gt;data = q-&gt;data; m-&gt;index = q-&gt;index; t-&gt;next = m; t = m; q = q-&gt;next; temp-&gt;len++; &#125; &#125; while(p) &#123; ListNode *m = new ListNode; m-&gt;data = p-&gt;data; m-&gt;index = p-&gt;index; t-&gt;next = m; t = m; p = p-&gt;next; &#125; while(q) &#123; ListNode *m = new ListNode; m-&gt;data = q-&gt;data; m-&gt;index = q-&gt;index; t-&gt;next = m; t = m; q = q-&gt;next; &#125; return temp; &#125; LinkList *sub(LinkList *b) &#123; LinkList *temp = new LinkList(); ListNode *t = (*temp).head; ListNode *p = head-&gt;next; ListNode *q = b-&gt;head-&gt;next; while(p &amp;&amp; q) &#123; ListNode *m = new ListNode; if(p-&gt;index == q-&gt;index) &#123; m-&gt;data = p-&gt;data - q-&gt;data; if(m-&gt;data != 0) &#123; m-&gt;index = p-&gt;index; t-&gt;next = m; t = m; temp-&gt;len++; &#125; p = p-&gt;next; q = q-&gt;next; continue; &#125; if(p-&gt;index &lt; q-&gt;index) &#123; m-&gt;data = p-&gt;data; m-&gt;index = p-&gt;index; t-&gt;next = m; t = m; p = p-&gt;next; temp-&gt;len++; continue; &#125; if(p-&gt;index &gt; q-&gt;index) &#123; m-&gt;data = -q-&gt;data; // 这里减数应该为负 m-&gt;index = q-&gt;index; t-&gt;next = m; t = m; q = q-&gt;next; temp-&gt;len++; &#125; &#125; while(p) &#123; ListNode *m = new ListNode; m-&gt;data = p-&gt;data; m-&gt;index = p-&gt;index; t-&gt;next = m; t = m; p = p-&gt;next; temp-&gt;len++; &#125; while(q) &#123; ListNode *m = new ListNode; m-&gt;data = q-&gt;data; m-&gt;index = q-&gt;index; t-&gt;next = m; t = m; q = q-&gt;next; temp-&gt;len++; &#125; return temp; &#125; LinkList *mul(LinkList *b) &#123; LinkList *temp1 = new LinkList(); //存放相乘的结果 ListNode *p = head-&gt;next; while(p) &#123; LinkList *temp2 = new LinkList(); ListNode *t2 = (*temp2).head; //让第一个多项式的第i项乘以第二个多项式的每一项,存放到temp2 ListNode *q = (*b).head-&gt;next; //循环一次后重新把 while(q) &#123; ListNode *m = new ListNode; m-&gt;data = q-&gt;data * p-&gt;data; m-&gt;index = q-&gt;index + p-&gt;index; t2-&gt;next = m; t2 = m; q = q-&gt;next; &#125; temp1 = temp1-&gt;add(temp2); //把每一个第i项相乘的答案temp2 相加到一起就是最终结果 p = p-&gt;next; &#125; return temp1; &#125;&#125;;int main() &#123; int data, index, n, n1 ,n2; cin&gt;&gt;n; while(n--) &#123; LinkList *a = new LinkList(); cin&gt;&gt;n1; //第一个多项式的项数 a-&gt;createList(n1); LinkList *b = new LinkList(); cin&gt;&gt;n2; b-&gt;createList(n2); LinkList *c; c = a-&gt;add(b); c-&gt;LL_display(); //用指针调用 c = a-&gt;sub(b); c-&gt;LL_display(); c = a-&gt;mul(b); c-&gt;LL_display(); &#125;&#125; 图的顶点可达闭包: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;struct matrix&#123; bool x[100][100];&#125;;matrix Matrix_Multiply(matrix a, matrix b, int n)&#123; matrix c; for( int i=0; i&lt;n; i++)&#123; for( int j=0; j&lt;n; j++)&#123; for( int k=0; k&lt;n; k++)&#123; c.x[i][j] += a.x[i][k]*b.x[k][j]; &#125; &#125; &#125; return c;&#125;int main()&#123; int n; cin &gt;&gt; n; matrix array, b, a; for( int i=0; i&lt;n; i++)&#123; for( int j=0; j&lt;n; j++)&#123; cin &gt;&gt; array.x[i][j]; b.x[i][j] = array.x[i][j]; &#125; &#125; for( int i=1; i&lt;n; i++)&#123; a=Matrix_Multiply(b,array,n); for( int i=0; i&lt;n; i++)&#123; for( int j=0; j&lt;n; j++)&#123; b.x[i][j] += a.x[i][j]; &#125; &#125; &#125; for( int i=0; i&lt;n; i++)&#123; for( int j=0; j&lt;n; j++)&#123; cout &lt;&lt; b.x[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125;&#125; 二叉树后序线索（DS树）: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;iostream&gt;using namespace std;class BiNode&#123; char data; BiNode *lChild; BiNode *rChild; BiNode():lChild(NULL),rChild(NULL)&#123;&#125; BiNode(char e):data(e),lChild(NULL),rChild(NULL)&#123;&#125; friend class BiTree;&#125;;class BiTree&#123; BiNode *root; int cnt=0; char post_array[10000]; void CreateTree(BiNode *&amp;t); void Post(BiNode *&amp;t);public: void Post(); void CreateTree(); ~BiTree(); void Search(char key);&#125;;void BiTree::Search(char key) &#123; int i=0; for(i=0; i&lt;cnt; i++)&#123; if(post_array[i] == key)&#123; break; &#125; &#125; if( i==0 )&#123; cout &lt;&lt; &quot;-1 &quot; &lt;&lt; post_array[i+1] &lt;&lt; endl; &#125;else if( i==cnt-1 )&#123; cout &lt;&lt; post_array[i-1] &lt;&lt; &quot; -1&quot; &lt;&lt; endl; &#125;else if( i==cnt )&#123; cout &lt;&lt; &quot;ERROR&quot; &lt;&lt; endl; &#125;else&#123; cout &lt;&lt; post_array[i-1] &lt;&lt; &quot; &quot; &lt;&lt; post_array[i+1] &lt;&lt; endl; &#125;&#125;void BiTree::Post(BiNode *&amp;t) &#123; if(t)&#123; Post(t-&gt;lChild); Post(t-&gt;rChild); post_array[cnt] = t-&gt;data; cnt++; &#125;&#125;void BiTree::Post() &#123; Post(root);&#125;BiTree::~BiTree() &#123; delete root;&#125;void BiTree::CreateTree(BiNode *&amp;t) &#123; char e; cin &gt;&gt; e; if(e!=&#x27;0&#x27;)&#123; t = new BiNode(e); CreateTree(t-&gt;lChild); CreateTree(t-&gt;rChild); &#125;else&#123; t = NULL; &#125;&#125;void BiTree::CreateTree() &#123; CreateTree(root);&#125;int main()&#123; int n; cin &gt;&gt; n; while (n--)&#123; BiTree myTree; myTree.CreateTree(); myTree.Post(); char key; cin &gt;&gt; key; myTree.Search(key); cin &gt;&gt; key; myTree.Search(key); &#125; return 0;&#125; 图的应用之——图的连通: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;iostream&gt;using namespace std;class Graph&#123; int vexNum; int **array, **array1, **array2, **array3;public: Graph(); ~Graph(); void Multiply(); void Addition(); void Final();&#125;;void Graph::Final() &#123; bool final = 1; for(int i=0; i&lt;vexNum; i++)&#123; for(int j=0; j&lt;vexNum; j++)&#123; if(i==j)&#123; continue; &#125; if(array2[i][j]==0)&#123; final = 0; break; &#125; &#125; &#125; if(final==1)&#123; cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; &#125;else&#123; cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125;&#125;void Graph::Addition() &#123; for(int i=1; i&lt;vexNum; i++)&#123; Multiply(); for( int j=0; j&lt;vexNum; j++)&#123; for( int k=0; k&lt;vexNum; k++)&#123; array2[j][k] += array3[j][k]; &#125; &#125; &#125;&#125;void Graph::Multiply() &#123; for( int i=0; i&lt;vexNum; i++)&#123; for( int j=0; j&lt;vexNum; j++)&#123; for( int k=0; k&lt;vexNum; k++)&#123; array3[i][j] += array[i][k]*array1[k][j]; &#125; &#125; &#125; for(int i=0; i&lt;vexNum; i++)&#123; for(int j=0; j&lt;vexNum; j++)&#123; array1[i][j] = array3[i][j]; &#125; &#125;&#125;Graph::~Graph() &#123; for(int i=0; i&lt;vexNum; i++)&#123; delete[] array[i]; delete[] array1[i]; delete[] array2[i]; delete[] array3[i]; &#125; delete[] array; delete[] array1; delete[] array2; delete[] array3; vexNum = 0;&#125;Graph::Graph() &#123; cin &gt;&gt; vexNum; array = new int*[vexNum]; array1 = new int*[vexNum]; array2 = new int*[vexNum]; array3 = new int*[vexNum]; for(int i=0; i&lt;vexNum; i++)&#123; array[i] = new int[vexNum]; array1[i] = new int[vexNum]; array2[i] = new int[vexNum]; array3[i] = new int[vexNum]; for( int j=0; j&lt;vexNum; j++)&#123; cin &gt;&gt; array[i][j]; array1[i][j] = array[i][j]; array2[i][j] = array[i][j]; array3[i][j] = 0; &#125; &#125;&#125;int main()&#123; int t; cin &gt;&gt; t; while( t-- )&#123; Graph myGraph; myGraph.Addition(); myGraph.Final(); &#125;&#125; 图综合练习–构建邻接表: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;iostream&gt;using namespace std;class Node&#123; int pos; Node *next;public: Node():next(NULL)&#123;&#125; Node(int position):pos(position),next(NULL)&#123;&#125; friend class AdjList;&#125;;class AdjList&#123; int vexNum; int arcNum; char *vex; Node *heads; int Index(char c);public: AdjList(); ~AdjList(); void outPut();&#125;;AdjList::AdjList()&#123; cin &gt;&gt; vexNum &gt;&gt; arcNum; vex = new char[vexNum]; for( int i=0; i&lt;vexNum; i++)&#123; cin &gt;&gt; vex[i]; &#125; heads = new Node[vexNum]; for( int i=0; i&lt;arcNum; i++)&#123; char c1, c2; cin &gt;&gt; c1 &gt;&gt; c2; int num1 = Index(c1), num2 = Index(c2); Node *p = &amp;heads[num1]; while(p-&gt;next)&#123; p=p-&gt;next; &#125; Node *s = new Node; s-&gt;pos = num2; p-&gt;next = s; &#125;&#125;AdjList::~AdjList()&#123; delete []vex; for( int i=0; i&lt;vexNum; i++)&#123; Node *p = heads[i].next; while(p)&#123; Node *q = p; p=p-&gt;next; delete q; &#125; &#125; delete []heads;&#125;int AdjList::Index(char c)&#123; for( int i=0; i&lt;vexNum; i++)&#123; if(c==vex[i])&#123; return i; &#125; &#125; return -1;&#125;void AdjList::outPut()&#123; for( int i=0; i&lt;vexNum; i++)&#123; cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; vex[i]; Node *p = heads[i].next; while(p)&#123; cout &lt;&lt; &quot;-&quot; &lt;&lt; p-&gt;pos; p=p-&gt;next; &#125; cout &lt;&lt; &quot;-^&quot; &lt;&lt; endl; &#125;&#125;int main()&#123; int t; cin &gt;&gt; t; while(t--)&#123; AdjList myAdjList; myAdjList.outPut(); &#125; return 0;&#125; 中后序遍历构建二叉树（DS树）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;using namespace std;class BiNode&#123; int data; BiNode *lChild; BiNode *rChild; BiNode():lChild(NULL),rChild(NULL)&#123;&#125; friend class BiTree;&#125;;class BiTree&#123; BiNode *root; int *midOrder; int *postOrder; int len; void PreOrder(BiNode *&amp;t);public: int min; BiTree(int n, int *mid, int *post); BiNode *CreateTree(int left, int right, int root); void PreOrder();&#125;;BiTree::BiTree(int n, int *mid, int *post) &#123; min = 65535; midOrder = mid; postOrder = post; len = n; root = CreateTree(0, len-1, len-1);&#125;BiNode *BiTree::CreateTree(int left, int right, int root) &#123; if(right &lt; left)&#123; return NULL; &#125; int newRoot; BiNode *t = new BiNode; for(int i=left; i&lt;=right; i++)&#123; if(midOrder[i]==postOrder[root])&#123; newRoot = i; break; &#125; &#125; t-&gt;data = postOrder[root]; t-&gt;lChild = CreateTree(left, newRoot-1, root-1-(right-newRoot)); t-&gt;rChild = CreateTree(newRoot+1,right, root-1);&#125;void BiTree::PreOrder(BiNode *&amp;t) &#123; if(t)&#123; if(t-&gt;lChild == NULL &amp;&amp; t-&gt;rChild == NULL)&#123; if(t-&gt;data&lt;min)&#123; min = t-&gt;data; &#125; &#125; PreOrder(t-&gt;lChild); PreOrder(t-&gt;rChild); &#125;&#125;void BiTree::PreOrder() &#123; PreOrder(root);&#125;int main()&#123; int n; while(cin &gt;&gt; n)&#123; int mid[10001], post[10001]; for(int i=0; i&lt;n; i++)&#123; cin &gt;&gt; mid[i]; &#125; for( int i=0; i&lt;n; i++)&#123; cin &gt;&gt; post[i]; &#125; BiTree myTree(n, mid, post); myTree.PreOrder(); cout &lt;&lt; myTree.min &lt;&lt; endl; &#125; return 0;&#125; 【动态规划】套汇问题（Floyd算法）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208#include &lt;iostream&gt;using namespace std;#define MAX_NUM 20class AdjMatrix&#123;private: double matrix[MAX_NUM][MAX_NUM]; string node[MAX_NUM]; int node_num; int arc_num; int conn_num; double value; ///路径汇率乘积 int flag; ///是否能套汇 char type; int Visit[MAX_NUM]; void DFS(int v);public: AdjMatrix(char ty, int n) &#123; type = ty; node_num = n; conn_num=0; flag=0; &#125; int getIndex(string s); void getMatrix(); void display(); void DFSTraverse();&#125;;int AdjMatrix::getIndex(string s)&#123; for(int i=0; i&lt;node_num; i++) &#123; if(node[i]==s) return i; &#125; return -1;&#125;void AdjMatrix::getMatrix()&#123; for(int i=0; i&lt;node_num; i++) for(int j=0; j&lt;node_num; j++) matrix[i][j] = 0; cin&gt;&gt;arc_num; for(int i=0; i&lt;node_num; i++) &#123; string s1; cin&gt;&gt;s1; node[i] = s1; &#125; for(int i=0; i&lt;arc_num; i++) &#123; string s1, s2; double currency; int index1, index2; cin&gt;&gt;s1; cin&gt;&gt;currency; cin&gt;&gt;s2; index1 = getIndex(s1); index2 = getIndex(s2); if(type==&#x27;D&#x27;) &#123; matrix[index1][index2] = currency; &#125; else if(type==&#x27;U&#x27;) &#123; ///这题用不到 matrix[index1][index2]++; matrix[index2][index1]++; &#125; &#125;&#125;void AdjMatrix::DFSTraverse()&#123; int v, k; int i; for(k=0; k&lt;node_num; k++) &#123; int counter=0; value=1.0; v=k; for(i=0; i&lt;node_num; i++) &#123; if(i==v) Visit[i] = 2; ///表示起始点 else Visit[i] = 0; &#125; do &#123; //cout&lt;&lt;&quot;v=&quot;&lt;&lt;v&lt;&lt;&quot; &quot;; if(Visit[v]==0 || Visit[v]==2) &#123; counter++; if(counter&gt;1) break; //表示从该点出发无法形成环，直接跳过 DFS(v); &#125; v = (v+1) % node_num; &#125;while(v!=k); //cout&lt;&lt;endl; //cout&lt;&lt;counter&lt;&lt;endl; &#125; if(flag==1) cout&lt;&lt;&quot;YES&quot;; else cout&lt;&lt;&quot;NO&quot;; cout&lt;&lt;endl;&#125;void AdjMatrix::DFS(int v)&#123; int w, i, k; //cout&lt;&lt;node[v]&lt;&lt;&quot;-&gt;&quot;; if(Visit[v]==0) Visit[v]=1; int *AdjVex = new int[node_num]; for(i=0; i&lt;node_num; i++) AdjVex[i] = -1; k = 0; ///寻找其相邻的点 for(i=0; i&lt;node_num; i++) &#123; if(matrix[v][i]!=0) ///小心 &#123; AdjVex[k] = i; k++; &#125; &#125; i=0; for(w=AdjVex[0]; w!=-1; w=AdjVex[i]) &#123; ///访问其所有相邻的点 if(Visit[w]==0) &#123; value = value*matrix[v][w]; DFS(w); &#125; else if(Visit[w]==2) //如果可以回到初始点形成环 &#123; double temp_value = value; //判定边乘积是否大于1 temp_value = temp_value*matrix[v][w]; //cout&lt;&lt;temp_value&lt;&lt;endl; if(temp_value&gt;1.0) &#123; flag = 1; &#125; &#125; i++; &#125; delete []AdjVex;&#125;void AdjMatrix::display()&#123; int i, j; for(i=0; i&lt;node_num; i++) &#123; ///输出点 cout&lt;&lt;node[i]; if(i!=node_num-1) cout&lt;&lt;&quot;\\t&quot;; &#125; cout&lt;&lt;endl; for(i=0; i&lt;node_num; i++) &#123; for(j=0; j&lt;node_num; j++) &#123; cout&lt;&lt;matrix[i][j]; if(j!=node_num-1) cout&lt;&lt;&quot;\\t&quot;; &#125; cout&lt;&lt;endl; &#125; //cout&lt;&lt;conn_num&lt;&lt;endl;&#125;int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; //char ty; int n; cin&gt;&gt;n; AdjMatrix test(&#x27;D&#x27;, n); test.getMatrix(); //test.display(); test.DFSTraverse(); //cout&lt;&lt;endl; &#125; return 0;&#125; 有向无环图上的最长路径（DS图）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;stack&gt;using namespace std;class ListNode&#123; int vertex; double weight; ListNode* next;public: ListNode() &#123; next = NULL; &#125; friend class Graph;&#125;;class Graph&#123;private: int vexnum; int edgenum; ListNode** adjlist; double** matrix; int* S; int* s; double* dist; int* path; int IsOver(); void DisplayPath(int i); void TopologicalSort();public: Graph(); ~Graph(); void Dijkstra();&#125;;Graph::Graph()&#123; int i, j; cin &gt;&gt; vexnum &gt;&gt; edgenum; adjlist = new ListNode * [vexnum]; s = new int[vexnum]; S = new int[vexnum]; dist = new double[vexnum]; path = new int[vexnum]; matrix = new double* [vexnum]; for (i = 0; i &lt; vexnum; i++) &#123; s[i] = 0; dist[i] = 0; path[i] = -1; adjlist[i] = new ListNode; matrix[i] = new double[vexnum]; for (j = 0; j &lt; vexnum; j++) matrix[i][j] = 0; &#125; for (i = 0; i &lt; edgenum; i++) &#123; ListNode* p; int startvex, endvex; double weight; cin &gt;&gt; startvex &gt;&gt; endvex &gt;&gt; weight; p = new ListNode; p-&gt;weight = weight; p-&gt;vertex = endvex; p-&gt;next = adjlist[startvex]-&gt;next; adjlist[startvex]-&gt;next = p; matrix[startvex][endvex] = weight; &#125;&#125;Graph::~Graph()&#123; delete[]adjlist; delete[]s; delete[]dist; delete[]path; for (int i = 0; i &lt; vexnum; i++) delete[]matrix[i]; delete[]matrix;&#125;int Graph::IsOver()&#123; for (int i = 0; i &lt; vexnum; i++) &#123; if (!s[i]) return 0; &#125; return 1;&#125;void Graph::DisplayPath(int i)&#123; stack&lt;int&gt; s; s.push(i); while (path[i] != -1) &#123; i = path[i]; s.push(i); &#125; while (!s.empty()) &#123; i = s.top(); s.pop(); cout &lt;&lt; i &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; endl;&#125;void Graph::TopologicalSort()&#123; int num = 0; while (!IsOver()) &#123; int i, j; for (i = 0; i &lt; vexnum; i++) &#123; if (!s[i]) &#123; for (j = 0; j &lt; vexnum; j++) &#123; if (matrix[j][i]) break; &#125; if (j == vexnum) break; &#125; &#125; s[i] = 1; S[num] = i; num++; for (j = 0; j &lt; vexnum; j++) matrix[i][j] = 0; &#125;&#125;void Graph::Dijkstra()&#123; TopologicalSort(); int i; ListNode* q; for (i = 0; i &lt; vexnum; i++) &#123; int temp = S[i]; q = adjlist[temp]; while (q-&gt;next) &#123; q = q-&gt;next; if (dist[q-&gt;vertex] &lt; dist[temp] + q-&gt;weight) &#123; dist[q-&gt;vertex] = dist[temp] + q-&gt;weight; path[q-&gt;vertex] = temp; &#125; &#125; &#125; for (i = 0; i &lt; vexnum; i++) &#123; if (i != S[0]) DisplayPath(i); &#125;&#125;int main(void)&#123; Graph myGraph; myGraph.Dijkstra();&#125;","categories":[],"tags":[]}],"categories":[{"name":"算法","slug":"算法","permalink":"http://www.misaka-9982.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"OS","slug":"OS","permalink":"http://www.misaka-9982.com/tags/OS/"},{"name":"6.S081","slug":"6-S081","permalink":"http://www.misaka-9982.com/tags/6-S081/"},{"name":"CS144","slug":"CS144","permalink":"http://www.misaka-9982.com/tags/CS144/"},{"name":"Network","slug":"Network","permalink":"http://www.misaka-9982.com/tags/Network/"},{"name":"CS61A","slug":"CS61A","permalink":"http://www.misaka-9982.com/tags/CS61A/"},{"name":"CS188","slug":"CS188","permalink":"http://www.misaka-9982.com/tags/CS188/"},{"name":"AI","slug":"AI","permalink":"http://www.misaka-9982.com/tags/AI/"},{"name":"CS61BL","slug":"CS61BL","permalink":"http://www.misaka-9982.com/tags/CS61BL/"},{"name":"Java","slug":"Java","permalink":"http://www.misaka-9982.com/tags/Java/"},{"name":"Wireshark","slug":"Wireshark","permalink":"http://www.misaka-9982.com/tags/Wireshark/"},{"name":"Acwing","slug":"Acwing","permalink":"http://www.misaka-9982.com/tags/Acwing/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://www.misaka-9982.com/tags/Algorithm/"}]}