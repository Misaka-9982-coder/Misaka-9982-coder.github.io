<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>CS144-Lab4 | Misaka's blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({google_ad_client: "ca-pub-5060306535186583", enable_page_level_ads: true});</script><meta name="generator" content="Hexo 6.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">CS144-Lab4</h1><a id="logo" href="/.">Misaka's blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a><a href="/messageboard/"><i class="fa fa fa-comments"> 留言版</i></a><a href="/link/"><i class="fa fa fa-external-link"> 友链</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">CS144-Lab4</h1><div class="post-meta">2023-02-19<span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 9.6k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 37</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><h2 id="概述-2">概述</h2>
<p>在实验0中，你实现了流量控制的字节流(<code>ByteStream</code>)的抽象概念。</p>
<p>在实验1、2和3中，你实现了该抽象概念与互联网提供的抽象概念之间的转换工具：不可靠的数据报(IP或UDP)。</p>
<p>现在，你已经接近顶峰：一个可以工作的<code>TCPConnection</code>，它结合了你的<code>TCPSender</code>和<code>TCPReceiver</code>，并能以至少100Mbit/s的速度与其他TCP实现对话。</p>
<p>图1显示了整体设计：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Misaka-9982-coder/img_hosting/img/image-20220322233230399.png" alt="image-20220322233230399"></p>
<p>图1：TCP实现中的模块和数据流的安排。</p>
<h2 id="开始-2">开始</h2>
<p>你的<code>TCPConnection</code>实现将使用与你在实验0-3中使用的相同的Sponge库，并增加了类和测试。我们将给你提供支持代码，用于将TCP段读写到用户数据报(“TCP-over-UDP”)和互联网数据报(“TCP/IP”)的有效载荷中。我们还将给你一个类(<code>CS144TCPSocket</code>)，它可以包装你的<code>TCPConnection</code>，使其表现得像一个正常的流套接字，就像你在实验0中用来实现<code>webget</code>的TCPSocket。为了开始进行作业：</p>
<ol>
<li>请确保你已经提交了你在实验3中的所有解决方案。请不要修改<code>libsponge</code>目录顶层以外的任何文件，或者<code>webget.cc</code>。否则，你可能会在合并实验4的启动代码时遇到麻烦。</li>
<li>在实验作业的存储库中，运行<code>git fetch</code>来检索实验作业的最新版本。</li>
<li>通过运行<code>git merge origin/lab4-startercode</code>，下载实验4的启动代码。</li>
<li>在<code>build</code>目录中，编译源代码：<code>make</code>(编译时可以运行<code>make -j4</code>以使用四个处理器)。</li>
<li>在<code>build</code>目录外，打开并开始编辑<code>writeups/lab4.md</code>文件。这是你实验报告的模板，将包含在你提交的内容中。</li>
</ol>
<h2 id="实验4：TCP连接">实验4：TCP连接</h2>
<p>本周，你将完成构建一个与互联网上数十亿台计算机和移动设备兼容的工作TCP实现。你已经完成了大部分的工作：你已经实现了发送方和接收方。本周你的工作是将它们”连接”起来，成为一个对象(<code>TCPConnection</code>)，并处理一些对连接来说是全局性的管家任务。</p>
<p>回顾一下：TCP可靠地传递一对受流量控制的字节流，每个方向一个。两方参与TCP连接，每一方同时作为”发送方”(自己的出站字节流)和”接收方”(入站字节流)行动：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Misaka-9982-coder/img_hosting/img/image-20230219110444953.png" alt="image-20230219110444953"></p>
<p>双方(上图中的”A”和”B”)被称为连接的”端点”，或”对等方”。你的<code>TCPConnection</code>作为其中一个对等方，负责接收和发送数据段，确保发送方和接收方被告知并有机会对他们关心的传入和传出段的字段作出贡献。</p>
<p><strong>接收段</strong>。<code>TCPConnection</code>将接收来自互联网的<code>TCPSegment</code>，并且</p>
<ul>
<li>如果<code>ACK</code>标志被设置，告诉<code>TCPSender</code>关于它在传入段上所关心的字段：<code>ackno</code>和<code>window_size</code>，并且</li>
<li>将段交给<code>TCPReceiver</code>，这样它就可以检查它所关心的传入段的字段：<code>seqno, syn, payload, fin</code>。</li>
</ul>
<p><strong>发送段</strong>。<code>TCPConnection</code>将通过互联网发送<code>TCPSegment</code>：</p>
<ul>
<li>每当<code>TCPSender</code>将一个段push到它的传出队列中时，它就会在传出段上设置它负责的字段。(<code>seqno, syn, payload, fin</code>)。</li>
<li>在发送段之前，<code>TCPConnection</code>会向<code>TCPReceiver</code>询问它负责的传出段的字段：<code>ackno</code>和<code>window_size</code>。如果有<code>ackno</code>(请记住，<code>TCPReceiver::ackno()</code>返回一个可选值。)，它将设置<code>ack</code>标志和<code>TCPSegment</code>中的字段。</li>
</ul>
<p>因此，每个<code>TCPSegment</code>的整体结构看起来像这样，”发送方 “和”接收方”字段用不同的颜色显示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Misaka-9982-coder/img_hosting/img/image-20230219110636651.png" alt="image-20230219110636651"></p>
<p><code>TCPConnection</code>的完整接口在<a target="_blank" rel="noopener" href="https://cs144.github.io/doc/lab4/class_t_c_p_connection.html">类文档</a>中。请花一些时间来阅读。你的大部分实现将涉及到将<code>TCPConnection</code>的公共API与<code>TCPSender</code>和<code>TCPReceiver</code>中的适当例程进行”连接”。你希望尽可能将任何繁重的工作推迟到你已经实现的发送方和接收方。话虽如此，但并不是所有的事情都那么简单，有一些微妙的地方涉及到整体连接的”全局”行为。最难的部分是决定何时完全终止一个TCPConnection并宣布它不再是”活动的”。</p>
<p>下面是一些常见问题和你需要处理的边缘情况的细节。</p>
<h2 id="常见问题和特殊情形">常见问题和特殊情形</h2>
<ul>
<li>
<p>你们希望有多少代码？</p>
<p>总的来说，我们预计实现(在<code>tcp_connection.cc</code>中)总共需要大约100-150行的代码。当你完成后，测试套件将广泛地测试你自己的实现以及Linux内核的TCP实现的交互性。</p>
</li>
<li>
<p>我应该如何开始？</p>
<p>最好的开始方式可能是将一些”普通”方法与<code>TCPSender</code>和<code>TCPReceiver</code>中的适当调用连接起来。这可能包括像<code>remaining_outbound_capacity()</code>，<code>bytes_in_flight()</code>以及<code>unassembled_bytes()</code>。</p>
<p>然后你可以选择实现”writer”的方法：<code>connect()</code>、<code>write()</code>和<code>end_input_stream()</code>。其中一些方法可能需要对出站的<code>ByteStream</code>(由<code>TCPSender</code>拥有)做一些事情，并告知<code>TCPSender</code>。</p>
<p>你可能会选择在你完全实现每个方法之前开始运行测试套件(<code>make check</code>)；测试的失败信息可以给你一个线索或指南，告诉你接下来要处理什么。</p>
</li>
<li>
<p>应用程序如何从入站流中读取？</p>
<p><code>TCPConnection::inbound_stream()</code>已经在头文件中实现了。</p>
</li>
<li>
<p><code>TCPConnection</code>是否需要任何花哨的数据结构或算法？</p>
<p>不，它真的不需要。繁重的工作都是由你已经实现的<code>TCPSender</code>和<code>TCPReceiver</code>完成的。这里的工作实际上只是把所有的东西连接起来，处理一些难以轻易融入发送方和接收方的连接范围内的微妙问题。</p>
</li>
<li>
<p><code>TCPConnection</code>如何实际发送一个段？</p>
<p>类似于<code>TCPSender</code>，把段push到<code>_segments_out</code>队列中。就你的<code>TCPConnection</code>而言，当你把它push到这个队列上时，就认为它已经发送了。很快，所有者会出现并pop它(使用公共的<code>segments_out()</code>访问器方法)并真正发送它。</p>
</li>
<li>
<p><code>TCPConnection</code>如何了解时间的流逝？</p>
<p>与<code>TCPSender</code>类似——<code>tick()</code>方法将被定期调用。请不要使用任何其他方式来获得时间，tick方法是你对时间流逝的唯一访问，这样可以保持事情的确定性和可测试性。</p>
</li>
<li>
<p>如果一个传入段设置了<code>RST</code>标志，<code>TCPConnection</code>会做什么？</p>
<p>这个标志(“重置”)表示连接立即终止。如果你收到一个带有<code>RST</code>的段，你应该在入站和出站的<code>ByteStreams</code>上设置错误标志，并且任何后续对<code>TCPConnection::active()</code>的调用都应该返回false。</p>
</li>
<li>
<p>什么时候应该发送一个设置了<code>RST</code>标志的段？</p>
<p>有两种情况下，你会想中止整个连接。</p>
<ol>
<li>如果发送方连续发送了太多的重传而没有成功(超过了<code>TCPConfig::MAX_RETX_ATTEMPTS</code>，即8)。</li>
<li>如果在连接仍处于活动状态时调用<code>TCPConnection</code>析构函数(<code>active()</code>返回true)。</li>
</ol>
<p>发送一个设置了<code>RST</code>的段与接收一个段的效果类似：连接已断开且不再<code>active()</code>，两个<code>ByStream</code>都应设置为错误状态。</p>
</li>
<li>
<p>等等，但我如何生成一个可以设置<code>RST</code>标志的段？序列号是什么？</p>
<p>任何流出的段都需要有适当的序列号。你可以通过调用<code>TCPSender</code>的<code>send_empty_segment()</code>方法，强制<code>TCPSender</code>生成一个具有适当序列号的空段。或者你可以通过调用它的<code>fill_window()</code>方法让它填充窗口(如果它有未完成的信息要发送，例如，来自流的字节或SYN/FIN)。</p>
</li>
<li>
<p><code>ACK</code>标志的作用是什么？不是一直有一个<code>ackno</code>吗？</p>
<ul>
<li><strong>几乎</strong>每个<code>TCPSegment</code>都有一个<code>ackno</code>，并且设置了<code>ACK</code>标志。例外的情况是在连接的最开始，在接收方有任何需要确认的东西之前。</li>
<li><strong>在传出段中</strong>，你要尽可能地设置<code>ackno</code>和<code>ACK</code>标志。也就是说，只要<code>TCPReceiver</code>的<code>ackno()</code>方法返回一个<code>std::optional&lt;WrappingInt32&gt;</code>的值，你就可以用<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/utility/optional">has_value()</a>测试。</li>
<li><strong>在传入段中</strong>，只有当<code>ACK</code>字段被设置时，才需要查看<code>ackno</code>。如果<code>ACK</code>字段被设置，就把这个<code>ackno</code>(和窗口大小)给<code>TCPSender</code>。</li>
</ul>
</li>
<li>
<p>在接收段时，如果<code>TCPReceiver</code>抱怨说该段没有与窗口重叠，是不可接受的(<code>segment_received()</code>返回false)，我应该怎么做？</p>
<p>在这种情况下，<code>TCPConnection</code>需要确保向对等方发回一个段，给出当前的<code>ackno</code>和窗口大小。这有助于纠正对等方的困惑。</p>
</li>
<li>
<p>好的，很好。如果<code>TCPConnection</code>收到了一个段，而<code>TCPSender</code>抱怨说<code>ackno</code>无效(<code>ack_received()</code>返回false)，该怎么办？</p>
<p>同样的答案!</p>
</li>
<li>
<p>如果<code>TCPConnection</code>收到了一个网段，而且一切都很好呢？那我还需要回复吗？</p>
<p><strong>如果该段占用了任何序列号</strong>，那么你需要确保它被确认——至少需要向对等方发送一个带有适当的序列号和新的<code>ackno</code>和<code>window_size</code>的段。你可能不需要做任何事情来强制这样做，因为<code>TCPSender</code>通常会在<code>ack_received()</code>中决定发送一个新的段(因为窗口中已经打开了更多的空间)。但是，即使<code>TCPSender</code>没有更多的数据要发送，你也需要确保传入的段以某种方式被确认。</p>
</li>
<li>
<p>如果<code>TCPConnection</code>只是确认每个网段，即使它不占用任何序列号，又如何呢？</p>
<p>这可不是个好主意！两个对等方最终会来回发送无限多的acks。</p>
</li>
<li>
<p>如何解读这些”状态”名称(如”流开始(stream started)”或”流进行中(stream ongoing)”)？</p>
<p>请查看<a target="_blank" rel="noopener" href="https://github.com/CS144/sponge/blob/lab4-startercode/libsponge/tcp_helpers/tcp_state.hh">libsponge/tcp_helpers/tcp_state.hh</a>和<a target="_blank" rel="noopener" href="https://github.com/CS144/sponge/blob/lab4-startercode/libsponge/tcp_helpers/tcp_state.cc">tcp_state.cc</a>文件。</p>
</li>
<li>
<p>如果<code>TCPReceiver</code>想公布一个比<code>TCPSegment::header().win</code>字段大的窗口尺寸，我应该发送什么？</p>
<p>发送你能发送的最大值。你可能会发现<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/types/numeric_limits">std::numeric limits</a>类有帮助。</p>
</li>
<li>
<p>TCP连接何时最终”完成”？<code>active()</code>什么时候可以返回false？</p>
<p>请看下一节。</p>
</li>
<li>
<p>如果本PDF发布后有更多常见问题，我可以在哪里阅读？</p>
<p>请定期查看网站(<a target="_blank" rel="noopener" href="https://cs144.github.io/lab_faq.html">https://cs144.github.io/lab_faq.html</a>)和Piazza。</p>
</li>
</ul>
<h2 id="TCP连接的结束：共识需要工作">TCP连接的结束：共识需要工作</h2>
<p><code>TCPConnection</code>的一个重要功能是决定TCP连接何时完全”完成”。当这种情况发生时，该实现会释放其对本地端口号的独占申明，停止发送回复传入段的确认，认为该连接已成为历史，并让其<code>active()</code>方法返回false。</p>
<p>有两种方式可以结束一个连接。在一个<strong>不干净的关闭</strong>中，<code>TCPConnection</code>发送或接收一个设置了<code>RST</code>标志的段。在这种情况下，出站和入站的<code>ByteStream</code>应该都处于错误状态，而<code>active()</code>可以立即返回false。</p>
<p>一个<strong>干净的关闭</strong>是我们如何在没有错误的情况下达到”完成”(<code>active() = false</code>)。这比较复杂，但这是件美好的事情，因为它尽可能地确保两个<code>ByteStream</code>中的每一个都被可靠地完全交付给接收方。在下一节(§§5.1)中，我们给出了干净的关闭发生时的实际情况，所以如果你愿意，可以随意跳过前面的内容。</p>
<p>酷，你还在这里。由于”<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Two_Generals'_Problem">Two Generals Problem</a>“的存在，不可能保证两个对等方都能实现干净的关闭，但是TCP已经非常接近了。情况是这样的。从一个对等方(一个<code>TCPConnection</code>，我们称之为”本地”对等方)的角度来看，在其与”远程”对等方的连接中，有四个前提条件可以实现干净的关闭：</p>
<ul>
<li>
<p>前提条件#1 <strong>入站</strong>流已完全组装并已结束。</p>
</li>
<li>
<p>前提条件#2 <strong>出站</strong>流已被本地应用程序结束，并完全发送(包括它结束的事实，即一个带有<code>FIN</code>的段)到远程对等方。</p>
</li>
<li>
<p>前提条件#3 <strong>出站</strong>流已被远程对等方完全确认。</p>
</li>
<li>
<p>前提条件#4 <strong>本地</strong><code>TCPConnection</code>确信<strong>远程</strong>对等方能满足前提条件#3。这是令人头疼的部分。有两种可选的方法可以实现这一点：(等待修改为徘徊)</p>
<ul>
<li>
<p><strong>选项A：在两个流结束后徘徊</strong>。前提条件#1到#3都是真的，而且远程对等方似乎已经得到了本地对等方对整个流的确认。本地对等方并不确定这一点——TCP无法可靠地传递acks(它不接受acks)。但是本地对等方非常确信远程对等方已经得到了它的acks，因为远程对等方似乎没有重传任何东西，而且本地对等方已经等待了一段时间来确定。</p>
<p>具体来说，当前提条件#1到#3得到满足，<strong>并且本地对等方从远程对等方收到任何网段后，至少已经过了10倍的初始重传超时(<code>_cfg.rt_timeout</code>)</strong>，连接就完成了。这被称为在两个流结束后的”徘徊”，以确保远程对等方没有试图重传我们需要确认的东西。这确实意味着<code>TCPConnection</code>需要保持一段时间的活跃状态，保持对本地端口号的独占要求，并可能发送acks以响应传入的段，甚至在<code>TCPSender</code>和<code>TCPReceiver</code>完全完成其工作且两个流都结束之后。</p>
<ul>
<li>在一个生产型的TCP实现中，等待计时器(也被称为时间等待计时器或最大段寿命(MSL)的两倍)通常是60或120秒。在一个连接有效完成后，保留一个端口号的时间可能很长，特别是如果你想启动一个新的服务器，绑定到同一个端口号，没有人愿意等待两分钟。<a target="_blank" rel="noopener" href="https://cs144.github.io/doc/lab4/class_socket.html#afc6ed565fddaa9d7ee4904ecc96bb6c0"><code>SO_REUSEADDR</code></a> socket选项本质上是让Linux忽略保留，对于调试或测试来说是很方便的。</li>
</ul>
</li>
<li>
<p><strong>选项B：被动关闭</strong>。前提条件#1到#3都是真的，而且本地对等方100%确定远程对等方可以满足前提条件#3。如果TCP不确认确认，这怎么可能呢？因为远程对等方是<strong>第一个结束其流的人</strong>。</p>
<blockquote>
<p>为什么这个规则有效？这是脑筋急转弯，你不需要进一步阅读就能完成这个实验，但思考起来很有趣，而且能触及”Two Generals Problem”的深层原因，以及在不可靠的网络中对可靠性的固有限制。这样做的原因是，在收到并组装了远程对等方的<code>FIN</code>(前提条件#1)后，本地对等方发送了一个比以前发送的序列号更大的段(至少，它必须发送自己的<code>FIN</code>段以满足前提条件# 2)，该段也有一个<code>ackno</code>，承认远程对等方的<code>FIN</code>位。远程对等方承认该段(满足前提条件#3)，这意味着远程对等方一定也看到了本地对等方对远程对等方的<code>FIN</code>的ack。这就保证了远程对等方一定能够满足它自己的前提条件#3。所有这些都意味着本地对等方可以满足前提条件#4，而不需要等待。</p>
<p>呜呼! 我们说过这是一个脑筋急转弯。在你的实验报告中加分：你能找到一个更好的方法来解释这个问题吗</p>
</blockquote>
<p>底线是，如果**<code>TCPConnection</code>的入站流在<code>TCPConnection</code>发送<code>FIN</code>段之前就结束了，那么<code>TCPConnection</code>就不需要在两个流结束后等待**。</p>
</li>
</ul>
</li>
</ul>
<h3 id="TCP连接的结束-实践总结">TCP连接的结束(实践总结)</h3>
<p>实际上这意味着你的<code>TCPConnection</code>在流结束后有一个叫做<code>_linger_after_streams_finish</code>的成员变量，通过<code>state()</code>方法暴露给测试程序。这个变量一开始是<code>true</code>。如果入站流在<code>TCPConnection</code>到达其出站流的EOF之前结束，则需要将此变量设置为<code>false</code>。</p>
<p>在满足前提条件#1到#3的任何一点上，如果<code>_linger_after_streams_finish</code>为false，连接就”完成”了(并且<code>active()</code>应该返回false)。否则，你需要等待：只有在收到最后一个网段后经过足够的时间(<code>10 × _cfg.rt_timeout</code>)，连接才会完成。</p>
<h2 id="性能">性能</h2>
<p>在你完成了你的TCP实现，并且通过了<code>make check</code>运行的所有测试之后，请提交！然后，测量你的系统的性能，使其至少达到每秒100兆比特。</p>
<p>在build目录中，运行<code>./apps/tcp benchmark</code>。如果一切顺利的话，你会看到像这样的输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user@computer:~/sponge/build$ ./apps/tcp_benchmark </span><br><span class="line">CPU-limited throughput : 1.78 Gbit/s </span><br><span class="line">CPU-limited throughput with reordering: 1.21 Gbit/s</span><br></pre></td></tr></table></figure>
<p>为了获得实验的全部学分，你的性能需要在两条线上至少达到”0.10Gbit/s”(每秒100兆比特)。你可能需要对你的代码进行剖析，或者对它慢的地方进行推理，你可能需要改进一些关键模块(如<code>ByteStream</code>或<code>StreamReassembler</code>)的实现来达到这一点。</p>
<p>在你的报告中，请报告你所取得的速度数据(有无重新排序)。</p>
<p>如果你愿意，欢迎你尽可能地优化你的代码，但请不要以牺牲CS144的其他部分为代价，包括本实验的其他部分。如果你的性能超过100Mbit/s，我们不会给你加分——你所做的任何超出这个最低限度的改进都只是为了你自己的满意和学习。如果你在不改变任何公共接口的情况下实现了比我们快的速度，我们很愿意向你了解你是如何做到的。</p>
<p>(我们在2011年英特尔酷睿i7-2600K CPU @ 4.40GHz上运行我们的参考实现，使用Ubuntu 19.04，Linux 5.0.0-31-generic #33-Ubuntu，带有针对Meltdown/Spectre/等的默认缓解措施，以及带有默认编译器标志的g++ 8.3.0，进行默认(“发布”)构建。CPU限制的吞吐量(第一行)为7.18 Gbit/s，(第二行，有重新排序)为6.84 Gbit/s。)</p>
<h2 id="webget重温">webget重温</h2>
<p>胜利的时刻到了! 还记得你在实验0中写的<code>webget.cc</code>吗？它使用了由Linux内核提供的TCP实现(<code>TCPSocket</code>)。我们希望你能把它改成使用你自己的TCP实现，而不需要改变其他任何东西。我们认为你所需要做的就是：</p>
<ul>
<li>用<code>#include &quot;tcp_sponge_socket.hh&quot;</code>替换<code>#include &quot;socket.hh&quot;</code> 。</li>
<li>将<code>TCPSocket</code>类型改为<code>CS144TCPSocket</code>。</li>
<li>在你的<code>get_URL()</code>函数的末尾，添加一个对<code>socket.wait_until_closed()</code>的调用。</li>
</ul>
<blockquote>
<p>为什么要这样做？通常情况下，Linux内核负责等待TCP连接达到”干净关闭”(并放弃它们的端口保留)，即使在用户进程退出后也是如此。但由于你的TCP实现都在用户空间，除了你的程序，没有其他东西可以跟踪连接状态。添加这个调用使套接字等待，直到你的<code>TCPConnection</code>报告<code>active() = false</code>。</p>
</blockquote>
<p>重新编译，并运行<code>make check webget</code>来确认你已经完成了完整的闭环：你已经在你自己完整的TCP实现之上写了一个基本的web获取器，而且它仍然成功地与一个真正的webserver对话。如果你有问题，试着手动运行程序：<code>./apps/webget cs144.keithw.org /hasher/xyzzy</code>。你会在终端上得到一些调试输出，可能会有帮助。</p>
<h2 id="TCPState">TCPState</h2>
<h3 id="TCP-状态自动机">TCP 状态自动机</h3>
<ul>
<li><a target="_blank" rel="noopener" href="https://users.cs.northwestern.edu/~agupta/cs340/project2/TCPIP_State_Transition_Diagram.pdf">TCP/IP State Transition Diagram</a></li>
<li><a target="_blank" rel="noopener" href="http://tcpipguide.com/free/t_TCPOperationalOverviewandtheTCPFiniteStateMachineF-2.htm">TCP Finite State Machine</a></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Misaka-9982-coder/img_hosting/img/TCP%20state%20transition%20diagram.png" alt="TCP state transition diagram"></p>
<ul>
<li><code>LISTEN</code>：表示正在等待来自任何远程 TCP 和端口的连接请求。</li>
<li><code>SYN-SENT</code>：表示在发送连接请求后等待匹配的连接请求。</li>
<li><code>SYN-RECEIVED</code>：表示在接收和发送连接请求后等待确认的连接请求确认。</li>
<li><code>ESTABLISHED</code>：表示打开的连接，接收到的数据可以传递给用户，是连接传输阶段的正常状态。</li>
<li><code>FIN-WAIT-1</code>：表示等待来自远程 TCP 的连接终止请求，或先前发送的连接终止请求的确认。</li>
<li><code>FIN-WAIT-2</code>：表示等待远程 TCP 的连接终止请求。</li>
<li><code>CLOSE-WAIT</code>：表示正在等待来自本地用户的连接终止请求。</li>
<li><code>CLOSING</code>：表示正在等待来自远程 TCP 的连接终止请求确认。</li>
<li><code>LAST-ACK</code>：表示等待先前发送给远程 TCP 的连接终止请求的确认（其中包括其连接终止请求的确认）。</li>
<li><code>TIME-WAIT</code>：表示等待足够的时间以确保远程 TCP 接收到其连接终止请求的确认。</li>
<li><code>CLOSED</code>：表示根本没有连接状态。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! \brief Official state names from the [TCP](\ref rfc::rfc793) specification</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">State</span> &#123;</span></span><br><span class="line">        LISTEN = <span class="number">0</span>,   <span class="comment">//!&lt; Listening for a peer to connect</span></span><br><span class="line">        SYN_RCVD,     <span class="comment">//!&lt; Got the peer&#x27;s SYN</span></span><br><span class="line">        SYN_SENT,     <span class="comment">//!&lt; Sent a SYN to initiate a connection</span></span><br><span class="line">        ESTABLISHED,  <span class="comment">//!&lt; Three-way handshake complete</span></span><br><span class="line">        CLOSE_WAIT,   <span class="comment">//!&lt; Remote side has sent a FIN, connection is half-open</span></span><br><span class="line">        LAST_ACK,     <span class="comment">//!&lt; Local side sent a FIN from CLOSE_WAIT, waiting for ACK</span></span><br><span class="line">        FIN_WAIT_1,   <span class="comment">//!&lt; Sent a FIN to the remote side, not yet ACK&#x27;d</span></span><br><span class="line">        FIN_WAIT_2,   <span class="comment">//!&lt; Received an ACK for previously-sent FIN</span></span><br><span class="line">        CLOSING,      <span class="comment">//!&lt; Received a FIN just after we sent one</span></span><br><span class="line">        TIME_WAIT,    <span class="comment">//!&lt; Both sides have sent FIN and ACK&#x27;d, waiting for 2 MSL</span></span><br><span class="line">        CLOSED,       <span class="comment">//!&lt; A connection that has terminated normally</span></span><br><span class="line">        RESET,        <span class="comment">//!&lt; A connection that terminated abnormally</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p><code>TCPState</code> 是一个枚举类型，表示 TCP 连接可能存在的不同状态。它有十一个可能的状态：</p>
<ul>
<li><code>LISTEN</code>：TCP 正在等待来自任何远程 TCP 和端口的连接请求。</li>
<li><code>SYN_RCVD</code>：已经接收到来自远程 TCP 的连接请求，TCP 正在等待确认连接请求的确认。</li>
<li><code>SYN_SENT</code>：TCP 已经发送了连接请求，正在等待来自远程 TCP 的连接请求确认。</li>
<li><code>ESTABLISHED</code>：TCP 与远程 TCP 建立了打开连接，可以发送和接收数据。</li>
<li><code>CLOSE_WAIT</code>：远程 TCP 已经启动了连接的关闭，TCP 正在等待本地应用程序关闭连接。</li>
<li><code>LAST_ACK</code>：TCP 已经启动了连接的关闭并发送了 FIN，正在等待远程 TCP 确认 FIN。</li>
<li><code>FIN_WAIT_1</code>：TCP 已经启动了连接的关闭并发送了 FIN，正在等待远程 TCP 的连接终止请求，或等待远程 TCP 对 FIN 的确认。</li>
<li><code>FIN_WAIT_2</code>：TCP 已经收到来自远程 TCP 的连接终止请求的确认，并正在等待远程 TCP 的连接终止请求。</li>
<li><code>CLOSING</code>：TCP 已经发送了 FIN 并收到了远程 TCP 的连接终止请求的确认，但同时也收到了来自远程 TCP 的 FIN 并正在等待其 FIN 的确认。</li>
<li><code>TIME_WAIT</code>：TCP 已经发送了 FIN 并收到了来自远程 TCP 的连接终止请求的确认，正在等待一段时间（2 * MSL），然后最终关闭连接。</li>
<li><code>CLOSED</code>：TCP 连接已经正常关闭，不能再发送或接收任何数据。</li>
<li><code>RESET</code>：由于收到重置，TCP 连接已经异常终止。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">TCPState::<span class="built_in">TCPState</span>(<span class="keyword">const</span> TCPState::State state) &#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (state) &#123;</span><br><span class="line">        <span class="keyword">case</span> TCPState::State::LISTEN:</span><br><span class="line">            _receiver = TCPReceiverStateSummary::LISTEN;</span><br><span class="line">            _sender = TCPSenderStateSummary::CLOSED;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TCPState::State::SYN_RCVD:</span><br><span class="line">            _receiver = TCPReceiverStateSummary::SYN_RECV;</span><br><span class="line">            _sender = TCPSenderStateSummary::SYN_SENT;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TCPState::State::SYN_SENT:</span><br><span class="line">            _receiver = TCPReceiverStateSummary::LISTEN;</span><br><span class="line">            _sender = TCPSenderStateSummary::SYN_SENT;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TCPState::State::ESTABLISHED:</span><br><span class="line">            _receiver = TCPReceiverStateSummary::SYN_RECV;</span><br><span class="line">            _sender = TCPSenderStateSummary::SYN_ACKED;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TCPState::State::CLOSE_WAIT:</span><br><span class="line">            _receiver = TCPReceiverStateSummary::FIN_RECV;</span><br><span class="line">            _sender = TCPSenderStateSummary::SYN_ACKED;</span><br><span class="line">            _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TCPState::State::LAST_ACK:</span><br><span class="line">            _receiver = TCPReceiverStateSummary::FIN_RECV;</span><br><span class="line">            _sender = TCPSenderStateSummary::FIN_SENT;</span><br><span class="line">            _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TCPState::State::CLOSING:</span><br><span class="line">            _receiver = TCPReceiverStateSummary::FIN_RECV;</span><br><span class="line">            _sender = TCPSenderStateSummary::FIN_SENT;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TCPState::State::FIN_WAIT_1:</span><br><span class="line">            _receiver = TCPReceiverStateSummary::SYN_RECV;</span><br><span class="line">            _sender = TCPSenderStateSummary::FIN_SENT;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TCPState::State::FIN_WAIT_2:</span><br><span class="line">            _receiver = TCPReceiverStateSummary::SYN_RECV;</span><br><span class="line">            _sender = TCPSenderStateSummary::FIN_ACKED;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TCPState::State::TIME_WAIT:</span><br><span class="line">            _receiver = TCPReceiverStateSummary::FIN_RECV;</span><br><span class="line">            _sender = TCPSenderStateSummary::FIN_ACKED;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TCPState::State::RESET:</span><br><span class="line">            _receiver = TCPReceiverStateSummary::ERROR;</span><br><span class="line">            _sender = TCPSenderStateSummary::ERROR;</span><br><span class="line">            _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line">            _active = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TCPState::State::CLOSED:</span><br><span class="line">            _receiver = TCPReceiverStateSummary::FIN_RECV;</span><br><span class="line">            _sender = TCPSenderStateSummary::FIN_ACKED;</span><br><span class="line">            _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line">            _active = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数是一个 switch 语句，将每个 <code>TCPState</code> 值映射到相应的 <code>TCPReceiverStateSummary</code> 和 <code>TCPSenderStateSummary</code> 值。这两种类型分别表示 TCP 接收器和发送器的摘要状态，用于向应用程序报告 TCP 连接的当前状态。根据 <code>TCPState</code> 值，switch 语句将适当的值分配给 <code>TCPConnection</code> 对象的 <code>_receiver</code>、<code>_sender</code>、<code>_linger_after_streams_finish</code> 和 <code>_active</code> 成员变量。</p>
<p>根据不同的TCP状态转换，更新TCP发送方和接收方的状态，并做出相应的操作。具体来说，这段代码将TCP状态转换成TCP发送方和接收方的状态，转换逻辑如下：</p>
<ul>
<li><code>LISTEN</code>状态：TCP接收方进入 <code>LISTEN</code> 状态，TCP发送方进入 <code>CLOSED</code> 状态。</li>
<li><code>SYN_RCVD</code>状态：TCP接收方进入 <code>SYN_RECV</code> 状态，TCP发送方进入 <code>SYN_SENT</code> 状态。</li>
<li><code>SYN_SENT</code>状态：TCP接收方进入 <code>LISTEN</code> 状态，TCP发送方继续保持在 <code>SYN_SENT</code> 状态。</li>
<li><code>ESTABLISHED</code>状态：TCP接收方进入 <code>SYN_RECV</code> 状态，TCP发送方进入 <code>SYN_ACKED</code> 状态。</li>
<li><code>CLOSE_WAIT</code>状态：TCP接收方进入 <code>FIN_RECV</code> 状态，TCP发送方进入 <code>SYN_ACKED</code> 状态，设置 <code>_linger_after_streams_finish</code> 为 <code>false</code>。</li>
<li><code>LAST_ACK</code>状态：TCP接收方进入 <code>FIN_RECV</code> 状态，TCP发送方进入 <code>FIN_SENT</code> 状态，设置 <code>_linger_after_streams_finish</code> 为 <code>false</code>。</li>
<li><code>CLOSING</code>状态：TCP接收方进入 <code>FIN_RECV</code> 状态，TCP发送方进入 <code>FIN_SENT</code> 状态。</li>
<li><code>FIN_WAIT_1</code>状态：TCP接收方进入 <code>SYN_RECV</code> 状态，TCP发送方进入 <code>FIN_SENT</code> 状态。</li>
<li><code>FIN_WAIT_2</code>状态：TCP接收方进入 <code>SYN_RECV</code> 状态，TCP发送方进入 <code>FIN_ACKED</code> 状态。</li>
<li><code>TIME_WAIT</code>状态：TCP接收方进入 <code>FIN_RECV</code> 状态，TCP发送方进入 <code>FIN_ACKED</code> 状态。</li>
<li><code>RESET</code>状态：TCP接收方和TCP发送方进入 <code>ERROR</code> 状态，设置<code>_linger_after_streams_finish</code>为<code>false</code> ，设置 <code>_active</code> 为 <code>false</code>。</li>
<li><code>CLOSED</code>状态：TCP接收方进入 <code>FIN_RECV</code> 状态，TCP发送方进入 <code>FIN_ACKED</code> 状态，设 置 <code>_linger_after_streams_finish</code> 为false，设置 <code>_active</code> 为 <code>false</code>。</li>
</ul>
<p>需要注意的是，这段代码并未包含所有可能的TCP状态转换，可能还有其他的状态转换情况需要另行处理。</p>
<h3 id="TCP-握手挥手">TCP 握手挥手</h3>
<ul>
<li><a href="https://www.misaka-9982.com/2022/03/04/Wireshark-Lab5/">https://www.misaka-9982.com/2022/03/04/Wireshark-Lab5/</a></li>
</ul>
<h4 id="TCP三次握手的流程和状态转换">TCP三次握手的流程和状态转换</h4>
<p>TCP三次握手是在建立TCP连接时使用的一种协议，其流程和状态转换如下：</p>
<ol>
<li>客户端向服务器发送SYN包，表示客户端请求建立连接。</li>
<li>服务器接收到SYN包，回复客户端一个SYN+ACK包，表示服务器确认收到了客户端的请求，并请求建立连接。</li>
<li>客户端收到服务器的SYN+ACK包，发送一个ACK包给服务器，表示客户端确认收到了服务器的确认，并建立连接。</li>
</ol>
<p>这个过程中，客户端和服务器之间的状态转换如下：</p>
<ol>
<li>客户端从CLOSED状态转换到SYN-SENT状态，表示客户端已经向服务器发送了一个SYN包，等待服务器的响应。</li>
<li>服务器从LISTEN状态转换到SYN-RECEIVED状态，表示服务器已经收到了客户端的SYN包，并回复了SYN+ACK包，等待客户端的确认。</li>
<li>客户端从SYN-SENT状态转换到ESTABLISHED状态，表示客户端已经收到了服务器的SYN+ACK包，并发送了确认ACK包，连接建立成功。</li>
<li>服务器从SYN-RECEIVED状态转换到ESTABLISHED状态，表示服务器已经收到了客户端的ACK包，连接建立成功。</li>
</ol>
<p>在TCP三次握手过程中，通过交换SYN和ACK包来确认连接的建立，确保客户端和服务器之间建立的连接是可靠的。这个过程中，如果任何一个包丢失或者延迟，都会导致连接建立失败，因此TCP协议是一种可靠的面向连接的协议。</p>
<h4 id="TCP四次挥手的流程和状态转换">TCP四次挥手的流程和状态转换</h4>
<p>TCP四次挥手是在关闭TCP连接时使用的一种协议，其流程和状态转换如下：</p>
<ol>
<li>主动关闭方（可以是客户端或服务器）发送一个FIN包给被动关闭方（对方），表示主动关闭方想要关闭连接，进入FIN-WAIT-1状态。</li>
<li>被动关闭方接收到主动关闭方的FIN包，回复一个ACK包进行确认，表示已经收到了主动关闭方的请求，进入CLOSE-WAIT状态。</li>
<li>被动关闭方发送一个FIN包给主动关闭方，表示对方也想要关闭连接，进入LAST-ACK状态。</li>
<li>主动关闭方接收到被动关闭方的FIN包，回复一个ACK包进行确认，表示主动关闭方已经收到了被动关闭方的请求，进入TIME-WAIT状态。</li>
<li>经过一段时间后，主动关闭方退出TIME-WAIT状态，连接彻底关闭。</li>
</ol>
<p>这个过程中，主动关闭方和被动关闭方之间的状态转换如下：</p>
<ol>
<li>主动关闭方从ESTABLISHED状态转换到FIN-WAIT-1状态，表示主动关闭方已经发送了一个FIN包，等待被动关闭方的确认。</li>
<li>被动关闭方从ESTABLISHED状态转换到CLOSE-WAIT状态，表示被动关闭方已经接收到主动关闭方的FIN包，并发送了一个ACK包进行确认。</li>
<li>被动关闭方从CLOSE-WAIT状态转换到LAST-ACK状态，表示被动关闭方也想要关闭连接，发送了一个FIN包给主动关闭方。</li>
<li>主动关闭方从FIN-WAIT-1状态转换到FIN-WAIT-2状态，表示主动关闭方已经收到了被动关闭方的ACK包，并等待被动关闭方的FIN包。</li>
<li>主动关闭方从FIN-WAIT-2状态转换到TIME-WAIT状态，表示主动关闭方已经收到了被动关闭方的FIN包，并发送了一个ACK包进行确认，等待一段时间（2倍的MSL，最长报文段寿命）以确保对方已经接收到ACK包。</li>
<li>被动关闭方从LAST-ACK状态转换到CLOSED状态，表示被动关闭方已经收到了主动关闭方的ACK包，并关闭连接。</li>
</ol>
<p>在TCP四次挥手过程中，主动关闭方和被动关闭方之间通过交换FIN和ACK包来关闭连接，确保连接关闭的可靠性。这个过程中，如果任何一个包丢失或者延迟，都会导致连接关闭失败，因此TCP协议是一种可靠的面向连接的协议。</p>
<h2 id="TCPConnection">TCPConnection</h2>
<h3 id="代码解读">代码解读</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! \brief A complete endpoint of a TCP connection</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TCPConnection</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    TCPConfig _cfg;</span><br><span class="line">    TCPReceiver _receiver&#123;_cfg.recv_capacity&#125;;</span><br><span class="line">    TCPSender _sender&#123;_cfg.send_capacity, _cfg.rt_timeout, _cfg.fixed_isn&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! outbound queue of segments that the TCPConnection wants sent</span></span><br><span class="line">    std::queue&lt;TCPSegment&gt; _segments_out&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Should the TCPConnection stay active (and keep ACKing)</span></span><br><span class="line">    <span class="comment">//! for 10 * _cfg.rt_timeout milliseconds after both streams have ended,</span></span><br><span class="line">    <span class="comment">//! in case the remote TCPConnection doesn&#x27;t know we&#x27;ve received its whole stream?</span></span><br><span class="line">    <span class="keyword">bool</span> _linger_after_streams_finish&#123;<span class="literal">true</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> _last_seg_time&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">size_t</span> _curr_seg_time&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//! \name &quot;Input&quot; interface for the writer</span></span><br><span class="line">    <span class="comment">//!@&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief Initiate a connection by sending a SYN segment</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief Write data to the outbound byte stream, and send it over TCP if possible</span></span><br><span class="line">    <span class="comment">//! \returns the number of bytes from `data` that were actually written.</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">write</span><span class="params">(<span class="keyword">const</span> std::string &amp;data)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \returns the number of `bytes` that can be written right now.</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">remaining_outbound_capacity</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief Shut down the outbound byte stream (still allows reading incoming data)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">end_input_stream</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//!@&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \name &quot;Output&quot; interface for the reader</span></span><br><span class="line">    <span class="comment">//!@&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief The inbound byte stream received from the peer</span></span><br><span class="line">    <span class="function">ByteStream &amp;<span class="title">inbound_stream</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _receiver.<span class="built_in">stream_out</span>(); &#125;</span><br><span class="line">    <span class="comment">//!@&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \name Accessors used for testing</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//!@&#123;</span></span><br><span class="line">    <span class="comment">//! \brief number of bytes sent and not yet acknowledged, counting SYN/FIN each as one byte</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">bytes_in_flight</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//! \brief number of bytes not yet reassembled</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">unassembled_bytes</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//! \brief Number of milliseconds since the last segment was received</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">time_since_last_segment_received</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//!&lt; \brief summarize the state of the sender, receiver, and the connection</span></span><br><span class="line">    <span class="function">TCPState <span class="title">state</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> &#123;_sender, _receiver, <span class="built_in">active</span>(), _linger_after_streams_finish&#125;; &#125;;</span><br><span class="line">    <span class="comment">//!@&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \name Methods for the owner or operating system to call</span></span><br><span class="line">    <span class="comment">//!@&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Called when a new segment has been received from the network</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">segment_received</span><span class="params">(<span class="keyword">const</span> TCPSegment &amp;seg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Called periodically when time elapses</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tick</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> ms_since_last_tick)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send_segment</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief TCPSegments that the TCPConnection has enqueued for transmission.</span></span><br><span class="line">    <span class="comment">//! \note The owner or operating system will dequeue these and</span></span><br><span class="line">    <span class="comment">//! put each one into the payload of a lower-layer datagram (usually Internet datagrams (IP),</span></span><br><span class="line">    <span class="comment">//! but could also be user datagrams (UDP) or any other kind).</span></span><br><span class="line">    <span class="function">std::queue&lt;TCPSegment&gt; &amp;<span class="title">segments_out</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _segments_out; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief Is the connection still alive in any way?</span></span><br><span class="line">    <span class="comment">//! \returns `true` if either stream is still running or if the TCPConnection is lingering</span></span><br><span class="line">    <span class="comment">//! after both streams have finished (e.g. to ACK retransmissions from the peer)</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">active</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//!@&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Construct a new connection from a configuration</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">TCPConnection</span><span class="params">(<span class="keyword">const</span> TCPConfig &amp;cfg)</span> : _cfg&#123;</span>cfg&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \name construction and destruction</span></span><br><span class="line">    <span class="comment">//! moving is allowed; copying is disallowed; default construction not possible</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//!@&#123;</span></span><br><span class="line">    ~<span class="built_in">TCPConnection</span>();  <span class="comment">//!&lt; destructor sends a RST if the connection is still open</span></span><br><span class="line">    <span class="built_in">TCPConnection</span>() = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">TCPConnection</span>(TCPConnection &amp;&amp;other) = <span class="keyword">default</span>;</span><br><span class="line">    TCPConnection &amp;<span class="keyword">operator</span>=(TCPConnection &amp;&amp;other) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">TCPConnection</span>(<span class="keyword">const</span> TCPConnection &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">    TCPConnection &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> TCPConnection &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">//!@&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>TCPConnection</code>是一个类，用于表示 TCP 连接。它作为一个连接的一方(端点或对等方)，负责接收和发送数据段，确保发送方和接收方被告知并有机会对它们关心的传入和传出段的字段进行贡献。</p>
<p>具体来说，<code>TCPConnection</code>的主要功能包括：</p>
<ul>
<li>接收来自互联网的 <code>TCPSegment</code>，并将其交给 <code>TCPReceiver</code> 进行处理，以检查它所关心的传入段的字段。</li>
<li>将每个传出段的字段设置为合适的值(由 <code>TCPSender</code> 确定)，并将其放入出站队列(<code>_segments_out</code>)中以便发送。</li>
<li>向 <code>TCPSender</code> 询问传出段的字段，特别是 <code>ackno</code> 和 <code>window_size</code>，以便构造传出段。</li>
<li>处理连接范围内的一些难以轻易融入发送方和接收方的微妙问题，比如如何终止连接并宣布它不再是“活动的”。</li>
</ul>
<p>综上所述，<code>TCPConnection</code>的功能是将 <code>TCPSender</code> 和 <code>TCPReceiver</code> 中的例程与连接的公共 API 进行连接，以创建一个完整的 TCP 连接。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPConnection::send_segment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TCPSegment seg = _sender.<span class="built_in">segments_out</span>().<span class="built_in">front</span>();</span><br><span class="line">        _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">            seg.<span class="built_in">header</span>().ack = <span class="literal">true</span>;</span><br><span class="line">            seg.<span class="built_in">header</span>().ackno = _receiver.<span class="built_in">ackno</span>().<span class="built_in">value</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        seg.<span class="built_in">header</span>().win = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint16_t</span>&gt;(</span><br><span class="line">            <span class="built_in">min</span>(_receiver.<span class="built_in">window_size</span>(), <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(numeric_limits&lt;<span class="keyword">uint16_t</span>&gt;::<span class="built_in">max</span>()))</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        _segments_out.<span class="built_in">push</span>(seg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>send_segment()</code>，它的作用是将传出队列中的段发送出去。在发送之前，它会检查接收方是否有等待确认的段，以及接收窗口的大小。</p>
<p>具体来说，这段代码会从发送队列的前面取出一个段。如果接收方等待确认，它会将<code>ack</code>标志和确认号(<code>ackno</code>)设置为对应的值。然后，它将窗口大小(<code>win</code>)设置为接收方的窗口大小，但不会超过16位无符号整数的最大值。最后，它将段添加到传输队列中，准备发送。这个方法会循环执行，直到传输队列为空。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TCPConnection::active</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// unclean shutdown</span></span><br><span class="line">    <span class="keyword">if</span> (_sender.<span class="built_in">stream_in</span>().<span class="built_in">error</span>() || _receiver.<span class="built_in">stream_out</span>().<span class="built_in">error</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ended = _receiver.<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>();</span><br><span class="line">    <span class="keyword">auto</span> eof = _sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>();</span><br><span class="line">    <span class="keyword">auto</span> eq2 = _sender.<span class="built_in">next_seqno_absolute</span>() == _sender.<span class="built_in">stream_in</span>().<span class="built_in">bytes_written</span>() + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">auto</span> no_flight = _sender.<span class="built_in">bytes_in_flight</span>() == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> checked = ended &amp;&amp; eof &amp;&amp; eq2 &amp;&amp; no_flight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clean shut down</span></span><br><span class="line">    <span class="keyword">if</span> (!_linger_after_streams_finish) &#123;  </span><br><span class="line">        <span class="comment">// # 1 ~ # 3 satisfied -&gt;connection done</span></span><br><span class="line">        <span class="keyword">if</span> (checked) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (checked) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">time_since_last_segment_received</span>() &lt; <span class="number">10</span> * _cfg.rt_timeout) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码定义了一个TCP连接的状态，通过判断发送方和接收方的状态，以及数据传输的进度来确定连接是否处于激活状态。</p>
<p><code>active()</code>函数首先检查连接是否存在异常关闭情况，即发送流或接收流是否有错误，如果有则返回false，表示连接不再激活。</p>
<p>如果连接没有异常关闭，它将检查发送方和接收方的状态以及数据传输的进度。如果这些条件都满足，它将返回false，否则返回true，表示连接仍然激活。在这个实现中，一个TCP连接被认为是&quot;激活&quot;的条件是：</p>
<ol>
<li>接收流中没有未接收的数据，也没有接收流的错误（即没有未处理的数据或错误）</li>
<li>发送流中已经写入了EOF</li>
<li>发送方已经发送了所有数据，并且等待所有数据的确认，确认号为发送方写入的字节数+2（因为SYN和FIN标志也算在字节数中）</li>
</ol>
<p>如果连接设置了 <code>linger_after_streams_finish</code> 标志，则还需要进行以下检查：</p>
<ol>
<li>上述3个条件都满足</li>
<li>最近接收到的段距离当前时间不超过10倍的重传超时时间，否则返回false，表示连接不再激活</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! \param[in] ms_since_last_tick number of milliseconds since the last call to this method</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPConnection::tick</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">    _curr_seg_time += ms_since_last_tick;</span><br><span class="line">    _sender.<span class="built_in">tick</span>(ms_since_last_tick);</span><br><span class="line">    <span class="built_in">send_segment</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_sender.<span class="built_in">consecutive_retransmissions</span>() &gt; TCPConfig::MAX_RETX_ATTEMPTS) &#123;</span><br><span class="line">        <span class="comment">// abort the connnection</span></span><br><span class="line">        _sender.<span class="built_in">send_empty_rst</span>();</span><br><span class="line">        _sender.<span class="built_in">stream_in</span>().<span class="built_in">set_error</span>();</span><br><span class="line">        _receiver.<span class="built_in">stream_out</span>().<span class="built_in">set_error</span>();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// syn received</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>()) &#123; </span><br><span class="line">        _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">send_segment</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码是 TCPConnection 类中的 <code>tick()</code> 函数，用于模拟 TCP 连接的运行过程。具体而言，函数接收一个时间差（<code>ms_since_last_tick</code>），并根据这个时间差更新当前已经经过的时间和发送方的状态，并尝试发送 TCP 报文。</p>
<p>在函数的开头，代码会将时间差累加到当前已经经过的时间（<code>_curr_seg_time</code>）中，然后调用 <code>_sender.tick()</code> 函数更新发送方的状态，再调用 <code>send_segment()</code> 函数尝试发送 TCP 报文。</p>
<p>接下来，如果发送方连续重传的次数超过了最大重传次数（<code>TCPConfig::MAX_RETX_ATTEMPTS</code>），就会终止连接。如果接收方收到了 SYN 报文（即连接已经建立），就会调用 <code>_sender.fill_window()</code> 函数来填充发送窗口，并调用 <code>send_segment()</code> 尝试发送 TCP 报文。</p>
<p>最后再次调用 <code>send_segment()</code> 函数，以确保已经生成的 TCP 报文都已经被发送。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPConnection::segment_received</span><span class="params">(<span class="keyword">const</span> TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Unclean shutdown of TCPConnection</span></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().rst) &#123;</span><br><span class="line">        _sender.<span class="built_in">stream_in</span>().<span class="built_in">set_error</span>();</span><br><span class="line">        _receiver.<span class="built_in">stream_out</span>().<span class="built_in">set_error</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// normal routine</span></span><br><span class="line">    _last_seg_time = _curr_seg_time;</span><br><span class="line">    _receiver.<span class="built_in">segment_received</span>(seg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().ack) &#123;</span><br><span class="line">        _sender.<span class="built_in">ack_received</span>(seg.<span class="built_in">header</span>().ackno, seg.<span class="built_in">header</span>().win);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// syn received</span></span><br><span class="line">    <span class="keyword">if</span> (_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        <span class="built_in">send_segment</span>();</span><br><span class="line">        _sender.<span class="built_in">fill_window</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// at least one segment is sent in reply</span></span><br><span class="line">        <span class="keyword">if</span> (seg.<span class="built_in">length_in_sequence_space</span>() &amp;&amp; _sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;  </span><br><span class="line">            _sender.<span class="built_in">send_empty_ack</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">send_segment</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (_receiver.<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>() &amp;&amp; !_sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>()) &#123;</span><br><span class="line">            _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码处理接收到的TCP段（<code>segment</code>）。当接收到的段被传递到此方法时，代码将首先检查段是否包含RST标志，如果是，则TCP连接出现异常关闭。如果不是，则代码将处理TCP连接的正常过程。</p>
<p>如果此段包含ACK标志，则代码将调用 <code>_sender.ack_received</code> 方法来处理确认。如果 <code>_receiver.ackno</code> 返回值已设置，则表示已接收到SYN，代码将调用 <code>send_segment</code> 方法来发送数据段。 <code>_sender.fill_window</code> 方法将填充发送方窗口，以便在空闲时发送更多数据段。如果发送一个回复，但此时发送方没有待发送的段，则还会发送一个空的ACK段以确认该回复。此外，如果接收方流已结束但发送方流未结束，则 <code>_linger_after_streams_finish</code> 将设置为false，以指示连接可以正常关闭。</p>
<p>总之，此方法的目的是根据接收到的TCP段执行必要的操作以保持TCP连接的状态。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_URL</span><span class="params">(<span class="keyword">const</span> string &amp;host, <span class="keyword">const</span> string &amp;path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// You will need to connect to the &quot;http&quot; service on</span></span><br><span class="line">    <span class="comment">// the computer whose name is in the &quot;host&quot; string,</span></span><br><span class="line">    <span class="comment">// then request the URL path given in the &quot;path&quot; string.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// GET /hello HTTP/1.1</span></span><br><span class="line">    <span class="comment">// Host: cs144.keithw.org</span></span><br><span class="line">    <span class="comment">// Connection: close</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Address <span class="title">address</span><span class="params">(host, <span class="string">&quot;http&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// TCPSocket socket;</span></span><br><span class="line">    CS144TCPSocket socket&#123;&#125;;</span><br><span class="line">    socket.<span class="built_in">connect</span>(address);</span><br><span class="line"></span><br><span class="line">    socket.<span class="built_in">write</span>(<span class="string">&quot;GET &quot;</span> + path + <span class="string">&quot; HTTP/1.1\r\n&quot;</span>);</span><br><span class="line">    socket.<span class="built_in">write</span>(<span class="string">&quot;Host: &quot;</span> + host + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    socket.<span class="built_in">write</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    socket.<span class="built_in">shutdown</span>(SHUT_WR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Then you&#x27;ll need to print out everything the server sends back,</span></span><br><span class="line">    <span class="comment">// (not just one call to read() -- everything) until you reach</span></span><br><span class="line">    <span class="comment">// the &quot;eof&quot; (end of file).</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!socket.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; socket.<span class="built_in">read</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    socket.<span class="built_in">close</span>();</span><br><span class="line">    socket.<span class="built_in">wait_until_closed</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cerr &lt;&lt; &quot;Function called: get_URL(&quot; &lt;&lt; host &lt;&lt; &quot;, &quot; &lt;&lt; path &lt;&lt; &quot;).\n&quot;;</span></span><br><span class="line">    <span class="comment">// cerr &lt;&lt; &quot;Warning: get_URL() has not been implemented yet.\n&quot;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="性能测试">性能测试</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./apps/tcp_benchmark</span><br><span class="line">CPU-limited throughput                : 12.56 Gbit/s</span><br><span class="line">CPU-limited throughput with reordering: 11.36 Gbit/s</span><br></pre></td></tr></table></figure>
<h2 id="完整代码-4">完整代码</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Misaka-9982-coder/CS144-fa21/blob/optimize/libsponge/tcp_connection.hh">tcp_connection.hh</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Misaka-9982-coder/CS144-fa21/blob/optimize/libsponge/tcp_connection.cc">tcp_connection.cc</a></li>
</ul>
</div><div class="tags"><a href="/tags/CS144"><i class="fa fa-tag">CS144</i></a><a href="/tags/Network"><i class="fa fa-tag">Network</i></a></div><div class="post-nav"><a class="pre" href="/2023/02/20/Makefile-%E5%92%8C-CMake/">Makefile 和 CMake</a><a class="next" href="/2023/02/19/CS144-Lab3/">CS144-Lab3</a></div><div id="tcomment"></div><script src="https://unpkg.com/twikoo@1.5.7/dist/twikoo.all.min.js"></script><script>twikoo.init({
  envId: 'https://twikoo-f8467x06b-misaka-9982-coder.vercel.app/',
  el: '#tcomment',
  region: '',
  path: ''
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.jpeg"/></a><p>Try to be better.</p><a class="info-icon" href="https://twitter.com/five96413950" title="Twitter" target="_blank" style="margin-inline:5px"> <i class="fa fa-twitter-square" style="margin-inline:5px"></i></a><a class="info-icon" href="mailto:1784321894@qq.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/Misaka-9982-coder" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/OS/" style="font-size: 15px;">OS</a> <a href="/tags/6-S081/" style="font-size: 15px;">6.S081</a> <a href="/tags/Acwing/" style="font-size: 15px;">Acwing</a> <a href="/tags/Algorithm/" style="font-size: 15px;">Algorithm</a> <a href="/tags/CS144/" style="font-size: 15px;">CS144</a> <a href="/tags/Network/" style="font-size: 15px;">Network</a> <a href="/tags/CS188/" style="font-size: 15px;">CS188</a> <a href="/tags/AI/" style="font-size: 15px;">AI</a> <a href="/tags/CS61A/" style="font-size: 15px;">CS61A</a> <a href="/tags/CS61BL/" style="font-size: 15px;">CS61BL</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Wireshark/" style="font-size: 15px;">Wireshark</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/03/15/6-S081-Lab-3-page-tables/">6.S081 Lab 3 page tables</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/14/6-S081-Lab-2-System-Calls/">6.S081-Lab 2: System Calls</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/10/6-S081-Lab-1-Xv6-and-Unix-utilities/">6.S081-Lab 1: Xv6 and Unix utilities</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/09/6-S081%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/">6.S081环境配置及参考资料</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/25/CS144-Lab7/">CS144-Lab7</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/25/CS144-Lab6/">CS144-Lab6</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/24/CS144-Lab5/">CS144-Lab5</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/20/Makefile-%E5%92%8C-CMake/">Makefile 和 CMake</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/19/CS144-Lab4/">CS144-Lab4</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/19/CS144-Lab3/">CS144-Lab3</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.colopen-blog.com/" title="彩色铅笔" target="_blank">彩色铅笔</a><ul></ul><a href="https://www.selfknow.cn/" title="L2c" target="_blank">L2c</a><ul></ul><a href="https://blognas.hwb0307.com" title="浮云翩迁之间" target="_blank">浮云翩迁之间</a></div><div class="widget"><div class="widget-title"><i class="fa fa-heartbeat"> 访客地图</i></div></div><script id="clstr_globe" type="text/javascript" defer="defer" src="//clustrmaps.com/globe.js?d=NAGSI3cBPnTXd3xVo3V7zDC9xqeu_9ed2OCmGUj1uiw"></script><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async="async"></script><div class="widget"><div class="widget-title"><i class="fa fa-tags"> 网站资讯</i></div><ul> </ul><div class="webinfo-item"><div class="item-name">本站访客数  : </div><div class="item-count" id="busuanzi_value_site_uv"></div></div><ul> </ul><div class="webinfo-item"><div class="item-name">本站总访问量  : </div><div class="item-count" id="busuanzi_value_site_pv"></div></div><ul></ul><div class="webinfo-item"><div class="item-name">本站总字数 : </div><div class="item-count">300.4k</div></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 - 2023 <a href="/." rel="nofollow">Misaka's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>