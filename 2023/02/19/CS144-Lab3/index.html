<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>CS144-Lab3 | Misaka's blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({google_ad_client: "ca-pub-5060306535186583", enable_page_level_ads: true});</script><meta name="generator" content="Hexo 6.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">CS144-Lab3</h1><a id="logo" href="/.">Misaka's blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a><a href="/messageboard/"><i class="fa fa fa-comments"> 留言版</i></a><a href="/link/"><i class="fa fa fa-external-link"> 友链</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">CS144-Lab3</h1><div class="post-meta">2023-02-19<span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 6.5k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 25</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><h2 id="概述">概述</h2>
<p>在实验0中，你实现了流控制字节流（<code>ByteStream</code>）的抽象。</p>
<p>在实验1和2中，你实现了将不可靠数据报中的段转换为传入字节流的工具：<code>StreamReassembler</code>和<code>TCPReceiver</code>。</p>
<p>现在，在实验3中，你将实现连接的另一端：一个将出站字节流转换为不可靠数据报中发送段的工具。</p>
<p>最后，在第4个实验中，你将结合前几个实验的工作，创建一个工作的TCP实现：<code>TCPConnection</code>，其中包含<code>TCPSender</code>和<code>TCPReceiver</code>。你将用它来与世界各地的真实服务器进行对话。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Misaka-9982-coder/img_hosting/img/image-20220322233230399.png" alt="image-20220322233230399"></p>
<h2 id="开始">开始</h2>
<p>你对<code>TCPSender</code>的实现将使用与你在实验0-2中使用的相同的Sponge库，并有额外的类和测试。为了开始进行作业：</p>
<ol>
<li>请确保你已经提交了你在实验2中的所有解决方案。请不要修改<code>libsponge</code>目录顶层以外的任何文件，或者<code>webget.cc</code>。否则，你可能会在合并实验3的启动代码时遇到麻烦。</li>
<li>在实验作业的存储库中，运行<code>git fetch</code>来检索实验作业的最新版本。</li>
<li>通过运行<code>git merge origin/lab3-startercode</code>，下载实验3的启动代码。</li>
<li>在<code>build</code>目录中，编译源代码：<code>make</code>（编译时可以运行<code>make -j4</code>以使用四个处理器）。</li>
<li>在<code>build</code>目录外，打开并开始编辑<code>writeups/lab3.md</code>文件。这是你实验报告的模板，将包含在你提交的内容中。</li>
</ol>
<h2 id="实验3：TCP发送方">实验3：TCP发送方</h2>
<p>TCP是一个协议，通过不可靠的数据报可靠地传输一对流量控制字节流（每个方向一个）。双方参与TCP连接，并且每一方同时充当“发送方”（其自身的传出字节流）和“接收方”（传入字节流）。双方被称为连接的“端点”或“对等点”。</p>
<p>本周，你将实现TCP的“发送方”部分，负责读取<code>ByTestStream</code>（由某些发送方应用程序创建并写入），并将流转换为一系列传出TCP段。在远程端，TCP接收方（重要的是要记住，接收方可以是有效TCP接收方的任何实现，而不一定是你自己的TCPReceiver。互联网标准最有价值的一点是，它们在端点之间建立一种通用语言，否则（指的是没有通用语言的情况），这些端点的行为可能会非常不同。）将这些段（那些到达的段，它们不一定都能到达）转换回原始字节流，并将确认和窗口发送回发送方。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Misaka-9982-coder/img_hosting/img/image-20230217113144228.png" alt="image-20230217113144228"></p>
<p><code>TCPSender</code>将负责：</p>
<ul>
<li>跟踪接收方的窗口（处理传入的确认号（<strong>ackno</strong>）和窗口大小（<strong>window size</strong>）） ；</li>
<li>尽可能通过读取<code>ByTestStream</code>、创建新的TCP段（包括SYN和FIN标志，如果需要），填充窗口，并发送它们；</li>
<li>跟踪哪些段已经发送但尚未被接收方确认——我们称之为“未完成的”段；</li>
<li>如果发送后经过足够的时间但尚未确认，则重新发送未完成的段；</li>
</ul>
<blockquote>
<p>为什么要这样做？基本原则是发送接收方允许我们发送的任何内容（填充窗口），并不断重传，直到接收方确认每段内容，这称为“自动重复请求”（ARQ）。发送方将字节流分成若干段，并在接收方窗口允许的范围内发送它们。感谢你上周的工作，我们知道，只要远程TCP接收方至少收到一次带有索引标记的字节，就可以重构字节流，而无论其顺序如何。发送方的工作是确保接收方至少获得每个字节一次。</p>
</blockquote>
<h3 id="TCPSender-应在何时断定某个段丢失并再次发送？"><code>TCPSender</code> 应在何时断定某个段丢失并再次发送？</h3>
<p>你的 <code>TCPSender</code> 将发送一组 <code>TCPSegments</code>。每个将包含来自传出 <code>ByTestStream</code> 的一个子字符串（可能为空），用序列号索引以指示其在流中的位置，并在流的开头用 <code>SYN</code> 标志标记，在流的结尾用 <code>FIN</code> 标志标记。</p>
<p>除了发送这些段外，<code>TCPSender</code> 还必须跟踪其未完成的段，直到它们占用的序列号被完全确认。<code>TCPSender</code> 的所有者将定期调用 <code>TCPSender</code> 的 <code>tick</code> 方法，以指示时间的流逝。<code>TCPSender</code> 负责查看其未完成的 <code>TCPSegments</code> 集合，并确定最早的已发送的段是否在未完成的情况下因为时间过长而未被确认（即，未确认其所有序列号）。如果是，则需要重新传输（再次发送）。</p>
<p>以下是“由于太长时间未完成”的含义规则。（这些是基于 <code>TCP</code> “真实”规则的简化版本：<code>RFC 6298</code>，建议5.1至5.6。这里的版本有点简化，但是你的TCP实现仍然能够与Internet上的真实服务器进行通信。）你将要实现的逻辑非常详细，但我们不希望你担心隐藏的测试用例试图绊倒你，或将其视为 <code>SAT</code>上的文字问题。本周我们将为你提供一些合理的单元测试，完成整个 <code>TCP</code> 实现后，在实验4中进行更全面的集成测试。只要你100%通过了这些测试，并且你的实现是合理的，就没事了。</p>
<blockquote>
<p>为什么要这样做？总的目标是让发送方及时检测到段丢失并需要重新发送的情况。重发前的等待时间是很重要的：你不希望发送方等待太长的时间来重发一个网段（因为这会延迟流向接收应用程序的字节），但你也不希望它重新发送一段如果发送方再等一段时间就会被确认的信息，这会浪费互联网的宝贵容量。</p>
</blockquote>
<ol>
<li>每隔几毫秒，你的 <code>TCPSender</code> 的 <code>tick</code> 方法就会被调用一次，它的参数是告诉你自上次调用该方法以来已经过了多少毫秒。使用参数可以维护 <code>TCPSender</code>已激活的总毫秒数的概念。请不要试图从操作系统或CPU调用任何“time”或“clock”函数——tick方法是你唯一访问时间流逝的方法。这样可以保持事物的确定性和可测试性。</li>
<li>当构建<code>TCPSender</code>时，会给它一个参数，告诉它**重传超时（retransmission timeout, RTO）**的“初始值”。RTO是在重新发送一个未完成的TCP段之前要等待的毫秒数。RTO的值会随时间变化，但“初始值”保持不变。启动代码将RTO的“初始值”保存在一个名为 <code>_initial_retransmission_timeout</code> 的成员变量中。</li>
<li>你将实现重传计时器<strong>timer</strong>：一个可以在某个时间启动的警报，一旦RTO过期，警报就会熄灭（或”过期”）。我们强调，这种时间流逝的概念来自于被调用的tick方法，而不是通过获取一天中的实际时间。</li>
<li>每次发送包含数据（在序列空间中长度非零）的段（不管是第一次还是重传），如果 <code>timer</code> 没有运行，就启动它，使它在RTO毫秒后失效（对于RTO的当前值）。</li>
<li>当所有未完成的数据都被确认后，关闭重传计时器。</li>
<li>如果 <code>tick</code> 被调用，并且重传计时器已经过期：
<ul>
<li>(a) 重传TCP接收方尚未完全确认的最早（最低序列号）段。你需要在一些内部数据结构中存储未发送的段，以便能够做到这一点。</li>
<li>(b) 如果窗口大小为非零：
<ul>
<li>i. 跟踪连续重新传输的次数，并增加它，因为你刚刚重新传输了一些内容。你的<code>TCPConnection</code>将使用这些信息来决定连接是否无望（连续重传次数过多）并需要中止。</li>
<li>ii. 将RTO的值增加一倍。（这被称为“指数回退”——它会减慢糟糕网络上的重传速度，以避免进一步堵塞工作。我们将在稍后的课堂上了解更多有关这方面的内容。）</li>
</ul>
</li>
<li>© 启动重传timer，使其在RTO毫秒后过期（对于前一个要点中概述的加倍操作后的RTO值）。</li>
</ul>
</li>
<li>当接收方给发送方确认成功接收新数据的<code>ackno</code>时（该<code>ackno</code>反映了一个大于之前的任何<code>ackno</code>的绝对序列号）。
<ul>
<li>(a) 将RTO调回其“初始值”。</li>
<li>(b) 如果发送方有任何未完成的数据，重新启动重传timer，使其在RTO毫秒后失效（对于RTO的当前值）。</li>
<li>© 将“连续重传”的计数重设为零。</li>
</ul>
</li>
</ol>
<p>你可能希望在单独的类中实现重传计时器的功能，这取决于你自己。如果需要，请将其添加到现有文件（<code>tcp_sender.hh</code>和<code>tcp_receiver.hh</code>）。</p>
<h3 id="实现TCP发送方">实现TCP发送方</h3>
<p>Ok！我们已经讨论了TCP发送方所做的基本概念（给定一个传出的<code>ByteStream</code>，把它分割成若干段，发送给接收者，如果它们没有很快得到确认，就继续重新发送）。我们还讨论了何时得出结论：未完成的段已经丢失，需要重新发送。</p>
<p>现在是你的<code>TCPSender</code>将提供的具体接口的时候了。有四个重要的事件需要它来处理，每一个事件都可能最终发送一个<code>TCPSegment</code>：</p>
<ol>
<li><code>fill_window</code>：<code>TCPSender</code>被要求填充窗口：它从其输入的<code>ByteStream</code>中读取并以<code>TCPSegments</code>的形式发送尽可能多的字节，只要窗口中有新的字节要读取和可用空间。你要确保你发送的每一个<code>TCPSegment</code>都能完全放入接收方的窗口中。使每个单独的<code>TCPSegment</code>尽可能大，但不能大于<code>TCPConfig::MAX_PAYLOAD_SIZE</code>（1452字节）所给的值。你可以使用<code>TCPSegment::length_in_sequence_space()</code>方法来计算一个段所占用的序列号的总数。你的TCPSender维护着一个名为<code>_next_seqn</code>的成员变量，它存储着从零开始的发送的绝对序列号。对于你发送的每一个段，你都要让<code>_next_seqno</code>增加段的长度，以便知道下一段的序列号。</li>
<li><code>ack_received</code>：从接收方收到一个确认信息，包括窗口的左边缘（= <code>ackno</code>）和右边缘（= <code>ackno + window size</code>）。<code>TCPSender</code>应该查看其未完成的段的集合，并删除任何现在已被完全确认的段（<code>ackno</code>大于该段中的所有序列号）。如果打开了新空间（指窗口变大），<code>TCPSender</code>可能需要再次填充窗口。如果<code>ackno</code>无效，即确认发送方尚未发送的数据，则此方法返回false。</li>
<li><code>tick</code>：经过的时间；<code>TCPSender</code>将检查重传计时器是否已过期，如果是，则以最低的序列号重传未发送的段。（重要的是，重新传输的决定不必看接收方的窗口：该段在第一次发送时落在窗口内，并且尚未确认，因此现在仍在接收方的窗口内。接收方不应该“收缩”窗口的右边缘，你可以假设右边缘始终保持不变或向右移动。）</li>
<li><code>send_empty_segment</code>：<code>TCPSender</code>应该生成并发送一个在序列空间中长度为零的<code>TCPSegment</code>，并将序列号正确设置为<code>_next_seqno</code>。如果所有者（你下周要实现的TCPConnection）想发送一个空的ACK段，这很有用。这种段（不携带数据，不占用序列号）不需要作为”未完成”来跟踪，也不会被重传。</li>
</ol>
<p>为了完成实验3，请查看文档中的完整接口，网址是https://cs144.github.io/doc/lab3/class_t_c_p_sender.html，并在<code>tcp_sender.hh</code>和<code>tcp_sender.cc</code>文件中实现完整的<code>TCPSender</code>公共接口。我们预计你会想添加私有方法和成员变量，可能还有一个辅助类。</p>
<h3 id="常见问题和特殊情况">常见问题和特殊情况</h3>
<ul>
<li>
<p>如何“发送”一个片段？</p>
<p>把它push到<code>_segments_out</code>队列中。就你的<code>TCPSender</code>而言，当你把它push到这个队列时，就认为它已经发送了。很快，所有者就会出现并pop它（使用公共的<code>segments_out()</code>访问器方法），并真正发送它。</p>
</li>
<li>
<p>等等，我如何既“发送”一段，又将同一段记录为未完成，以便我知道以后重新传输什么？那我不是要给每个网段做一个副本吗？这是不是很浪费？</p>
<p>当你发送一个包含数据的段时，你可能想把它push到<code>_segments_out</code>队列中，同时在内部的数据结构中保留一个副本，让你跟踪未完成的网段，以便可能的重传。这并不是很浪费，因为段的有效载荷被存储为引用计数的只读字符串（一个<code>Buffer</code>对象）。所以不用担心，它实际上并没有复制有效载荷数据。</p>
</li>
<li>
<p>在我从接收方得到<code>ACK</code>之前，我的<code>TCPSender</code>应该假定接收方的窗口大小是多少？</p>
<p>一个字节。</p>
</li>
<li>
<p>接收方告诉我它的窗口大小是零字节。我是否应该被卡住，不再发送任何数据？</p>
<p>否。如果接收方告诉你它的窗口长度是零字节，请将该信息保存为任何其他窗口使用（advertisement），因为它对3.1中描述的重传行为很重要。但当需要填充窗口时，请将窗口大小设置为一个字节。这被称为“零窗口探测”——这是一种定期探测接收方的方式，看看自从我们上次听到他们的消息后，他们是否碰巧在窗口中开辟了一些更多的空间。最坏的情况是，接收方会忽略你的一个字节段。（在一个更适合生产的TCP实现中，零窗口探测行为会更复杂一些，但也不会过于复杂。）</p>
</li>
<li>
<p>如果确认仅部分确认某些未完成的部分，我该怎么办？我是否应该尝试删除已确认的字节？</p>
<p>TCP发送方可以这样做，但就课程而言，没有必要搞得太复杂。在完全确认之前，将每个段视为完全未完成——它所占用的所有序列号都小于ackno。</p>
</li>
<li>
<p>如果我发送了三个包含 “a”、”b “和 “c “的独立段，但它们从未被确认，我可以在以后将它们重新传送到一个包含 “abc “的大段吗？还是我必须单独重发每个段？</p>
<p>再说一遍：TCP发送方可以做到这一点，但就本课程而言，没有必要搞得太花哨。只要单独跟踪每个未处理的段，当重传计时器到期时，再次发送最早的未处理段。</p>
</li>
<li>
<p>我应该在“未处理”数据结构中存储空段，并在必要时重发它们吗？</p>
<p>不，只有那些传递一些数据的网段（即在序列空间中消耗一些长度的网段）才应该被追踪为未完成的网段，并可能被重传。一个空的ACK不需要被记住，也不需要被重传。</p>
</li>
<li>
<p>如果这个PDF出来后还有更多的FAQ，我在哪里可以看到？</p>
<p>请定期查看网站（<a target="_blank" rel="noopener" href="https://cs144.github.io/lab_faq.html%EF%BC%89%E5%92%8CPiazza%E3%80%82">https://cs144.github.io/lab_faq.html）和Piazza。</a></p>
</li>
</ul>
<h3 id="RTO-Timer">RTO Timer</h3>
<ul>
<li><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/rfc6298/">RFC6298</a></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Misaka-9982-coder/img_hosting/img/image-20230219091320947.png" alt="image-20230219091320947"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RetransmissionTimer</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> _time_rest;</span><br><span class="line">    <span class="keyword">bool</span> _on_off;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RetransmissionTimer</span>(uint RTO = <span class="number">0</span>)</span><br><span class="line">      : _time_rest(RTO), _on_off(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(uint RTO)</span> </span>&#123;</span><br><span class="line">      _on_off = <span class="literal">true</span>;</span><br><span class="line">      _time_rest = RTO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">passing</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">      _time_rest -= ms_since_last_tick;</span><br><span class="line">      <span class="keyword">return</span> _on_off &amp;&amp; (_time_rest &lt;= <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">activated</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _on_off; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123; _on_off = <span class="literal">false</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这段代码定义了一个重传定时器类 <code>RetransmissionTimer</code>，用于在 TCP 协议中进行超时重传。该类具有以下成员变量和成员函数：</p>
<ul>
<li><code>_time_rest</code>：表示当前定时器剩余的时间（以毫秒为单位），默认为0。</li>
<li><code>_on_off</code>：表示当前定时器是否处于开启状态，默认为关闭状态。</li>
<li><code>RetransmissionTimer</code> 构造函数：可以传入一个可选的 RTO（重传超时）值作为参数，用于初始化 <code>_time_rest</code> 和 <code>_on_off</code>。</li>
<li><code>reset</code> 成员函数：用于重新设置定时器的状态，将 <code>_on_off</code> 置为 <code>true</code>，将 <code>_time_rest</code> 设置为 RTO 的值。</li>
<li><code>passing</code> 成员函数：接受一个时间间隔 <code>ms_since_last_tick</code> 的参数，表示距离上一次定时器计时已经过去了多少毫秒。函数首先将 <code>_time_rest</code> 减去这个时间间隔，然后返回 <code>_on_off &amp;&amp; (_time_rest &lt;= 0)</code> 的结果。如果定时器开启且剩余时间小于等于 0，则表示定时器已经超时，函数返回 true。</li>
<li><code>activated</code> 成员函数：返回定时器是否处于开启状态。</li>
<li><code>stop</code> 成员函数：将定时器关闭，将 <code>_on_off</code> 置为 <code>false</code>。</li>
</ul>
<h3 id="TCPSender">TCPSender</h3>
<p>TCPSender的状态转移</p>
<p><img src="https://kiprey.github.io/2021/11/cs144-lab3/image-20211109080457029.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! Accepts a ByteStream, divides it up into segments and sends the</span></span><br><span class="line"><span class="comment">//! segments, keeps track of which segments are still in-flight,</span></span><br><span class="line"><span class="comment">//! maintains the Retransmission Timer, and retransmits in-flight</span></span><br><span class="line"><span class="comment">//! segments if the retransmission timer expires.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TCPSender</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//! our initial sequence number, the number for our SYN.</span></span><br><span class="line">    WrappingInt32 _isn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! outbound queue of segments that the TCPSender wants sent</span></span><br><span class="line">    std::queue&lt;TCPSegment&gt; _segments_out&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! retransmission timer for the connection</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> _initial_retransmission_timeout;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! outgoing stream of bytes that have not yet been sent</span></span><br><span class="line">    ByteStream _stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! the (absolute) sequence number for the next byte to be sent</span></span><br><span class="line">    <span class="keyword">uint64_t</span> _next_seqno&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    uint _consecutive_retransmission_count&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    uint _retransmission_timeout;</span><br><span class="line">    </span><br><span class="line">    RetransmissionTimer _timer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> _window_size;</span><br><span class="line">    <span class="keyword">size_t</span> _bytes_in_flight;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">TCPState</span> &#123;</span> CLOSED, SYN_SENT, SYN_ACKED, FIN_SENT, FIN_ACKED &#125;;</span><br><span class="line">    TCPState _state&#123; CLOSED &#125;;</span><br><span class="line"></span><br><span class="line">    std::queue&lt;TCPSegment&gt; _segments_in_flight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">segcmp</span><span class="params">(<span class="keyword">const</span> TCPSegment &amp;seg1, <span class="keyword">const</span> TCPSegment &amp;seg2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> seg1.<span class="built_in">header</span>().seqno.<span class="built_in">raw_value</span>() &gt; seg2.<span class="built_in">header</span>().seqno.<span class="built_in">raw_value</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//! Initialize a TCPSender</span></span><br><span class="line">    <span class="built_in">TCPSender</span>(<span class="keyword">const</span> <span class="keyword">size_t</span> capacity = TCPConfig::DEFAULT_CAPACITY,</span><br><span class="line">              <span class="keyword">const</span> <span class="keyword">uint16_t</span> retx_timeout = TCPConfig::TIMEOUT_DFLT,</span><br><span class="line">              <span class="keyword">const</span> std::optional&lt;WrappingInt32&gt; fixed_isn = &#123;&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \name &quot;Input&quot; interface for the writer</span></span><br><span class="line">    <span class="comment">//!@&#123;</span></span><br><span class="line">    <span class="function">ByteStream &amp;<span class="title">stream_in</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _stream; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> ByteStream &amp;<span class="title">stream_in</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _stream; &#125;</span><br><span class="line">    <span class="comment">//!@&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \name Methods that can cause the TCPSender to send a segment</span></span><br><span class="line">    <span class="comment">//!@&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief A new acknowledgment was received</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ack_received</span><span class="params">(<span class="keyword">const</span> WrappingInt32 ackno, <span class="keyword">const</span> <span class="keyword">uint16_t</span> window_size)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief Generate an empty-payload segment (useful for creating empty ACK segments)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send_empty_ack</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send_empty_rst</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  	<span class="function"><span class="keyword">void</span> <span class="title">fill_segment</span><span class="params">(TCPSegment&amp; seg)</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//! \brief create and send segments to fill as much of the window as possible</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fill_window</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief Notifies the TCPSender of the passage of time</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tick</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> ms_since_last_tick)</span></span>;</span><br><span class="line">    <span class="comment">//!@&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \name Accessors</span></span><br><span class="line">    <span class="comment">//!@&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief How many sequence numbers are occupied by segments sent but not yet acknowledged?</span></span><br><span class="line">    <span class="comment">//! \note count is in &quot;sequence space,&quot; i.e. SYN and FIN each count for one byte</span></span><br><span class="line">    <span class="comment">//! (see TCPSegment::length_in_sequence_space())</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">bytes_in_flight</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief Number of consecutive retransmissions that have occurred in a row</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">consecutive_retransmissions</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief TCPSegments that the TCPSender has enqueued for transmission.</span></span><br><span class="line">    <span class="comment">//! \note These must be dequeued and sent by the TCPConnection,</span></span><br><span class="line">    <span class="comment">//! which will need to fill in the fields that are set by the TCPReceiver</span></span><br><span class="line">    <span class="comment">//! (ackno and window size) before sending.</span></span><br><span class="line">    <span class="function">std::queue&lt;TCPSegment&gt; &amp;<span class="title">segments_out</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _segments_out; &#125;</span><br><span class="line">    <span class="comment">//!@&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \name What is the next sequence number? (used for testing)</span></span><br><span class="line">    <span class="comment">//!@&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief absolute seqno for the next byte to be sent</span></span><br><span class="line">    <span class="function"><span class="keyword">uint64_t</span> <span class="title">next_seqno_absolute</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _next_seqno; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief relative seqno for the next byte to be sent</span></span><br><span class="line">    <span class="function">WrappingInt32 <span class="title">next_seqno</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">wrap</span>(_next_seqno, _isn); &#125;</span><br><span class="line">    <span class="comment">//!@&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该代码定义了一个 TCPSender 类，表示 TCP 的发送端。</p>
<p>该类有以下成员变量：</p>
<ul>
<li>_isn：TCP 连接的初始序列号，也就是 SYN 包的序列号。</li>
<li>_segments_out：已经准备好的待发送的 TCP 段。</li>
<li>_initial_retransmission_timeout：初始的重传超时时间。</li>
<li>_stream：未发送的字节流。</li>
<li>_next_seqno：下一个待发送的字节的序列号。</li>
<li>_consecutive_retransmission_count：连续重传的次数。</li>
<li>_retransmission_timeout：当前的重传超时时间。</li>
<li>_timer：TCP 发送端的重传定时器。</li>
<li>_window_size：TCP 接收端的窗口大小。</li>
<li>_bytes_in_flight：已经发送但未确认的字节数。</li>
<li>_state：TCP 连接的状态，包括 CLOSED、SYN_SENT、SYN_ACKED、FIN_SENT 和 FIN_ACKED。</li>
<li>_segments_in_flight：已经发送但未确认的 TCP 段。</li>
</ul>
<p>该类有以下成员函数：</p>
<ul>
<li>TCPSender()：构造函数。</li>
<li>stream_in()：获取待发送的字节流。</li>
<li>ack_received()：接收到 ACK 报文，更新状态信息。</li>
<li>send_empty_ack() 和 send_empty_rst()：发送空 ACK 和 RST 报文。</li>
<li>fill_window()：尽可能填充窗口并创建并发送 TCP 段。</li>
<li>tick()：定时器回调函数。</li>
<li>bytes_in_flight() 和 consecutive_retransmissions()：获取未确认的字节数和连续重传的次数。</li>
<li>segments_out()：获取已经准备好的待发送的 TCP 段。</li>
<li>next_seqno_absolute() 和 next_seqno()：获取下一个待发送字节的绝对序号和相对序号。</li>
</ul>
<h3 id="tick-函数">tick 函数</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! \param[in] ms_since_last_tick the number of milliseconds since the last call to this method</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPSender::tick</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> ms_since_last_tick)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// If tick is called and the retransmission timer has expired</span></span><br><span class="line">    <span class="keyword">if</span> (_timer.<span class="built_in">activated</span>() &amp;&amp; _timer.<span class="built_in">passing</span>(ms_since_last_tick)) &#123;</span><br><span class="line">        <span class="comment">// 6. (a) </span></span><br><span class="line">        TCPSegment seg = _segments_in_flight.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the window size is nonzero</span></span><br><span class="line">        <span class="keyword">if</span> (_window_size != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 6. (b) i</span></span><br><span class="line">            _consecutive_retransmission_count ++ ;</span><br><span class="line">            <span class="comment">// 6. (b) ii</span></span><br><span class="line">            _retransmission_timeout *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. (c)</span></span><br><span class="line">        <span class="keyword">if</span> (_consecutive_retransmission_count &lt;= TCPConfig::MAX_RETX_ATTEMPTS) &#123;</span><br><span class="line">            _segments_out.<span class="built_in">push</span>(seg);</span><br><span class="line">            _timer.<span class="built_in">reset</span>(_retransmission_timeout);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _timer.<span class="built_in">stop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码是 TCP 发送方 TCPSender 的 tick() 方法的实现。tick() 方法会在每次定时器触发时被调用，参数 <code>ms_since_last_tick</code> 表示自上次调用该方法以来经过的时间。</p>
<p>代码中的注释已经非常详细了，下面是一些简要的解释：</p>
<p>首先，如果定时器已经触发且已经过了超时时间，就需要对当前正在传输中的段进行处理。</p>
<p>然后，如果窗口大小是非零的，就将当前段的连续重传次数加 1，同时将重传超时时间加倍。</p>
<p>如果连续重传次数不超过最大重传次数，则将该段推入待发送队列 <code>_segments_out</code> 中，同时重置定时器。如果超过最大重传次数，则停止定时器。</p>
<p>整个过程的目的是确保 TCP 连接上的数据能够被成功传输，即使在网络出现故障、丢包等问题时也能够自动进行重传。</p>
<h3 id="ack-received">ack_received</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! \param ackno The remote receiver&#x27;s ackno (acknowledgment number)</span></span><br><span class="line"><span class="comment">//! \param window_size The remote receiver&#x27;s advertised window size</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPSender::ack_received</span><span class="params">(<span class="keyword">const</span> WrappingInt32 ackno, <span class="keyword">const</span> <span class="keyword">uint16_t</span> window_size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do not receive</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">unwrap</span>(ackno, _isn, _next_seqno) &gt; _next_seqno) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _window_size = window_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// from SYN_SENT state to SYN_ACKED state</span></span><br><span class="line">    <span class="keyword">if</span> (_state == SYN_SENT &amp;&amp; ackno == <span class="built_in">wrap</span>(<span class="number">1</span>, _isn)) &#123;</span><br><span class="line">        _state = SYN_ACKED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// no segments to receive</span></span><br><span class="line">    <span class="keyword">if</span> (_segments_in_flight.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TCPSegment seg = _segments_in_flight.<span class="built_in">front</span>();</span><br><span class="line">    <span class="keyword">bool</span> successful_receipt_of_new_data = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> seq = <span class="built_in">unwrap</span>(seg.<span class="built_in">header</span>().seqno, _isn, _next_seqno) + seg.<span class="built_in">length_in_sequence_space</span>();</span><br><span class="line">    <span class="keyword">auto</span> ack = <span class="built_in">unwrap</span>(ackno, _isn, _next_seqno);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (seq &lt;= ack) &#123;</span><br><span class="line">        _bytes_in_flight -= seg.<span class="built_in">length_in_sequence_space</span>();</span><br><span class="line">        _segments_in_flight.<span class="built_in">pop</span>();</span><br><span class="line">        successful_receipt_of_new_data = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_segments_in_flight.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        seg = _segments_in_flight.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">        seq = <span class="built_in">unwrap</span>(seg.<span class="built_in">header</span>().seqno, _isn, _next_seqno) + seg.<span class="built_in">length_in_sequence_space</span>();</span><br><span class="line">        ack = <span class="built_in">unwrap</span>(ackno, _isn, _next_seqno);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (successful_receipt_of_new_data) &#123;</span><br><span class="line">        <span class="comment">// 7. (a) Set the RTO back to its “initial value.”</span></span><br><span class="line">        _retransmission_timeout = _initial_retransmission_timeout;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. (b) If the sender has any outstanding data, restart the retransmission timer </span></span><br><span class="line">        <span class="comment">// so that it will expire after RTO milliseconds (for the current value of RTO).</span></span><br><span class="line">        <span class="keyword">if</span> (!_segments_in_flight.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            _timer.<span class="built_in">reset</span>(_retransmission_timeout);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _timer.<span class="built_in">stop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. (c) Reset the count of “consecutive retransmissions” back to zero.</span></span><br><span class="line">        _consecutive_retransmission_count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码是TCP发送方的一个函数，用于处理接收到的确认报文。确认报文包含远程接收方已经成功接收到的字节数以及窗口大小。</p>
<p>首先，代码检查接收到的确认号是否是一个有效的号码，如果确认号比已经接收到的下一个序号还要大，则说明该确认号还没有被接收到，直接返回。</p>
<p>然后，代码更新发送窗口大小为接收到的窗口大小。如果发送方处于 <code>SYN_SENT</code> 状态，并且收到了期望的确认号（即初始序列号加 1），则将发送方状态更新为 <code>SYN_ACKED</code> 状态。</p>
<p>代码继续处理接收到的确认号，查找序列号等于或小于确认号的段，并从未确认段列表中移除它们。如果成功接收到新数据，发送方将执行以下操作：</p>
<ul>
<li>(a) 重置重传超时计时器为其初始值。</li>
<li>(b) 如果发送方有任何未确认的数据，则重新启动重传计时器，以便在 RTO 毫秒后超时（对于当前的 RTO 值）。</li>
<li>© 将“连续重传计数”的计数重置为零。</li>
</ul>
<p>最后，如果所有未确认的数据段都已经被确认，则代码停止计时器，如果还有未确认的数据，则重置计时器并更新“连续重传计数”的计数。</p>
<h3 id="fill-segment">fill_segment</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPSender::fill_segment</span><span class="params">(TCPSegment&amp; seg)</span> </span>&#123;</span><br><span class="line">    seg.<span class="built_in">header</span>().seqno = <span class="built_in">wrap</span>(_next_seqno, _isn);</span><br><span class="line"></span><br><span class="line">    _next_seqno += seg.<span class="built_in">length_in_sequence_space</span>();</span><br><span class="line">    _bytes_in_flight += seg.<span class="built_in">length_in_sequence_space</span>();</span><br><span class="line"></span><br><span class="line">    _segments_in_flight.<span class="built_in">push</span>(seg);</span><br><span class="line">    _segments_out.<span class="built_in">emplace</span>(<span class="built_in">move</span>(seg));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!_timer.<span class="built_in">activated</span>()) &#123;</span><br><span class="line">        _timer.<span class="built_in">reset</span>(_retransmission_timeout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码是 TCP 发送方在发送一个 TCP 数据报前填充数据报的头部信息，并将数据报添加到待发送队列中。</p>
<p>在代码中，首先使用 <code>wrap()</code> 函数计算出数据报的序列号，并将该序列号设置为数据报头部的 <code>seqno</code> 字段。然后，将发送方的下一个序列号增加数据报的序列号空间长度（即增加 <code>seqno + payload.size()</code>）以更新发送方的下一个序列号，并将数据报的序列号空间长度加入到发送方的字节流队列中以更新发送方的字节流窗口。接着，将数据报添加到正在发送队列中（<code>segments_in_flight</code>）以便在重传时能够找到该数据报，同时将数据报添加到待发送队列中（<code>segments_out</code>）。最后，如果当前计时器没有启动，则使用计时器的 <code>reset()</code> 函数启动计时器，以便在超时时重传该数据报。</p>
<h3 id="fill-window">fill_window</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPSender::fill_window</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_state == CLOSED) &#123;</span><br><span class="line">        <span class="comment">// syn_segment</span></span><br><span class="line">        TCPSegment syn_seg;</span><br><span class="line"></span><br><span class="line">        syn_seg.<span class="built_in">header</span>().syn = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">fill_segment</span>(syn_seg);</span><br><span class="line">        </span><br><span class="line">        _state = SYN_SENT;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_state == SYN_ACKED) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> window_size = _window_size == <span class="number">0</span> ? <span class="number">1</span> : _window_size;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Congestion control</span></span><br><span class="line">        <span class="keyword">if</span> (_bytes_in_flight &gt;= window_size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> bytes_sent = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">size_t</span> max_tobe_sent = window_size - _bytes_in_flight;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (bytes_sent &lt; max_tobe_sent &amp;&amp; !_stream.<span class="built_in">buffer_empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// normal segment</span></span><br><span class="line">            TCPSegment seg;</span><br><span class="line">            seg.<span class="built_in">payload</span>() = <span class="built_in">Buffer</span>(<span class="built_in">move</span>(_stream.<span class="built_in">read</span>(<span class="built_in">min</span>(</span><br><span class="line">                TCPConfig::MAX_PAYLOAD_SIZE, max_tobe_sent - bytes_sent</span><br><span class="line">            ))));</span><br><span class="line">            </span><br><span class="line">            bytes_sent += seg.<span class="built_in">payload</span>().<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (_stream.<span class="built_in">eof</span>() &amp;&amp; bytes_sent &lt; max_tobe_sent) &#123;</span><br><span class="line">                seg.<span class="built_in">header</span>().fin = <span class="literal">true</span>;</span><br><span class="line">                _state = FIN_SENT;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">fill_segment</span>(seg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (window_size - _bytes_in_flight &gt;= <span class="number">1</span> &amp;&amp; _stream.<span class="built_in">eof</span>() &amp;&amp; _state == SYN_ACKED) &#123;</span><br><span class="line">            <span class="comment">// fin_segment</span></span><br><span class="line">            TCPSegment fin_seg;</span><br><span class="line"></span><br><span class="line">            fin_seg.<span class="built_in">header</span>().fin = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">fill_segment</span>(fin_seg);</span><br><span class="line"></span><br><span class="line">            _state = FIN_SENT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码是 TCP 发送方在填充发送窗口的过程中使用的。当发送方处于 <code>CLOSED</code> 状态时，它会创建一个 <code>SYN</code> 段，通过调用 <code>fill_segment</code> 函数来将这个段添加到发送窗口中，并且将发送方的状态改为 <code>SYN_SENT</code>。</p>
<p>当发送方处于 <code>SYN_ACKED</code> 状态时，发送方会进行拥塞控制，确保没有过多的未确认段在传输，从而避免网络拥塞。发送方首先检查已经发送但还未被确认的字节数是否达到了窗口大小，如果达到了则停止填充窗口。如果还可以发送数据，发送方从流中读取最多 <code>max_tobe_sent - bytes_sent</code> 个字节，然后将这些字节放入 TCP 段的 <code>payload</code> 中，填写 TCP 段的首部信息，并通过调用 <code>fill_segment</code> 函数将 TCP 段添加到发送窗口中。如果此时流已经被读取完且还有一些字节没有被发送，那么发送方会创建一个 <code>FIN</code> 段，并通过 <code>fill_segment</code> 函数将 FIN 段添加到发送窗口中。如果 FIN 段也被确认，那么发送方的状态会变为 <code>FIN_SENT</code>。</p>
<h2 id="完整代码-3">完整代码</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Misaka-9982-coder/CS144-fa21/blob/optimize/libsponge/tcp_sender.hh">tcp_sender.hh</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Misaka-9982-coder/CS144-fa21/blob/optimize/libsponge/tcp_sender.cc">tcp_sender.cc</a></li>
</ul>
</div><div class="tags"><a href="/tags/CS144"><i class="fa fa-tag">CS144</i></a><a href="/tags/Network"><i class="fa fa-tag">Network</i></a></div><div class="post-nav"><a class="pre" href="/2023/02/19/CS144-Lab4/">CS144-Lab4</a><a class="next" href="/2023/02/18/CS144-Lab2/">CS144-Lab2</a></div><div id="tcomment"></div><script src="https://unpkg.com/twikoo@1.5.7/dist/twikoo.all.min.js"></script><script>twikoo.init({
  envId: 'https://twikoo-f8467x06b-misaka-9982-coder.vercel.app/',
  el: '#tcomment',
  region: '',
  path: ''
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.jpeg"/></a><p>Try to be better.</p><a class="info-icon" href="mailto:1784321894@qq.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/Misaka-9982-coder" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/OS/" style="font-size: 15px;">OS</a> <a href="/tags/6-S081/" style="font-size: 15px;">6.S081</a> <a href="/tags/Acwing/" style="font-size: 15px;">Acwing</a> <a href="/tags/Algorithm/" style="font-size: 15px;">Algorithm</a> <a href="/tags/CS144/" style="font-size: 15px;">CS144</a> <a href="/tags/Network/" style="font-size: 15px;">Network</a> <a href="/tags/CS188/" style="font-size: 15px;">CS188</a> <a href="/tags/AI/" style="font-size: 15px;">AI</a> <a href="/tags/CS61A/" style="font-size: 15px;">CS61A</a> <a href="/tags/CS61BL/" style="font-size: 15px;">CS61BL</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Wireshark/" style="font-size: 15px;">Wireshark</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/06/28/Codewar-%E4%BD%93%E9%AA%8C/">Codewar 体验</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/15/6-S081-Lab-3-page-tables/">6.S081 Lab 3 page tables</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/14/6-S081-Lab-2-System-Calls/">6.S081-Lab 2: System Calls</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/10/6-S081-Lab-1-Xv6-and-Unix-utilities/">6.S081-Lab 1: Xv6 and Unix utilities</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/09/6-S081%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/">6.S081环境配置及参考资料</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/25/CS144-Lab7/">CS144-Lab7</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/25/CS144-Lab6/">CS144-Lab6</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/24/CS144-Lab5/">CS144-Lab5</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/20/Makefile-%E5%92%8C-CMake/">Makefile 和 CMake</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/19/CS144-Lab4/">CS144-Lab4</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.colopen-blog.com/" title="彩色铅笔" target="_blank">彩色铅笔</a><ul></ul><a href="https://www.selfknow.cn/" title="L2c" target="_blank">L2c</a><ul></ul><a href="https://blognas.hwb0307.com" title="浮云翩迁之间" target="_blank">浮云翩迁之间</a></div><div class="widget"><div class="widget-title"><i class="fa fa-heartbeat"> 访客地图</i></div></div><script id="clstr_globe" type="text/javascript" defer="defer" src="//clustrmaps.com/globe.js?d=NAGSI3cBPnTXd3xVo3V7zDC9xqeu_9ed2OCmGUj1uiw"></script><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async="async"></script><div class="widget"><div class="widget-title"><i class="fa fa-tags"> 网站资讯</i></div><ul> </ul><div class="webinfo-item"><div class="item-name">本站访客数  : </div><div class="item-count" id="busuanzi_value_site_uv"></div></div><ul> </ul><div class="webinfo-item"><div class="item-name">本站总访问量  : </div><div class="item-count" id="busuanzi_value_site_pv"></div></div><ul></ul><div class="webinfo-item"><div class="item-name">本站总字数 : </div><div class="item-count">301k</div></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 - 2023 <a href="/." rel="nofollow">Misaka's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>