<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>CS144-Lab6 | Misaka's blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({google_ad_client: "ca-pub-5060306535186583", enable_page_level_ads: true});</script><meta name="generator" content="Hexo 6.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">CS144-Lab6</h1><a id="logo" href="/.">Misaka's blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a><a href="/messageboard/"><i class="fa fa fa-comments"> 留言版</i></a><a href="/link/"><i class="fa fa fa-external-link"> 友链</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">CS144-Lab6</h1><div class="post-meta">2023-02-25<span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 3.8k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 15</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><h2 id="概述-5">概述</h2>
<p>在本周的实验中，你将在现有的<code>NetworkInterface</code>基础上实现一个IP路由器，从而结束本课程。路由器有几个网络接口，可以在其中任何一个接口上接收互联网数据报。路由器的工作是根据<strong>路由表</strong>转发它得到的数据报：一个规则列表，它告诉路由器，对于任何给定的数据报：</p>
<ul>
<li>发送到哪个接口；</li>
<li>下一跳的IP地址 ；</li>
</ul>
<p>你的工作是实现一个路由器，它可以为任何给定的数据报计算出这两件事。(你不需要实现设置路由表的算法，例如RIP、OSPF、BGP或SDN控制器，只需要实现跟随路由表的算法)。</p>
<p>你对路由器的实现将使用带有新的<code>Router</code>类的Sponge库，以及在模拟网络中检查你的路由器功能的测试。实验6建立在你在实验5中对<code>NetworkInterface</code>的实现之上，但不使用你在实验0-4中实现的TCP栈。IP路由器不需要知道任何关于TCP、ARP或以太网的信息(仅限IP)。我们希望你的实现将需要大约25-30行的代码。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Misaka-9982-coder/img_hosting/img/1-20230224183738464.jpg" alt=""></p>
<p>图1：路由器包含多个网络接口，可以在其中任何一个接口上接收IP数据报。路由器将接收到的任何数据报转发到相应出站接口上的下一跳，路由表告诉路由器如何做出这个决定。</p>
<h2 id="开始-4">开始</h2>
<ol>
<li>请确保你已经提交了你在实验5中的所有解决方案。请不要修改<code>libsponge</code>目录顶层以外的任何文件，或者<code>webget.cc</code>。(请不要添加代码所依赖的额外文件。)否则，你可能会在合并实验6的启动代码时遇到麻烦。</li>
<li>在实验作业的存储库中，运行<code>git fetch</code>来检索实验作业的最新版本。</li>
<li>通过运行<code>git merge origin/lab6-startercode</code>，下载实验6的启动代码。</li>
<li>在<code>build</code>目录中，编译源代码：<code>make</code>(编译时可以运行<code>make -j4</code>以使用四个处理器)。</li>
<li>在<code>build</code>目录外，打开并开始编辑<code>writeups/lab6.md</code>文件。这是你实验报告的模板，将包含在你提交的内容中。</li>
</ol>
<h2 id="实现路由器">实现路由器</h2>
<p>在本实验中，你将实现一个Router类，它可以：</p>
<ul>
<li>跟踪路由表(转发规则或路由列表)，并</li>
<li>转发它收到的每个数据报：
<ul>
<li>转发到正确的下一跳</li>
<li>在正确的出站<code>NetworkInterface</code>上</li>
</ul>
</li>
</ul>
<p>你的实现将被添加到<a target="_blank" rel="noopener" href="https://github.com/CS144/sponge/blob/lab6-startercode/libsponge/router.hh">router.hh</a>和<a target="_blank" rel="noopener" href="https://github.com/CS144/sponge/blob/lab6-startercode/libsponge/router.cc">router.cc</a>骨架文件中。在你开始编码之前，请查看<a target="_blank" rel="noopener" href="https://cs144.github.io/doc/lab6/class_router.html">新的Router类的文档</a>。</p>
<p>下面是你要实现的两个方法，以及我们对每个方法的期望：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_route</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint32_t</span> route_prefix,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">const</span> <span class="keyword">uint8_t</span> prefix_length,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">const</span> optional&lt;Address&gt; next_hop,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">const</span> <span class="keyword">size_t</span> interface_num)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个方法将一条路由添加到路由表中。你要在Router类中添加一个数据结构作为私有成员来存储这些信息。这个方法所要做的就是保存路由，以供以后使用。</p>
<blockquote>
<p><strong>路由的各个部分是什么意思？</strong></p>
<p>路由是一个”匹配——行动”规则：它告诉路由器，如果一个数据报前往一个特定的网络(一个IP地址范围)，并且如果该路由被选为最具体的匹配路由，那么路由器应该把数据报转发到特定接口上的特定下一跳。</p>
<p><strong>“匹配”：数据报是前往这个网络的吗?</strong><code>route_prefix</code>和<code>prefix_length</code>共同指定了一个可能包括数据报目的地的IP地址范围(一个网络)。<code>route_prefix</code>是一个32位数字的IP地址。<code>prefix_length</code>是一个介于0和32(包括32)之间的数字；它告诉路由器路由前缀中有多少最高有效位是有效的。例如，要表达一个到网络”18.47.0.0/16”的路由(这与前两个字节为18和47的任何32位IP地址匹配)，路由前缀将是305070080(18×224+47×216)，前缀长度是16。任何以”18.47.x.y”为目的地的数据报都会匹配。</p>
<p>**“行动”：如果路由匹配并被选中，该怎么做。**如果路由器直接连接到有关的网络，<code>next_hop</code>将是一个空的可选项；在这种情况下，<code>next_hop</code>是数据报的目标地址。但如果路由器是通过其他路由器连接到有关网络的，则<code>next_hop</code>将包含路径中下一路由器的IP地址。<code>interface_num</code>给出了路由器<code>NetworkInterface</code>的索引，它用来将数据报发送到下一跳。你可以用<code>interface(interface_num)</code>方法访问这个接口。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">route_one_datagram</span><span class="params">(InternetDatagram &amp;dgram)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里是橡胶与道路的交汇处。这个方法需要将数据报路由到下一跳，从适当的接口传出。它需要实现IP路由器的”最长前缀匹配”逻辑，以找到最佳路由，这意味着：</p>
<ul>
<li>路由器搜索路由表，以找到与数据报的目的地址相匹配的路由。我们所说的”匹配”是指目的地址的最高有效<code>prefix_length</code>比特与<code>route_prefix</code>的最高有效<code>prefix_length</code>比特相同的。</li>
<li>在匹配的路由中，路由器选择具有最大<code>prefix_length</code>的路由，这就是<strong>最长前缀匹配</strong>路由。</li>
<li>如果没有匹配的路由，路由器会丢弃数据报。</li>
<li>路由器会递减数据报的TTL(生存时间)。如果TTL已经为零，或在递减后为零，路由器应该放弃该数据报。</li>
<li>否则，路由器将修改后的数据报通过适当的接口(<code>interface(interface_num).send_datagram()</code>)发送到适当的下一跳。</li>
</ul>
<blockquote>
<p>在这个互联网的设计中，有个优点(或至少是一种成功的抽象)：路由器从不考虑TCP、ARP或以太网帧。路由器甚至不知道链路层是什么样子的。路由器只考虑互联网数据包，并且只通过<code>NetworkInterface</code>抽象与链路层进行交互。当涉及到”链路层地址是如何解决的？”或”链路层是否有自己的不同于IP的寻址方案？”或”链路层帧的格式是什么？”或”数据报的有效载荷是什么意思？”等问题时，路由器根本不关心。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! \brief A wrapper for NetworkInterface that makes the host-side</span></span><br><span class="line"><span class="comment">//! interface asynchronous: instead of returning received datagrams</span></span><br><span class="line"><span class="comment">//! immediately (from the `recv_frame` method), it stores them for</span></span><br><span class="line"><span class="comment">//! later retrieval. Otherwise, behaves identically to the underlying</span></span><br><span class="line"><span class="comment">//! implementation of NetworkInterface.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncNetworkInterface</span> :</span> <span class="keyword">public</span> NetworkInterface &#123;</span><br><span class="line">    std::queue&lt;InternetDatagram&gt; _datagrams_out&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> NetworkInterface::NetworkInterface;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Construct from a NetworkInterface</span></span><br><span class="line">    <span class="built_in">AsyncNetworkInterface</span>(NetworkInterface &amp;&amp;interface) : <span class="built_in">NetworkInterface</span>(interface) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief Receives and Ethernet frame and responds appropriately.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! - If type is IPv4, pushes to the `datagrams_out` queue for later retrieval by the owner.</span></span><br><span class="line">    <span class="comment">//! - If type is ARP request, learn a mapping from the &quot;sender&quot; fields, and send an ARP reply.</span></span><br><span class="line">    <span class="comment">//! - If type is ARP reply, learn a mapping from the &quot;target&quot; fields.</span></span><br><span class="line">    <span class="comment">//!</span></span><br><span class="line">    <span class="comment">//! \param[in] frame the incoming Ethernet frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recv_frame</span><span class="params">(<span class="keyword">const</span> EthernetFrame &amp;frame)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> optional_dgram = NetworkInterface::<span class="built_in">recv_frame</span>(frame);</span><br><span class="line">        <span class="keyword">if</span> (optional_dgram.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">            _datagrams_out.<span class="built_in">push</span>(std::<span class="built_in">move</span>(optional_dgram.<span class="built_in">value</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Access queue of Internet datagrams that have been received</span></span><br><span class="line">    <span class="function">std::queue&lt;InternetDatagram&gt; &amp;<span class="title">datagrams_out</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _datagrams_out; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">route_rule</span>&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> route_prefix&#123;&#125;;</span><br><span class="line">    <span class="keyword">uint8_t</span> prefix_length&#123;&#125;;</span><br><span class="line">    std::optional&lt;Address&gt; next_hop;</span><br><span class="line">    <span class="keyword">size_t</span> interface_num&#123;&#125;;</span><br><span class="line">    <span class="built_in">route_rule</span>(<span class="keyword">const</span> <span class="keyword">uint32_t</span> _route_prefix,</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">uint8_t</span> _prefix_length,</span><br><span class="line">                <span class="keyword">const</span> std::optional&lt;Address&gt; _next_hop,</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">size_t</span> _interface_num)</span><br><span class="line">    :<span class="built_in">route_prefix</span>(_route_prefix),<span class="built_in">prefix_length</span>(_prefix_length)</span><br><span class="line">    ,<span class="built_in">next_hop</span>(_next_hop),<span class="built_in">interface_num</span>(_interface_num)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \brief A router that has multiple network interfaces and</span></span><br><span class="line"><span class="comment">//! performs longest-prefix-match routing between them.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span> &#123;</span></span><br><span class="line">    <span class="comment">//! The router&#x27;s collection of network interfaces</span></span><br><span class="line">    std::vector&lt;AsyncNetworkInterface&gt; _interfaces&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Send a single datagram from the appropriate outbound interface to the next hop,</span></span><br><span class="line">    <span class="comment">//! as specified by the route with the longest prefix_length that matches the</span></span><br><span class="line">    <span class="comment">//! datagram&#x27;s destination address.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">route_one_datagram</span><span class="params">(InternetDatagram &amp;dgram)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;route_rule&gt; _rules&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//! Add an interface to the router</span></span><br><span class="line">    <span class="comment">//! \param[in] interface an already-constructed network interface</span></span><br><span class="line">    <span class="comment">//! \returns The index of the interface after it has been added to the router</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">add_interface</span><span class="params">(AsyncNetworkInterface &amp;&amp;interface)</span> </span>&#123;</span><br><span class="line">        _interfaces.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(interface));</span><br><span class="line">        <span class="keyword">return</span> _interfaces.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Access an interface by index</span></span><br><span class="line">    <span class="function">AsyncNetworkInterface &amp;<span class="title">interface</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> N)</span> </span>&#123; <span class="keyword">return</span> _interfaces.<span class="built_in">at</span>(N); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Add a route (a forwarding rule)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_route</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint32_t</span> route_prefix,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">const</span> <span class="keyword">uint8_t</span> prefix_length,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">const</span> std::optional&lt;Address&gt; next_hop,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">const</span> <span class="keyword">size_t</span> interface_num)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Route packets between the interfaces</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">route</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">prefix_equal</span><span class="params">(<span class="keyword">uint32_t</span> ip1, <span class="keyword">uint32_t</span> ip2, <span class="keyword">uint8_t</span> prefix_length)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这段代码实现了一个多接口的路由器，其中每个接口都有一个异步接收数据报的队列。路由器的功能是根据最长前缀匹配算法对接收到的每个数据报进行路由，并将其发送到下一跳，以使其达到目标地址。</p>
<p><code>AsyncNetworkInterface</code>是一个对<code>NetworkInterface</code>的封装，它具有一个异步队列<code>_datagrams_out</code>，在接收到数据报后将其推送到队列中。它还覆盖了<code>NetworkInterface</code>的<code>recv_frame</code>方法，以便将数据报推送到队列中，以供稍后检索。</p>
<p><code>Router</code>类有一个包含所有网络接口的向量 <code>_interfaces</code>，一个包含所有路由表规则的向量 <code>_rules</code>，以及一个<code>add_interface</code>方法，用于添加接口。路由器还实现了一个<code>add_route</code>方法，该方法接受路由前缀、路由前缀长度、下一跳IP地址(可选)以及出站接口的索引。它将所有路由规则存储在一个向量中，以便在进行数据报路由时进行查找。此外，还实现了一个<code>route</code>方法，用于将路由器的所有接口一起轮询，处理每个接口上接收到的数据报，并调用<code>route_one_datagram</code>方法将其路由到下一跳。最后，还实现了一个<code>prefix_equal</code>方法，用于检查两个IP地址的前缀是否相同。</p>
<p>在路由表的最长前缀匹配算法中，对于目的地址，路由器从路由表中选择最具体的路由，该路由匹配前缀长度最长，而且其匹配的前缀位数与目标地址的前缀位数相同。<code>prefix_equal</code>方法用于比较两个IP地址的前缀。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! \param[in] route_prefix The &quot;up-to-32-bit&quot; IPv4 address prefix to match the datagram&#x27;s destination address against</span></span><br><span class="line"><span class="comment">//! \param[in] prefix_length For this route to be applicable, how many high-order (most-significant) bits of the route_prefix will need to match the corresponding bits of the datagram&#x27;s destination address?</span></span><br><span class="line"><span class="comment">//! \param[in] next_hop The IP address of the next hop. Will be empty if the network is directly attached to the router (in which case, the next hop address should be the datagram&#x27;s final destination).</span></span><br><span class="line"><span class="comment">//! \param[in] interface_num The index of the interface to send the datagram out on.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Router::add_route</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint32_t</span> route_prefix,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">const</span> <span class="keyword">uint8_t</span> prefix_length,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">const</span> optional&lt;Address&gt; next_hop,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">const</span> <span class="keyword">size_t</span> interface_num)</span> </span>&#123;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;DEBUG: adding route &quot;</span> &lt;&lt; Address::<span class="built_in">from_ipv4_numeric</span>(route_prefix).<span class="built_in">ip</span>() &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">int</span></span>(prefix_length)</span><br><span class="line">         &lt;&lt; <span class="string">&quot; =&gt; &quot;</span> &lt;&lt; (next_hop.<span class="built_in">has_value</span>() ? next_hop-&gt;<span class="built_in">ip</span>() : <span class="string">&quot;(direct)&quot;</span>) &lt;&lt; <span class="string">&quot; on interface &quot;</span> &lt;&lt; interface_num &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="function">route_rule <span class="title">r</span><span class="params">(route_prefix,prefix_length,next_hop,interface_num)</span></span>;</span><br><span class="line">    _rules.<span class="built_in">push_back</span>(<span class="built_in">move</span>(r));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Router::add_route</code> 函数添加一个路由规则，包含路由表项中的路由前缀，前缀长度，下一跳地址（如果有），以及数据包的输出接口索引。这个函数打印了调试信息，用于检查添加的路由规则。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! \param[in] dgram The datagram to be routed</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Router::route_one_datagram</span><span class="params">(InternetDatagram &amp;dgram)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> dst = dgram.<span class="built_in">header</span>().dst;</span><br><span class="line">    optional&lt;Address&gt; next_hop&#123;&#125;;</span><br><span class="line">    <span class="keyword">size_t</span> interface_num&#123;&#125;;</span><br><span class="line">    optional&lt;<span class="keyword">uint8_t</span>&gt; best_by_far&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; r: _rules) &#123;</span><br><span class="line">        <span class="keyword">if</span>((!best_by_far.<span class="built_in">has_value</span>() || r.prefix_length&gt;best_by_far.<span class="built_in">value</span>()) &amp;&amp; <span class="built_in">prefix_equal</span>(dst,r.route_prefix,r.prefix_length))&#123;</span><br><span class="line">            next_hop = r.next_hop;</span><br><span class="line">            interface_num = r.interface_num;</span><br><span class="line">            best_by_far = r.prefix_length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(best_by_far.<span class="built_in">has_value</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(dgram.<span class="built_in">header</span>().ttl&gt;<span class="number">1</span>) &#123;</span><br><span class="line">            dgram.<span class="built_in">header</span>().ttl--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(next_hop.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">                <span class="built_in">interface</span>(interface_num).<span class="built_in">send_datagram</span>(dgram,next_hop.<span class="built_in">value</span>());</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// if not have next_hop, the next_hop is dgram&#x27;s destination hop</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">interface</span>(interface_num).<span class="built_in">send_datagram</span>(dgram,Address::<span class="built_in">from_ipv4_numeric</span>(dst));</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Router::route_one_datagram</code> 函数根据路由表将数据报路由到下一个合适的接口。它使用路由表中最长前缀匹配的规则来查找应该用哪个输出接口。如果找到合适的路由规则，则检查数据报的 TTL 是否大于1。如果是，减少TTL并将数据报发送到下一个合适的接口。如果找不到合适的路由规则，数据报将被丢弃。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Router::route</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Go through all the interfaces, and route every incoming datagram to its proper outgoing interface.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;interface : _interfaces) &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;queue = interface.<span class="built_in">datagrams_out</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">not</span> queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="built_in">route_one_datagram</span>(queue.<span class="built_in">front</span>());</span><br><span class="line">            queue.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Router::route</code> 函数遍历路由器的所有网络接口，将每个接口的入队数据报依次路由到正确的输出接口上。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Router::prefix_equal</span><span class="params">(<span class="keyword">uint32_t</span> ip1, <span class="keyword">uint32_t</span> ip2, <span class="keyword">uint8_t</span> prefix_length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prefix_length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">return</span></span> (ip1 &gt;&gt; (<span class="number">32</span>-prefix_length)) == (ip2 &gt;&gt; (<span class="number">32</span>-prefix_length));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Router::prefix_equal</code> 函数用于比较两个IP地址的最高 <code>prefix_length</code> 位是否相等。如果前缀长度为0，将返回 true。如果前缀长度不为0，则将两个地址右移（32-prefix_length）位，并比较结果是否相等。</p>
<h2 id="测试">测试</h2>
<p>你可以通过运行<code>make checklab6</code>来测试你的实现。这将在特定的模拟网络中测试路由器，如图2所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Misaka-9982-coder/img_hosting/img/2.jpg" alt=""></p>
<p>图2：应用/网络模拟器工具中使用的模拟测试网络，也是由<code>make check lab6</code>运行的。 (有趣的事实：uun网络是<a target="_blank" rel="noopener" href="https://whois.arin.net/rest/net/NET-198-178-229-0-1">David Mazieres的互联网切片，于1993年分配</a>。<code>whois</code>工具或链接的网站可以用来查询谁控制了每个IP地址的分配)。</p>
<h2 id="Q-A">Q &amp; A</h2>
<ul>
<li>
<p>我应该用什么数据结构来记录路由表？</p>
<p>由你决定! 但不需要太过疯狂。每个数据报需要做O(n)个工作是完全可以接受的，其中n是路由表的条目数。如果你想做一些更有效的事情，我们鼓励你在优化之前先得到一个有效的实现，并仔细记录和评论你选择的任何实现。</p>
</li>
<li>
<p>如何将以地址对象形式出现的IP地址转换为可以写入ARP消息的32位原始整数？</p>
<p>使用<code>Address::ipv4_numeric()</code>方法。</p>
</li>
<li>
<p>如何将一个以原始32位整数形式出现的IP地址转换为一个地址对象？</p>
<p>使用 <code>Address::from_ipv4_numeric()</code>方法。</p>
</li>
<li>
<p>如何将一个32位IP地址的最高n位(其中0≤n≤32) 与另一个32位IP地址的最重要的n位进行比较？</p>
<p>这可能是这项任务中”最棘手”的部分，因为要让逻辑正确。也许值得在C++中写一个小的测试程序(一个简短的独立程序)或者在Sponge中添加一个测试，以验证你对相关的C++操作符的理解，并仔细检查你的逻辑。</p>
<p>回顾一下，在C和C++中，将一个32位整数移位32位，可能会产生未定义行为。使用<code>make_clean</code>，然后在编译代码时打开sanitizer(<code>cmake -DCMAKE_BUILD_TYPE=RelASan</code>)以便在你提交之前尝试捕捉你的代码中任何未定义的行为。</p>
<p>你可以通过在<code>build</code>目录中运行<code>./apps/network simulator</code>来直接运行路由器测试。</p>
</li>
<li>
<p>如果路由器没有到目的地的路由，或者TTL为零，它是不是应该向数据报的源头发送一个ICMP错误信息？</p>
<p>在现实生活中，是的，这将是有帮助的。但在这个实验里没有必要——丢弃数据报就足够了。(即使在现实生活中，也不是每个路由器都会在这些情况下向源头发送ICMP消息)。</p>
</li>
<li>
<p>我如何运行本实验的测试套件？</p>
<p><code>make check_lab6</code>(两个测试)。或者你可以用<code>make check</code>运行整个测试套件(161个测试)。</p>
</li>
<li>
<p>如果这个PDF出来后还有更多的FAQ，我在哪里可以看到？</p>
<p>请定期查看网站(<a target="_blank" rel="noopener" href="https://cs144.github.io/lab_faq.html">https://cs144.github.io/lab_faq.html</a>)和Piazza。</p>
</li>
</ul>
</div><div class="tags"><a href="/tags/CS144"><i class="fa fa-tag">CS144</i></a><a href="/tags/Network"><i class="fa fa-tag">Network</i></a></div><div class="post-nav"><a class="pre" href="/2023/02/25/CS144-Lab7/">CS144-Lab7</a><a class="next" href="/2023/02/24/CS144-Lab5/">CS144-Lab5</a></div><div id="tcomment"></div><script src="https://unpkg.com/twikoo@1.5.7/dist/twikoo.all.min.js"></script><script>twikoo.init({
  envId: 'https://twikoo-f8467x06b-misaka-9982-coder.vercel.app/',
  el: '#tcomment',
  region: '',
  path: ''
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.jpeg"/></a><p>Try to be better.</p><a class="info-icon" href="https://twitter.com/five96413950" title="Twitter" target="_blank" style="margin-inline:5px"> <i class="fa fa-twitter-square" style="margin-inline:5px"></i></a><a class="info-icon" href="mailto:1784321894@qq.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/Misaka-9982-coder" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/OS/" style="font-size: 15px;">OS</a> <a href="/tags/6-S081/" style="font-size: 15px;">6.S081</a> <a href="/tags/Acwing/" style="font-size: 15px;">Acwing</a> <a href="/tags/Algorithm/" style="font-size: 15px;">Algorithm</a> <a href="/tags/CS144/" style="font-size: 15px;">CS144</a> <a href="/tags/Network/" style="font-size: 15px;">Network</a> <a href="/tags/CS188/" style="font-size: 15px;">CS188</a> <a href="/tags/AI/" style="font-size: 15px;">AI</a> <a href="/tags/CS61A/" style="font-size: 15px;">CS61A</a> <a href="/tags/CS61BL/" style="font-size: 15px;">CS61BL</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Wireshark/" style="font-size: 15px;">Wireshark</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/03/15/6-S081-Lab-3-page-tables/">6.S081 Lab 3 page tables</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/14/6-S081-Lab-2-System-Calls/">6.S081-Lab 2: System Calls</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/10/6-S081-Lab-1-Xv6-and-Unix-utilities/">6.S081-Lab 1: Xv6 and Unix utilities</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/09/6-S081%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/">6.S081环境配置及参考资料</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/25/CS144-Lab7/">CS144-Lab7</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/25/CS144-Lab6/">CS144-Lab6</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/24/CS144-Lab5/">CS144-Lab5</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/20/Makefile-%E5%92%8C-CMake/">Makefile 和 CMake</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/19/CS144-Lab4/">CS144-Lab4</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/19/CS144-Lab3/">CS144-Lab3</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.colopen-blog.com/" title="彩色铅笔" target="_blank">彩色铅笔</a><ul></ul><a href="https://www.selfknow.cn/" title="L2c" target="_blank">L2c</a><ul></ul><a href="https://blognas.hwb0307.com" title="浮云翩迁之间" target="_blank">浮云翩迁之间</a></div><div class="widget"><div class="widget-title"><i class="fa fa-heartbeat"> 访客地图</i></div></div><script id="clstr_globe" type="text/javascript" defer="defer" src="//clustrmaps.com/globe.js?d=NAGSI3cBPnTXd3xVo3V7zDC9xqeu_9ed2OCmGUj1uiw"></script><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async="async"></script><div class="widget"><div class="widget-title"><i class="fa fa-tags"> 网站资讯</i></div><ul> </ul><div class="webinfo-item"><div class="item-name">本站访客数  : </div><div class="item-count" id="busuanzi_value_site_uv"></div></div><ul> </ul><div class="webinfo-item"><div class="item-name">本站总访问量  : </div><div class="item-count" id="busuanzi_value_site_pv"></div></div><ul></ul><div class="webinfo-item"><div class="item-name">本站总字数 : </div><div class="item-count">300.4k</div></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 - 2023 <a href="/." rel="nofollow">Misaka's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>