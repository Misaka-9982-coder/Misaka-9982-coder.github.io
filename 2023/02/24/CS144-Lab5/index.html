<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>CS144-Lab5 | Misaka's blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({google_ad_client: "ca-pub-5060306535186583", enable_page_level_ads: true});</script><meta name="generator" content="Hexo 6.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">CS144-Lab5</h1><a id="logo" href="/.">Misaka's blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a><a href="/messageboard/"><i class="fa fa fa-comments"> 留言版</i></a><a href="/link/"><i class="fa fa fa-external-link"> 友链</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">CS144-Lab5</h1><div class="post-meta">2023-02-24<span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 5k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 20</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><h2 id="概述-3">概述</h2>
<p>在本周的实验中，你将深入研究并实现一个网络接口：世界各地的互联网数据报和一跳一跳的链路层以太网帧之间的桥梁。该组件可以“隐藏”在早期实验的TCP/IP实现之下，但它也将用于不同的设置：当你在实验6中建立一个路由器时，它将在网络接口之间路由数据报。图1显示了网络接口如何适应这两种设置。</p>
<p>你对网络接口的实现将使用与你在实验0-4中使用的相同的Sponge库，并增加了类和测试。但是，应大众的要求，本实验的大部分(但不是全部)都可以在不依赖早期实验的TCP连接的情况下完成。</p>
<p>在过去的实验中，你写了一个TCP实现，可以成功地与使用TCP的任何其他计算机交换TCP段。这些网段实际上是如何传达给对等方的TCP实现的呢？正如我们所讨论的，有几种选择：</p>
<ul>
<li>
<p><strong>TCP-in-UDP-in-IP</strong>：TCP段可以在用户数据报的有效载荷中携带。在正常(用户空间)环境下工作时，这是最容易实现的。Linux提供了一个接口(“互联网数据报套接字”，<code>UDPSocket</code>)，允许应用程序只提供用户数据报和目标地址的有效载荷，内核负责构造UDP报头、IP报头和以太网报头，然后将数据包发送到适当的下一跳。内核确保每个套接字具有本地和远程地址以及端口号的独占组合，并且由于内核是将这些地址和端口号写入UDP和IP头的内核，因此它可以保证不同应用程序之间的隔离。</p>
</li>
<li>
<p><strong>TCP-in-IP</strong>：在通常情况下，TCP段几乎总是直接放在互联网数据报中，在IP和TCP报头之间没有UDP报头。这就是人们所说的”TCP/IP”。这在实现上要困难一些。Linux提供了一个称为TUN设备的接口，该接口允许应用程序提供整个Internet数据报，内核负责其余部分(编写以太网报头，并通过物理以太网卡实际发送，等等)。但是现在，应用程序必须自己构造完整的IP报头，而不仅仅是有效载荷。</p>
<p>你已经做了这个。在实验4中，我们为你提供了一个表示Internet数据报的对象，它知道如何解析和序列化自身(<a target="_blank" rel="noopener" href="https://cs144.github.io/doc/lab5/class_i_pv4_datagram.html">tcp_helpers/ipv4_datagram.{hh,cc}</a>)以及在IP中封装TCP段的逻辑(现在可以在<a target="_blank" rel="noopener" href="https://github.com/CS144/sponge/blob/lab5-startercode/libsponge/tcp_helpers/tcp_over_ip.cc">tcp_helpers/tcp_over_ip.cc</a>中找到)。<code>CS144TCPSocket</code>使用这些工具将<code>TCPConnection</code>连接到TUN设备。</p>
</li>
<li>
<p><strong>TCP-in-IP-in-Ethernet</strong>：在上述方法中，我们仍然依赖于Linux内核的部分网络栈。每次你的代码向TUN设备写入一个IP数据报时，Linux必须构建一个适当的链路层(以太网)帧，并将IP数据报作为其有效载荷。这意味着Linux必须根据下一跳的IP地址来计算出下一跳的以太网目标地址。如果它还不知道这个映射，Linux就会广播一个查询，问：”谁要求使用下面的IP地址？你的以太网地址是什么？”并等待回应。</p>
<p>这些功能由网络接口执行：一个将出站IP数据报翻译成链路层(如以太网)帧的组件，反之亦然。(在实际系统中，网络接口通常有<code>eth0</code>、<code>eth1</code>、<code>wlan0</code>等名称。) <strong>在本周的实验中</strong>，你将实现一个网络接口，并把它放在TCP/IP协议栈的最底层。你的代码将产生原始的以太网帧，这些帧将通过一个叫做TAP设备的接口交给Linux——类似于TUN设备，但更底层，因为它交换的是原始链路层帧而不是IP数据报。</p>
</li>
</ul>
<p>大部分的工作是为每个下一跳的IP地址查找(和缓存)以太网地址。这方面的协议被称为<strong>地址解析协议(ARP)</strong>。</p>
<p>我们已经为你提供了单元测试，使你的网络接口能够正常运行。然后，在本实验结束时，你将略微修改你的<code>webget</code>，以使用你的TCP实现，这样整个过程将生成原始以太网帧，并且仍然可以通过Internet与真正的Web服务器通信。在实验6中，你将在TCP的上下文之外使用同一个网络接口，作为IP路由器的一部分。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Misaka-9982-coder/img_hosting/img/1.jpg" alt="img"></p>
<p>图1：网络接口连接互联网数据报和链路层帧。该组件作为主机TCP/IP堆栈的一部分(左侧)和IP路由器的一部分(右侧)都很有用。</p>
<h2 id="开始-3">开始</h2>
<ol>
<li>请确保你已经提交了你在实验4中的所有解决方案。请不要修改<code>libsponge</code>目录顶层以外的任何文件，或者<code>webget.cc</code>。(请不要添加代码所依赖的额外文件。)否则，你可能会在合并实验5的启动代码时遇到麻烦。</li>
<li>在实验作业的存储库中，运行<code>git fetch</code>来检索实验作业的最新版本。</li>
<li>通过运行<code>git merge origin/lab5-startercode</code>，下载实验5的启动代码。</li>
<li>在<code>build</code>目录中，编译源代码：<code>make</code>(编译时可以运行<code>make -j4</code>以使用四个处理器)。</li>
<li>在<code>build</code>目录外，打开并开始编辑<code>writeups/lab5.md</code>文件。这是你实验报告的模板，将包含在你提交的内容中。</li>
</ol>
<h2 id="地址解析协议">地址解析协议</h2>
<p>在开始编码之前，请阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://cs144.github.io/doc/lab5/class_network_interface.html">NetworkInterface对象的公共接口</a>。</li>
<li>维基百科对<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Address_Resolution_Protocol">ARP总结</a>和原始<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc826">ARP规范(RFC 1982)</a>。</li>
<li><a target="_blank" rel="noopener" href="https://cs144.github.io/doc/lab5/class_ethernet_frame.html">EthernetFrame</a>和<a target="_blank" rel="noopener" href="https://cs144.github.io/doc/lab5/struct_ethernet_header.html">EthernetHeader</a>对象的文档/实现。</li>
<li><a target="_blank" rel="noopener" href="https://cs144.github.io/doc/lab5/class_i_pv4_datagram.html">IPV4数据报</a>和<a target="_blank" rel="noopener" href="https://cs144.github.io/doc/lab5/struct_i_pv4_header.html">IPv4Header</a>对象的文档和实现(可以解析和序列化互联网数据报，序列化后可以分配给以太网帧的有效载荷)。</li>
<li><a target="_blank" rel="noopener" href="https://cs144.github.io/doc/lab5/struct_a_r_p_message.html">ARPMessage</a>对象的文档和实现(它知道如何解析和序列化ARP消息，并且在序列化时还可以作为以太网帧的有效载荷)。</li>
</ul>
<p>本实验的主要任务是实现<code>NetworkInterface</code>的三种主要方法(在<code>network_interface.cc</code>文件中)，维护从IP地址到以太网地址的映射。映射是一个缓存，或“软状态”：NetworkInterface为了提高效率而保留它，但是如果它必须从头开始重新启动，映射将自然地重新生成，而不会引起问题。</p>
<ol>
<li>
<p><code>void NetworkInterface::send_datagram(const InternetDatagram &amp;dgram, const Address &amp;next_hop)</code></p>
<p>当调用者(如你的TCPConnection或路由器)希望将出站互联网(IP)数据报发送到下一个跃点时，将调用此方法。(请不要把数据报的最终目的地与下一跳混为一谈，后者在数据报自己的报头中是目标地址。在这个实验里，你只关心下一跳的地址。)该接口的工作是将此数据报转换为以太网帧并(最终)发送。</p>
<ul>
<li>如果目标以太网地址已知，请立即发送。创建以太网帧(<code>type = EthernetHeader::TYPE_IPv4</code>)，将有效载荷设置为序列化数据报，并设置源地址和目标地址。</li>
<li>如果目标以太网地址未知，广播下一跳以太网地址的ARP请求，并将IP数据报排队，以便在收到ARP回复后发送。</li>
</ul>
<p><strong>例外</strong>：你不想让ARP请求充斥网络。如果网络接口在过去5秒内已经发送了一个关于相同IP地址的ARP请求，不要发送第二个，只需等待第一个请求的回复即可。同样，对数据报进行排队，直到了解到目标以太网地址。</p>
</li>
<li>
<p><code>optional&lt;InternetDatagram&gt; NetworkInterface::recv_frame(const EthernetFrame &amp;frame)</code></p>
<p>当以太网帧从网络到达时，调用此方法。代码应忽略任何不发送到网络接口的帧(也就是说，只接受以太网目的地是广播地址或存储在以太网地址成员变量<code>_ethernet_address</code>中的以太网地址)。</p>
<ul>
<li>如果入站帧是IPv4，将有效载荷解析为<code>InternetDatagram</code>，如果成功(意味着<code>parse()</code>方法返回<code>ParseResult::NoError</code>)，则将生成的<code>InternetDatagram</code>返回给调用者。</li>
<li>如果入站帧是ARP，将有效载荷解析为ARP消息，如果成功，记住发送方的IP地址和以太网地址之间的映射，持续30秒。(从请求和回复中学习映射。)此外，如果是ARP请求请求我们的IP地址，请发送适当的ARP回复。</li>
</ul>
</li>
<li>
<p><code>void NetworkInterface::tick(const size_t ms_since_last_tick)</code></p>
<p>随着时间的推移，这将被调用。使任何已经过期的IP到以太网的映射过期。</p>
</li>
</ol>
<p>你可以通过运行<code>ctest -V -R &quot;^arp&quot;</code>来测试你的实现。此测试不依赖于你的TCP实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkInterface</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//! Ethernet (known as hardware, network-access-layer, or link-layer) address of the interface</span></span><br><span class="line">    EthernetAddress _ethernet_address;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! IP (known as internet-layer or network-layer) address of the interface</span></span><br><span class="line">    Address _ip_address;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! outbound queue of Ethernet frames that the NetworkInterface wants sent</span></span><br><span class="line">    std::queue&lt;EthernetFrame&gt; _frames_out&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">time_t</span> <span class="keyword">size_t</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map + heap to achieve O(lgN) search,insert,expire check operation of IP-to-Ethernet mappings</span></span><br><span class="line">    std::map&lt;<span class="keyword">uint32_t</span>, std::pair&lt;EthernetAddress, <span class="keyword">time_t</span>&gt;&gt; _arp_table&#123;&#125;;</span><br><span class="line">    std::priority_queue&lt;std::pair&lt;<span class="keyword">time_t</span>, <span class="keyword">uint32_t</span>&gt;,</span><br><span class="line">                        std::vector&lt;std::pair&lt;<span class="keyword">time_t</span>, <span class="keyword">uint32_t</span>&gt;&gt;,</span><br><span class="line">                        std::greater&lt;std::pair&lt;<span class="keyword">time_t</span>, <span class="keyword">uint32_t</span>&gt;&gt;&gt;</span><br><span class="line">        _arp_failure_time&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">time_t</span> _curr_time&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// datagrams not sent yet</span></span><br><span class="line">    std::queue&lt;std::pair&lt;InternetDatagram, Address&gt;&gt; _dgrames_queue&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt; arp request sent and not get response yet, timestamp, ip to find&gt;</span></span><br><span class="line">    std::tuple&lt;<span class="keyword">bool</span>, <span class="keyword">time_t</span>, <span class="keyword">uint32_t</span>&gt; _arp_retransmission_timer&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//! \brief Construct a network interface with given Ethernet (network-access-layer) and IP (internet-layer) addresses</span></span><br><span class="line">    <span class="built_in">NetworkInterface</span>(<span class="keyword">const</span> EthernetAddress &amp;ethernet_address, <span class="keyword">const</span> Address &amp;ip_address);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief Access queue of Ethernet frames awaiting transmission</span></span><br><span class="line">    <span class="function">std::queue&lt;EthernetFrame&gt; &amp;<span class="title">frames_out</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _frames_out; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief Sends an IPv4 datagram, encapsulated in an Ethernet frame (if it knows the Ethernet destination address).</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Will need to use [ARP](\ref rfc::rfc826) to look up the Ethernet destination address for the next hop</span></span><br><span class="line">    <span class="comment">//! (&quot;Sending&quot; is accomplished by pushing the frame onto the frames_out queue.)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send_datagram</span><span class="params">(<span class="keyword">const</span> InternetDatagram &amp;dgram, <span class="keyword">const</span> Address &amp;next_hop)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief Receives an Ethernet frame and responds appropriately.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! If type is IPv4, returns the datagram.</span></span><br><span class="line">    <span class="comment">//! If type is ARP request, learn a mapping from the &quot;sender&quot; fields, and send an ARP reply.</span></span><br><span class="line">    <span class="comment">//! If type is ARP reply, learn a mapping from the &quot;sender&quot; fields.</span></span><br><span class="line">    <span class="function">std::optional&lt;InternetDatagram&gt; <span class="title">recv_frame</span><span class="params">(<span class="keyword">const</span> EthernetFrame &amp;frame)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief Called periodically when time elapses</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tick</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> ms_since_last_tick)</span></span>;</span><br><span class="line">    <span class="comment">// boardcast to find the Ethernet addr of an ip </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send_arp_request</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint32_t</span> ip_to_find)</span></span>;</span><br><span class="line">    <span class="comment">// resend the datagrams queued for not knowing their Ehternet addrs</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resend</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>_ethernet_address</code> 和 <code>_ip_address</code> 分别表示该接口的以太网地址和 IP 地址。</li>
<li><code>_frames_out</code> 保存尚未发送的数据帧，通过 <code>frames_out()</code> 方法获取该队列。</li>
<li><code>_arp_table</code> 和 <code>_arp_failure_time</code> 用于保存 IP 地址和以太网地址的映射，前者保存正常情况下的映射，后者保存因为 ARP 请求失败而需要重试的映射。</li>
<li><code>_dgrames_queue</code> 保存尚未发送的数据报，其中数据报表示一个完整的 IP 数据包。</li>
<li><code>send_datagram()</code> 方法用于发送 IP 数据报，其中需要通过 ARP 协议找到下一跳的以太网地址。</li>
<li><code>recv_frame()</code> 方法用于接收以太网帧并进行处理，如果接收到的是 IPv4 数据帧则返回一个数据报，如果是 ARP 请求或回复则需要进行对应的处理。</li>
<li><code>tick()</code> 方法表示时间流逝，用于处理 ARP 请求的超时和重新发送尚未发送的数据报。</li>
<li><code>send_arp_request()</code> 方法用于向网络广播 ARP 请求，以寻找特定 IP 地址的以太网地址。</li>
<li><code>resend()</code> 方法用于重新发送尚未发送成功的数据报。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NetworkInterface::resend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!_dgrames_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> dgrams = _dgrames_queue.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">uint32_t</span> next_hop_ip = dgrams.second.<span class="built_in">ipv4_numeric</span>();</span><br><span class="line">        <span class="comment">// if destination Ehernet address known</span></span><br><span class="line">        <span class="keyword">if</span> (_arp_table.<span class="built_in">count</span>(next_hop_ip)) &#123;</span><br><span class="line">            _dgrames_queue.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">send_datagram</span>(dgrams.first, dgrams.second);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>resend()</code>，用于重新发送还未发送成功的数据报。函数中，通过 <code>while</code> 循环遍历 <code>_dgrames_queue</code>（存储了还未成功发送的数据报），如果下一跳的 Ethernet 地址已经存在（即在 <code>_arp_table</code> 中），那么就将该数据报从队列中移除，调用 <code>send_datagram()</code> 方法进行发送，如果下一跳的 Ethernet 地址不存在，那么就退出循环。</p>
<p>因为在 <code>send_datagram()</code> 中，如果目的地的 Ethernet 地址不可用，则会将该数据报添加到 <code>_dgrames_queue</code> 中，等待重新发送。因此，<code>resend()</code> 的作用就是从队列中取出数据报重新发送，直到队列为空或者下一跳的 Ethernet 地址可用为止。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! \param[in] dgram the IPv4 datagram to be sent</span></span><br><span class="line"><span class="comment">//! \param[in] next_hop the IP address of the interface to send it to (typically a router or default gateway, but may also be another host if directly connected to the same network as the destination)</span></span><br><span class="line"><span class="comment">//! (Note: the Address type can be converted to a uint32_t (raw 32-bit IP address) with the Address::ipv4_numeric() method.)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NetworkInterface::send_datagram</span><span class="params">(<span class="keyword">const</span> InternetDatagram &amp;dgram, <span class="keyword">const</span> Address &amp;next_hop)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// convert IP address of next hop to raw 32-bit representation (used in ARP header)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> next_hop_ip = next_hop.<span class="built_in">ipv4_numeric</span>();</span><br><span class="line">    <span class="comment">// if destination Ehernet address known</span></span><br><span class="line">    <span class="keyword">if</span> (_arp_table.<span class="built_in">count</span>(next_hop_ip)) &#123;</span><br><span class="line">        EthernetFrame to_send;</span><br><span class="line">        to_send.<span class="built_in">payload</span>() = dgram.<span class="built_in">serialize</span>();</span><br><span class="line">        to_send.<span class="built_in">header</span>().dst = _arp_table[next_hop_ip].first;</span><br><span class="line">        to_send.<span class="built_in">header</span>().src = _ethernet_address;</span><br><span class="line">        to_send.<span class="built_in">header</span>().type = EthernetHeader::TYPE_IPv4;</span><br><span class="line">        _frames_out.<span class="built_in">emplace</span>(to_send);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                          <span class="comment">// if destination Ethernet address unkown</span></span><br><span class="line">        <span class="keyword">if</span> (!get&lt;<span class="keyword">bool</span>&gt;(_arp_retransmission_timer)) &#123;  <span class="comment">// no arp sent yet</span></span><br><span class="line">            <span class="built_in">send_arp_request</span>(next_hop_ip);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  queue the IP datagram</span></span><br><span class="line">        _dgrames_queue.<span class="built_in">push</span>(&#123;dgram, next_hop&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">resend</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码实现了将一个 IPv4 数据报通过该网络接口发送出去的功能。其中，数据报和下一个跳的地址（一般是路由器或者默认网关，但也可能是直接连接在同一网络中的另一个主机）作为参数传入。</p>
<p>首先，将下一跳地址转换为 uint32_t 类型的 IPv4 地址。如果已知下一跳的 Ethernet 地址，则将数据报封装成 Ethernet 帧并发送出去。如果下一跳的 Ethernet 地址不可知，则将此数据报加入到待发送数据报队列中，并发送 ARP 请求以查找下一跳的 Ethernet 地址。</p>
<p>最后，通过调用 <code>resend()</code> 函数来遍历待发送数据报队列，查看其中是否有已知下一跳地址的数据报，如果有，则将其从队列中弹出，并重复调用 <code>send_datagram()</code> 函数进行数据报发送。如果待发送数据报队列中没有已知下一跳地址的数据报，则函数退出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! \param[in] frame the incoming Ethernet frame</span></span><br><span class="line"><span class="function">optional&lt;InternetDatagram&gt; <span class="title">NetworkInterface::recv_frame</span><span class="params">(<span class="keyword">const</span> EthernetFrame &amp;frame)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (frame.<span class="built_in">header</span>().dst != _ethernet_address &amp;&amp; frame.<span class="built_in">header</span>().dst != ETHERNET_BROADCAST)</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (frame.<span class="built_in">header</span>().type == EthernetHeader::TYPE_IPv4) &#123;</span><br><span class="line">        InternetDatagram ret;</span><br><span class="line">        <span class="keyword">if</span> (ret.<span class="built_in">parse</span>(<span class="built_in">Buffer</span>(frame.<span class="built_in">payload</span>())) == ParseResult::NoError) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frame.<span class="built_in">header</span>().type == EthernetHeader::TYPE_ARP) &#123;</span><br><span class="line">        <span class="comment">// parse</span></span><br><span class="line">        ARPMessage arp_packet;</span><br><span class="line">        <span class="keyword">if</span> (arp_packet.<span class="built_in">parse</span>(<span class="built_in">Buffer</span>(frame.<span class="built_in">payload</span>())) == ParseResult::NoError) &#123;</span><br><span class="line">            <span class="comment">// record the sender&#x27;s info</span></span><br><span class="line">            _arp_table[arp_packet.sender_ip_address] = &#123;arp_packet.sender_ethernet_address, _curr_time + <span class="number">30</span> * <span class="number">1000</span>&#125;;</span><br><span class="line">            <span class="comment">// turn off timer</span></span><br><span class="line">            <span class="keyword">if</span> (get&lt;<span class="keyword">bool</span>&gt;(_arp_retransmission_timer) &amp;&amp;</span><br><span class="line">                get&lt;<span class="keyword">uint32_t</span>&gt;(_arp_retransmission_timer) == arp_packet.sender_ip_address)</span><br><span class="line">                _arp_retransmission_timer = <span class="built_in">make_tuple</span>(<span class="literal">false</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            _arp_failure_time.<span class="built_in">push</span>(&#123;_curr_time + <span class="number">30</span> * <span class="number">1000</span>, arp_packet.sender_ip_address&#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// send reply</span></span><br><span class="line">            <span class="keyword">if</span> (arp_packet.target_ip_address == _ip_address.<span class="built_in">ipv4_numeric</span>() &amp;&amp;</span><br><span class="line">                arp_packet.opcode == ARPMessage::OPCODE_REQUEST) &#123;</span><br><span class="line">                EthernetFrame arp_to_send;</span><br><span class="line">                <span class="comment">// header</span></span><br><span class="line">                arp_to_send.<span class="built_in">header</span>().dst = arp_packet.sender_ethernet_address;</span><br><span class="line">                arp_to_send.<span class="built_in">header</span>().src = _ethernet_address;</span><br><span class="line">                arp_to_send.<span class="built_in">header</span>().type = EthernetHeader::TYPE_ARP;</span><br><span class="line">                <span class="comment">// payload</span></span><br><span class="line">                ARPMessage arp_reply;</span><br><span class="line">                arp_reply.opcode = ARPMessage::OPCODE_REPLY;</span><br><span class="line">                arp_reply.sender_ethernet_address = _ethernet_address;</span><br><span class="line">                arp_reply.sender_ip_address = _ip_address.<span class="built_in">ipv4_numeric</span>();</span><br><span class="line">                arp_reply.target_ethernet_address = arp_packet.sender_ethernet_address;</span><br><span class="line">                arp_reply.target_ip_address = arp_packet.sender_ip_address;</span><br><span class="line">                arp_to_send.<span class="built_in">payload</span>() = <span class="built_in">BufferList</span>(<span class="built_in">move</span>(arp_reply.<span class="built_in">serialize</span>()));</span><br><span class="line">                <span class="comment">// send reply</span></span><br><span class="line">                <span class="comment">// cerr&lt;&lt; &quot;send reply&quot; &lt;&lt; arp_reply.to_string() &lt;&lt;endl;</span></span><br><span class="line">                _frames_out.<span class="built_in">emplace</span>(arp_to_send);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">resend</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法是在网络接口接收到一个新的以太网帧时被调用。</p>
<p>如果接收到帧的目的地址不是该接口的以太网地址，也不是广播地址，那么说明该帧不是发给该接口的，因此该方法返回一个空的可选值。</p>
<p>如果该帧包含一个IPv4数据报，该方法尝试从帧的负载中解析数据报。如果解析成功，该方法返回解析后的数据报，以可选值的形式封装返回。</p>
<p>如果该帧包含一个ARP消息，该方法尝试从帧的负载中解析消息。如果解析成功，该方法会更新ARP表中的发送者信息，关闭对应的ARP重传计时器（如果有的话），并将ARP条目的到期时间推入到ARP失败时间堆中。如果ARP消息是一个针对该接口IP地址的ARP请求，该方法会构建一个ARP回复并将其发送回发送者。</p>
<p>在处理接收到的帧后，该方法调用resend()方法检查是否有任何等待ARP解析的数据报被排队。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! \param[in] ms_since_last_tick the number of milliseconds since the last call to this method</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NetworkInterface::tick</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">    _curr_time += ms_since_last_tick;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Expire any IP-to-Ethernet mappings that have expired.</span></span><br><span class="line">    <span class="keyword">while</span> (!_arp_failure_time.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> arp_entry = _arp_failure_time.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span> (arp_entry.first &lt;= _curr_time) &#123;</span><br><span class="line">            _arp_failure_time.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (_arp_table[arp_entry.second].second &lt;= _curr_time)</span><br><span class="line">                _arp_table.<span class="built_in">erase</span>(arp_entry.second);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Resend arp if no response</span></span><br><span class="line">    <span class="keyword">if</span> (get&lt;<span class="keyword">bool</span>&gt;(_arp_retransmission_timer) &amp;&amp; _curr_time - get&lt;<span class="keyword">time_t</span>&gt;(_arp_retransmission_timer) &gt; <span class="number">5</span> * <span class="number">1000</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> ip_to_find = get&lt;<span class="keyword">uint32_t</span>&gt;(_arp_retransmission_timer);</span><br><span class="line">        <span class="built_in">send_arp_request</span>(ip_to_find);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tick() 方法会定期调用来执行各种维护任务。</p>
<p>该方法通过将自上次调用该方法以来经过的毫秒数添加到当前时间来更新当前时间。</p>
<p>然后，该方法通过迭代 ARP 失败时间堆来检查是否有已过期的 IP 到 Ethernet 映射。如果堆中的某个条目的过期时间小于或等于当前时间，则该方法将该条目从堆中弹出，并检查对应的 ARP 表中的 ARP 条目是否也已过期。如果 ARP 条目已过期，则该方法从 ARP 表中删除该条目。</p>
<p>接下来，该方法检查是否需要重新发送 ARP 请求。如果已经发送了 ARP 请求且当前时间减去请求发送时间大于 5 秒，则该方法会重新发送 ARP 请求。</p>
<p>总体而言，tick() 方法确保已过期的 ARP 条目从 ARP 表中删除，并在及时未收到响应时重新发送 ARP 请求。</p>
<ul>
<li><code>NetworkInterface::NetworkInterface(const EthernetAddress &amp;ethernet_address, const Address &amp;ip_address)</code>：构造函数，初始化网络接口的以太网地址和 IP 地址。</li>
<li><code>NetworkInterface::send_datagram(const InternetDatagram &amp;dgram, const Address &amp;next_hop)</code>：发送 IP 数据包，如果目的 IP 对应的以太网地址已知，则直接封装成以太网帧并通过 <code>_frames_out</code> 成员变量发送出去，否则发送 ARP 请求并将 IP 数据包加入到待发送队列 <code>_dgrames_queue</code> 中等待。</li>
<li><code>NetworkInterface::recv_frame(const EthernetFrame &amp;frame)</code>：接收以太网帧，如果帧的目的地址是本机的以太网地址或者广播地址，则根据帧类型分别处理。如果是 IP 数据帧，尝试解析出 IP 数据包并返回；如果是 ARP 请求或响应帧，则更新 ARP 表，并根据请求发送响应帧。</li>
<li><code>NetworkInterface::tick(const time_t ms_since_last_tick)</code>：定期调用的方法，用于处理 ARP 表项的过期和 ARP 请求的超时重传。</li>
<li><code>NetworkInterface::send_arp_request(const uint32_t ip_to_find)</code>：发送 ARP 请求，将请求封装成以太网帧并通过 <code>_frames_out</code> 成员变量发送出去，并设置超时计时器 <code>_arp_retransmission_timer</code>。</li>
<li><code>NetworkInterface::resend()</code>：定期检查待发送队列 <code>_dgrames_queue</code> 中是否有 IP 数据包可以发送，如果目的 IP 对应的以太网地址已知，则封装成以太网帧并通过 <code>_frames_out</code> 成员变量发送出去，否则停止检查。</li>
</ul>
<h2 id="webget回顾">webget回顾</h2>
<p>还记得你在实验0中写的<code>webget.cc</code>吗(在<code>TCPSocket</code>中使用Linux提供的TCP实现)？还记得你在实验4中如何修改它，以便在<code>CS144TCPSocket</code>中使用你自己的TCP-in-IP实现吗？如上所述，这仍然依赖于Linux内核作为堆栈的一部分：在IP和链路层(以太网)之间转换的网络接口。</p>
<p>我们希望你在不更改任何其他内容的情况下将其切换为使用网络接口。你只需将<code>CS144TCPSocket</code>类型替换为<code>FullStackSocket</code>。</p>
<p>这将使用TCP-in-IP-in-Ethernet堆栈，如图1(左侧)所示：你的<code>webget.cc</code>应用程序，在TCP的TCPConnection实现之上，在TCP-in-IP的<a target="_blank" rel="noopener" href="https://github.com/CS144/sponge/blob/lab5-startercode/libsponge/tcp_helpers/tcp_over_ip.cc">tcp_helpers/tcp_over_ip.cc</a>代码之上，在<code>NetworkInterface</code>之上。</p>
<p>重新编译并运行<code>make check_lab5</code>以确认你已经完成了完整的堆栈：你已经在自己完整的TCP实现和自己的网络接口实现之上编写了一个基本的网络抓取程序，并且它仍然成功地与真正的Web服务器通信。</p>
<p>如果遇到问题，请尝试手动运行该程序：<code>./apps/webget cs144.keithw.org /hasher/xyzzy</code>，并尝试使用<code>wireshark</code>捕获它发送和接收的内容。你可以通过运行<code>sudo TCPdump -i tap10 -w /tmp/packets.tap</code>来保存它正在发送和接收的分组。然后在<code>wireshark</code>中打开<code>/tmp/packets.tap</code>文件。</p>
<h2 id="完整代码-5">完整代码</h2>
<p>- <a target="_blank" rel="noopener" href="https://github.com/Misaka-9982-coder/CS144-fa21/blob/optimize/libsponge/network_interface.hh">network_interface.hh</a></p>
<p>- <a target="_blank" rel="noopener" href="https://github.com/Misaka-9982-coder/CS144-fa21/blob/optimize/libsponge/network_interface.cc">network_interface.cc</a></p>
</div><div class="tags"><a href="/tags/CS144"><i class="fa fa-tag">CS144</i></a><a href="/tags/Network"><i class="fa fa-tag">Network</i></a></div><div class="post-nav"><a class="pre" href="/2023/02/25/CS144-Lab6/">CS144-Lab6</a><a class="next" href="/2023/02/20/Makefile-%E5%92%8C-CMake/">Makefile 和 CMake</a></div><div id="tcomment"></div><script src="https://unpkg.com/twikoo@1.5.7/dist/twikoo.all.min.js"></script><script>twikoo.init({
  envId: 'https://twikoo-f8467x06b-misaka-9982-coder.vercel.app/',
  el: '#tcomment',
  region: '',
  path: ''
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.jpeg"/></a><p>Try to be better.</p><a class="info-icon" href="https://twitter.com/Misaka___9982" title="Twitter" target="_blank" style="margin-inline:5px"> <i class="fa fa-twitter-square" style="margin-inline:5px"></i></a><a class="info-icon" href="mailto:1784321894@qq.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/Misaka-9982-coder" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a><a class="info-icon" href="/atom.xml" title="RSS" target="_blank" style="margin-inline:5px"> <i class="fa fa-rss-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/OS/" style="font-size: 15px;">OS</a> <a href="/tags/6-S081/" style="font-size: 15px;">6.S081</a> <a href="/tags/Acwing/" style="font-size: 15px;">Acwing</a> <a href="/tags/Algorithm/" style="font-size: 15px;">Algorithm</a> <a href="/tags/CS144/" style="font-size: 15px;">CS144</a> <a href="/tags/Network/" style="font-size: 15px;">Network</a> <a href="/tags/CS188/" style="font-size: 15px;">CS188</a> <a href="/tags/AI/" style="font-size: 15px;">AI</a> <a href="/tags/CS61A/" style="font-size: 15px;">CS61A</a> <a href="/tags/CS61BL/" style="font-size: 15px;">CS61BL</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Wireshark/" style="font-size: 15px;">Wireshark</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/03/15/6-S081-Lab-3-page-tables/">6.S081 Lab 3 page tables</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/14/6-S081-Lab-2-System-Calls/">6.S081-Lab 2: System Calls</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/10/6-S081-Lab-1-Xv6-and-Unix-utilities/">6.S081-Lab 1: Xv6 and Unix utilities</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/03/09/6-S081%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/">6.S081环境配置及参考资料</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/25/CS144-Lab7/">CS144-Lab7</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/25/CS144-Lab6/">CS144-Lab6</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/24/CS144-Lab5/">CS144-Lab5</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/20/Makefile-%E5%92%8C-CMake/">Makefile 和 CMake</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/19/CS144-Lab4/">CS144-Lab4</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/02/19/CS144-Lab3/">CS144-Lab3</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.colopen-blog.com/" title="彩色铅笔" target="_blank">彩色铅笔</a><ul></ul><a href="https://www.selfknow.cn/" title="L2c" target="_blank">L2c</a><ul></ul><a href="https://blognas.hwb0307.com" title="浮云翩迁之间" target="_blank">浮云翩迁之间</a></div><div class="widget"><div class="widget-title"><i class="fa fa-heartbeat"> 访客地图</i></div></div><script id="clstr_globe" type="text/javascript" defer="defer" src="//clustrmaps.com/globe.js?d=NAGSI3cBPnTXd3xVo3V7zDC9xqeu_9ed2OCmGUj1uiw"></script><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async="async"></script><div class="widget"><div class="widget-title"><i class="fa fa-tags"> 网站资讯</i></div><ul> </ul><div class="webinfo-item"><div class="item-name">本站访客数  : </div><div class="item-count" id="busuanzi_value_site_uv"></div></div><ul> </ul><div class="webinfo-item"><div class="item-name">本站总访问量  : </div><div class="item-count" id="busuanzi_value_site_pv"></div></div><ul></ul><div class="webinfo-item"><div class="item-name">本站总字数 : </div><div class="item-count">300.4k</div></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 - 2023 <a href="/." rel="nofollow">Misaka's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
  search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>